// Copyright 2022 Cognite AS
import { promises as fs } from 'fs';
import * as pathUtil from 'path';

import * as ts from 'typescript';

import {
  OpenApiDocument,
  OpenApiSchema,
  OpenApiOperationObject,
  isReferenceObject,
  OpenApiPathsObject,
  filterPaths,
  operationsInPath,
  ReferenceWalker,
  OpenApiSchemas,
  OpenApiResponses,
  OpenApiParameters,
  OpenApiReference,
} from './openapi';
import { AutoNameInlinedRequestOption } from './utils';
import { TypeGenerator, TypeGeneratorResult } from './generator/generator';
import sorterTransformer from './ast_transformer/sorter';
import cursorAndAsyncIteratorTransformer from './ast_transformer/cursor_and_async_iterator';

export type StringFilter = (str: string) => boolean;

export const passThroughFilter: StringFilter = (): boolean => true;

const createServiceNameRegex = (name: string): RegExp => {
  return new RegExp(`^/api/.+/projects/{project}/${name}($|/)`);
};

export const createServiceNameFilter = (service: string): StringFilter => {
  const r = createServiceNameRegex(service);
  return (path: string): boolean => r.test(path);
};

export const createServiceNameIgnoreFilters = (
  services: string[]
): StringFilter[] => {
  return services.map(createServiceNameFilter);
};

export interface CodeGenOptions extends AutoNameInlinedRequestOption {
  filter: {
    path: StringFilter;
    schema?: StringFilter;
  };
  outputDir: string;
}

export const createPathFilter = (
  includePredicates: StringFilter[],
  ignorePredicates: StringFilter[]
): StringFilter => {
  return (service: string): boolean => {
    for (const predicate of includePredicates) {
      if (predicate(service)) {
        for (const ignorePredicate of ignorePredicates) {
          if (ignorePredicate(service)) {
            return false;
          }
        }

        return true;
      }
    }

    return false;
  };
};

export class CodeGen {
  static outputFileName = 'types.gen.ts';

  // Ordering matters! "sorterTransformer" must be the last transformer specified.
  astTransformers = [
    cursorAndAsyncIteratorTransformer,
    sorterTransformer, // must be last
  ];

  constructor(
    readonly generator: TypeGenerator,
    readonly options: CodeGenOptions
  ) {}

  /**
   * runSwaggerGenerate generates types for all component schematics.
   */
  private saveGeneratedTypes = async (
    result: TypeGeneratorResult
  ): Promise<void> => {
    const fileComment = `// Do not modify this file!
// It was generated by the command "yarn codegen".
// Instead update the code generation logic or the OpenAPI document.\n\n`;

    await fs.writeFile(
      pathUtil.resolve(this.options.outputDir, CodeGen.outputFileName),
      fileComment + result.astProcessedCode
    );
  };

  private operationsWithInlinedRequest = (
    paths: OpenApiPathsObject
  ): [string, OpenApiOperationObject][] => {
    const operations: [string, OpenApiOperationObject][] = [];
    for (const [path, item] of Object.entries(filterPaths(paths))) {
      for (const operation of operationsInPath(item)) {
        const requestBody = operation.requestBody;
        if (requestBody == null || isReferenceObject(requestBody)) {
          continue;
        }

        operations.push([path, operation]);
      }
    }

    return operations;
  };

  private autoNameInlinedRequests = (
    paths: OpenApiPathsObject
  ): [string, OpenApiSchema][] => {
    if (!this.options.autoNameInlinedRequest) {
      return [];
    }

    const inlined: [string, OpenApiSchema][] = [];
    for (const [path, operation] of this.operationsWithInlinedRequest(paths)) {
      const requestBody = operation.requestBody;
      if (requestBody == null || isReferenceObject(requestBody)) {
        continue;
      }

      const schema = requestBody.content?.['application/json']?.schema || {};
      if (isReferenceObject(schema)) {
        continue;
      }

      // schema name
      if (
        operation.operationId == null ||
        operation.operationId.trim() === ''
      ) {
        throw new Error(
          path +
            ': inlined requests must have a operationId specified to automatically name the request type'
        );
      }
      const operationId = operation.operationId.trim();
      let schemaName = this.capitalizeFirstLetter(operationId);
      if (!schemaName.toLowerCase().endsWith('request')) {
        schemaName += 'Request';
      }

      inlined.push([schemaName, schema]);
    }

    return inlined;
  };

  private getOnlyDefinitionsUsedByRefs = (
    originalDefinitions: string[],
    relevantReferenceNames: string[],
    walker: ReferenceWalker
  ): string[] => {
    const relevantReferencePredicate = (reference: string) =>
      relevantReferenceNames.some((refName) =>
        reference.endsWith('/' + refName)
      );

    const referenceSubsetRoots = originalDefinitions.filter(
      relevantReferencePredicate
    );
    if (referenceSubsetRoots.length > 0) {
      // Restrict set of references to those reachable from the filter names
      return walker.walk(referenceSubsetRoots);
    }

    return originalDefinitions;
  };

  private findAllDefinitionsRecursively = (
    doc: OpenApiDocument,
    relevantReferenceNames: string[] = []
  ): OpenApiDocument => {
    const walker = new ReferenceWalker(doc);

    const referencesInOperations = Object.values(doc.paths)
      .map(walker.references)
      .reduce((acc, v) => acc.concat(v), []);

    let references = walker.walk(referencesInOperations);

    if (relevantReferenceNames.length > 0) {
      references = this.getOnlyDefinitionsUsedByRefs(
        references,
        relevantReferenceNames,
        walker
      );
    }

    const filteredDoc: any = references
      .map(walker.splitReference)
      .reduce((acc, location) => {
        this.copyDefinitionsByLocation(acc, doc, location);
        return acc;
      }, {});

    return {
      ...doc,
      components: {
        ...filteredDoc.components,
      },
    };
  };

  private copyDefinitionsByLocation = (
    dst: any,
    src: any,
    location: string[]
  ) => {
    const next = location.shift()!;
    if (location.length == 0) {
      Object.assign(dst, { [next]: src[next] });
    } else {
      if (!(next in dst)) {
        dst[next] = {};
      }

      this.copyDefinitionsByLocation(dst[next], src[next], location);
    }
  };

  private filterPaths = (paths: OpenApiPathsObject): OpenApiPathsObject => {
    return Object.keys(paths)
      .filter(this.options.filter.path)
      .reduce((acc, path) => {
        return Object.assign(acc, { [path]: paths[path] });
      }, {});
  };

  private transformResponsesToSchemas = (
    responses: OpenApiResponses = {}
  ): [string, OpenApiReference | OpenApiSchema][] => {
    const schemas: OpenApiSchemas = {};
    for (const [name, response] of Object.entries(responses)) {
      if (isReferenceObject(response)) {
        continue;
      }

      const schema = response.content?.['application/json']?.schema;
      if (schema == null) {
        continue;
      }

      const missingResponseSuffix = !name.toLowerCase().endsWith('response');
      const schemaName = missingResponseSuffix ? name + 'Response' : name;
      schemas[schemaName] = schema;
    }

    return Object.entries(schemas);
  };

  private transformQueryParametersToSchemas = (
    parameters: OpenApiParameters = {}
  ): [string, OpenApiReference | OpenApiSchema][] => {
    const schemas: OpenApiSchemas = {};
    for (const [name, parameter] of Object.entries(parameters)) {
      if (isReferenceObject(parameter)) {
        continue;
      }

      if (parameter.in != 'query' || parameter.schema == null) {
        continue;
      }

      const schema: OpenApiSchema = {
        type: 'object',
        properties: {},
      };
      schema.properties![parameter.name] = parameter.schema;

      const missingSuffix = !name.toLowerCase().endsWith('queryparameter');
      const schemaName = missingSuffix ? name + 'QueryParameter' : name;
      schemas[schemaName] = schema;
    }

    return Object.entries(schemas);
  };

  private capitalizeFirstLetter = (str: string): string => {
    const capitalized = str.charAt(0).toUpperCase();
    const remain = str.length > 1 ? str.slice(1) : '';
    return capitalized + remain;
  };

  /**
   * generateTypesFromSchemas
   *
   * @param version OpenAPI version (3.0.1, 3.1.0, etc.)
   * @param schemas OpenAPI schemas, object where key will be the type name.
   * @param schemaFilter Filter out specific type names
   * @returns names of generated types
   */
  public generateTypesFromSchemas = async (
    version: string,
    schemas: OpenApiSchemas,
    schemaFilter?: StringFilter
  ): Promise<TypeGeneratorResult> => {
    if (schemas == null) {
      throw new Error('No schemas to generate types for defined');
    }

    const strippedOpenApiDoc = {
      openapi: version,
      components: { schemas: schemas },
    };

    // deep copy
    const doc = JSON.parse(
      JSON.stringify(strippedOpenApiDoc)
    ) as OpenApiDocument;

    if (schemaFilter != null) {
      doc.components!.schemas = Object.keys(doc.components!.schemas!)
        .filter(schemaFilter)
        .reduce(
          (acc, schemaName) =>
            Object.assign(acc, {
              [schemaName]: doc.components!.schemas![schemaName],
            }),
          {}
        );
    }

    // swagger generator capitalized the first letter
    doc.components!.schemas = Object.keys(doc.components!.schemas!).reduce(
      (acc, name) => {
        const formattedName = this.capitalizeFirstLetter(name);
        return Object.assign(acc, {
          [formattedName]: doc.components!.schemas![name],
        });
      },
      {} as OpenApiSchemas
    );

    const docJson = JSON.stringify(doc);
    const result = await this.generator.generateTypes(docJson);
    result.astProcessedCode = this.astPostProcessing(result.code);

    return result;
  };

  private astPostProcessing = (code: string): string => {
    const src = ts.createSourceFile(
      'generated.ts',
      code,
      ts.ScriptTarget.ES2015,
      false,
      ts.ScriptKind.TS
    );
    const result = ts.transform<ts.SourceFile>(src, this.astTransformers);
    const printer = ts.createPrinter();
    return printer.printFile(result.transformed[0]);
  };

  /**
   * generateTypes
   *
   * Derives relevant schemas from responses and other locations before generating types from schemas.
   *
   * @returns names of generated types
   */
  public generateTypes = async (
    openApiDoc: OpenApiDocument,
    relevantReferenceNames?: string[]
  ): Promise<string[]> => {
    // deep copy
    openApiDoc = JSON.parse(JSON.stringify(openApiDoc)) as OpenApiDocument;
    openApiDoc.paths = this.filterPaths(openApiDoc.paths);

    openApiDoc = this.findAllDefinitionsRecursively(
      openApiDoc,
      relevantReferenceNames
    );

    for (const [typeName, schema] of this.transformResponsesToSchemas(
      openApiDoc.components?.responses
    )) {
      if (typeName in openApiDoc.components!.schemas!) {
        throw new Error(
          `Unable to transform response to schema. Schema "${typeName}" already exists`
        );
      }

      openApiDoc.components!.schemas![typeName] = schema;
    }

    for (const [typeName, schema] of this.transformQueryParametersToSchemas(
      openApiDoc.components?.parameters
    )) {
      if (typeName in openApiDoc.components!.schemas!) {
        throw new Error(
          `Unable to transform parameter to schema. Schema "${typeName}" already exists`
        );
      }

      openApiDoc.components!.schemas![typeName] = schema;
    }

    for (const [typeName, schema] of this.autoNameInlinedRequests(
      openApiDoc.paths
    )) {
      if (typeName in openApiDoc.components!.schemas!) {
        throw new Error(
          `Unable to use automatic name for inlined request type. "${typeName}" already exists in the component schemas`
        );
      }

      openApiDoc.components!.schemas![typeName] = schema;
    }

    const skipTypes = [
      // remove the common json error structure as it is not needed here.
      // this is the `{"error": {"message": "hello", "code": 400, ...}}`
      'Error',

      // remove EmptyResponse as this is will never directly be used by the sdk
      // it's just used in openapi to state we return an empty json `{}`.
      'EmptyResponse',
      'ErrorResponse',
    ];

    const generated = await this.generateTypesFromSchemas(
      openApiDoc.openapi,
      openApiDoc.components?.schemas,
      (name: string) => !skipTypes.includes(name)
    );

    await this.saveGeneratedTypes(generated);
    return generated.typeNames;
  };
}
