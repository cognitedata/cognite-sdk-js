// Copyright 2020 Cognite AS
import { promises as fs } from 'fs';
import * as tmp from 'tmp-promise';
import * as pathUtil from 'path';

import { generateApi } from 'swagger-typescript-api-nextgen';
import {
  OpenApiDocument,
  OpenApiSchema,
  OpenApiOperationObject,
  isReferenceObject,
  OpenApiPathsObject,
  filterPaths,
  operationsInPath,
  ReferenceWalker,
} from './openapi';
import { ConfigurationOptions } from './configuration';

/**
 * PathFilter creates a new set of openapi paths that pass the filter implementation.
 */
export type PathFilter = (path: string) => boolean;

export const PassThroughFilter: PathFilter = (): boolean => true;

export const ServiceNameFilter = (service: string): PathFilter => {
  const r = new RegExp('^/api/.+/projects/{project}/' + service);
  return (path: string): boolean => r.test(path);
};

export type CodeGenOptions = {
  filter: {
    path: PathFilter;
  };
  outputDir: string;
} & Omit<ConfigurationOptions, 'filter'>;

export class CodeGen {
  static outputFileName = 'types.gen.ts';
  readonly versionFile: OpenApiDocument;

  constructor(versionFile: OpenApiDocument, readonly options: CodeGenOptions) {
    this.versionFile = JSON.parse(
      JSON.stringify(versionFile)
    ) as OpenApiDocument;
  }

  /**
   * runSwaggerGenerate generates types for all component schematics.
   */
  private runSwaggerGenerator = async (): Promise<void> => {
    const fileComment = `// Do not modify this file!
// It was generated by the command "yarn codegen".
// Instead update the code generation logic or the open api constracts.\n\n`;

    const file = await tmp.file({ postfix: '.json' });
    const data = JSON.stringify(this.versionFile);
    await fs.writeFile(file.path, data);

    const result = await generateApi({
      name: 'types.gen.ts',
      input: file.path,
      generateClient: false,
      toJS: false,
      generateResponses: false,
      extractRequestParams: false,
      extractRequestBody: false,
      generateUnionEnums: true,
      // prettier config is automatically loaded from project config
      cleanOutput: false,
      enumNamesAsValues: true,
    });

    result.files.forEach(async ({ content }) => {
      await fs.writeFile(
        pathUtil.resolve(this.options.outputDir, CodeGen.outputFileName),
        fileComment + content
      );
    });

    await file.cleanup();
  };

  // private operationResponseWithoutRef = (operation: OpenApiOperationObject): boolean => {
  //   for (const response of Object.values(operation.responses)) {
  //     if (isReferenceObject(response)) {
  //       continue;
  //     }

  //     const schema = response.content?.['application/json']?.schema || {};
  //     if (!("$ref" in schema)) {
  //       return true;
  //     }
  //   }

  //   return false;
  // }

  // private extractInlineResponseSchemas = (paths: OpenApiPathsObject) => {
  //   // some endpoint define inline schemas, these must be extracted in order to generate a type.
  //   //
  //   let schemas = {};
  //   for (const [path, item] of Object.entries(filterPaths(paths))) {
  //     for (const operation of operationsInPath(item)) {
  //       if (this.operationResponseWithoutRef(operation)) {
  //         console.error(path + ": inline responses are not currently supported");
  //         process.exit(1);
  //       }
  //     }
  //   }

  //   return Object.entries(schemas);
  // }

  private operationsWithInlinedRequest = (
    paths: OpenApiPathsObject
  ): [string, OpenApiOperationObject][] => {
    const operations: [string, OpenApiOperationObject][] = [];
    for (const [path, item] of Object.entries(filterPaths(paths))) {
      for (const operation of operationsInPath(item)) {
        const requestBody = operation.requestBody;
        if (
          typeof requestBody === 'undefined' ||
          isReferenceObject(requestBody)
        ) {
          continue;
        }

        operations.push([path, operation]);
      }
    }

    return operations;
  };

  private autoNameInlinedResponses = (): [string, OpenApiSchema][] => {
    return [];
    // console.error('inline responses are not currently supported');
    // process.exit(1);
  };

  private autoNameInlinedRequests = (): [string, OpenApiSchema][] => {
    if (!this.options.autoNameInlinedRequest) {
      return [];
    }

    const inlined: [string, OpenApiSchema][] = [];
    for (const [path, operation] of this.operationsWithInlinedRequest(
      this.versionFile.paths
    )) {
      const requestBody = operation.requestBody;
      if (
        typeof requestBody === 'undefined' ||
        isReferenceObject(requestBody)
      ) {
        continue;
      }

      const schema = requestBody.content?.['application/json']?.schema || {};
      if (isReferenceObject(schema)) {
        continue;
      }

      // schema name
      if (
        typeof operation.operationId === 'undefined' ||
        operation.operationId.trim() === ''
      ) {
        console.error(
          path +
            ': inlined requests must have a operationId specified to automatically name the request type'
        );
        process.exit(1);
      }
      const operationId = operation.operationId.trim();
      let schemaName =
        operationId.charAt(0).toUpperCase() +
        (operationId.length > 1 ? operationId.slice(1) : '');
      if (!schemaName.toLowerCase().endsWith('request')) {
        schemaName += 'Request';
      }

      inlined.push([schemaName, schema]);
    }

    return inlined;
  };

  private removeSchemasWithoutPathRelations = (): void => {
    const walker = new ReferenceWalker(this.versionFile);

    const referencesInOperations = Object.values(this.versionFile.paths)
      .map(walker.references)
      .reduce((acc, v) => acc.concat(v), []);

    const references = walker.walk(referencesInOperations);
    this.updateComponentCategories(references.map(walker.splitReference));
  };

  private updateComponentCategories = (references: string[][]) => {
    const components = this.versionFile.components;
    this.versionFile.components = {};

    for (const ref of references) {
      let pointer = this.versionFile as any;
      for (const key of ref) {
        if (!(key in pointer)) {
          pointer[key] = {};
        }
        pointer = pointer[key];
      }

      // @ts-ignore
      this.versionFile.components[ref[1]][ref[2]] = components[ref[1]][ref[2]];
    }
  };

  private filterPaths = (): void => {
    this.versionFile.paths = Object.keys(this.versionFile.paths)
      .filter(this.options.filter.path)
      .reduce((acc, path) => {
        return Object.assign(acc, { [path]: this.versionFile.paths[path] });
      }, {} as OpenApiPathsObject);
  };

  private copyResponsesToSchemas = (): void => {
    if (typeof this.versionFile.components!.responses === 'undefined') {
      return;
    }

    // some refs are responses, and we must fetch out the schema for any json responses
    for (const [name, response] of Object.entries(
      this.versionFile.components!.responses
    )) {
      if (isReferenceObject(response)) {
        continue;
      }

      const schema = response.content?.['application/json']?.schema;
      if (typeof schema === 'undefined') {
        continue;
      }

      const missingResponseSuffix = !name.toLowerCase().endsWith('response');
      const schemaName = missingResponseSuffix ? name + 'Response' : name;
      this.versionFile.components!.schemas![schemaName] = schema;
    }
  };

  private queryParameters = () => {
    const parameters = this.versionFile.components?.parameters;
    if (typeof parameters === 'undefined') {
      return {};
    }

    const schemas: Record<string, any> = {};
    for (const [name, parameter] of Object.entries(parameters)) {
      if (isReferenceObject(parameter)) {
        continue;
      }

      if (parameter.in != 'query') {
        continue;
      }

      const schema = {
        type: 'object',
        properties: Object.assign({}, { [parameter.name]: parameter.schema }),
      };
      schemas[name] = schema;
    }

    return schemas;
  };

  private copyQueryParametersToSchemas = (): void => {
    const parameters = this.queryParameters();
    for (const [name, schema] of Object.entries(parameters)) {
      this.versionFile.components!.schemas![name + 'QueryParameter'] = schema;
    }
  };

  /**
   * generateTypes
   *
   * generate all types with a given versionfile and configuration. Returns name of all generated types afterwards.
   */
  public generateTypes = async (): Promise<string[]> => {
    this.filterPaths();
    this.removeSchemasWithoutPathRelations();
    this.copyResponsesToSchemas();
    this.copyQueryParametersToSchemas();

    for (const [typeName, schema] of this.autoNameInlinedResponses()) {
      if (typeName in this.versionFile.components!.schemas!) {
        console.error(
          `unable to use automatic name for inlined response type. "${typeName}" already exists in the component schemas`
        );
        process.exit(1);
      }

      this.versionFile.components!.schemas![typeName] = schema;
    }

    for (const [typeName, schema] of this.autoNameInlinedRequests()) {
      if (typeName in this.versionFile.components!.schemas!) {
        console.error(
          `unable to use automatic name for inlined request type. "${typeName}" already exists in the component schemas`
        );
        process.exit(1);
      }

      this.versionFile.components!.schemas![typeName] = schema;
    }

    // remove the common json error structure as it is not needed here.
    // this is the `{"error": {"message": "hello", "code": 400, ...}}`
    delete this.versionFile.components!.schemas!['Error'];

    // remove EmptyResponse as this is will never directly be used by the sdk
    // it's just used in openapi to state we return an empty json `{}`.
    delete this.versionFile.components!.schemas!['EmptyResponse'];

    const typeNames = Object.keys(this.versionFile.components?.schemas || {});
    await this.runSwaggerGenerator();

    return typeNames;

    //  5. recursively explore root types to identify all relevant types, discard the rest
    //  3. copy responses over to schemas (normalise: add "Response" suffix)
    //  4. process query parameter, add name and add to schemas (little magic)
    //  1. name inline responses and add to schemas (magic) (normalise: add "Response" suffix)
    //  2. name inline requests and add to schemas (magic) (normalise: add "Request" suffix)
    //  6. discard error types (error responses as these aren't needed)
    //  7. make sure everything is in order (sorted, maybe use prettier?)
    //  8. run swagger code gen on the filtered open api spec
    //  9. use swagger's onCreateComponent hook to remove types to be imported from core
    // 10. update file comment and imports
    // 11. write to file
  };
}
