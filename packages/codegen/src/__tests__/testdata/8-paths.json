{
  "openapi": "3.0.1",
  "info": {
    "title": "Cognite playground APIs",
    "description": "# Introduction\nThis is a collection of APIs that are highly experimental and is meant as a way to communicate a few things we're experimenting with.\nPlease use these APIs with care, as we issue no guarantees these APIs won't break. Have fun!\n\n# Postman\nYou can download our postman collection [here](https://storage.googleapis.com/cognite-postman-collections/playground.json).\nOpen Postman, click `Import -> Import From Link`, insert the link and import.\n\nYou can read more about how to use Postman [here](https://docs.cognite.com/dev/guides/postman/)\n\n# Pagination\nMost resource types can be paginated, indicated by the field `nextCursor` in the response.\nBy passing the value of `nextCursor` as the cursor you will get the next page of `limit` results.\nNote that all parameters except `cursor` has to stay the same.\n\n# Parallel retrieval\nIf you want to download a lot of resources (let's say events), paginating through millions of records can be slow.\nWe support parallel retrieval through the `partition` parameter, which has the format `m/n` where `n` is the amount of partitions you would like to split the entire data set into.\nIf you want to download the entire data set by splitting it into 10 partitions, you would do the following in parallel with `m` running from 1 to 10:\n  - Make a request to `/events` with `partition=m/10`.\n  - Paginate through the response by following the cursor as explained above. Note that the `partition` parameter needs to be passed to all subqueries.\n",
    "version": "playground"
  },
  "servers": [
    {
      "url": "https://api.cognitedata.com"
    }
  ],
  "paths": {
    "/serviceA": {
      "get": {
        "tags": ["Functions"],
        "summary": "List functions",
        "operationId": "get-function",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/LimitQuery"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/FunctionErrorResponse"
          }
        },
        "x-capability": ["functionsAcl:READ"]
      },
      "post": {
        "summary": "Create functions",
        "operationId": "post-api-playground-projects-project-functions",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "You can only create one function per request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "description": "Array of functions to create.",
                    "maxItems": 1,
                    "minItems": 1,
                    "items": {
                      "$ref": "#/components/schemas/Function"
                    }
                  }
                },
                "required": ["items"]
              },
              "examples": {
                "Minimal function": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343
                      }
                    ]
                  }
                },
                "With API key": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343,
                        "apiKey": "ABCMYKEY"
                      }
                    ]
                  }
                },
                "With secrets": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343,
                        "secrets": {
                          "key1": "secret1",
                          "key2": "secret2"
                        }
                      }
                    ]
                  }
                },
                "Full example": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "description": "This function does some things",
                        "owner": "anders.hafreager@cognite.com",
                        "fileId": 5467347282343,
                        "externalId": "my-function",
                        "apiKey": "MYKEY12345",
                        "secrets": {
                          "key1": "secret1",
                          "key2": "secret2"
                        }
                      }
                    ]
                  }
                }
              }
            }
          },
          "description": ""
        },
        "security": [
          {
            "api-key": []
          }
        ],
        "tags": ["Functions"],
        "x-capability": ["functionsAcl:WRITE"]
      }
    },
    "/serviceA/limits": {
      "get": {
        "tags": ["Functions"],
        "summary": "Functions limits",
        "description": "Service limits for the associated project.",
        "operationId": "get-functions-limits",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionsLimits"
          },
          "400": {
            "$ref": "#/components/responses/FunctionErrorResponse"
          }
        },
        "x-capability": ["functionsAcl:READ"]
      }
    },
    "/serviceB/list": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "summary": "Filter functions",
        "operationId": "listFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/FunctionErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find functions.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionListScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "status": "Queued"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": ["Functions"]
      }
    },
    "/serviceC/delete": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "summary": "Delete functions",
        "operationId": "post-api-playground-projects-project-functions-delete",
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Delete functions. You can delete a maximum of 10 functions per request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionDeleteRequest"
              }
            }
          }
        },
        "tags": ["Functions"],
        "x-capability": ["functionsAcl:WRITE"]
      }
    },
    "/serviceC/{functionId}/call": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "tags": ["Function calls"],
        "x-capability": ["functionsAcl:WRITE"],
        "summary": "Call a function asynchronously",
        "operationId": "post-api-playground-projects-project-functions-function_name-call",
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionCalled"
          },
          "400": {
            "$ref": "#/components/responses/FunctionErrorResponse"
          }
        },
        "description": "Perform a function call. To provide input data to the function, add the data in an object called `data` in the request body. It will be available as the `data` argument into the function. Info about the function call at runtime can be obtained through the `function_call_info` argument if added in the function handle. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionCallRequest"
              }
            }
          }
        }
      }
    },
    "/serviceC/{functionId}/calls": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        },
        {
          "$ref": "#/components/parameters/LimitQuery"
        },
        {
          "$ref": "#/components/parameters/Cursor"
        }
      ],
      "get": {
        "summary": "List function calls",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallListWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/FunctionErrorResponse"
          }
        },
        "operationId": "get-api-playground-projects-project-functions-function_name-calls",
        "description": "List all function calls.",
        "tags": ["Function calls"],
        "x-capability": ["functionsAcl:READ"]
      }
    },
    "/serviceC/{functionId}/calls/byids": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "summary": "Retrieve calls",
        "requestBody": {
          "description": "List of IDs of calls to retrieve. Must be up to a maximum of 10000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FunctionCallIds"
                  },
                  {
                    "$ref": "#/components/schemas/IgnoreUnknownIdsField"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "byidsFunctionCalls",
        "description": "Retrieve function calls by call ids.",
        "tags": ["Function calls"],
        "x-capability": ["functionsAcl:READ"]
      }
    },
    "/serviceD/{functionId}/calls/{callId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "operationId": "get-api-playground-projects-project-functions-function_name-calls-call_id",
        "description": "Retrieve function calls.",
        "tags": ["Function calls"],
        "x-capability": ["functionsAcl:READ"],
        "summary": "Retrieve a function call by its id",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionCall"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/FunctionErrorResponse"
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "api-key": {
        "type": "apiKey",
        "description": "An admin can create API keys in the Cognite console.",
        "name": "api-key",
        "in": "header"
      },
      "token": {
        "type": "http",
        "description": "Human users log in via an OpenId/OAuth flow. Use the /login/redirect flow to obtain a bearer access token. Use a header key of 'Authorization' with a value of 'Bearer: $accesstoken'",
        "scheme": "bearer"
      },
      "oidc-token": {
        "type": "http",
        "description": "Access token issued by the CDF project's configured identity provider. Access token must be an OpenID Connect token, and the project must be configured to accept OpenID Connect tokens. Use a header key of 'Authorization' with a value of 'Bearer $accesstoken'",
        "scheme": "bearer"
      }
    },
    "schemas": {
      "CPURange": {
        "type": "object",
        "description": "The number of CPU cores per function exectuion (i.e. function call).",
        "required": ["min", "max", "default"],
        "properties": {
          "min": {
            "type": "number",
            "example": 0.1,
            "description": "The minimum value you can request when creating a function."
          },
          "max": {
            "type": "number",
            "example": 0.6,
            "description": "The maximum value you can request when creating a function."
          },
          "default": {
            "type": "number",
            "example": 0.25,
            "description": "The default value when creating a function."
          }
        }
      },
      "MemoryRange": {
        "type": "object",
        "description": "The amount of available memory in GB per function execution (i.e. function call).",
        "required": ["min", "max", "default"],
        "properties": {
          "min": {
            "type": "number",
            "example": 0.1,
            "description": "The minimum value you can request when creating a function."
          },
          "max": {
            "type": "number",
            "example": 2.5,
            "description": "The maximum value you can request when creating a function."
          },
          "default": {
            "type": "number",
            "example": 1,
            "description": "The default value when creating a function."
          }
        }
      },
      "IgnoreUnknownIdsField": {
        "type": "object",
        "properties": {
          "ignoreUnknownIds": {
            "description": "Ignore IDs that are not found",
            "type": "boolean",
            "default": false
          }
        }
      },
      "SomeUnusedOpenApiSchema": {
        "type": "object",
        "properties": {
          "ignoreUnknownIds": {
            "description": "Ignore IDs that are not found",
            "type": "boolean",
            "default": false
          }
        }
      },
      "FunctionBuildError": {
        "type": "object",
        "required": ["code", "message"],
        "description": "Cognite Function API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 400
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not build function."
          }
        }
      },
      "FunctionErrorBasic": {
        "type": "object",
        "required": ["code", "message"],
        "description": "Cognite Function API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 400
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          }
        }
      },
      "FunctionCallError": {
        "type": "object",
        "required": ["code", "message"],
        "description": "Error occuring due to user's function code.",
        "properties": {
          "trace": {
            "type": "string",
            "description": "Stack trace of exception, useful for debugging.",
            "example": "Cannot assign foo to bar."
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          }
        }
      },
      "FunctionScheduleCronExpression": {
        "type": "string",
        "example": "* * * * *",
        "maxLength": 1024,
        "description": "Cron expression describes when the function should be called. Use http://www.cronmaker.com to create a cron expression."
      },
      "FunctionScheduleDescription": {
        "type": "string",
        "example": "This is a nice schedule",
        "maxLength": 500,
        "description": "Description of function schedule."
      },
      "FunctionScheduleName": {
        "type": "string",
        "description": "Name of function schedule.",
        "example": "My schedule",
        "minLength": 1,
        "maxLength": 140
      },
      "FunctionName": {
        "type": "string",
        "description": "The name of the function.",
        "example": "myfunction",
        "minLength": 1,
        "maxLength": 140
      },
      "FunctionOwner": {
        "type": "string",
        "example": "anders.hafreager@cognite.com",
        "maxLength": 128,
        "description": "Owner of this function. Typically used to know who created it."
      },
      "FunctionId": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "The ID of the function."
      },
      "FunctionExternalId": {
        "type": "object",
        "required": ["externalId"],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "description": "The external ID of the function. Should be unique for the project."
      },
      "FunctionCallId": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "FunctionCallIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": ["items"],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FunctionCallId"
                },
                "maxItems": 10000,
                "minItems": 1
              }
            }
          }
        ]
      },
      "FunctionScheduleId": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "The ID of the function schedule."
      },
      "FunctionIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FunctionId"
          },
          {
            "$ref": "#/components/schemas/FunctionExternalId"
          }
        ]
      },
      "FunctionScheduleIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": ["items"],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": ["id"],
                  "properties": {
                    "id": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      ]
                    }
                  }
                },
                "maxItems": 10000,
                "minItems": 1
              }
            }
          }
        ]
      },
      "FunctionCallStatus": {
        "type": "string",
        "description": "Status of the function call.",
        "enum": ["Running", "Completed", "Failed", "Timeout"],
        "example": "Running"
      },
      "FunctionStatus": {
        "type": "string",
        "enum": ["Queued", "Deploying", "Ready", "Failed"],
        "example": "Queued",
        "description": "Status of the function. It starts in a Queued state, is then Deploying before it is either Ready or Failed. If the function is Ready, it can be called."
      },
      "FunctionListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          }
        ]
      },
      "LimitList": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to be returned.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "default": 100
          }
        }
      },
      "FunctionFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionFilter",
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FunctionName"
              },
              "owner": {
                "$ref": "#/components/schemas/FunctionOwner"
              },
              "fileId": {
                "$ref": "#/components/schemas/FunctionFileId"
              },
              "status": {
                "$ref": "#/components/schemas/FunctionStatus"
              },
              "externalIdPrefix": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        }
      },
      "FunctionCallFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionCallFilter",
            "type": "object",
            "properties": {
              "scheduleId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "status": {
                "$ref": "#/components/schemas/FunctionCallStatus"
              },
              "startTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "endTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            },
            "description": ""
          }
        }
      },
      "FunctionCallListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionCallFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "FunctionScheduleFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionScheduleFilter",
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FunctionScheduleName"
              },
              "FunctionId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "FunctionExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "cronExpression": {
                "$ref": "#/components/schemas/FunctionScheduleCronExpression"
              }
            },
            "description": ""
          }
        }
      },
      "FunctionScheduleScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionScheduleFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          }
        ]
      },
      "FunctionScheduleIdArray": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 10,
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/FunctionScheduleId"
            }
          }
        }
      },
      "FunctionIdEitherList": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": ["items"],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FunctionIdEither"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FunctionSchedule": {
        "allOf": [
          {
            "title": "Funtion Schedule",
            "type": "object",
            "description": "",
            "properties": {
              "id": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                ],
                "readOnly": true
              },
              "name": {
                "$ref": "#/components/schemas/FunctionScheduleName"
              },
              "createdTime": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EpochTimestamp"
                  }
                ],
                "readOnly": true
              },
              "description": {
                "$ref": "#/components/schemas/FunctionScheduleDescription"
              },
              "cronExpression": {
                "$ref": "#/components/schemas/FunctionScheduleCronExpression"
              },
              "functionId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "functionExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "data": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/data"
                  }
                ],
                "writeOnly": true
              },
              "nonce": {
                "$ref": "#/components/schemas/nonce"
              }
            }
          }
        ],
        "required": ["id", "name", "createdTime", "cronExpression"]
      },
      "FunctionCallLogEntry": {
        "title": "FunctionCallLogEntry",
        "type": "object",
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "message": {
            "type": "string",
            "description": "Single line from stdout / stderr.",
            "example": "Did something great"
          }
        }
      },
      "FunctionCall": {
        "title": "FunctionCall",
        "type": "object",
        "required": ["id", "status", "startTime", "functionId"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "status": {
            "$ref": "#/components/schemas/FunctionCallStatus"
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "error": {
            "$ref": "#/components/schemas/FunctionCallError"
          },
          "scheduleId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "functionId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "scheduledTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "FunctionCalls": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          }
        }
      },
      "FunctionCallsWithCursor": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "FunctionDeleteRequest": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 10,
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/FunctionIdEither"
            }
          }
        },
        "required": ["items"]
      },
      "FunctionCallRequest": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/data"
          },
          "nonce": {
            "$ref": "#/components/schemas/nonce"
          }
        }
      },
      "FunctionFileId": {
        "description": "The file ID to a file uploaded to Cognite's Files API. This file must be a zip file and contain a file called `handler.py` (unless otherwise specified through the `functionPath` argument). This file must contain a function named `handle` with any of the following arguments: `data`, `client`, `secrets` and `function_call_info`, which are passed into the function. The zip file can contain other files as well (model binary data, libraries etc).\n\nCustom packages can be pip installed by providing a requirements.txt file in the root of the zip file. The latest version of the Cognite Python SDK is automatically installed. If a specific version is needed, please specify this in the requirements.txt file.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "Function": {
        "type": "object",
        "required": ["id", "createdTime", "status", "name", "fileId"],
        "properties": {
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "readOnly": true
          },
          "createdTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ],
            "readOnly": true,
            "example": 123455234
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionStatus"
              }
            ],
            "readOnly": true
          },
          "name": {
            "$ref": "#/components/schemas/FunctionName"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "fileId": {
            "$ref": "#/components/schemas/FunctionFileId"
          },
          "owner": {
            "$ref": "#/components/schemas/FunctionOwner"
          },
          "description": {
            "type": "string",
            "example": "My fantastic function with advanced ML",
            "maxLength": 500,
            "description": "Description of the function."
          },
          "metadata": {
            "type": "object",
            "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32, value 512 characters, up to 16 key-value pairs. Maximum size of entire metadata is 4096 bytes.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "apiKey": {
            "type": "string",
            "description": "(Deprecated) API key that can be used inside the function to access data in CDF. This is deprecated and will be replaced by OIDC tokens. With OIDC tokens, a session is created on behalf of the user/service principal at the point when either (1) the function is called directly, or (2) when a schedule is created for the function.",
            "maxLength": 50,
            "example": "***"
          },
          "secrets": {
            "type": "object",
            "description": "Object with additional secrets as key/value pairs. These can e.g. password to simulators or other data sources. Keys must be lowercase characters, numbers or dashes (-) and at most 15 characters. You can create at most 30 secrets, all keys must be unique, and cannot be `apikey`, `indexUrl` or `extraIndexUrls`.",
            "maxProperties": 30,
            "example": {
              "MySecret": "***"
            }
          },
          "functionPath": {
            "type": "string",
            "example": "myfunction/handler.py",
            "maxLength": 500,
            "description": "Relative path from the root folder to the file containing the `handle` function. Defaults to `handler.py`. Must be on POSIX path format."
          },
          "envVars": {
            "type": "object",
            "description": "Object with environment variables as key/value pairs. Keys can contain only letters, numbers or the underscore character. You can create at most 100 environment variables.",
            "maxProperties": 100,
            "example": {
              "MyKey": "MyValue"
            }
          },
          "cpu": {
            "type": "number",
            "format": "float",
            "description": "Number of CPU cores per function (not available in Azure). Defaults to 0.25. Allowed values are in the range [0.1, 0.6]."
          },
          "memory": {
            "type": "number",
            "format": "float",
            "description": "Memory per function measured in GB (not available in Azure). Defaults to 1. Allowed values are in the range [0.1, 2.5]."
          },
          "runtime": {
            "type": "string",
            "example": "py38",
            "default": "py38",
            "enum": ["py37", "py38", "py39"],
            "description": "The runtime of the function. Runtime \"py3x\" translates to the latest version of the Python 3.x.y series."
          },
          "error": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionBuildError"
              }
            ],
            "readOnly": true
          },
          "indexUrl": {
            "description": "Specify a different python package index, allowing for packages published in private repositories.\nSupports basic HTTP authentication as described in [pip basic authentication](https://pip.pypa.io/en/stable/topics/authentication/#basic-http-authentication).\nSee the\n[documentation](https://docs.cognite.com/cdf/functions/#additional-arguments)\nfor additional information related to the security risks of using this\noption. ",
            "example": "https://username:password@pypi.company.com/simple",
            "type": "string",
            "writeOnly": true
          },
          "extraIndexUrls": {
            "description": "Extra package index URLs to use when building the function, allowing for packages published in private repositories.\nSupports basic HTTP authentication as described in [pip basic\nauthentication](https://pip.pypa.io/en/stable/topics/authentication/#basic-http-authentication).\nSee the\n[documentation](https://docs.cognite.com/cdf/functions/#additional-arguments)\nfor additional information related to the security risks of using this\noption. ",
            "example": [
              "https://username:password@pypi.company.com/simple",
              "https://token@pypi.company.com/simple",
              "https://pypi.company.com/simple"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "writeOnly": true
          }
        }
      },
      "data": {
        "type": "object",
        "description": "Input data to the function. This data is passed deserialized into the function through one of the arguments called `data`. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.'",
        "example": {
          "timeSeriesId1": 13435351,
          "maxValue": 4
        }
      },
      "nonce": {
        "type": "string",
        "description": "Nonce retrieved from sessions API when creating a session. This will be used to bind the session before executing the function.",
        "writeOnly": true
      },
      "CreatedTime": {
        "type": "integer",
        "description": "The creation time of the resource, in milliseconds since January 1, 1970 at 00:00 UTC.",
        "format": "int64",
        "example": 0,
        "readOnly": true
      },
      "ExperimentalRevisionIdList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentalRevisionId"
            },
            "minItems": 1,
            "maxItems": 1
          }
        }
      },
      "ExperimentalRevisionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentalRevision"
            }
          }
        }
      },
      "ExperimentalRevision": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the revision.",
            "format": "int64",
            "example": 1000
          },
          "fileId": {
            "type": "integer",
            "description": "The file id.",
            "format": "int64",
            "example": 1000
          },
          "published": {
            "type": "boolean",
            "description": "True if the revision is marked as published.",
            "default": false
          },
          "rotation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            }
          },
          "camera": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          },
          "status": {
            "type": "string",
            "enum": ["Queued", "Processing", "Done", "Failed"],
            "description": "The status of the revision.",
            "example": "Done"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          },
          "thumbnailThreedFileId": {
            "type": "integer",
            "description": "The threed file ID of a thumbnail for the revision. Use /3d/files/{id} to retrieve the file.",
            "format": "int64",
            "example": 1000
          },
          "thumbnailURL": {
            "type": "string",
            "description": "The URL of a thumbnail for the revision.",
            "example": "https://api.cognitedata.com/api/v1/project/myproject/3d/files/1000"
          },
          "assetMappingCount": {
            "type": "integer",
            "description": "The number of asset mappings for this revision.",
            "format": "int64",
            "example": 0
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "walkablePathFiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VersionedThreedFile"
            }
          }
        }
      },
      "ExperimentalCreateRevisionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentalCreateRevision"
            }
          }
        }
      },
      "ExperimentalCreateRevision": {
        "type": "object",
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "The ID of the model this revision is for.",
            "format": "int64",
            "example": 1000
          },
          "fileId": {
            "type": "integer",
            "description": "The file id.",
            "format": "int64",
            "example": 1000
          },
          "published": {
            "type": "boolean",
            "description": "True if the revision is marked as published.",
            "default": false
          },
          "rotation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            }
          },
          "camera": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          },
          "creationParams": {
            "type": "object",
            "properties": {
              "walkablePath": {
                "type": "boolean",
                "description": "Set to generate walkable path files for this revision",
                "default": false
              }
            }
          }
        }
      },
      "VersionedThreedFile": {
        "type": "object",
        "properties": {
          "version": {
            "type": "integer",
            "description": "The version of the filetype in question",
            "format": "int64",
            "example": 1
          },
          "fileId": {
            "type": "integer",
            "description": "The id to use against the 3d file endpoint to get access to the refered file.",
            "format": "int64",
            "example": 12345654321
          }
        }
      },
      "ExperimentalRevisionId": {
        "type": "object",
        "properties": {
          "modelId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "revisionId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "RevisionCameraProperties": {
        "type": "object",
        "properties": {
          "target": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "description": "Initial camera target.",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "position": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "description": "Initial camera position.",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "description": "Initial camera position and target."
      },
      "RaycastRequest": {
        "type": "object",
        "description": "Set of raycasting queries on a model",
        "required": ["modelId", "items", "tolerance"],
        "properties": {
          "model": {
            "description": "Internal or external identifier of the model",
            "$ref": "#/components/schemas/DataIdentifier"
          },
          "tolerance": {
            "type": "number",
            "format": "double",
            "description": "How far away the ray can be from a point in order for it to be considdered a hit."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RaycastRequestItems"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "RaycastRequestItems": {
        "type": "object",
        "required": ["origin", "direction"],
        "example": {
          "origin": {
            "x": 0,
            "y": 0,
            "z": 0
          },
          "direction": {
            "x": 1,
            "y": 1,
            "z": 1
          }
        },
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/Point3D"
          },
          "direction": {
            "$ref": "#/components/schemas/Point3D"
          }
        }
      },
      "RayCastResultList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Point3D"
            }
          }
        }
      },
      "CropboxRequest": {
        "type": "object",
        "description": "Cropbox request",
        "required": ["modelId", "boundingBox"],
        "properties": {
          "model": {
            "description": "Internal or external identifier of the model",
            "$ref": "#/components/schemas/DataIdentifier"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          },
          "maxDepth": {
            "type": "integer",
            "format": "int64"
          },
          "maxNumberOfPoints": {
            "type": "integer",
            "format": "int64"
          },
          "format": {
            "type": "string"
          }
        }
      },
      "PathTransitQuery": {
        "type": "object",
        "description": "Set of transit queries on a model",
        "required": ["modelId", "items"],
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "model to find path in"
          },
          "walkableAreaOverride": {
            "$ref": "#/components/schemas/WalkableAreaOverride"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathTransitRequest"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "PathTransitRequest": {
        "type": "object",
        "required": ["from", "to"],
        "properties": {
          "from": {
            "$ref": "#/components/schemas/PathRequestItem"
          },
          "to": {
            "$ref": "#/components/schemas/PathRequestItem"
          },
          "movingObjectSize": {
            "$ref": "#/components/schemas/PathRequestObjectSize"
          }
        }
      },
      "PathRoundtripRequest": {
        "type": "object",
        "required": ["modelId", "base", "visit"],
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "The model to do the pathfinding on",
            "format": "int64"
          },
          "walkableAreaOverride": {
            "$ref": "#/components/schemas/WalkableAreaOverride"
          },
          "base": {
            "$ref": "#/components/schemas/PathRequestItem"
          },
          "visit": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathRequestItem"
            },
            "minItems": 1,
            "maxItems": 10
          },
          "movingObjectSize": {
            "$ref": "#/components/schemas/PathRequestObjectSize"
          }
        }
      },
      "PathRequestItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/Point3D"
          },
          {
            "$ref": "#/components/schemas/NodeId"
          }
        ]
      },
      "NodeId": {
        "type": "object",
        "required": ["nodeId"],
        "properties": {
          "nodeId": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "PathRequestObjectSize": {
        "type": "object",
        "description": "Optional object size. If not set, assumes height 2.10 and diameter 0.50",
        "required": ["diameter", "height"],
        "properties": {
          "diameter": {
            "type": "number",
            "format": "double"
          },
          "height": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "WalkableAreaOverride": {
        "type": "object",
        "properties": {
          "blockers": {
            "$ref": "#/components/schemas/PathBlocker"
          },
          "passages": {
            "$ref": "#/components/schemas/PathPassage"
          }
        }
      },
      "PathBlocker": {
        "type": "object",
        "properties": {
          "minX": {
            "type": "number",
            "format": "double"
          },
          "minY": {
            "type": "number",
            "format": "double"
          },
          "minZ": {
            "type": "number",
            "format": "double"
          },
          "maxX": {
            "type": "number",
            "format": "double"
          },
          "maxY": {
            "type": "number",
            "format": "double"
          },
          "maxZ": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "PathPassage": {
        "type": "object",
        "required": ["point1", "point2"],
        "properties": {
          "point1": {
            "$ref": "#/components/schemas/Point3D"
          },
          "point2": {
            "$ref": "#/components/schemas/Point3D"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "default": 1,
            "description": "Factor multiplied with distance to determine cost of using path."
          }
        }
      },
      "PathResultList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathResult"
            }
          }
        }
      },
      "PathResult": {
        "type": "object",
        "properties": {
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathSegment"
            }
          }
        }
      },
      "PathSegment": {
        "type": "object",
        "description": "The path from one object to the next",
        "properties": {
          "sourceIndex": {
            "type": "integer",
            "format": "int64",
            "example": 0
          },
          "destinationIndex": {
            "type": "integer",
            "format": "int64",
            "example": 1
          },
          "path": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Point3D"
            }
          }
        }
      },
      "Point3D": {
        "type": "object",
        "required": ["x", "y", "z"],
        "properties": {
          "x": {
            "type": "number",
            "format": "double"
          },
          "y": {
            "type": "number",
            "format": "double"
          },
          "z": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "Metadata3D": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
        "additionalProperties": {
          "type": "string"
        }
      },
      "NextCursorData": {
        "type": "object",
        "properties": {
          "nextCursor": {
            "type": "string"
          }
        }
      },
      "DataIdentifier": {
        "oneOf": [
          {
            "type": "object",
            "required": ["id"],
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "type": "object",
            "required": ["externalId"],
            "properties": {
              "externalId": {
                "type": "string"
              }
            }
          }
        ]
      },
      "Model3D": {
        "type": "object",
        "required": ["id", "name", "source", "createdTime"],
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "externalId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "source": {
            "$ref": "#/components/schemas/Model3DSource"
          },
          "options": {
            "type": "object"
          },
          "createdTime": {
            "type": "integer",
            "format": "int64"
          },
          "status": {
            "type": "string",
            "enum": ["None", "Queued", "Processing", "Done", "Failed"]
          }
        }
      },
      "Model3DSource": {
        "oneOf": [
          {
            "type": "object",
            "required": ["fileId"],
            "properties": {
              "fileId": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "type": "object",
            "required": ["fileIds"],
            "properties": {
              "fileIds": {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "int64"
                }
              }
            }
          }
        ]
      },
      "Model3DPipeline": {
        "type": "object",
        "required": ["stages"],
        "properties": {
          "stages": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["name"],
              "properties": {
                "name": {
                  "type": "string"
                },
                "after": {
                  "type": "string"
                },
                "status": {
                  "type": "string",
                  "enum": ["None", "Queued", "Processing", "Done", "Failed"]
                }
              }
            }
          }
        }
      },
      "Model3DList": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3D"
            }
          }
        }
      },
      "Model3DUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataIdentifier"
          },
          {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/SetModel3DNameField"
                  },
                  "externalId": {
                    "$ref": "#/components/schemas/UpdateExternalId"
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/ObjectPatch"
                  }
                }
              }
            }
          }
        ]
      },
      "UpdateExternalId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "set",
            "required": ["set"],
            "properties": {
              "set": {
                "type": "string"
              }
            }
          },
          {
            "title": "remove",
            "type": "object",
            "required": ["setNull"],
            "properties": {
              "setNull": {
                "type": "boolean",
                "example": true
              }
            }
          }
        ]
      },
      "SetModel3DNameField": {
        "type": "object",
        "properties": {
          "set": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          }
        }
      },
      "Model3DUpdateList": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DUpdate"
            }
          }
        }
      },
      "Model3DUpload": {
        "type": "object",
        "required": ["name", "source"],
        "properties": {
          "externalId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "source": {
            "$ref": "#/components/schemas/Model3DSource"
          },
          "options": {
            "type": "object"
          }
        }
      },
      "Model3DOutputRequestList": {
        "type": "object",
        "required": ["models"],
        "properties": {
          "models": {
            "description": "Array of model identifiers to list outputs for",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "model": {
                  "description": "Internal or external identifier of a model",
                  "$ref": "#/components/schemas/DataIdentifier"
                }
              }
            },
            "example": [
              {
                "id": 10
              },
              {
                "externalId": "my-unique-model-id"
              }
            ]
          },
          "formats": {
            "description": "A list of named output formats to retrieve. Omit parameter to return list of public formats.",
            "example": ["ept-pointcloud"],
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Model3DOutputResponseList": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "description": "One item per model in the request payload.",
            "type": "array",
            "items": {
              "type": "object",
              "required": ["model", "outputs"],
              "properties": {
                "model": {
                  "allOf": [
                    {
                      "description": "Internal or external identifier of a model"
                    },
                    {
                      "$ref": "#/components/schemas/DataIdentifier"
                    }
                  ]
                },
                "outputs": {
                  "description": "A list of named and versioned outputs for the model. Note that the list is not sorted.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["format", "version", "blobId"],
                    "properties": {
                      "format": {
                        "description": "Format identifier, e.g. 'ept-pointcloud' (point cloud).",
                        "example": "ept-pointcloud",
                        "type": "string"
                      },
                      "version": {
                        "description": "Version of the output format, starting at 1.",
                        "example": 1,
                        "type": "integer"
                      },
                      "blobId": {
                        "description": "Reference to blob containing output. Blob can either be a single file or folder.",
                        "$ref": "#/components/schemas/CogniteInternalId"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "Model3DUploadList": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DUpload"
            }
          }
        }
      },
      "Node3D": {
        "type": "object",
        "required": ["id", "treeIndex", "subtreeSize", "depth", "name"],
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1000
          },
          "treeIndex": {
            "type": "integer",
            "minimum": 0,
            "description": "The index of the node in the 3D model hierarchy, starting from 0. The tree is traversed in a depth-first order.",
            "format": "int64",
            "example": 3
          },
          "parentId": {
            "type": "integer",
            "description": "The parent of the node, null if it is the root node.",
            "format": "int64",
            "example": 2
          },
          "depth": {
            "type": "integer",
            "description": "The depth of the node in the tree, starting from 0 at the root node.",
            "format": "int64",
            "example": 2
          },
          "name": {
            "type": "string",
            "description": "The name of the node.",
            "example": "Node name"
          },
          "subtreeSize": {
            "type": "integer",
            "description": "The number of descendants of the node, plus one (counting itself).",
            "format": "int64",
            "example": 4
          },
          "properties": {
            "$ref": "#/components/schemas/Node3DProperties"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          }
        }
      },
      "Node3DFilter": {
        "type": "object",
        "description": "Property specification in filter, with property categories containing a list of filter values for each property.",
        "example": {
          "PDMS": {
            "Area": ["AB76", "AB77", "AB78"],
            "Type": ["PIPE", "BEND", "PIPESUP"]
          }
        }
      },
      "Node3DProperties": {
        "type": "object",
        "description": "Properties extracted from 3D model, with property categories containing key/value string pairs.",
        "example": {
          "PDMS": {
            "Area": "AB78",
            "Type": "PIPE"
          }
        }
      },
      "Node3DListWithCursorResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Node3DList"
          },
          {
            "$ref": "#/components/schemas/NextCursorData"
          }
        ]
      },
      "Node3DList": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Node3D"
            }
          }
        }
      },
      "Node3DFilterBody": {
        "type": "object",
        "required": ["filters"],
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/Node3DFilter"
          }
        }
      },
      "Node3DBoundingBoxFilterBody": {
        "type": "object",
        "required": ["boundingBox"],
        "properties": {
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          },
          "fullyContainedOnly": {
            "type": "boolean",
            "example": true,
            "description": "Determines whether to only include nodes within the bounding box or not. Set to `true` to retrieve nodes that are fully inside the query bounding box. Set to `false` to retrieve nodes with a bounding box that intersects the query bounding box."
          }
        }
      },
      "Model3DOutput": {
        "type": "object",
        "required": ["versions"],
        "properties": {
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DOutputVersion"
            }
          }
        }
      },
      "Model3DOutputVersion": {
        "type": "object",
        "required": ["version", "blobs"],
        "properties": {
          "version": {
            "type": "integer",
            "format": "int64"
          },
          "blobs": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "Sector3D": {
        "type": "object",
        "required": ["id", "path", "depth"],
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "parentId": {
            "type": "integer",
            "format": "int64"
          },
          "path": {
            "type": "string"
          },
          "depth": {
            "type": "integer",
            "format": "int64"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          },
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DOutput"
            }
          }
        }
      },
      "BoundingBox3D": {
        "type": "object",
        "required": ["min", "max"],
        "properties": {
          "min": {
            "type": "array",
            "minLength": 3,
            "maxLength": 3,
            "example": [0, 1, 2],
            "items": {
              "type": "number"
            }
          },
          "max": {
            "type": "array",
            "minLength": 3,
            "maxLength": 3,
            "example": [3, 4, 5],
            "items": {
              "type": "number"
            }
          }
        }
      },
      "CogniteExternalIdPrefix": {
        "description": "Filter by this (case-sensitive) prefix for the external ID.",
        "type": "string",
        "maxLength": 255,
        "example": "my.known.prefix"
      },
      "DataLong": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "example": [23872937137, 1238712837, 128371973],
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "Error": {
        "type": "object",
        "required": ["code", "message"],
        "description": "Cognite API error",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code",
            "format": "int32",
            "example": 401
          },
          "message": {
            "type": "string",
            "description": "Error message",
            "example": "Could not authenticate."
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "ArrayPatchLongSet": {
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "ArrayPatchLongAddOrRemove": {
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "ArrayPatchLong": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ArrayPatchLongSet"
          },
          {
            "$ref": "#/components/schemas/ArrayPatchLongAddOrRemove"
          }
        ],
        "description": "Change that will be applied to the array object."
      },
      "SinglePatchBoolean": {
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "type": "boolean"
          }
        }
      },
      "ObjectPatch": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemove"
          }
        ]
      },
      "ObjectPatchSet": {
        "title": "set",
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": ["value1", "value2"],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchEvent": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated event: Maximum length of key is 128 bytes, value 128000 bytes, up to 256 key-value pairs, of total size at most 200000.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchEventSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchEventAddRemove"
          }
        ]
      },
      "ObjectPatchEventSet": {
        "title": "set",
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 128000
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 200000,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchEventAddRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 128000
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 200000,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": ["value1", "value2"],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "JsonArrayInt64": {
        "type": "string",
        "format": "jsonArray(int64)",
        "example": [1238712837, 238712361376, 23786237623]
      },
      "JsonArrayString": {
        "type": "string",
        "format": "jsonArray(string)"
      },
      "EpochTimestamp": {
        "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
        "type": "integer",
        "minimum": 0,
        "format": "int64",
        "example": 1638795554528
      },
      "EpochTimestampRange": {
        "description": "Range between two timestamps.",
        "type": "object",
        "properties": {
          "max": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "min": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "Partition": {
        "type": "object",
        "properties": {
          "partition": {
            "description": "Splits the data set into N partitions.\nYou need to follow the cursors within each partition in order to receive all the data.\nExample: 1/10\n",
            "type": "string",
            "example": "1/10"
          }
        }
      },
      "CogniteInternalId": {
        "description": "A server-generated ID for the object.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "Version": {
        "description": "A server-generated ID for the object.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "CogniteExternalId": {
        "description": "External Id provided by client. Should be unique within a given project/resource combination.",
        "type": "string",
        "maxLength": 255
      },
      "InternalIdList": {
        "type": "object",
        "required": ["internalIds"],
        "properties": {
          "internalIds": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "ExternalIdList": {
        "type": "object",
        "required": ["externalIds"],
        "properties": {
          "externalIds": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        }
      },
      "ResourceType": {
        "type": "string",
        "enum": ["asset", "event", "timeseries", "sequence"]
      },
      "ResourceInternalId": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "resourceType": {
            "$ref": "#/components/schemas/ResourceType"
          },
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "ResourceExternalId": {
        "type": "object",
        "properties": {
          "resourceType": {
            "$ref": "#/components/schemas/ResourceType"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "ResourceIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ResourceInternalId"
          },
          {
            "$ref": "#/components/schemas/ResourceExternalId"
          }
        ]
      },
      "Cursor": {
        "type": "object",
        "properties": {
          "cursor": {
            "description": "Cursor for paging through results.",
            "type": "string"
          }
        }
      },
      "Limit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to return.",
            "type": "integer",
            "default": 100,
            "minimum": 1,
            "maximum": 1000
          }
        }
      },
      "ExternalIdPrefixFilter": {
        "description": "filter external ids starting with the prefix specified",
        "type": "string",
        "maxLength": 255
      },
      "CountAggregateResult": {
        "description": "Count aggregation result.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": ["count"],
              "properties": {
                "count": {
                  "type": "integer",
                  "description": "Number of items in this aggregation group.",
                  "format": "int64"
                }
              }
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 10
            }
          ]
        }
      },
      "StringValue": {
        "description": "A unique string value in the field.",
        "type": "object",
        "required": ["value"],
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "IntegerValue": {
        "description": "A unique integer value in the field.",
        "type": "object",
        "required": ["value"],
        "properties": {
          "value": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "ValuesAggregateResult": {
        "description": "Values aggregation result.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "allOf": [
                {
                  "type": "object",
                  "required": ["count"],
                  "properties": {
                    "count": {
                      "description": "Number of items in this aggregation group.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/StringValue"
                    },
                    {
                      "$ref": "#/components/schemas/IntegerValue"
                    }
                  ]
                }
              ]
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 5,
              "value": "value_1"
            },
            {
              "count": 10,
              "value": "value_2"
            }
          ]
        }
      },
      "AggregateResult": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/CountAggregateResult"
          },
          {
            "$ref": "#/components/schemas/ValuesAggregateResult"
          }
        ]
      },
      "ResourceDescription": {
        "type": "string",
        "description": "The description of the resource type.",
        "maxLength": 500
      },
      "ObjectPatchAsset": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated asset: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSetAsset"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemoveAsset"
          }
        ]
      },
      "ObjectPatchSetAsset": {
        "title": "set",
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemoveAsset": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": ["value1", "value2"],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchDataSet": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated asset: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSetDataSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemoveDataSet"
          }
        ]
      },
      "ObjectPatchSetDataSet": {
        "title": "set",
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemoveDataSet": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": ["value1", "value2"],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchStringSet": {
        "title": "set",
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchStringAddOrRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchString": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ArrayPatchStringSet"
          },
          {
            "$ref": "#/components/schemas/ArrayPatchStringAddOrRemove"
          }
        ],
        "description": "Change that will be applied to the array."
      },
      "IsNull": {
        "type": "object",
        "properties": {
          "isNull": {
            "type": "boolean",
            "example": true,
            "description": "Set to true if you want to search for data with field value not set, false to search for cases where some value is present."
          }
        }
      },
      "PartitionObject": {
        "type": "object",
        "properties": {
          "partition": {
            "$ref": "#/components/schemas/Partition"
          }
        }
      },
      "SetLongField": {
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SetStringField": {
        "type": "object",
        "title": "set",
        "required": ["set"],
        "properties": {
          "set": {
            "type": "string"
          }
        }
      },
      "SetIntegerField": {
        "type": "object",
        "title": "set",
        "required": ["set"],
        "properties": {
          "set": {
            "type": "integer"
          }
        }
      },
      "SetBooleanField": {
        "type": "object",
        "title": "set",
        "required": ["set"],
        "properties": {
          "set": {
            "type": "boolean"
          }
        }
      },
      "GeoLocationFilter": {
        "description": "Only include files matching the specified geographic relation.",
        "type": "object",
        "required": ["relation", "shape"],
        "properties": {
          "relation": {
            "type": "string",
            "enum": ["INTERSECTS", "DISJOINT", "WITHIN"],
            "description": "One of the supported queries."
          },
          "shape": {
            "type": "object",
            "description": "Represents the points, curves and surfaces in the coordinate space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/Point"
              },
              {
                "$ref": "#/components/schemas/LineString"
              },
              {
                "$ref": "#/components/schemas/Polygon"
              },
              {
                "$ref": "#/components/schemas/MultiLineString"
              },
              {
                "$ref": "#/components/schemas/MultiPolygon"
              }
            ],
            "discriminator": {
              "propertyName": "type"
            }
          }
        }
      },
      "GeoLocationGeometry": {
        "type": "object",
        "required": ["type"],
        "description": "Represents the points, curves and surfaces in the coordinate space.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Point"
          },
          {
            "$ref": "#/components/schemas/LineString"
          },
          {
            "$ref": "#/components/schemas/Polygon"
          },
          {
            "$ref": "#/components/schemas/MultiPoint"
          },
          {
            "$ref": "#/components/schemas/MultiLineString"
          },
          {
            "$ref": "#/components/schemas/MultiPolygon"
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "Point": {
        "type": "object",
        "required": ["type", "coordinates"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["Point"]
          },
          "coordinates": {
            "$ref": "#/components/schemas/PointCoordinates"
          }
        }
      },
      "PointCoordinates": {
        "description": "Coordinates of a point in 2D space, described as an array of 2 numbers.\n\nExample: `[4.306640625, 60.205710352530346]`\n",
        "type": "array",
        "minItems": 2,
        "maxItems": 2,
        "items": {
          "type": "number"
        }
      },
      "LineString": {
        "type": "object",
        "required": ["type", "coordinates"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["LineString"]
          },
          "coordinates": {
            "$ref": "#/components/schemas/LineStringCoordinates"
          }
        }
      },
      "LineStringCoordinates": {
        "description": "Coordinates of a line described by a list of two or more points.\nEach point is defined as a pair of two numbers in an array, representing coordinates of a point in 2D space.\n\nExample: `[[30, 10], [10, 30], [40, 40]]`\n",
        "type": "array",
        "minItems": 2,
        "items": {
          "$ref": "#/components/schemas/PointCoordinates"
        }
      },
      "Polygon": {
        "type": "object",
        "required": ["type", "coordinates"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["Polygon"]
          },
          "coordinates": {
            "$ref": "#/components/schemas/PolygonCoordinates"
          }
        }
      },
      "PolygonCoordinates": {
        "description": "List of one or more linear rings representing a shape.\n\nA linear ring is the boundary of a surface or the boundary of a hole in a surface. It is defined as a list consisting of 4 or more Points, where the first and last Point is equivalent.\n\nEach Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]], [[20, 30], [35, 35], [30, 20], [20, 30]]]`\n",
        "type": "array",
        "minItems": 2,
        "items": {
          "$ref": "#/components/schemas/LineStringCoordinates"
        }
      },
      "MultiPoint": {
        "type": "object",
        "required": ["type", "coordinates"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["MultiPoint"]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiPointCoordinates"
          }
        }
      },
      "MultiPointCoordinates": {
        "description": "List of Points. Each Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[35, 10], [45, 45]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PointCoordinates"
        }
      },
      "MultiLineString": {
        "type": "object",
        "required": ["type", "coordinates"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["MultiLineString"]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiLineStringCoordinates"
          }
        }
      },
      "MultiLineStringCoordinates": {
        "description": "List of lines where each line (LineString) is defined as a list of two or more points.\nEach point is defined as a pair of two numbers in an array, representing coordinates of a point in 2D space.\n\nExample: `[[[30, 10], [10, 30]], [[35, 10], [10, 30], [40, 40]]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/LineStringCoordinates"
        }
      },
      "MultiPolygon": {
        "type": "object",
        "required": ["type", "coordinates"],
        "properties": {
          "type": {
            "type": "string",
            "enum": ["MultiPolygon"]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiPolygonCoordinates"
          }
        }
      },
      "MultiPolygonCoordinates": {
        "description": "List of multiple polygons.\n\nEach polygon is defined as a list of one or more linear rings representing a shape.\n\nA linear ring is the boundary of a surface or the boundary of a hole in a surface. It is defined as a list consisting of 4 or more Points, where the first and last Point is equivalent.\n\nEach Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[[[30, 20], [45, 40], [10, 40], [30, 20]]], [[[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PolygonCoordinates"
        }
      },
      "GeoLocation": {
        "description": "The geographic metadata of the file.",
        "required": ["type", "geometry"],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["Feature"],
            "description": "One of the GeoJSON types. Currently only the 'Feature' type is supported."
          },
          "geometry": {
            "$ref": "#/components/schemas/GeoLocationGeometry"
          },
          "properties": {
            "type": "object",
            "description": "Additional properties in a String key -> Object value format."
          }
        }
      },
      "SinglePatchGeoLocation": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetGeoLocation"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the geoLocation, or remove the value."
      },
      "SetGeoLocation": {
        "title": "set",
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/GeoLocation"
          }
        }
      },
      "RemoveField": {
        "title": "remove",
        "type": "object",
        "required": ["setNull"],
        "properties": {
          "setNull": {
            "type": "boolean",
            "example": true
          }
        }
      },
      "SetExternalId": {
        "type": "object",
        "title": "set",
        "required": ["set"],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "SetDataSetId": {
        "type": "object",
        "required": ["set"],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/DataSetId"
          }
        }
      },
      "SetDescription": {
        "type": "object",
        "title": "set",
        "required": ["set"],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ResourceDescription"
          }
        }
      },
      "SinglePatchResourceDescription": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDescription"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchDataSetId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDataSetId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchExternalId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetExternalId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the externalId, or remove the value. Must be unique for the resource type."
      },
      "SinglePatchLong": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetLongField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the string, or remove the value."
      },
      "ModifyPatchInteger": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetIntegerField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the integer, or remove the value"
      },
      "ModifyPatchBoolean": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetBooleanField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the boolean, or remove the value"
      },
      "SinglePatchString": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetStringField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the string, or remove the value."
      },
      "SinglePatchRequiredString": {
        "title": "set",
        "type": "object",
        "properties": {
          "set": {
            "type": "string"
          }
        },
        "description": "Set a new value for the string.",
        "required": ["set"]
      },
      "DataSetInternalId": {
        "type": "object",
        "title": "DataSetInternalId",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DataSetExternalId": {
        "type": "object",
        "title": "DataSetExternalId",
        "required": ["externalId"],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "DataSetIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DataSetInternalId"
          },
          {
            "$ref": "#/components/schemas/DataSetExternalId"
          }
        ]
      },
      "DataSetIdEithers": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/DataSetIdEither"
        }
      },
      "DataSetId": {
        "description": "The dataSet Id for the item.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "TimestampOrStringStart": {
        "oneOf": [
          {
            "type": "integer",
            "default": 0
          },
          {
            "type": "string"
          }
        ],
        "description": "Get datapoints starting from, and including, this time. The format is N[timeunit]-ago where\ntimeunit is w,d,h,m,s. Example: '2d-ago' gets datapoints that are up to 2 days\nold. You can also specify time in milliseconds since epoch. Note that for aggregates, the start time is rounded down to a whole granularity unit (in UTC timezone). Daily granularities (d)\nare rounded to 0:00 AM; hourly granularities (h) to the start of the hour, etc."
      },
      "TimestampOrStringEnd": {
        "oneOf": [
          {
            "type": "integer"
          },
          {
            "type": "string",
            "default": "now"
          }
        ],
        "description": "Get datapoints up to, but excluding, this point in time. Same format as for start. Note that when using aggregates, the end will be rounded up such that the last aggregate represents a full aggregation interval containing the original end, where the interval is the granularity unit times the granularity multiplier. For granularity 2d, the aggregation interval is 2 days, if end was originally 3 days after the start, it will be rounded to 4 days after the start."
      },
      "Label": {
        "type": "object",
        "title": "Label",
        "required": ["externalId"],
        "description": "A label assigned to a resource.",
        "properties": {
          "externalId": {
            "description": "An external ID to a predefined label definition.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          }
        }
      },
      "LabelList": {
        "type": "array",
        "description": "A list of the labels associated with this resource item.",
        "minItems": 0,
        "maxItems": 10,
        "uniqueItems": true,
        "items": {
          "$ref": "#/components/schemas/Label"
        }
      },
      "LabelFilter": {
        "description": "Return only the resource matching the specified label constraints.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/LabelContainsAllFilter"
          }
        ]
      },
      "LabelContainsAnyFilter": {
        "type": "object",
        "required": ["containsAny"],
        "properties": {
          "containsAny": {
            "description": "The resource item contains at least one of the listed labels.",
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelContainsAllFilter": {
        "type": "object",
        "required": ["containsAll"],
        "properties": {
          "containsAll": {
            "description": "The resource item contains at least all the listed labels.",
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelDefinitionExternalId": {
        "type": "object",
        "required": ["externalId"],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "LabelDefinitionExternalIdList": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/LabelDefinitionExternalId"
            }
          }
        }
      },
      "LabelsPatch": {
        "description": "Updates the resource's assigned labels.\n\nLabels can be added, removed or replaced (set). Adding an already attached label is an idempotent operation. Removing a label with no matching externalId is silently ignored.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelsAddRemove"
          },
          {
            "$ref": "#/components/schemas/LabelsSet"
          }
        ]
      },
      "LabelsAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "A list of the labels to add to a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          },
          "remove": {
            "type": "array",
            "description": "A list of the labels to remove from a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelsSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "A list of the labels to replace (set) to a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "NextCursor": {
        "type": "string",
        "description": "Cursor to get the next page of results (if available)."
      },
      "DigitalTwinConfig": {
        "type": "object",
        "description": "Digital twin resource.",
        "required": ["id", "data"],
        "properties": {
          "id": {
            "type": "integer",
            "description": "ID of the digital twin.",
            "format": "int64"
          },
          "data": {
            "$ref": "#/components/schemas/TwinConfiguration"
          }
        }
      },
      "CreateDigitalTwinConfig": {
        "type": "object",
        "description": "Digital twin resource.",
        "required": ["data"],
        "properties": {
          "data": {
            "$ref": "#/components/schemas/TwinConfiguration"
          }
        }
      },
      "UpdateDigitalTwinConfig": {
        "type": "object",
        "description": "Digital twin resource.",
        "required": ["id", "data"],
        "properties": {
          "id": {
            "type": "integer",
            "description": "ID of the digital twin.",
            "format": "int64"
          },
          "data": {
            "$ref": "#/components/schemas/TwinConfiguration"
          }
        }
      },
      "DigitalTwinConfigList": {
        "type": "object",
        "description": "List of digital twins.",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DigitalTwinConfig"
            }
          }
        }
      },
      "TwinConfiguration": {
        "description": "Data structure that fully defines a digital twin in the Cognite Digital Twin Application.",
        "required": ["header", "assets", "scenes"],
        "type": "object",
        "properties": {
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "assets": {
            "$ref": "#/components/schemas/Assets"
          },
          "scenes": {
            "description": "Array of 3D scenes in this available in this twin. Only one scene can be active and visible at any moment",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Scene"
            },
            "minItems": 1
          },
          "hierarchy": {
            "$ref": "#/components/schemas/BaseMenuHierarchy"
          },
          "simulations": {
            "description": "Array of timeseries simulations for this twin",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Simulation"
            }
          },
          "timeseriesFilters": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TimeseriesFilter"
            }
          }
        }
      },
      "Simulation": {
        "type": "object",
        "description": "Data structure that defines a simulation.",
        "required": ["displayName", "timeseriesMappings"],
        "properties": {
          "displayName": {
            "description": "Name of the simulation, to be shown in the user interface.",
            "type": "string"
          },
          "timeseriesFilterId": {
            "description": "The identifier of the timeseries filter to apply when this simulation is active.",
            "type": "string"
          },
          "timeseriesMappings": {
            "description": "Array of timeseries mappings for this simulataion.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimeSeriesMapping"
            }
          }
        }
      },
      "TimeSeriesMapping": {
        "description": "Mapping between time series in a simulation.",
        "type": "object",
        "required": ["mappingFrom", "mappingTo"],
        "properties": {
          "mappingFrom": {
            "$ref": "#/components/schemas/ExtendedTimeSeriesId"
          },
          "mappingTo": {
            "$ref": "#/components/schemas/TimeSeriesIdOrConstant"
          }
        }
      },
      "TimeSeriesId": {
        "description": "An ID that uniquely identifies a time series.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          }
        }
      },
      "TimeSeriesIdOrConstant": {
        "description": "Represents either a time series ID or a constant value that will be used in place of a time series.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "constantValue": {
            "description": "Constant value to use instead of a time series.",
            "type": "number",
            "format": "double"
          }
        }
      },
      "ExtendedTimeSeriesId": {
        "description": "Represents either a time series ID or an identifier that can be mapped to a time series ID in a simulation.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "simulationIdentifier": {
            "type": "string",
            "description": "An identifier that can be used instead of a time series ID when mapping time series for a simulation.",
            "maxLength": 255
          }
        }
      },
      "ExtendedTimeSeriesIdOrConstant": {
        "description": "Represents either a time series ID, an identifier that can be mapped to a time series ID in a simulation, or a constant value that will be used in place of a time series.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "simulationIdentifier": {
            "type": "string",
            "description": "An identifier that can be used instead of a time series ID when mapping time series for a simulation.",
            "maxLength": 255
          },
          "constantValue": {
            "description": "Constant value to use instead of a time series.",
            "type": "number",
            "format": "double"
          }
        }
      },
      "ExtendedTimeSeriesIdOrFileId": {
        "description": "Represents either a time series ID or a file ID.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "simulationIdentifier": {
            "type": "string",
            "description": "An identifier that can be used instead of a time series ID when mapping time series for a simulation.",
            "maxLength": 255
          },
          "fileId": {
            "description": "A unique id of a file in the file API.",
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991
          }
        }
      },
      "Header": {
        "description": "Header containing basic information and metadata about the twin.",
        "required": ["name"],
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the twin, as it will be shown in the Digital Twin Application.",
            "type": "string"
          },
          "thumbnailImageId": {
            "description": "File API ID of image that will be used as thumbnail for the twin in the Digital Twin Application.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "Assets": {
        "description": "Declaration of the data assets used by this twin. Actors in the twin refer to these assets as data sources.",
        "type": "object",
        "properties": {
          "geometries": {
            "description": "Map of all geometry data used by this digital twin. Keys in this map represent IDs that can be used as references to the data in twin actors.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/GeometryData"
            }
          },
          "splines": {
            "description": "Map of all spline data used by this digital twin. Keys in this map represent IDs that can be used as references to the data in spline actors.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SplineData"
            }
          }
        }
      },
      "GeometryData": {
        "description": "A 3D model asset used by this twin. Contains IDs referencing a 3D model file in the 3D API, and optionally applies a transform to the model. <br> Additional field usage information:\n  * `colorOverride` - color to apply on this 3d model. This color will override any texture information.\n  * `photogrammetryLightingOverride` - Override for how photogrammetry meshes (if any) in this model are affected by lighting.\n",
        "type": "object",
        "required": ["modelId", "revisionId"],
        "properties": {
          "modelId": {
            "description": "3D API ID of the model.",
            "type": "integer",
            "format": "int64"
          },
          "revisionId": {
            "description": "3D API ID of the revision of the model.",
            "type": "integer",
            "format": "int64"
          },
          "preserveMaterialSlots": {
            "description": "Whether or not to preserve material slots from the original 3D file. Should only be true if the model will use textured material overrides.",
            "type": "boolean"
          },
          "transform": {
            "$ref": "#/components/schemas/RelativeTransform"
          },
          "colorOverride": {
            "$ref": "#/components/schemas/Color"
          },
          "photogrammetryLightingOverride": {
            "$ref": "#/components/schemas/PhotogrammetryLightingType"
          }
        }
      },
      "SplineDataFormat": {
        "type": "string",
        "enum": ["noTangents", "withTangents"],
        "description": "Describes the format of spline data:\n  * `noTangents` - Sequence of X, Y, Z coordinates for spline points, in centimeters in the local coordinate system of the spline.\n  * `withTangents ` - Sequence of spline points, where each point in the sequence is represented with 9 floating point numbers; all in the local coordinate system of the spline: <br> - X, Y, Z coordinates of the spline point in centimeters. <br> - X, Y, Z components of incoming tangent vector. <br> - X, Y, Z components of outgoing tangent vector.\n"
      },
      "SplineData": {
        "description": "Spline data used by this twin.",
        "type": "object",
        "required": ["splinePoints", "splineDataFormat"],
        "properties": {
          "splineDataFormat": {
            "$ref": "#/components/schemas/SplineDataFormat"
          },
          "splinePoints": {
            "description": "Array of spline points, with or without tangents.",
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "MenuHierarchyType": {
        "type": "string",
        "enum": ["fullAssetHierarchy", "customHierarchy"],
        "description": "Source of the hierarchy for the navigation menu:\n  * `fullAssetHierarchy` - \"Full asset hierarchy for the current tenant. Should only be used on tenants with very small asset hierarchies.\"\n  * `customHierarchy` - \"Custom made hierarchy, defined in this file.\"\n"
      },
      "PhotogrammetryLightingType": {
        "type": "string",
        "enum": ["unlitRendering", "litRendering"],
        "description": "Lighting style for photogrammetry models:\n  * `unlitRendering` - Unlit rendering: The models will not be affected by the lighting in the scene. This is the default setting.\n  * `litRendering` - Lit rendering: The models will be affected by lights and shadows in the scene. This is not recommended, as photogrammetry textures usually have lighting baked into them.\n"
      },
      "GeographicLocation": {
        "description": "Describes a global position using a set of coordinates and an optional Coordinate Reference System (CRS). If no CRS is given, coordinates are assumed to be local Unreal Engine 4 coordinates.",
        "type": "object",
        "required": ["coordinates"],
        "properties": {
          "crs": {
            "description": "A Proj.4 formatted string describing a Coordinate Reference System (CRS). Currently, only longlat and utm (for WGS84) are supported.",
            "example": "+proj=utm +zone=31 +units=m",
            "type": "string"
          },
          "coordinates": {
            "description": "An array of three floating-point numbers specifying a coordinate in the given CRS (or in UE4 coordinates if no CRS is given). The third value is always the altitude given in cm.",
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            },
            "minItems": 3,
            "maxItems": 3
          }
        }
      },
      "GeographicCoordinateMapping": {
        "description": "Relates the coordinate system in the application with a geographic coordinate system. Sets up a reference point in geographic coordinates, and the corresponding reference point in the coordinate system of the 3D scene.<br> Additional field usage information:\n  * `referencePointGeographicLocation` - A geographic coordinate to be related with a given position in the coordinate system of the 3D scene.\n",
        "type": "object",
        "required": [
          "referencePointGeographicLocation",
          "referencePointSceneCoordinate",
          "northAngle"
        ],
        "properties": {
          "referencePointGeographicLocation": {
            "$ref": "#/components/schemas/GeographicLocation"
          },
          "referencePointSceneCoordinate": {
            "description": "The position in the (Unreal Engine 4) scene coordinate system to be related with the given location in geographic coordinates. Expects an array of three numbers for position (in centimeters) along the XYZ-axes.",
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            },
            "minItems": 3,
            "maxItems": 3
          },
          "northAngle": {
            "description": "The angle (in degrees) from the positive X-axis in the 3D scene that describes geographic north. Example: If X-axis in the scene points south, northAngle should be 180. If it points west, northAngle should be 90.",
            "type": "number",
            "format": "float"
          }
        }
      },
      "BaseMenuHierarchy": {
        "description": "Defines a navigation menu hierarchy.<br> Variants:\n  * `fullAssetHierarchy` - Defines a navigation menu hierarchy constructed from the full asset hierarchy of the tenant. Warning: Should only be used on tenants with small asset hierarchies, as this will fetch the full asset hierarchy.\n  * `customMenuHierarchy` - Defines a custom navigation menu hierarchy. The children defined here will be considered root nodes, and each root node can have any number of child nodes and subsequent descendant nodes.\n",
        "type": "object",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "fullAssetHierarchy": "#/components/schemas/FullAssetHierarchy",
            "customHierarchy": "#/components/schemas/CustomMenuHierarchy"
          }
        },
        "required": ["type"],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/MenuHierarchyType"
          }
        }
      },
      "FullAssetHierarchy": {
        "description": "Defines a navigation menu hierarchy constructed from the full asset hierarchy of the tenant. Warning: Should only be used on tenants with small asset hierarchies, as this will fetch the full asset hierarchy.",
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseMenuHierarchy"
          },
          {
            "type": "object",
            "properties": {
              "rootAssetId": {
                "description": "Asset ID of the asset hierarchy node that will be used as root node for the hierarchy.",
                "type": "integer",
                "format": "int64"
              }
            }
          }
        ]
      },
      "CustomMenuHierarchy": {
        "description": "Defines a custom navigation menu hierarchy. The children defined here will be considered root nodes, and each root node can have any number of child nodes and subsequent descendant nodes.",
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseMenuHierarchy"
          },
          {
            "type": "object",
            "required": ["rootNodes"],
            "properties": {
              "rootNodes": {
                "description": "Root nodes of the hierarchy.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/CustomMenuHierarchyNode"
                }
              }
            }
          }
        ]
      },
      "CustomMenuHierarchyNode": {
        "description": "A node in a custom menu hierarchy. Can be linked to a CDF asset ID, and can have any number of child nodes.",
        "type": "object",
        "properties": {
          "displayName": {
            "description": "The name of the node, as it will be displayed in the menu. If both this field and assetInternalId are provided, this field will be displayed instead of the name from the asset associated with the asset ID.",
            "type": "string"
          },
          "assetInternalId": {
            "description": "CDF internal ID of asset associated with this hierarchy node. If displayName is not provided, the name of the asset in CDF will be displayed in the menu.",
            "type": "integer",
            "format": "int64"
          },
          "children": {
            "description": "Child hierarchy nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CustomMenuHierarchyNode"
            }
          }
        }
      },
      "Box": {
        "description": "This is a bounding box.",
        "allOf": [
          {
            "type": "object",
            "required": ["min", "max"],
            "properties": {
              "min": {
                "$ref": "#/components/schemas/GeographicLocation"
              },
              "max": {
                "$ref": "#/components/schemas/GeographicLocation"
              }
            }
          }
        ]
      },
      "Camera": {
        "description": "Scene camera properties.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "initialCoordinates": {
                "$ref": "#/components/schemas/AbsoluteTransform"
              },
              "limits": {
                "$ref": "#/components/schemas/Box"
              },
              "groundReference": {
                "type": "number",
                "format": "float"
              }
            }
          }
        ]
      },
      "Scene": {
        "type": "object",
        "description": "Describes a 3D scene and all the objects in it.",
        "properties": {
          "geographicCoordinates": {
            "$ref": "#/components/schemas/GeographicCoordinateMapping"
          },
          "camera": {
            "$ref": "#/components/schemas/Camera"
          },
          "actors": {
            "description": "List of actors: objects that will be placed in the 3D scene.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Actor"
            }
          },
          "terrains": {
            "description": "List of objects that describe terrains in the scene.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Terrain"
            }
          },
          "heightRenderer": {
            "$ref": "#/components/schemas/HeightRenderer"
          },
          "basicMeshActors": {
            "description": "List of objects that describe basic meshes with materials positioned in the 3D scene.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BasicMeshActor"
            }
          },
          "waterPlane": {
            "$ref": "#/components/schemas/WaterPlane"
          },
          "environmentControl": {
            "$ref": "#/components/schemas/EnvironmentControl"
          },
          "visibilityLayers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VisibilityLayers"
            }
          }
        }
      },
      "Terrain": {
        "type": "object",
        "required": ["transform"],
        "properties": {
          "transform": {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          "heightMap": {
            "description": "A reference to the image to use as the source of heightmap data.",
            "type": "string"
          },
          "normalMapMap": {
            "description": "A reference to the image to use as surface normal information.",
            "type": "string"
          },
          "baseColor": {
            "description": "A reference to the image to use to color the terrain surface.",
            "type": "string"
          },
          "terrainMinHeight": {
            "description": "The height of the lowest point of the terrain.",
            "type": "number",
            "format": "float"
          },
          "terrainMaxHeight": {
            "description": "The height of the highest point of the terrain.",
            "type": "number",
            "format": "float"
          },
          "heightMapMinValue": {
            "description": "The value of the lowest point of the terrain as encoded in the heightmap.",
            "type": "number",
            "format": "float"
          },
          "heightMapMaxValue": {
            "description": "The value of the highest point of the terrain as encoded in the heightmap.",
            "type": "number",
            "format": "float"
          },
          "lodScreenSizeFactor": {
            "description": "The LOD screen-size factor determines the distance at which refinement of the geometry of the terrain mesh occurs. This impacts the performance and fidelity of the terrain object.",
            "type": "number",
            "format": "float"
          },
          "tileSizeScale": {
            "description": "the tile size scale parameter scales the terrain tiles. It does not affect the scale of the terrain features (see metersPerpixel). This parameter impacts performance, as larger tiles cover more terrain area, so that fewer are needed to cover the same region.",
            "type": "number",
            "format": "float"
          },
          "metersPerPixel": {
            "description": "The meters-per-pixel parameter determines the scale of the terrain data. It specifies how far apart in the scene to space the pixel-centers of the heightmap and the other terrain surface textures. A value of 1 corresponds to 1 meter between each heightmap sample point. The parameter must correspond to the scale and resolution of the provided heightmap.",
            "type": "number",
            "format": "float"
          },
          "numTilesX": {
            "description": "The number of terrain tiles along the first axis.",
            "type": "integer",
            "format": "int32"
          },
          "numTilesY": {
            "description": "The number of terrain tiles along the second axis.",
            "type": "integer",
            "format": "int32"
          }
        },
        "description": "The terrain object uses heightmap data to produce a 3D terrain in the scene.<br> The terrain assumes that the heightmap data is linearly encoded.<br> transform: The position of the terrain."
      },
      "WidgetRotationMode": {
        "type": "string",
        "enum": [
          "noRotation",
          "faceCamera",
          "faceCamera_ZOnly",
          "faceCamera_HorizontalAlignment"
        ],
        "description": "Rotation type for widgets in the scene (relative to camera):\n  * `noRotation` - The rotation will be fixed to the direction given by the transform.\n  * `faceCamera` - The widget will rotate to always face towards the camera.\n  * `faceCamera_ZOnly` - The widget will rotate around its vertical axis to face towards the camera. (Typical use-case: rotated towards camera while staying perpendicular to the ground).\n  * `faceCamera_HorizontalAlignment` - The widget will always face towards the camera and be aligned to the screen. Equivalent to a 2D widget, but placed in 3D space.\n"
      },
      "WidgetType": {
        "type": "string",
        "enum": ["text", "bar", "discreteTimeSeries"],
        "description": "Describes a type of a widget\n  * `text` - A widget displaying a single string of text.\n  * `bar` - A 3D grapical bar representing a value.\n  * `discreteTimeSeries` - A widget displaying discrete time series in the format of a heading, content based on user defined enums and a possible image.\n"
      },
      "BarFillType": {
        "type": "string",
        "enum": [
          "leftToRight",
          "rightToLeft",
          "fillFromCenter",
          "topToBottom",
          "bottomToTop"
        ],
        "description": "Gives the orientation of the progress bar fill mode.\n  * 'leftToRight' -    left to right fill mode\n  * 'rightToLeft' -    right to left fill mode\n  * 'fillFromCenter' - fill from center fill mode\n  * 'topToBottom' -    top to bottom fill mode\n  * 'bottomToTop' -    bottom to top fill mode\n"
      },
      "WidgetMaterialType": {
        "description": "Controls the translucency of a widget\n  * 'masked' - the widget will use a masked material, with sharp cutoff in opacity.\n  * 'translucent' - the widget uses a translucent material. Required if the widgets should fade out smoothly with distance.\n",
        "type": "string",
        "enum": ["translucent", "masked"]
      },
      "WidgetBase": {
        "description": "Base class for widgets (texts, images, etc) that appear in a scene.",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "text": "#/components/schemas/WidgetText",
            "bar": "#/components/schemas/WidgetBar",
            "discreteTimeSeries": "#/components/schemas/WidgetDiscreteTimeSeries"
          }
        },
        "required": ["type"],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/WidgetType"
          },
          "assetId": {
            "description": "Asset ID in CDF to which widget should be connected (useful for connecting widget to specific building on scene without explicitly specifying widget's location)",
            "type": "integer",
            "format": "int64"
          },
          "minScreenSize": {
            "description": "Minimal percentage of screen size along vertical axis for widget to occupy.",
            "type": "number",
            "format": "float"
          },
          "cutOffDistance": {
            "description": "Distance from camera above which the widget becomes invisible (If not specified, the widget will be visible from any distance).",
            "type": "number",
            "format": "float"
          },
          "fadeDistance": {
            "description": "Defines the size of the region where the visibility of the widget fades out. The widget will start fading out at a distance cutOffDistance - fadeDistance from the camera, and be completely invisible at a camera distance equal to cutOffDistance.",
            "type": "number",
            "format": "float"
          },
          "materialType": {
            "$ref": "#/components/schemas/WidgetMaterialType"
          },
          "transform": {
            "$ref": "#/components/schemas/RelativeTransform"
          },
          "rotationMode": {
            "$ref": "#/components/schemas/WidgetRotationMode"
          }
        }
      },
      "FontTypeface": {
        "description": "Font family",
        "type": "string",
        "enum": [
          "black",
          "blackItalic",
          "bold",
          "boldItalic",
          "extraBoldItalic",
          "extraLight",
          "extraLightItalic",
          "italic",
          "light",
          "lightItalic",
          "medium",
          "mediumItalic",
          "regular",
          "semiBold",
          "semiBoldItalic",
          "thin",
          "thinItalic"
        ]
      },
      "WidgetText": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WidgetBase"
          },
          {
            "type": "object",
            "description": "Widget for creating text labels in the 3D scene.",
            "required": ["content"],
            "properties": {
              "content": {
                "description": "String content of the text widget. Supports inline time series, see example for syntax.",
                "example": "Temperature is {timeseriesId:012345} degrees.",
                "type": "string"
              },
              "color": {
                "$ref": "#/components/schemas/Color"
              },
              "size": {
                "description": "Font size for text",
                "type": "number",
                "format": "float"
              },
              "outlineSize": {
                "description": "Outline size for text",
                "type": "number",
                "format": "float"
              },
              "outlineColor": {
                "$ref": "#/components/schemas/Color"
              },
              "typeface": {
                "$ref": "#/components/schemas/FontTypeface"
              },
              "shadowColor": {
                "$ref": "#/components/schemas/Color"
              },
              "shadowOffsetX": {
                "description": "Offset of a shadow along horizontal axis",
                "type": "number",
                "format": "float"
              },
              "shadowOffsetY": {
                "description": "Offset of a shadow along vertical axis",
                "type": "number",
                "format": "float"
              },
              "backgroundColor": {
                "$ref": "#/components/schemas/Color"
              }
            }
          }
        ]
      },
      "WidgetBar": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WidgetBase"
          },
          {
            "type": "object",
            "description": "Widget for creating graphical bars in the 3D scene.",
            "required": ["minValue", "maxValue"],
            "properties": {
              "heading": {
                "description": "Displayed heading for the bar widget. Will use timeseries name if not specified.",
                "type": "string"
              },
              "color": {
                "$ref": "#/components/schemas/Color"
              },
              "width": {
                "description": "The width of the bar widget",
                "type": "number",
                "format": "float"
              },
              "height": {
                "description": "The height of the bar widget",
                "type": "number",
                "format": "float"
              },
              "defaultValue": {
                "description": "Default value for bar widget",
                "type": "number",
                "format": "float"
              },
              "minValue": {
                "description": "Minimum value for bar widget",
                "type": "number",
                "format": "float"
              },
              "maxValue": {
                "description": "Maximum value for bar widget",
                "type": "number",
                "format": "float"
              },
              "timeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesId"
              },
              "currentValueMaxFractionalDigits": {
                "description": "The maximum number of fractional decimal digits to display for the current value",
                "type": "integer",
                "format": "int32"
              },
              "boundsValueMaxFractionalDigits": {
                "description": "The maximum number of fractional decimal digits to display for the min and max values",
                "type": "integer",
                "format": "int32"
              },
              "headingFontSize": {
                "description": "Font size for heading",
                "type": "number",
                "format": "float"
              },
              "valuesFontSize": {
                "description": "Font size for values",
                "type": "number",
                "format": "float"
              },
              "paddingSize": {
                "description": "Border padding override",
                "type": "number",
                "format": "float"
              },
              "barFill": {
                "$ref": "#/components/schemas/BarFillType"
              },
              "typeface": {
                "$ref": "#/components/schemas/FontTypeface"
              }
            }
          }
        ]
      },
      "DiscreteTimeSeriesEnums": {
        "description": "User defined content based on discrete time series enums.",
        "required": ["content"],
        "properties": {
          "content": {
            "description": "user defined message to be displayed once the enum is triggered by discrete time series content from the CDF",
            "type": "string"
          },
          "image": {
            "description": "Image ID in CDF for load as an icon in the display of widgetDiscreteTimeSeries",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "WidgetDiscreteTimeSeries": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WidgetBase"
          },
          {
            "type": "object",
            "description": "Widget for creating discrete time series labels in the 3D scene.",
            "required": ["heading", "timeSeries"],
            "properties": {
              "heading": {
                "description": "String with the containing header for displaying the discrete time series content.",
                "example": "Machine status:",
                "type": "string"
              },
              "timeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesId"
              },
              "colorHeading": {
                "$ref": "#/components/schemas/Color"
              },
              "sizeHeading": {
                "description": "Font size for text",
                "type": "number",
                "format": "float"
              },
              "outlineSizeHeading": {
                "description": "Outline size for text",
                "type": "number",
                "format": "float"
              },
              "outlineColorHeading": {
                "$ref": "#/components/schemas/Color"
              },
              "typefaceHeading": {
                "$ref": "#/components/schemas/FontTypeface"
              },
              "colorContent": {
                "$ref": "#/components/schemas/Color"
              },
              "sizeContent": {
                "description": "Font size for text",
                "type": "number",
                "format": "float"
              },
              "outlineSizeContent": {
                "description": "Outline size for text",
                "type": "number",
                "format": "float"
              },
              "outlineColorContent": {
                "$ref": "#/components/schemas/Color"
              },
              "typefaceContent": {
                "$ref": "#/components/schemas/FontTypeface"
              },
              "shadowColor": {
                "$ref": "#/components/schemas/Color"
              },
              "shadowOffsetX": {
                "description": "Offset of a shadow along horizontal axis",
                "type": "number",
                "format": "float"
              },
              "shadowOffsetY": {
                "description": "Offset of a shadow along vertical axis",
                "type": "number",
                "format": "float"
              },
              "TextPadding": {
                "description": "Padding added in the text area",
                "type": "number",
                "format": "float"
              },
              "ImagePadding": {
                "description": "Padding added in the image area",
                "type": "number",
                "format": "float"
              },
              "ImageScaleX": {
                "description": "Image scale along horizontal axis",
                "type": "number",
                "format": "float"
              },
              "ImageScaleY": {
                "description": "Image scale along along vertical axis",
                "type": "number",
                "format": "float"
              },
              "backgroundColor": {
                "$ref": "#/components/schemas/Color"
              },
              "enums": {
                "description": "Map of discrete time series enums to user defined messages.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/DiscreteTimeSeriesEnums"
                }
              },
              "defaultContent": {
                "description": "default content in case of not having a proper enum set up",
                "type": "string"
              },
              "defaultImage": {
                "description": "default image in case of not having a proper enum set up",
                "type": "integer",
                "format": "int64"
              }
            }
          }
        ]
      },
      "TransformControllerType": {
        "type": "string",
        "enum": [
          "latLongSeparateTimeSeries",
          "northingEastingSeparateTimeSeries",
          "localToWorldUserDefinedSeparateTimeSeries",
          "localToWorldWithVelocityVectorsUserDefinedSeparateTimeSeries"
        ],
        "description": "Specifies the type of a transform controller\n  * `latLongSeparateTimeSeries` - Controls the position and rotation of an actor based on time series containing latitude and longitude information.\n  * `northingEastingSeparateTimeSeries` - Controls the position and rotation of an actor based on time series containing northing and easting information.\n  * `localToWorldUserDefinedSeparateTimeSeries` - Controls the position and rotation of an actor based on time series containing local coordinates that will be transformed linearly to world coordinates.\n  * `localToWorldWithVelocityVectorsUserDefinedSeparateTimeSeries` - Controls the position and rotation with absolute positions and velocity vectors to be able to properly interpolate.\n"
      },
      "TransformControllerBase": {
        "description": "Controls the transform (position, rotation, scale) of the actor it is attached to.<br>  Variants:\n  * `latLongSeparateController` - Controls the position and rotation of an actor based on time series containing latitude and longitude information.\n  * `northingEastingSeparateController` - Controls the position and rotation of an actor based on time series containing northing and easting information.\n  * `localToWorldUserDefinedSeparateController` - Controls the position and rotation of an actor based on time series containing local coordinates that will be transformed linearly to world coordinates.\n",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "latLongSeparateTimeSeries": "#/components/schemas/LatLongSeparateController",
            "northingEastingSeparateTimeSeries": "#/components/schemas/NorthingEastingSeparateController",
            "localToWorldUserDefinedSeparateTimeSeries": "#/components/schemas/LocalToWorldUserDefinedSeparateController",
            "localToWorldWithVelocityVectorsUserDefinedSeparateTimeSeries": "#/components/schemas/LocalToWorldUserWithVelocityVectorsDefinedSeparateController"
          }
        },
        "type": "object",
        "required": ["type"],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TransformControllerType"
          }
        }
      },
      "HeightTrackingMode": {
        "type": "string",
        "enum": ["none", "constantValue", "heightmapData"],
        "description": "Determines how the vertical position of an actor will be adjusted by a transform controller:\n  * `none` - The vertical position of the actor will not be affected by the controller.\n  * `constantValue` - The actor will be placed at a fixed height.\n  * `heightmapData` - The vertical position of the actor is determined by a height map.\n"
      },
      "LatLongSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series containing latitude and longitude information.<br> Additional field usage information:\n  * `latitudeTimeSeries` - The time series from which to read geographic latitude coordinate data.     \n  * `longitudeTimeSeries` - The time series from which to read geographic longitude coordinate data.             \n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "latitudeTimeSeries",
              "longitudeTimeSeries",
              "heightTrackingMode"
            ],
            "properties": {
              "latitudeTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "longitudeTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "heightTrackingMode": {
                "$ref": "#/components/schemas/HeightTrackingMode"
              },
              "defaultHeightPosition": {
                "description": "If heightTrackingMode is set to constantValue, then defaultHeightPosition is used to specify the constant height value to use.",
                "type": "number",
                "format": "float"
              },
              "simulateRotationFromPosition": {
                "description": "Uses consecutive positions to infer rotation. Assumes that the first axis (the X-axis in local object space) should be aligned with the tangent vector of the position.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "vec4TimeSeries": {
        "description": "Four dimensional time series.<br>\n  * `xTimeSeries` - The time series from which to read the x component.\n  * `yTimeSeries` - The time series from which to read the y component.\n  * `zTimeSeries` - The time series from which to read the z component.\n  * `wTimeSeries` - The time series from which to read the w component.\n",
        "allOf": [
          {
            "type": "object",
            "required": [
              "xTimeSeries",
              "yTimeSeries",
              "zTimeSeries",
              "wTimeSeries"
            ],
            "properties": {
              "xTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "yTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "zTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "wTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              }
            }
          }
        ]
      },
      "vec3TimeSeries": {
        "description": "Three dimensional time series.<br>\n  * `xTimeSeries` - The time series from which to read the x component.\n  * `yTimeSeries` - The time series from which to read the y component.\n  * `zTimeSeries` - The time series from which to read the z component.\n",
        "allOf": [
          {
            "type": "object",
            "required": ["xTimeSeries", "yTimeSeries", "zTimeSeries"],
            "properties": {
              "xTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "yTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "zTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              }
            }
          }
        ]
      },
      "vec2TimeSeries": {
        "description": "Three dimensional time series.<br>\n  * `xTimeSeries` - The time series from which to read the x component.\n  * `yTimeSeries` - The time series from which to read the y component.\n",
        "allOf": [
          {
            "type": "object",
            "required": ["xTimeSeries", "yTimeSeries"],
            "properties": {
              "xTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "yTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              }
            }
          }
        ]
      },
      "BasicMeshType": {
        "type": "string",
        "enum": ["plane"],
        "description": "Specifies the type of the basic mesh to add to the scene\n   * `plane` - generates a plane of 1x1 m that will have applied the transform.\n"
      },
      "Material": {
        "type": "object",
        "properties": {
          "diffuse": {
            "description": "The file ID of the image in the file API.",
            "type": "integer",
            "format": "int64"
          },
          "normal": {
            "description": "The file ID of the image in the file API.",
            "type": "integer",
            "format": "int64"
          },
          "tiling": {
            "description": "The tiling for the textures attached to the material.",
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "offset": {
            "description": "The offset for the textures attached to the material.",
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "BasicMeshActor": {
        "description": "Controls the transform (position, rotation, scale) of the actor it is attached to.<br> \n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ActorBase"
          },
          {
            "type": "object",
            "required": ["meshType"],
            "properties": {
              "meshType": {
                "$ref": "#/components/schemas/BasicMeshType"
              },
              "material": {
                "$ref": "#/components/schemas/Material"
              }
            }
          }
        ]
      },
      "VisibilityController": {
        "description": "Controls the visibility of an actor based on a time series.<br> Additional field usage information:\n  * `timeSeries` - Time series used to control the visibility of the actor. \n",
        "allOf": [
          {
            "type": "object",
            "required": ["timeSeries", "minimumCondition", "maximumCondition"],
            "properties": {
              "timeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "minimumCondition": {
                "description": "The minimum value of the time series for when the actor is visible.",
                "type": "number",
                "format": "float"
              },
              "maximumCondition": {
                "description": "The maximum value of the time series for when the actor is visible.",
                "type": "number",
                "format": "float"
              }
            }
          }
        ]
      },
      "NorthingEastingSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series containing northing and easting information.<br> Additional field usage information:\n  * `northingTimeSeries` - The time series from which to read geographic northing coordinate data.       \n  * `eastingTimeSeries` - The time series from which to read geographic easting coordinate data.     \n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "northingTimeSeries",
              "eastingTimeSeries",
              "heightTrackingMode",
              "zone",
              "isNorthernHemisphere"
            ],
            "properties": {
              "northingTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "eastingTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "heightTrackingMode": {
                "$ref": "#/components/schemas/HeightTrackingMode"
              },
              "zone": {
                "description": "Set the northing easting zone.",
                "type": "integer",
                "format": "int32"
              },
              "isNorthernHemisphere": {
                "description": "If the coordinates are in the northern hemisphere.",
                "type": "boolean"
              },
              "defaultHeightPosition": {
                "description": "If heightTrackingMode is set to constantValue, then defaultHeightPosition is used to specify the constant height value to use.",
                "type": "number",
                "format": "float"
              },
              "simulateRotationFromPosition": {
                "description": "Uses consecutive positions to infer rotation. Assumes that the first axis (the X-axis in local object space) should be aligned with the tangent vector of the position.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "RotationTimeSeriesType": {
        "type": "string",
        "enum": [
          "quaternionTimeSeries",
          "yawPitchRollTimeSeries",
          "singleAxisRotationTimeSeries"
        ],
        "description": "Specifies the type of a rotation time series\n   * `quaternion` - i j q and k time series defining the quaternion orientation.\n   * `yawPitchRoll` - yaw pitch and roll time series defining the orientation.\n   * `singleAxisRotation` - single dimension rotation based on an input axis.\n"
      },
      "RotationUnitsType": {
        "type": "string",
        "enum": ["degree", "radians"],
        "description": "Specifies the unit of a rotation time series\n   * `degree` - yaw pitch and roll rotations will be considered as degrees, degrees/s in case of used as angular speed.\n   * `radians` - yaw pitch and roll rotations will be considered as radians, radians/s in case of used as angular speed.\n   \n"
      },
      "PositionTimeSeries": {
        "description": "Controls the position of the actor it is attached to with 3 time series that maps X, Y and Z.\n",
        "type": "object",
        "required": ["xyzTimeSeries"],
        "properties": {
          "xyzTimeSeries": {
            "$ref": "#/components/schemas/vec3TimeSeries"
          }
        }
      },
      "VelocityTimeSeries": {
        "description": "Controls the velocity of the actor it is attached to with 3 time series that maps X, Y and Z.\n",
        "type": "object",
        "required": ["xyzTimeSeries"],
        "properties": {
          "xyzTimeSeries": {
            "$ref": "#/components/schemas/vec3TimeSeries"
          }
        }
      },
      "AngularVelocityTimeSeriesBase": {
        "description": "Controls the rotation velocity of the actor it is attached to in rpm.\n",
        "type": "object",
        "required": ["rpmTimeSeries", "axisRotation"],
        "properties": {
          "rpmTimeSeries": {
            "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
          },
          "axisRotation": {
            "description": "Vector defining the rotation axis. Doesn't need to be normalized.",
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "RotationTimeSeriesBase": {
        "description": "Controls the rotation of the actor it is attached to.<br>  Variants:\n  * `quaternionController` - Controls the position and rotation of an actor based on time series containing latitude and longitude information.\n  * `yawPitchRollController` - Controls the position and rotation of an actor based on time series containing northing and easting information.\n  * `singleAxisRotationController` - Controls the position and rotation of an actor based on time series containing local coordinates that will be transformed linearly to world coordinates.\n",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "quaternionTimeSeries": "#/components/schemas/QuaternionController",
            "yawPitchRollTimeSeries": "#/components/schemas/YawPitchRollController",
            "singleAxisRotationTimeSeries": "#/components/schemas/SingleAxisRotationController"
          }
        },
        "type": "object",
        "required": ["type", "unitsType"],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/RotationTimeSeriesType"
          },
          "unitsType": {
            "$ref": "#/components/schemas/RotationUnitsType"
          }
        }
      },
      "QuaternionController": {
        "description": "Controls rotation of an actor based on time series containing quaternion data in a 4 dimensional time series defining i j k and q axis from a quaternion.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/RotationTimeSeriesBase"
          },
          {
            "type": "object",
            "required": ["quaternionTimeSeries"],
            "properties": {
              "quaternionTimeSeries": {
                "$ref": "#/components/schemas/vec4TimeSeries"
              }
            }
          }
        ]
      },
      "ComponentType": {
        "type": "string",
        "enum": [
          "geometryComponent",
          "widgetComponent",
          "splineComponent",
          "decalComponent"
        ],
        "description": "Type of component\n   * geometryComponent - Uses a 3D model from CDF as its geometry.\n   * widgetComponent - 3D widget positioned in the 3D scene displaying various information.\n   * splineComponent - Class for describing pipelines in scene.\n   * decalComponent - Class describing an image overlay for geometry in the scene.\n"
      },
      "Component": {
        "description": "Base class for different types of components that can be attached to actors.",
        "type": "object",
        "required": ["componentType"],
        "discriminator": {
          "propertyName": "componentType",
          "mapping": {
            "geometryComponent": "#/components/schemas/GeometryComponent",
            "widgetComponent": "#/components/schemas/WidgetComponent",
            "splineComponent": "#/components/schemas/SplineComponent",
            "decalComponent": "#/components/schemas/DecalComponent"
          }
        },
        "properties": {
          "componentType": {
            "$ref": "#/components/schemas/ComponentType"
          }
        }
      },
      "GeometryComponent": {
        "description": "Uses a 3D model from CDF as its geometry.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": ["geometryDataID"],
            "properties": {
              "geometryDataID": {
                "description": "Name of geometry listed in 'assets' section that this actor should use",
                "type": "string"
              }
            }
          }
        ]
      },
      "WidgetComponent": {
        "description": "3D widget positioned in the 3D scene.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": ["widget"],
            "properties": {
              "widget": {
                "$ref": "#/components/schemas/WidgetBase"
              }
            }
          }
        ]
      },
      "SplineComponent": {
        "description": "Class for describing pipelines in scene",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": ["splineDataID", "radius", "color"],
            "properties": {
              "splineDataID": {
                "description": "Name of spline asset listed in 'assets' section that this actor should use",
                "type": "string"
              },
              "radius": {
                "description": "Radius of the pipeline",
                "type": "number",
                "format": "float"
              },
              "color": {
                "$ref": "#/components/schemas/Color"
              }
            }
          }
        ]
      },
      "DecalComponent": {
        "description": "Class for describing decals projected onto geometry in the scene. Additional field usage information:\n  * `imageId` - File ID for the image that will be used for the decal, or ID of a time series that will specify the image file ID.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": ["decalHeight", "imageId"],
            "properties": {
              "decalHeight": {
                "description": "The height of the box volume which contains and restricts the projected texture. <br> It determines the height range across which the projected image is applied.",
                "type": "number",
                "format": "float"
              },
              "imageId": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrFileId"
              }
            }
          }
        ]
      },
      "Actor": {
        "description": "An object that will be placed in the 3D scene.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ActorBase"
          },
          {
            "type": "object",
            "required": ["components"],
            "properties": {
              "components": {
                "description": "Array of all components attached to this actor.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Component"
                }
              }
            }
          }
        ]
      },
      "YawPitchRollController": {
        "description": "Controls rotation of an actor based on time series containing Euler angles represented as yaw, pitch and roll in a vector of 3 time series data.<br>\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/RotationTimeSeriesBase"
          },
          {
            "type": "object",
            "required": ["yawPitchRollTimeSeries"],
            "properties": {
              "yawPitchRollTimeSeries": {
                "$ref": "#/components/schemas/vec3TimeSeries"
              }
            }
          }
        ]
      },
      "SingleAxisRotationController": {
        "description": "Controls rotation of an actor around a single axis, using time series for the rotation angle.<br> Additional field usage information:\n  * `rotationTimeSeries` - The time series from which to read the rotation angle.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/RotationTimeSeriesBase"
          },
          {
            "type": "object",
            "required": ["rotationTimeSeries", "axisRotation"],
            "properties": {
              "rotationTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "axisRotation": {
                "description": "Vector defining the rotation axis. Doesn't need to be normalized.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        ]
      },
      "LocalToWorldTransform": {
        "description": "A local to world space transform defined with translation, rotation and unit scale.",
        "allOf": [
          {
            "type": "object",
            "required": ["translation", "rotation", "unitScale"],
            "properties": {
              "translation": {
                "description": "The translation of the target object to be converted to world space coordinates from unreal. Expects an array of three numbers describing the X, Y and Z translation.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "rotation": {
                "description": "The rotation of the target object in model space. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around the Y, X and Z axes of the scene respectively.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "unitScale": {
                "description": "Scales the target object uniformly. Expects a single value that will be used to scale the XYZ-axes. A value of 1.0 corresponds to the original scale. It can be used for change of units like 100 for m to cm.",
                "type": "number",
                "format": "float"
              }
            }
          }
        ]
      },
      "LocalToWorldUserDefinedSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series data. Positions and rotations are given in a local coordinate system. The transformation to world space is defined by matrixTransformToWorld.<br> Additional field usage information:\n  * `positionTimeSeries` - Group of 3 time series defining x, y and z positions.\n  * `rotationTimeSeries` - Different possible representations of rotation position in different number of time series.\n  * `matrixTransformToWorld` - The matrix to transform from time series transforms to world transforms based on the twin calibration.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "positionTimeSeries",
              "rotationTimeSeries",
              "matrixTransformToWorld"
            ],
            "properties": {
              "positionTimeSeries": {
                "$ref": "#/components/schemas/PositionTimeSeries"
              },
              "rotationTimeSeries": {
                "$ref": "#/components/schemas/RotationTimeSeriesBase"
              },
              "matrixTransformToWorld": {
                "$ref": "#/components/schemas/LocalToWorldTransform"
              }
            }
          }
        ]
      },
      "LocalToWorldUserWithVelocityVectorsDefinedSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series data. Positions and rotations are given in a local coordinate system. The transformation to world space is defined by matrixTransformToWorld.<br> Additional field usage information:\n  * `positionTimeSeries` - Group of 3 time series defining x, y and z positions.\n  * `rotationTimeSeries` - Different possible representations of rotation position in different number of time series.\n  * `matrixTransformToWorld` - The matrix to transform from time series transforms to world transforms based on the twin calibration.\n  * `velocityTimeSeries` - Group of 3 time series defining x, y and z velocities.\n  * `angularVelocityTimeSeries` - Different possible representations of the angular velocity in different variation of time series.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": ["matrixTransformToWorld"],
            "properties": {
              "matrixTransformToWorld": {
                "$ref": "#/components/schemas/LocalToWorldTransform"
              },
              "positionTimeSeries": {
                "$ref": "#/components/schemas/PositionTimeSeries"
              },
              "rotationTimeSeries": {
                "$ref": "#/components/schemas/RotationTimeSeriesBase"
              },
              "velocityTimeSeries": {
                "$ref": "#/components/schemas/VelocityTimeSeries"
              },
              "angularVelocityTimeSeries": {
                "$ref": "#/components/schemas/AngularVelocityTimeSeriesBase"
              }
            }
          }
        ]
      },
      "ActorType": {
        "type": "string",
        "enum": ["basicMeshActor", "actor"]
      },
      "ActorBase": {
        "description": "Abstract base class for objects (actors) that can appear in scene.",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "basicMeshActor": "#/components/schemas/BasicMeshActor",
            "actor": "#/components/schemas/Actor"
          }
        },
        "type": "object",
        "required": ["name", "transform", "type"],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ActorType"
          },
          "name": {
            "description": "Unique name of the actor in scene.",
            "type": "string"
          },
          "transform": {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          "widgets": {
            "description": "Widgets that should be attached to this actor. (if actor will move, widgets will move along with it)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WidgetBase"
            }
          },
          "transformController": {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          "visibilityController": {
            "$ref": "#/components/schemas/VisibilityController"
          },
          "hiddenByDefault": {
            "description": "if true, actor will be invisible when entering a scene",
            "type": "boolean"
          },
          "assetIdOverride": {
            "description": "AssetID to be associated with the actor. This will override the asset hierarchy mapping for geometries.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "HeightRenderer": {
        "type": "object",
        "required": ["location", "orthoWidth", "textureSize"],
        "properties": {
          "location": {
            "description": "Determines where in the scene the heightmap is captured from.",
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "orthoWidth": {
            "description": "Determines the extent of the scene area captured by the height-renderer.",
            "type": "number",
            "format": "float"
          },
          "textureSize": {
            "description": "Determines the resolution of the height data.",
            "type": "integer",
            "format": "int32"
          }
        },
        "description": "An object in the scene responsible for capturing a heightmap. <br> The heightmap is used to determine the height-position of objects in the scene which do not have any other way of determining height position."
      },
      "WaterPlane": {
        "type": "object",
        "properties": {
          "followCamera": {
            "description": "Determines whether the water plane object moves with the player, creating an illusion of an endless expanse of water.",
            "type": "boolean"
          },
          "heightZoomFactor": {
            "description": "Adjusts the scale of the water surface as a function of camera height. This essentially moves the horizon of the water further away by scaling the water by the given factor, which helps maintain the same level of detail at all scales. The parameters should be left to a default of 1.0 in most cases.",
            "type": "number",
            "format": "float"
          },
          "minimumHeight": {
            "description": "The lowest height at which to scale the water surface. This is to prevent the water from disappearing when near zero height. Should be left at default, or a number slightly larger than zero.",
            "type": "number",
            "format": "float"
          },
          "transform": {
            "$ref": "#/components/schemas/AbsoluteTransform"
          }
        },
        "description": "An object in the scene responsible for rendering a water surface. Typically used for oceans."
      },
      "EnvironmentControl": {
        "description": "The environment controller is responsible for controlling environmental effects such as weather, underwater effects, and so on.<br> Additional field usage information:\n  * `fogInscatteringColor` - A property of the Unreal engine post-process volume, which is used here for the underwater fogginess effect.\n",
        "type": "object",
        "properties": {
          "underWaterDensity": {
            "description": "The density of the particles of the underwater scene. used to simulate the absorption of light as it passes through the water. Admissable range is within 0.0, to 0.05\n",
            "type": "number",
            "format": "float"
          },
          "underWaterVignetteIntensity": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurScale": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurFocalDistance": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurNearTransitionRegion": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurFarTransitionRegion": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underwaterColor": {
            "$ref": "#/components/schemas/Color"
          },
          "useDynamicLighting": {
            "description": "Whether or not to use dynamic lighting in the scene. Currently only affects the sunlight.",
            "type": "boolean"
          },
          "renderSkySphere": {
            "description": "Whether or not to render the sky. Can be used to turn off sky rendering for indoor scenes.",
            "type": "boolean"
          },
          "hideSkySphereUnderWater": {
            "description": "Whether or not to render the sky when below the water surface. Requires 'renderSkySphere' to be true to have any effect.",
            "type": "boolean"
          },
          "useTimeOfDayUpdate": {
            "description": "Whether or not to update the sun and sky according to the time of day",
            "type": "boolean"
          },
          "directionalLightSettings": {
            "$ref": "#/components/schemas/DirLightSettings"
          }
        }
      },
      "VisibilityLayers": {
        "description": "A view mode determines the visibility of a set of objects in the scene.<br> If a view mode is toggled, then it toggles the visibility of all its referenced objects.",
        "type": "object",
        "required": ["name", "actorNames"],
        "properties": {
          "name": {
            "description": "The name of the view mode as it appears in the user interface",
            "type": "string"
          },
          "actorNames": {
            "description": "A set of objects which is referenced by this view mode for visibility filtering.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AbsoluteTransformType": {
        "type": "string",
        "enum": ["unrealTransform", "universalTransform"],
        "description": "Specification of the format or coordinate system of a (world space) transform:\n   * `unrealTransform` - Coordinates are given in the Unreal Engine 4 coordinate system.\n   * `universalTransform` - Coordinates are given in a geographic coordinate system described by a CRS.\n"
      },
      "DirLightSettings": {
        "type": "object",
        "description": "controls the settings of a directional light",
        "properties": {
          "intensity": {
            "type": "number",
            "format": "float"
          },
          "color": {
            "$ref": "#/components/schemas/Color"
          },
          "rotation": {
            "description": "Rotates the target light. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around its local Y, X and Z axes respectively. A value of [0.0, 0.0, 0.0] corresponds to no change.",
            "type": "array",
            "example": [-90, 0, 180],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "TimeseriesFilterType": {
        "type": "string",
        "enum": ["nameRegex", "metadataExactMatch"],
        "description": "Describes which predicate type to use in filtering the timeseries.\n  * `nameRegex` - The filter will only keep timeseries in which the name field is accepted by the specified regular expression string.\n  * `metadataExactMatch` - THe filter will only keep timeseries in which the metadata field contains a given key-value pair of strings.\n"
      },
      "AbsoluteTransform": {
        "description": "A world space transform - a transformation of position, rotation and scale in the coordinate system of the 3D scene.<br> Variants:\n  * `unrealTransform` - A world space transform represented in the Unreal Engine 4 coordinate system.\n  * `universalTransform` - A world space transform represented geographic coordinate system described by a CRS. For this to work correctly, the scene must be set up with proper geographic coordinates.\n",
        "type": "object",
        "required": ["type"],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "unrealTransform": "#/components/schemas/UnrealTransform",
            "universalTransform": "#/components/schemas/UniversalTransform"
          }
        },
        "properties": {
          "type": {
            "$ref": "#/components/schemas/AbsoluteTransformType"
          }
        }
      },
      "UnrealTransform": {
        "description": "A world space transform represented in the Unreal Engine 4 coordinate system.",
        "allOf": [
          {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          {
            "type": "object",
            "required": ["position", "rotation", "scale"],
            "properties": {
              "position": {
                "description": "The position of the target object in the scene coordinate system. Expects an array of three numbers for position (in centimeters) along the XYZ-axes.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "rotation": {
                "description": "The orientation of the target object in the space of the 3D scene. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around the Y, X and Z axes of the scene respectively.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "scale": {
                "description": "Scales the target object along each axis in its local coordinate system. Expects an array of three numbers describing scale multipliers along the XYZ-axes. A value of [1.0, 1.0, 1.0] corresponds to the original scale. Note that not all objects support non-uniform scaling (different scale values along each axis).",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        ]
      },
      "UniversalTransform": {
        "description": "A world space transform represented geographic coordinate system described by a CRS. For this to work correctly, the scene must be set up with proper geographic coordinates.",
        "allOf": [
          {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          {
            "type": "object",
            "required": ["location", "rotation", "scale"],
            "properties": {
              "location": {
                "$ref": "#/components/schemas/GeographicLocation"
              },
              "rotation": {
                "description": "The orientation of the target object in the space of the 3D scene. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around the Y, X and Z axes of the scene respectively.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "scale": {
                "description": "Scales the target object along each axis in its local coordinate system. Expects an array of three numbers describing scale multipliers along the XYZ-axes. A value of [1.0, 1.0, 1.0] corresponds to the original scale. Note that not all objects support non-uniform scaling (different scale values along each axis).",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        ]
      },
      "RelativeTransform": {
        "description": "A transformation in an object's local coordinate system. This is primarily used for changing the origin, scale or default orientation of a 3D model.",
        "type": "object",
        "required": ["position", "rotation", "scale"],
        "properties": {
          "position": {
            "description": "Offsets the position of the target object in its local coordinate system. This is equivalent to changing the origin of the object. Expects an array of three numbers, corresponding to offsets along the XYZ-axes. A value of [0.0, 0.0, 0.0] corresponds to no change.",
            "type": "array",
            "example": [100, 0, -50],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "rotation": {
            "description": "Rotates the target object in its local coordinate system. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around its local Y, X and Z axes respectively. A value of [0.0, 0.0, 0.0] corresponds to no change.",
            "type": "array",
            "example": [-90, 0, 180],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "scale": {
            "description": "Scales the target object along each axis in its local coordinate system. Expects an array of three numbers describing scale multipliers along the XYZ-axes. A value of [1.0, 1.0, 1.0] corresponds to the original scale. Note that not all objects support non-uniform scaling (different scale values along each axis).",
            "type": "array",
            "example": [0.5, 0.5, 0.5],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "Color": {
        "type": "string",
        "description": "Color in hexadecimal format (HTML standard)",
        "example": "#05ff54"
      },
      "TimeseriesFilter": {
        "description": "The base class of all timeseries filter implementations.\n  * `type` The predicate type to use for filtering timeseries.\n",
        "type": "object",
        "required": ["type"],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TimeseriesFilterType"
          }
        },
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "nameRegex": "#/components/schemas/TimeseriesFilterNameRegex",
            "metadataExactMatch": "#/components/schemas/TimeseriesFilterMetadataExactMatch"
          }
        }
      },
      "TimeseriesFilterNameRegex": {
        "description": "A timeseries filter which keeps only the timeseries in which the name field is accepted by the specifiec regular expression string.\n  *  `regexString` - The regular expression to match against. The regular expression syntax is given by ICU and can be found at http://userguide.icu-project.org/strings/regexp\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TimeseriesFilter"
          },
          {
            "type": "object",
            "required": ["regexString"],
            "properties": {
              "regexString": {
                "type": "string"
              }
            },
            "description": "The timeseries name regex to filter with\n"
          }
        ]
      },
      "TimeseriesFilterMetadataExactMatch": {
        "description": "A timeseries filter which keeps only the timeseries which contain the given key-value string pair. The strings must match exactly.\n  * `key` - The metadata key entry to match\n  * `value` - The metadata value entry to match\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TimeseriesFilter"
          },
          {
            "type": "object",
            "required": ["key", "value"],
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "description": "The timeseries metadata entry to filter on\n"
          }
        ]
      },
      "FileId": {
        "type": "integer",
        "example": 1234,
        "description": "The file ID of a file in CDF.",
        "format": "int64"
      },
      "FileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The file external ID of a file in CDF."
      },
      "GaugeType": {
        "type": "string",
        "description": "Type of gauge in image. Either \"analog\", \"digital\" or \"level\".",
        "example": "analog"
      },
      "Unit": {
        "type": "string",
        "example": "bar",
        "description": "The unit of the gauge."
      },
      "DeadAngle": {
        "type": "number",
        "example": 1.57,
        "description": "The angle between the start and end point on the bottom part of an analog gauge, measured in radians."
      },
      "MinLevel": {
        "type": "number",
        "example": 0,
        "description": "The start value of the gauge."
      },
      "MaxLevel": {
        "type": "number",
        "example": 100,
        "description": "The end value of the gauge."
      },
      "MinNumDigits": {
        "type": "integer",
        "example": 2,
        "description": "Minimum number of digits on a digital gauge."
      },
      "MaxNumDigits": {
        "type": "integer",
        "example": 5,
        "description": "Maximum number of digits on a digital gauge."
      },
      "CommaPos": {
        "type": "integer",
        "example": 3,
        "description": "Number of digits after comma in a digital gauge."
      },
      "NeedlePoints": {
        "type": "object",
        "description": "Coordinates of needle ends in an analog gauge.",
        "example": {
          "startX": 0.1,
          "startY": 0.2,
          "tipX": 0.3,
          "tipY": 0.4
        },
        "required": ["startX", "startY", "tipX", "tipY"],
        "properties": {
          "startX": {
            "type": "number"
          },
          "startY": {
            "type": "number"
          },
          "tipX": {
            "type": "number"
          },
          "tipY": {
            "type": "number"
          }
        }
      },
      "Entities": {
        "type": "array",
        "example": [
          "21PT1019",
          {
            "name": "21PT1017",
            "ignoredfield": "AA11"
          },
          {
            "name": ["21PT1017-A", "21PT1017-B"]
          }
        ],
        "description": "A list of entities to look for in the P&ID. For example, all the assets under a root node. The entities can either be strings or objects. If objects, the searchField determines which string or strings that identify the entities. The value of an entity searchField could be a string or a list of strings, and if one of the strings is detected, the entity will be added to the detection result. ",
        "items": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "object"
            }
          ]
        }
      },
      "SearchField": {
        "type": "string",
        "example": "name",
        "default": "name",
        "description": "The field that determines the string or strings to search for and identify object entities. An object entity can have a string or a list of strings as value in its search field, and detecting any of the strings will identify the entity."
      },
      "NameMapping": {
        "type": "object",
        "example": {
          "21PT1019": "PT1019",
          "21PT1017": "PT1017"
        },
        "description": "Optional mapping between entity names and their synonyms in the P&ID. Use this if the P&ID contains names on a different form than the entity list. For example if the asset names have a prefix that is not in the P&ID. The response contain names as provided in the entity list."
      },
      "PartialMatch": {
        "type": "boolean",
        "description": "Allow partial (fuzzy) matching of entity names in the P&ID. Will only match when it is possible to do so unambiguously.",
        "default": false
      },
      "MinTokens": {
        "type": "integer",
        "description": "Each detected asset must match the matched entity on at least this number of tokens. That is, substrings of consecutive letters or consecutive digits.",
        "default": 2
      },
      "Patterns": {
        "type": "array",
        "example": [
          "([0-9]{2})-([A-Z]{2,3})-([0-9]{4,5})",
          "(TAG)_([0-9]{2,4})"
        ],
        "description": "Regular expression pattern to look for in the P&ID. The regular expressions must follow the rules described above.",
        "items": {
          "type": "string"
        }
      },
      "BoundingBox": {
        "type": "object",
        "description": "Bounding box in normalized coordinates with (0,0) corresponding to the upper left corner and (1,1) corresponding to the lower right corner of the image.",
        "example": {
          "xMax": 0.5895183277794608,
          "xMin": 0.573159648591336,
          "yMax": 0.3737254901960784,
          "yMin": 0.3611764705882352
        },
        "required": ["xMax", "xMin", "yMax", "yMin"],
        "properties": {
          "xMax": {
            "type": "number"
          },
          "xMin": {
            "type": "number"
          },
          "yMax": {
            "type": "number"
          },
          "yMin": {
            "type": "number"
          }
        }
      },
      "Annotation": {
        "description": "Annotation representing a detected entity.",
        "type": "object",
        "required": ["text", "boundingBox", "confidence", "type"],
        "properties": {
          "text": {
            "description": "The text extracted by the engine.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "entities": {
            "description": "The object corresponding to the extracted text.",
            "type": "object",
            "example": {
              "name": "21-PT-1019",
              "someField": "value"
            }
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox"
          },
          "confidence": {
            "type": "number",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "type": {
            "type": "string",
            "enum": ["word", "paragraph"]
          }
        }
      },
      "Vertex": {
        "type": "object",
        "description": "A vertex represents a 2D point in the image. The vertex coordinates are normalized.",
        "example": {
          "x": 0.58,
          "y": 0.12
        },
        "required": ["x", "y"],
        "properties": {
          "x": {
            "type": "number",
            "description": "Normalized x coordinate.",
            "minimum": 0,
            "maximum": 1
          },
          "y": {
            "type": "number",
            "description": "Normalized y coordinate.",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "Region": {
        "description": "Shape and coordinates of the detected entity in the image.",
        "type": "object",
        "required": ["shape", "vertices"],
        "properties": {
          "shape": {
            "type": "string",
            "description": "The geometrical shape of the image region to which a detected entity belongs.",
            "enum": ["points", "rectangle", "polyline", "polygon"]
          },
          "vertices": {
            "type": "array",
            "description": "List of vertices representing the image region to which a detected entity belongs.",
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/Vertex"
            }
          }
        }
      },
      "DiagramRegion": {
        "description": "Shape and coordinates of the detected entity in the image.",
        "type": "object",
        "required": ["shape", "vertices"],
        "properties": {
          "shape": {
            "type": "string",
            "description": "The geometrical shape of the image region to which a detected entity belongs.",
            "enum": ["rectangle"]
          },
          "vertices": {
            "type": "array",
            "description": "List of vertices representing the image region to which a detected entity belongs.",
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/Vertex"
            },
            "minItems": 4,
            "maxItems": 4
          }
        }
      },
      "JobId": {
        "description": "Contextualization job ID.",
        "type": "integer",
        "example": 123,
        "format": "int64"
      },
      "JobStatus": {
        "description": "The status of the job.",
        "type": "string",
        "enum": ["Queued", "Running", "Completed", "Failed"]
      },
      "BatchJobStatus": {
        "description": "The status of the job.",
        "type": "string",
        "enum": [
          "Queued",
          "Distributing",
          "Running",
          "Collecting",
          "Completed",
          "Failed",
          "Timeout"
        ]
      },
      "ErrorMessage": {
        "description": "Error message returned by the model if it fails.",
        "type": "string",
        "example": "Found zero entities, expecting more."
      },
      "ModelName": {
        "type": "string",
        "description": "User defined name.",
        "example": "simple_model_1",
        "maxLength": 256
      },
      "ModelDescription": {
        "type": "string",
        "description": "User defined description.",
        "example": "Simple model 1",
        "maxLength": 500
      },
      "FeatureType": {
        "type": "string",
        "example": "simple",
        "enum": [
          "simple",
          "insensitive",
          "bigram",
          "frequencyweightedbigram",
          "bigramextratokenizers",
          "bigramcombo"
        ],
        "default": "simple",
        "description": "Each feature type defines one combination of features that will be created and used in the entity matcher model. All features are based on matching tokens. Tokens are defined at the top of the Entity matching section.\nThe options are:\n  * Simple: Calculates the cosine-distance similarity score for each of the pairs of fields defined in `matchFields`. This is the fastest option.\n  * Insensitive: Similar to Simple, but ignores lowercase/uppercase differences.\n  * Bigram: Similar to `simple`, but adds similarity score based on matching bigrams of the tokens.\n  * FrequencyWeightedBigram: Similar to `bigram`, but give higher weights to less commonly occurring tokens.\n  * BigramExtraTokenizers: Similar to `bigram`, but able to learn that leading zeros, spaces, and uppercase/lowercase differences should be ignored in matching.\n  * BigramCombo: Calculates all of the above options, relying on the model to determine the appropriate features to use.\n  Hence, this option is only appropriate if there are  labeled data/trueMatches. This is the slowest option.\n"
      },
      "Classifier": {
        "type": "string",
        "description": "The classifier used in the model. Only relevant if there are trueMatches/labeled data and a supervised model is fitted.",
        "example": "randomforest",
        "default": "randomforest",
        "enum": [
          "randomforest",
          "decisiontree",
          "logisticregression",
          "augmentedlogisticregression",
          "augmentedrandomforest"
        ]
      },
      "IgnoreMissingFields": {
        "type": "boolean",
        "default": false,
        "example": true,
        "description": "If True, replaces missing fields in `sources` or `targets` entities, for fields set in set in `matchFields`, with empty strings. Else, returns an error if there are missing data."
      },
      "MatchFields": {
        "type": "array",
        "example": [
          {
            "source": "name",
            "target": "name"
          },
          {
            "source": "field",
            "target": "somefield"
          }
        ],
        "description": "List of pairs of fields from the target and source items used to calculate features. All source and target items should have all the `source` and `target` fields specified here.",
        "items": {
          "type": "object",
          "required": ["source", "target"],
          "properties": {
            "source": {
              "type": "string"
            },
            "target": {
              "type": "string"
            }
          }
        }
      },
      "PipelineName": {
        "type": "string",
        "description": "User defined name of the pipeline.",
        "example": "my_pipeline",
        "maxLength": 256
      },
      "PipelineDescription": {
        "type": "string",
        "description": "User defined description of the pipeline.",
        "example": "My pipeline",
        "maxLength": 500
      },
      "PipelineScoreThreshold": {
        "type": "number",
        "example": 0.7,
        "minimum": 0,
        "maximum": 1,
        "default": 0,
        "description": "Only return model matches with score above this threshold."
      },
      "PipelineReplacements": {
        "type": "array",
        "description": "Replace strings in entity fields. You can use this field to add input naming variations to the entity matching model to improve the suggested matches, for example, 'pmp' for 'pump' and 'bhp' for 'bottom hole pressure'. To avoid false positives, we recommend using the longer string as 'string' and the shorter as 'replacement'.",
        "items": {
          "type": "object",
          "required": ["field", "string", "replacement"],
          "properties": {
            "field": {
              "type": "string",
              "description": "Which field to replace in. Can be '*' to affect all fields in both source and targets."
            },
            "string": {
              "type": "string",
              "description": "String to search for and replace in both sources and targets."
            },
            "replacement": {
              "type": "string",
              "description": "Replacement for the string."
            }
          }
        }
      },
      "PipelineUseExistingMatches": {
        "type": "boolean",
        "example": true,
        "default": false,
        "description": "Use existing (id/assetId) links on the CDF resources as traning data when the entity matching model is created."
      },
      "Sources": {
        "type": "array",
        "items": {
          "type": "object",
          "example": {
            "id": 10,
            "name": "a_name",
            "field": "value",
            "ignoredfield": {
              "key": "value"
            }
          }
        },
        "description": "List of custom source object to match from, for example, time series. String key -> value. Only string values are considered in the matching. Optional id and/or externalId fields."
      },
      "Targets": {
        "type": "array",
        "items": {
          "type": "object",
          "example": {
            "id": 6,
            "name": "some_name",
            "somefield": "value",
            "ignoredfield": {
              "key": "value"
            }
          }
        },
        "description": "List of custom target object to match to, for example, assets. String key -> value. Only string values are considered in the matching. Optional id and/or externalId fields."
      },
      "EitherId": {
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            {
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          ]
        }
      },
      "SourceId": {
        "description": "The id for the from-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "SourceExternalId": {
        "description": "The external id for the source-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        ]
      },
      "TargetId": {
        "description": "The id for the target-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "TargetExternalId": {
        "description": "The external id for the to-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        ]
      },
      "TrueMatches": {
        "type": "array",
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a match used to train the model. If omitted, an unsupervised model is used.",
        "items": {
          "type": "object",
          "example": [
            {
              "sourceId": 1,
              "targetId": 1
            },
            {
              "sourceExternalId": "2",
              "targetExternalId": "2"
            }
          ],
          "oneOf": [
            {
              "properties": {
                "sourceId": {
                  "$ref": "#/components/schemas/SourceId"
                },
                "targetId": {
                  "$ref": "#/components/schemas/TargetId"
                }
              }
            },
            {
              "properties": {
                "sourceId": {
                  "$ref": "#/components/schemas/SourceId"
                },
                "targetExternalId": {
                  "$ref": "#/components/schemas/TargetExternalId"
                }
              }
            },
            {
              "properties": {
                "sourceExternalId": {
                  "$ref": "#/components/schemas/SourceExternalId"
                },
                "targetId": {
                  "$ref": "#/components/schemas/TargetId"
                }
              }
            },
            {
              "properties": {
                "sourceExternalId": {
                  "$ref": "#/components/schemas/SourceExternalId"
                },
                "targetExternalId": {
                  "$ref": "#/components/schemas/TargetExternalId"
                }
              }
            }
          ]
        }
      },
      "ConfirmedMatches": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TrueMatches"
          }
        ],
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a confirmed match by the user. A source and target pair in this list will override results from a model or rules and will therefore always be returned as a match. The matches are also used as training data when the entity matcher model is created."
      },
      "RejectedMatches": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TrueMatches"
          }
        ],
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a match rejected by the user. A source and target pair in this list will override results from a model or rules and will never be returned as a match."
      },
      "ModelParameters": {
        "type": "object",
        "example": {
          "featureType": "bigram"
        },
        "description": "The parameters used in the entity matching model.",
        "properties": {
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "classifier": {
            "$ref": "#/components/schemas/Classifier"
          },
          "matchFields": {
            "$ref": "#/components/schemas/MatchFields"
          }
        }
      },
      "ContextJobSchema": {
        "type": "object",
        "required": ["jobId", "status"],
        "properties": {
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatus"
          }
        }
      },
      "ContextModelReferenceSchema": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "EntityMatchingFeatureSchema": {
        "type": "object",
        "properties": {
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "classifier": {
            "description": "Name of the classifier used in the model, \"Unsupervised\" if unsupervised model.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Classifier"
              }
            ]
          },
          "ignoreMissingFields": {
            "description": "If True, missing fields in `sources` or `targets` entities set in `matchFields`, are replaced with empty strings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/IgnoreMissingFields"
              }
            ]
          },
          "matchFields": {
            "$ref": "#/components/schemas/MatchFields"
          },
          "originalId": {
            "type": "integer",
            "description": "The ID of original model, only relevant when the model is a retrained model.",
            "example": 111
          },
          "name": {
            "$ref": "#/components/schemas/ModelName"
          },
          "description": {
            "$ref": "#/components/schemas/ModelDescription"
          }
        }
      },
      "EntityMatcherResponseSchema": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/ContextModelReferenceSchema"
          },
          {
            "$ref": "#/components/schemas/EntityMatchingFeatureSchema"
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          }
        ]
      },
      "EntityMatcherPipelinesSchema": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "$ref": "#/components/schemas/PipelineName"
          },
          "description": {
            "$ref": "#/components/schemas/PipelineDescription"
          },
          "sources": {
            "$ref": "#/components/schemas/PipelineSources"
          },
          "targets": {
            "$ref": "#/components/schemas/PipelineTargets"
          },
          "confirmedMatches": {
            "$ref": "#/components/schemas/ConfirmedMatches"
          },
          "rejectedMatches": {
            "$ref": "#/components/schemas/RejectedMatches"
          },
          "useExistingMatches": {
            "$ref": "#/components/schemas/PipelineUseExistingMatches"
          },
          "scoreThreshold": {
            "$ref": "#/components/schemas/PipelineScoreThreshold"
          },
          "replacements": {
            "$ref": "#/components/schemas/PipelineReplacements"
          },
          "modelParameters": {
            "$ref": "#/components/schemas/ModelParameters"
          },
          "rules": {
            "$ref": "#/components/schemas/MatchRule"
          }
        }
      },
      "StatusSchema": {
        "type": "object",
        "required": ["status", "createdTime", "startTime", "statusTime"],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/JobStatus"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "startTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              {
                "nullable": true
              }
            ]
          },
          "statusTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "SinglePatchRequiredName": {
        "title": "Name",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelName"
          }
        },
        "description": "Set a new value for name.",
        "required": ["set"]
      },
      "SinglePatchRequiredDescription": {
        "title": "Description",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelDescription"
          }
        },
        "description": "Set a new value for description.",
        "required": ["set"]
      },
      "SinglePatchRequiredModelParameters": {
        "title": "ModelParameters",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelParameters"
          }
        },
        "description": "Set a new value for modelParameters.",
        "required": ["set"]
      },
      "SinglePatchRequiredSources": {
        "title": "Sources",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/Sources"
          }
        },
        "description": "Set a new value for Sources.",
        "required": ["set"]
      },
      "SinglePatchRequiredTargets": {
        "title": "Targets",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/Targets"
          }
        },
        "description": "Set a new value for Targets.",
        "required": ["set"]
      },
      "SinglePatchRequiredRules": {
        "title": "Rules",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/MatchRule"
          }
        },
        "description": "Set a new value for Rules.",
        "required": ["set"]
      },
      "SinglePatchRequiredConfirmedMatches": {
        "title": "TrueMatches",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ConfirmedMatches"
          }
        },
        "description": "Set a new value for confirmedMatches.",
        "required": ["set"]
      },
      "SinglePatchRequiredRejectedMatches": {
        "title": "RejectedMatches",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/TrueMatches"
          }
        },
        "description": "Set a new value for rejectedMatches.",
        "required": ["set"]
      },
      "SinglePatchRequiredScoreThreshold": {
        "title": "ScoreThreshold",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineScoreThreshold"
          }
        },
        "description": "Set a new value for scoreThreshold.",
        "required": ["set"]
      },
      "SinglePatchRequiredUseExistingMatches": {
        "title": "UseExistingMatches",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineUseExistingMatches"
          }
        },
        "description": "Set a new value for useExistingMatches.",
        "required": ["set"]
      },
      "PipelineChange": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/PipelineChangeById"
          },
          {
            "$ref": "#/components/schemas/PipelineChangeByExternalId"
          }
        ]
      },
      "PipelineChangeById": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PipelinePatch"
          },
          {
            "type": "object",
            "required": ["id"],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "PipelineChangeByExternalId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PipelinePatch"
          },
          {
            "type": "object",
            "required": ["externalId"],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "PipelinePatch": {
        "type": "object",
        "description": "Changes applied to model",
        "required": ["update"],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/SinglePatchRequiredName"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchRequiredDescription"
              },
              "modelParameters": {
                "$ref": "#/components/schemas/SinglePatchRequiredModelParameters"
              },
              "sources": {
                "$ref": "#/components/schemas/SinglePatchRequiredSources"
              },
              "targets": {
                "$ref": "#/components/schemas/SinglePatchRequiredTargets"
              },
              "useExistingMatches": {
                "$ref": "#/components/schemas/SinglePatchRequiredUseExistingMatches"
              },
              "rules": {
                "$ref": "#/components/schemas/SinglePatchRequiredRules"
              },
              "scoreThreshold": {
                "$ref": "#/components/schemas/SinglePatchRequiredScoreThreshold"
              },
              "confirmedMatches": {
                "$ref": "#/components/schemas/SinglePatchRequiredConfirmedMatches"
              },
              "rejectedMatches": {
                "$ref": "#/components/schemas/SinglePatchRequiredRejectedMatches"
              }
            }
          }
        }
      },
      "PipelineSources": {
        "type": "object",
        "required": ["dataSetIds", "assetSubtreeIds", "entities"],
        "oneOf": [
          {
            "properties": {
              "dataSetIds": {
                "type": "array",
                "description": "List of id or externalId for datasets to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "$ref": "#/components/schemas/PipelineResourceType"
              }
            }
          },
          {
            "properties": {
              "assetSubtreeIds": {
                "type": "array",
                "description": "List of id or externalId for asset subtrees to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "$ref": "#/components/schemas/PipelineResourceType"
              }
            }
          },
          {
            "properties": {
              "entities": {
                "type": "array",
                "items": {
                  "type": "object",
                  "example": {
                    "id": 10,
                    "name": "a_name",
                    "field": "value",
                    "ignoredfield": {
                      "key": "value"
                    }
                  }
                },
                "description": "List of custom source object to match from, for example, time series. String key -> value. Optional id and/or externalId fields."
              }
            }
          }
        ]
      },
      "PipelineTargets": {
        "type": "object",
        "required": ["dataSetIds", "assetSubtreeIds", "entities"],
        "oneOf": [
          {
            "properties": {
              "dataSetIds": {
                "type": "array",
                "description": "List of id or externalId for datasets to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "default": "assets",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "properties": {
              "assetSubtreeIds": {
                "type": "array",
                "description": "List of id or externalId for asset subtrees to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "default": "assets",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "properties": {
              "entities": {
                "type": "array",
                "items": {
                  "type": "object",
                  "example": {
                    "id": 10,
                    "name": "a_name",
                    "field": "value",
                    "ignoredfield": {
                      "key": "value"
                    }
                  }
                },
                "description": "List of custom target object to match to, for example, assets. String key -> value. Optional id and/or externalId fields."
              }
            }
          }
        ]
      },
      "PipelineResourceType": {
        "type": "string",
        "description": "Resource type.",
        "example": "assets",
        "enum": ["assets", "time_series", "events", "files", "sequences"],
        "default": "time_series"
      },
      "AvgScore": {
        "type": "number",
        "format": "float",
        "example": 0.9,
        "minimum": 0,
        "maximum": 1,
        "description": "The average score of the rule."
      },
      "ApplyPriorityRulesRequest": {
        "type": "object",
        "required": ["sources", "targets", "rules"],
        "properties": {
          "sources": {
            "type": "array",
            "example": [
              {
                "id": 1,
                "name": "Lady",
                "species": "dog"
              },
              {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              {
                "id": 6,
                "name": "Madame Mim",
                "species": "witch"
              }
            ],
            "items": {
              "type": "object"
            },
            "description": "List of source entities, for example time series, to match with target entities."
          },
          "targets": {
            "type": "array",
            "example": [
              {
                "id": 2,
                "name": "the tramp",
                "species": "dog"
              },
              {
                "id": 4,
                "name": "Donald",
                "species": "bird"
              },
              {
                "id": 5,
                "name": "Gander",
                "species": "bird"
              }
            ],
            "items": {
              "type": "object"
            },
            "description": "List of target entities, for example assets, to match with source entities."
          },
          "rules": {
            "description": "A list of rules with priorities. Each rule describes specific conditions for two entities to match. A single rule usually only applies to a limited set of entities and entities that do not match by one rule may well match by another. If separate rules match a source entity to different target entities, only the highest priority rules are applied to that source entity.",
            "type": "array",
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/MatchRule"
            }
          }
        }
      },
      "MatchRule": {
        "description": "An entity matching rule matches source entities with target entities based on a pattern defined by the rule. A rule has extractors that both require entities to follow a certain format, and produce lists of features. For a regex extractor, a specific field must match a pattern, and parts of the pattern become the features. The conditions of a rule express which extracted features must be equal for two entities to match. Since extractors restrict the scopes of rules to entities that conform with patterns, two rules will often not have entities in common that they apply to. But if they do, the more specific rule is given higher priority. If one rule is not a special case of the other, they may be inconsistent (conflict) or redundant (overlap).",
        "type": "object",
        "required": ["extractors", "conditions"],
        "example": {
          "extractors": [
            {
              "entitySet": "sources",
              "extractorType": "regex",
              "field": "species",
              "pattern": "(.*)"
            },
            {
              "entitySet": "targets",
              "extractorType": "regex",
              "field": "species",
              "pattern": "(.*)"
            }
          ],
          "conditions": [
            {
              "conditionType": "equals",
              "arguments": [[0, 0], [1, 0]]
            }
          ],
          "priority": 10
        },
        "properties": {
          "extractors": {
            "type": "array",
            "description": "An extractor produces a list of features based on a source entity or a target entity. In particular a regex extractor defines which entities (e.g. sources) it acts on, a field (e.g. name) and a regular expression. The extractor will only produce features if the field of an entity matches the pattern. The returned features are then substrings of the field as defined in the pattern. Entities in the relevant set that do not match the pattern will not be matched by the rule, but may be matched by other rules.",
            "items": {
              "$ref": "#/components/schemas/RegexExtractor"
            }
          },
          "conditions": {
            "type": "array",
            "description": "List of conditions that must be met for the rule to link two entities. The conditions refer to features extracted by the extractors. A condition of type \"equals\" that refers to features extracted from a source entity and a target entity requires these features to be equal for the entities to match.",
            "items": {
              "$ref": "#/components/schemas/MatchCondition"
            }
          },
          "priority": {
            "type": "number",
            "format": "int64",
            "minimum": 0,
            "default": 0,
            "description": "In case different rules provide matches for the same source entities, only the highest priority rules are applied to these entities."
          }
        }
      },
      "RegexExtractor": {
        "type": "object",
        "required": ["entitySet", "extractorType", "field", "pattern"],
        "description": "An extractor that acts on entities from 'entitySet'. An entity must have a value of 'field' that matches the regular expression 'pattern' to get features. The features are the catching groups of the pattern, that is the parts that are in parenthesis. E.g. ([A-Z])-00([0-9]) applied to A-007 produces [A, 7] as features.",
        "properties": {
          "entitySet": {
            "type": "string",
            "description": "Which set of entities the extractor will extract features from.",
            "enum": ["sources", "targets"]
          },
          "extractorType": {
            "type": "string",
            "description": "The type of extractor. Currently,  we only support \"regex\".",
            "enum": ["regex"]
          },
          "field": {
            "type": "string",
            "description": "The entity field that the extractor will get features from."
          },
          "pattern": {
            "type": "string",
            "description": "A regular expression without nested catching groups."
          }
        }
      },
      "MatchCondition": {
        "type": "object",
        "required": ["conditionType", "arguments"],
        "properties": {
          "conditionType": {
            "type": "string",
            "description": "The type of condition. Currently, we only support the 'equals' condition. It requires all features referenced by its arguments to be equal.",
            "enum": ["equals"]
          },
          "arguments": {
            "type": "array",
            "description": "References to features. Each argument is a list with two zero indexed indices. E.g. [0, 1] refers to the 1th (second) feature produced by the 0th (first) extractor of the rule.",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "int64",
                "minimum": 0
              }
            }
          },
          "config": {
            "$ref": "#/components/schemas/MatchConditionConfig"
          }
        }
      },
      "MatchConditionConfig": {
        "type": "object",
        "description": "Configuration of the condition not captured in its arguments and type.",
        "properties": {
          "synonyms": {
            "type": "array",
            "description": "Entries describing tokens that are equivalent.",
            "items": {
              "$ref": "#/components/schemas/SynonymEntry"
            },
            "example": [
              {
                "sources": ["odour"],
                "targets": ["odor"]
              },
              {
                "sources": ["petrol"],
                "targets": ["gas", "gasoline"]
              }
            ]
          }
        }
      },
      "SynonymEntry": {
        "type": "object",
        "description": "List of sources and targets words that all mean the same.",
        "properties": {
          "sources": {
            "type": "array",
            "description": "List of tokens that have the same meaning when appearing in a source entity.",
            "items": {
              "type": "string"
            }
          },
          "targets": {
            "type": "array",
            "description": "List of tokens that have the same meaning when appearing in a target entity.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "SuggestPriorityRulesRequest": {
        "type": "object",
        "required": ["sources", "targets", "matches"],
        "properties": {
          "sources": {
            "example": [
              {
                "id": 1,
                "name": "Lady",
                "species": "dog"
              },
              {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              {
                "id": 6,
                "name": "Madame Mim",
                "species": "witch"
              }
            ],
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "List of source entities, for example time series, to match with target entities."
          },
          "targets": {
            "example": [
              {
                "id": 2,
                "name": "the tramp",
                "species": "dog"
              },
              {
                "id": 4,
                "name": "Donald",
                "species": "bird"
              },
              {
                "id": 5,
                "name": "Gander",
                "species": "bird"
              }
            ],
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "List of target entities, assets for instance, to match with source entities."
          },
          "matches": {
            "type": "array",
            "description": "List of objects with either sourceId or sourceExternalId and either targetId or targetExternalId. The provided ids must correspond to id or externalId of a source entity and a target entity respectively. The entries represent matches that the suggested rules try to reproduce.",
            "items": {
              "type": "object",
              "example": [
                {
                  "sourceId": 1,
                  "targetId": 2
                }
              ],
              "oneOf": [
                {
                  "properties": {
                    "sourceId": {
                      "$ref": "#/components/schemas/SourceId"
                    },
                    "targetId": {
                      "$ref": "#/components/schemas/TargetId"
                    }
                  }
                },
                {
                  "properties": {
                    "sourceId": {
                      "$ref": "#/components/schemas/SourceId"
                    },
                    "targetExternalId": {
                      "$ref": "#/components/schemas/TargetExternalId"
                    }
                  }
                },
                {
                  "properties": {
                    "sourceExternalId": {
                      "$ref": "#/components/schemas/SourceExternalId"
                    },
                    "targetId": {
                      "$ref": "#/components/schemas/TargetId"
                    }
                  }
                },
                {
                  "properties": {
                    "sourceExternalId": {
                      "$ref": "#/components/schemas/SourceExternalId"
                    },
                    "targetExternalId": {
                      "$ref": "#/components/schemas/TargetExternalId"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "AppliedRulesItem": {
        "type": "object",
        "properties": {
          "flags": {
            "type": "array",
            "description": "An array of flags resulting from applying this rule. If a rule has more matches than there are source entities, it will yield no matches and get the flag \"Too many matches\".",
            "items": {
              "type": "string",
              "enum": ["Too many matches"]
            }
          },
          "numberOfMatches": {
            "type": "number",
            "format": "int64",
            "minimum": 0,
            "description": "The number of matches resulting form this rule that are not part of a conflict with another rule."
          },
          "conflicts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Conflict"
            },
            "description": "Objects referencing rules and the number of times this rule conflicts with those rules."
          },
          "overlaps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Overlap"
            },
            "description": "Objects referencing other rules and the number of times this rule overlaps with those rules."
          },
          "matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Match"
            },
            "description": "List of pairs of entities that match according to this rule. Source entities that are matched by rules with higher priority will not be seen among the matches."
          },
          "rule": {
            "$ref": "#/components/schemas/MatchRule"
          }
        },
        "example": {
          "flags": [],
          "numberOfMatches": 1,
          "conflicts": [
            {
              "ruleIndex": 0,
              "multiplicity": 2
            }
          ],
          "overlaps": [],
          "matches": [
            {
              "source": {
                "id": 1,
                "name": "Lady",
                "species": "dog"
              },
              "target": {
                "id": 2,
                "name": "the tramp",
                "species": "dog"
              }
            },
            {
              "source": {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              "target": {
                "id": 4,
                "name": "Donald",
                "species": "bird"
              }
            },
            {
              "source": {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              "target": {
                "id": 5,
                "name": "Gladstone",
                "species": "bird"
              }
            }
          ],
          "rule": {
            "extractors": [
              {
                "entitySet": "sources",
                "extractorType": "regex",
                "field": "species",
                "pattern": "(.*)"
              },
              {
                "entitySet": "targets",
                "extractorType": "regex",
                "field": "species",
                "pattern": "(.*)"
              }
            ],
            "conditions": [
              {
                "conditionType": "equals",
                "arguments": [[0, 0], [1, 0]]
              }
            ],
            "priority": 10
          }
        }
      },
      "Conflict": {
        "type": "object",
        "properties": {
          "ruleIndex": {
            "description": "Index reference of conflicting rule, could refer to the same rule if it has multiple matches for a source.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          },
          "multiplicity": {
            "description": "Number of matches this rule produces that conflicts with the referenced rule.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "Overlap": {
        "type": "object",
        "properties": {
          "ruleIndex": {
            "description": "Index of overlapping rule.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          },
          "multiplicity": {
            "description": "Number of identical matches between this rule and the referenced rule.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "Match": {
        "type": "object",
        "description": "Two entities that match.",
        "properties": {
          "source": {
            "type": "object",
            "description": "A source entity."
          },
          "target": {
            "type": "object",
            "description": "A target entity."
          }
        }
      },
      "Properties": {
        "type": "object",
        "description": "Properties of the template",
        "additionalProperties": {
          "type": "object",
          "description": "property of the template",
          "required": ["items"],
          "properties": {
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TemplateCompletionReport"
              }
            }
          }
        }
      },
      "TemplateCompletionReport": {
        "type": "object",
        "description": "Properties of the template",
        "properties": {
          "assetId": {
            "type": "integer",
            "description": "the id of the asset"
          },
          "assetExternalId": {
            "type": "string",
            "description": "the external id of the asset",
            "example": "WELL 12"
          },
          "assetName": {
            "type": "string",
            "description": "the name of the asset",
            "example": "Well 12"
          },
          "cost": {
            "type": "number",
            "description": "the cost used to match the resource with the pattern",
            "example": 0.000018
          },
          "currentExternalId": {
            "type": "string",
            "description": "the external id of the current resource",
            "example": "ABC_PT_WELL_01234"
          },
          "currentId": {
            "type": "integer",
            "description": "the id of the current resource"
          },
          "currentName": {
            "type": "string",
            "description": "the name of the current resource",
            "example": "ABC_PT_WELL_01234"
          },
          "foundExternalId": {
            "type": "string",
            "description": "External id of the found resource",
            "example": "ABC_PT_WELL_01234"
          },
          "foundExternalIds": {
            "type": "array",
            "description": "External ids of found resources"
          },
          "foundId": {
            "type": "integer",
            "description": "Id of the found resource"
          },
          "foundIds": {
            "type": "array",
            "description": "Ids of found resources"
          },
          "foundName": {
            "type": "string",
            "description": "name of the found resource",
            "example": "ABC_PT_WELL_01234"
          },
          "matchType": {
            "type": "string",
            "description": "which pattern is used to find the found resource.",
            "example": "PATTERN_1_CONFIRMED"
          }
        }
      },
      "TemplateReference": {
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string",
            "example": "templateGroupExternalId",
            "description": "External ID of the template group."
          },
          "templateName": {
            "type": "string",
            "description": "Name of the template to be completed within the template group",
            "example": "templateNameWithinTheDomain"
          },
          "assetProperty": {
            "type": "string",
            "example": "templateProperty",
            "description": "Which field (with constant type) in the template defines the externalId of the parent asset in each entry. If ommitted, it is assumed the externalId of the template instances is the same as the parent asset's externalId."
          },
          "version": {
            "type": "integer",
            "description": "Version of the domain, default at version 1",
            "example": 1
          }
        }
      },
      "ContextFileId": {
        "type": "integer",
        "example": 1234,
        "description": "The ID of a file in CDF.",
        "format": "int64"
      },
      "ContextFileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The external ID of a file in CDF."
      },
      "OneOfFileId": {
        "type": "object",
        "required": ["fileId", "fileExternalId"],
        "description": "An object containg file (external) id. The file can only have maximum 50 pages.",
        "oneOf": [
          {
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/ContextFileId"
              }
            }
          },
          {
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/ContextFileExternalId"
              }
            }
          }
        ]
      },
      "AllOfFileId": {
        "type": "object",
        "required": ["fileId"],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/ContextFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/ContextFileExternalId"
          }
        }
      },
      "DiagramDetectEntities": {
        "type": "array",
        "example": [
          {
            "userDefinedField": "21PT1017",
            "ignoredField": "AA11"
          },
          {
            "userDefinedField": ["21PT1017-A", "21PT1017-B"]
          }
        ],
        "description": "A list of entities to look for. For example, all the assets under a root node. The `searchField` determines the strings that identify the entities.",
        "items": {
          "type": "object",
          "maxProperties": 256
        },
        "minItems": 1,
        "maxItems": 500000
      },
      "DiagramSearchField": {
        "type": "string",
        "example": "userDefinedField",
        "default": "name",
        "description": "This field determines the string to search for and to identify object entities."
      },
      "DiagramPartialMatch": {
        "type": "boolean",
        "description": "Allow partial (fuzzy) matching of entities in the engineering diagrams. Creates a match only when it is possible to do so unambiguously.",
        "default": false
      },
      "DiagramMinTokens": {
        "type": "integer",
        "description": "Each detected item must match the detected entity on at least this number of tokens. A token is a substring of consecutive letters or digits.",
        "default": 2
      },
      "Page": {
        "type": "integer",
        "example": 1,
        "description": "The page of the file where the annotations in `annotations` were detected.",
        "maximum": 50,
        "minimum": 1
      },
      "DiagramDetectConfig": {
        "type": "object",
        "properties": {
          "searchField": {
            "$ref": "#/components/schemas/DiagramSearchField"
          },
          "partialMatch": {
            "$ref": "#/components/schemas/DiagramPartialMatch"
          },
          "minTokens": {
            "$ref": "#/components/schemas/DiagramMinTokens"
          }
        }
      },
      "DiagramConvertConfig": {
        "type": "object",
        "properties": {
          "grayscale": {
            "$ref": "#/components/schemas/Grayscale"
          }
        }
      },
      "Grayscale": {
        "type": "boolean",
        "example": true,
        "default": true,
        "description": "Return the SVG version in grayscale colors only (reduces the file size)."
      },
      "NewAnnotation": {
        "type": "object",
        "required": ["text", "region"],
        "properties": {
          "text": {
            "description": "The text and entities detected by the service.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "required": ["shape", "vertices", "page"],
            "allOf": [
              {
                "$ref": "#/components/schemas/DiagramRegion"
              },
              {
                "properties": {
                  "page": {
                    "$ref": "#/components/schemas/Page"
                  }
                }
              }
            ]
          }
        }
      },
      "DiagramDetectedEntities": {
        "type": "array",
        "example": [
          {
            "userDefinedField": "21PT1017",
            "ignoredField": "AA11"
          },
          {
            "userDefinedField": ["21PT1017-A", "21PT1017-B"]
          }
        ],
        "description": "A list of entities detected per annotation.",
        "items": {
          "type": "object"
        },
        "minItems": 1,
        "maxItems": 5
      },
      "DiagramAnnotation": {
        "description": "Annotation representing a detected entity.",
        "allOf": [
          {
            "$ref": "#/components/schemas/NewAnnotation"
          },
          {
            "type": "object",
            "properties": {
              "entities": {
                "$ref": "#/components/schemas/DiagramDetectedEntities"
              }
            }
          }
        ]
      },
      "DiagramDetectResultSchema": {
        "description": "An array of detected results, returned when the job finished or failed partially.",
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "annotations": {
                      "type": "array",
                      "description": "Annotations of entities detected by the service",
                      "items": {
                        "$ref": "#/components/schemas/DiagramAnnotation"
                      }
                    }
                  }
                }
              ],
              "required": ["annotations"]
            },
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "errorMessage": {
                      "type": "string",
                      "description": "Error message for the file."
                    }
                  }
                }
              ],
              "required": ["errorMessage"]
            }
          ]
        }
      },
      "DiagramSvgPngResultSchema": {
        "type": "object",
        "oneOf": [
          {
            "properties": {
              "page": {
                "$ref": "#/components/schemas/Page"
              },
              "svgUrl": {
                "type": "string",
                "example": "https://storage.googleapis.com/cluster/1234/PH-ME-P-0004-001.svg",
                "description": "A signed URL to an interactive SVG version of the engineering diagram (valid for 10 minutes)."
              },
              "pngUrl": {
                "type": "string",
                "example": "https://storage.googleapis.com/cluster/1234/PH-ME-P-0004-001.png",
                "description": "A signed URL to a PNG version of the engineering diagram (valid for 10 minutes)."
              }
            },
            "required": ["page", "svgUrl", "pngUrl"]
          },
          {
            "properties": {
              "page": {
                "$ref": "#/components/schemas/Page"
              },
              "errorMessage": {
                "type": "string",
                "description": "The error message for the page and file."
              }
            },
            "required": ["page", "errorMessage"]
          }
        ]
      },
      "DiagramConvertResultSchema": {
        "description": "An array of converted results, returned when the job finished or failed partially.",
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DiagramSvgPngResultSchema"
                      },
                      "maxItems": 50
                    }
                  }
                }
              ],
              "required": ["results"]
            },
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "errorMessage": {
                      "type": "string",
                      "description": "The error message for a file."
                    }
                  }
                }
              ],
              "required": ["errorMessage"]
            }
          ]
        }
      },
      "DiagramConvertRequestSchema": {
        "description": "An array of files and annotations to create interactive diagrams.",
        "type": "array",
        "maxItems": 50,
        "minItems": 1,
        "items": {
          "type": "object",
          "required": ["annotations"],
          "allOf": [
            {
              "$ref": "#/components/schemas/OneOfFileId"
            },
            {
              "properties": {
                "annotations": {
                  "description": "Annotations to draw on the engineering diagrams",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DiagramAnnotation"
                  },
                  "maxItems": 1000
                }
              }
            }
          ]
        }
      },
      "FailedBatchSchema": {
        "description": "List of the items and the corresponding error message(s) per failed batch.",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "errorMessage": {
              "type": "string",
              "description": "The error message(s) of the failed batch."
            },
            "items": {
              "type": "array",
              "description": "List of the items in the failed batch.",
              "items": {
                "$ref": "#/components/schemas/AllOfFileId"
              }
            }
          }
        }
      },
      "VisionAnnotation": {
        "description": "Annotation representing a detected entity.",
        "type": "object",
        "required": ["text"],
        "properties": {
          "text": {
            "description": "The entity (e.g. a valve, a pump or text) detected by a computer vision model.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "GaugeReadingAnnotation": {
        "description": "Annotation representing a detected valve.",
        "type": "object",
        "required": ["attributes", "region"],
        "properties": {
          "attributes": {
            "required": ["description", "gaugeValue"],
            "properties": {
              "description": {
                "description": "Type of gauge",
                "type": "string",
                "example": "analog"
              },
              "gaugeValue": {
                "description": "The predicted value of the gauge.",
                "type": "number",
                "example": 1.75
              }
            }
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "VisionTagDetectionAnnotation": {
        "description": "Annotation representing detected entities.",
        "type": "object",
        "required": ["text", "assetIds"],
        "properties": {
          "text": {
            "description": "The matched string which corresponds to either the name or the external id of the matched assets.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "assetIds": {
            "description": "List of internal IDs for matched assets.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "example": [1234, 8888]
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "ValveReadingAnnotation": {
        "description": "Annotation representing a detected valve.",
        "type": "object",
        "required": ["description", "data", "region"],
        "properties": {
          "description": {
            "description": "valve",
            "type": "string",
            "example": "valve"
          },
          "data": {
            "required": ["state"],
            "properties": {
              "state": {
                "description": "The predicted state of the valve.",
                "type": "string",
                "example": "on",
                "enum": ["on", "off", "undefined"]
              }
            }
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "ConfidenceThresholdMetricSchema": {
        "type": "object",
        "properties": {
          "confidenceThreshold": {
            "type": "number",
            "description": "The confidence threshold returns predictions as positive if their confidence score is the selected value or higher. A higher confidence threshold increases precision but lowers recall, and vice versa.",
            "example": 0.1,
            "minimum": 0,
            "maximum": 1
          },
          "precision": {
            "type": "number",
            "description": "The percentage of predictions that were correct (positive).",
            "example": 0.6,
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "The percentage of all ground truth items that were successfully predicted by the model.",
            "example": 0.4,
            "minimum": 0,
            "maximum": 1
          },
          "f1score": {
            "type": "number",
            "description": "Calculated F1 score. See [this Wikipedia article](https://en.wikipedia.org/wiki/F-score) for its definition and possible usages.",
            "example": 0.666,
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "ModelEvaluationSchema": {
        "type": "object",
        "required": ["meanAveragePrecision", "metrics"],
        "properties": {
          "iouThreshold": {
            "type": "number",
            "description": "The intersection over union (IOU) threshold used to generate the confidence metrics. Only returned for object detection models.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "meanAveragePrecision": {
            "type": "number",
            "description": "A measure of how well your model performs across all confidence thresholds by calculating the area under the precision-recall tradeoff curve.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "metrics": {
            "type": "array",
            "description": "The model metrics for different values of confidence thresholds. Ordered ascendingly by the confidence threshold.",
            "items": {
              "$ref": "#/components/schemas/ConfidenceThresholdMetricSchema"
            }
          }
        }
      },
      "DocumentsSearchRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsFilterOption"
          },
          {
            "$ref": "#/components/schemas/DocumentsSearch"
          },
          {
            "$ref": "#/components/schemas/DocumentsAggregates"
          },
          {
            "$ref": "#/components/schemas/DocumentsSort"
          },
          {
            "$ref": "#/components/schemas/DocumentsSearchLimit"
          }
        ]
      },
      "DocumentsFilterRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsFilterOption"
          },
          {
            "$ref": "#/components/schemas/DocumentsLimit"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "DocumentContentRequestItems": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/DocumentContentItem"
            }
          }
        }
      },
      "DocumentContentItem": {
        "oneOf": [
          {
            "type": "object",
            "title": "Select by Id",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/DocumentId"
              }
            }
          },
          {
            "type": "object",
            "title": "Select by ExternalId",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "DocumentContentRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentContentRequestItems"
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DocumentsClassifierListByIdsRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsClassifierListByIdsItems"
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DocumentsClassifierDeleteRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsClassifierDeleteItems"
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DocumentsLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DocumentsSearchLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items.",
            "type": "integer",
            "format": "int32",
            "minimum": 0,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DocumentsSort": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "array",
            "description": "List of fields to sort by, currently only supports 1 field.\nSyntax: `[\"<fieldname>:asc|desc\"]`. Default sort order is `asc` with short syntax `[\"<fieldname>\"]`.\n",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "string"
            },
            "example": ["externalId:desc"]
          }
        }
      },
      "DocumentsFilterOption": {
        "description": "Filter with exact match",
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/DocumentsFilter"
          }
        }
      },
      "DocumentsFilter": {
        "description": "Filter with exact match",
        "type": "object",
        "properties": {
          "id": {
            "description": "Id of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/IntPredicate"
              }
            ]
          },
          "externalIdPrefix": {
            "description": "External Id provided by client",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "title": {
            "description": "Derived title of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "author": {
            "description": "Derived author of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "createdTime": {
            "description": "Derived creation date of the file",
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "mimeType": {
            "description": "Derived MIME type of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "extension": {
            "description": "Extension of the file (case-insensitive)",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ],
            "example": "pdf"
          },
          "pageCount": {
            "description": "Number of pages for multi-page documents.",
            "type": "object",
            "properties": {
              "max": {
                "description": "The maximum page count for any document.",
                "type": "integer",
                "minimum": 0,
                "format": "int32"
              },
              "min": {
                "description": "The minimum page count for any document.",
                "type": "integer",
                "minimum": 0,
                "format": "int32"
              }
            }
          },
          "type": {
            "description": "Derived document type of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "language": {
            "description": "Derived langugage of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "assetIds": {
            "$ref": "#/components/schemas/AssetIdsFilter"
          },
          "assetExternalIds": {
            "$ref": "#/components/schemas/AssetExternalIdsFilter"
          },
          "assetSubtreeIds": {
            "$ref": "#/components/schemas/AssetSubtreeIdsFilter"
          },
          "sourceSystem": {
            "description": "The system the source file lives in",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "labels": {
            "$ref": "#/components/schemas/DocumentsLabelFilter"
          },
          "geoLocation": {
            "description": "Geometric shape and geoJson relation. The filtering here is done on the `geoLocation` of the file.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentGeoLocationFilter"
              }
            ]
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentsSourceFileFilter"
          }
        }
      },
      "DocumentsSourceFileFilter": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "directoryPrefix": {
            "description": "The name of the directory holding the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "source": {
            "description": "The source of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "mimeType": {
            "description": "MIME type of the file, e.g. `text/plain`, `application/pdf`",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "size": {
            "description": "Range between two integers.",
            "type": "object",
            "properties": {
              "max": {
                "description": "The maximum size of the source file in bytes.",
                "type": "integer",
                "minimum": 0,
                "format": "int64"
              },
              "min": {
                "description": "The minimum size of the source file in bytes.",
                "type": "integer",
                "minimum": 0,
                "format": "int64"
              }
            }
          },
          "assetIds": {
            "$ref": "#/components/schemas/AssetIdsFilter"
          },
          "assetExternalIds": {
            "$ref": "#/components/schemas/AssetExternalIdsFilter"
          },
          "assetSubtreeIds": {
            "$ref": "#/components/schemas/AssetSubtreeIdsFilter"
          },
          "uploadedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "sourceCreatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "sourceModifiedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "labels": {
            "$ref": "#/components/schemas/DocumentsLabelFilter"
          },
          "geoLocation": {
            "description": "Geometric shape and geoJson relation. The filtering here is done on the `geoLocation` of the file.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentGeoLocationFilter"
              }
            ]
          },
          "datasetId": {
            "description": "Data set id of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/IntPredicate"
              }
            ]
          },
          "metadata": {
            "type": "object",
            "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "DocumentsSearch": {
        "type": "object",
        "properties": {
          "search": {
            "type": "object",
            "properties": {
              "query": {
                "type": "string",
                "description": "The free text search query as described in detail above.",
                "maxLength": 1000
              },
              "highlight": {
                "type": "boolean",
                "description": "Whether or not matches in search results should be highlighted.",
                "default": false
              }
            }
          }
        }
      },
      "DocumentsAggregates": {
        "type": "object",
        "properties": {
          "aggregates": {
            "type": "array",
            "items": {
              "type": "object",
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DocumentsCountAggregate"
                },
                {
                  "$ref": "#/components/schemas/DocumentsDateHistogramAggregate"
                }
              ],
              "minItems": 1,
              "maxItems": 5
            }
          }
        }
      },
      "DocumentsCountAggregate": {
        "type": "object",
        "required": ["name", "aggregate"],
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined name for this aggregate"
          },
          "aggregate": {
            "type": "string",
            "description": "count",
            "example": "count"
          },
          "groupBy": {
            "type": "array",
            "description": "List of fields to group the count by. It is currently only possible to group by 1 field or 0 fields. If grouping by 0 fields, the aggregate value is the total count of all documents.",
            "items": {
              "type": "string",
              "minItems": 1,
              "maxItems": 1
            }
          }
        }
      },
      "DocumentsDateHistogramAggregate": {
        "type": "object",
        "required": ["name", "aggregate", "field", "interval"],
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined name for this aggregate"
          },
          "aggregate": {
            "type": "string",
            "description": "dateHistogram",
            "example": "dateHistogram"
          },
          "field": {
            "type": "string",
            "description": "Which field to create the date histogram on.",
            "example": true
          },
          "interval": {
            "type": "string",
            "description": "Date interval to use to create histogram, 'day', 'week', 'month', or 'year'."
          }
        }
      },
      "DocumentContent": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DocumentId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "content": {
            "type": "string",
            "description": "The textual content of the document, truncated to the first 1MB of text",
            "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
          }
        }
      },
      "Document": {
        "type": "object",
        "required": ["id", "sourceFile"],
        "description": "A document",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DocumentId",
            "example": 1
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId",
            "example": "haml001"
          },
          "title": {
            "description": "The title of the document",
            "type": "string",
            "example": "Hamlet"
          },
          "author": {
            "description": "The author of the document",
            "type": "string",
            "example": "William Shakespeare"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp",
            "description": "When the document was created, measured in milliseconds since 00:00:00 Thursday, 1 January 1970",
            "example": -11676052800000
          },
          "lastIndexedTime": {
            "$ref": "#/components/schemas/EpochTimestamp",
            "description": "When the document was indexed, measured in milliseconds since 00:00:00 Thursday, 1 January 1970",
            "example": -11676052800000
          },
          "mimeType": {
            "description": "Detected mime type for the document",
            "type": "string",
            "example": "text/plain"
          },
          "extension": {
            "type": "string",
            "description": "Extension of the file (always in lowercase)",
            "example": "pdf"
          },
          "pageCount": {
            "description": "Number of pages for multi-page documents",
            "type": "integer",
            "format": "int32",
            "example": 2
          },
          "type": {
            "description": "Detected mime type for the document",
            "type": "string",
            "example": "text/plain"
          },
          "language": {
            "description": "The detected language used in the document",
            "type": "string",
            "example": "en"
          },
          "truncatedContent": {
            "description": "The textual content of the document. Currently truncated to 155 characters",
            "type": "string",
            "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
          },
          "assetIds": {
            "description": "The ids of any assets referred to in the document",
            "type": "array",
            "example": [42, 101],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "labels": {
            "description": "A list of labels derived by this pipeline's document classifier.",
            "type": "array",
            "example": [
              {
                "externalId": "play"
              },
              {
                "externalId": "tragedy"
              }
            ],
            "$ref": "#/components/schemas/LabelList",
            "items": {
              "type": "object",
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          },
          "sourceSystem": {
            "type": "string",
            "example": "CDF"
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentSourceFile"
          },
          "geoLocation": {
            "$ref": "#/components/schemas/DocumentGeoLocation"
          }
        }
      },
      "DocumentSourceFile": {
        "type": "object",
        "description": "The source file that this document is derived from.",
        "required": ["name"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the file",
            "example": "hamlet.txt"
          },
          "directory": {
            "type": "string",
            "description": "The directory the file can be found in",
            "example": "plays/shakespeare"
          },
          "source": {
            "type": "string",
            "description": "The source of the file",
            "example": "SubsurfaceConnectors"
          },
          "mimeType": {
            "type": "string",
            "description": "The mime type of the file",
            "example": "application/octet-stream"
          },
          "size": {
            "type": "number",
            "format": "int64",
            "description": "The size of the source file in bytes",
            "example": 1000
          },
          "assetIds": {
            "type": "array",
            "description": "The ids of the assets related to this file",
            "example": [],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "createdTime": {
            "type": "number",
            "format": "int64",
            "description": "The time the file was created"
          },
          "lastIndexedTime": {
            "type": "number",
            "format": "int64",
            "description": "The time the file was indexed"
          },
          "lastUpdatedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "uploadedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "sourceCreatedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "sourceModifiedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "labels": {
            "description": "A list of labels associated with this document's source file in CDF.",
            "example": [
              {
                "externalId": "play"
              },
              {
                "externalId": "tragedy"
              }
            ],
            "$ref": "#/components/schemas/LabelList"
          },
          "geoLocation": {
            "$ref": "#/components/schemas/DocumentGeoLocation"
          },
          "datasetId": {
            "$ref": "#/components/schemas/CogniteInternalId",
            "description": "The id if the dataset this file belongs to, if any"
          },
          "securityCategories": {
            "type": "array",
            "description": "The security category IDs required to access this file",
            "example": [],
            "items": {
              "type": "number",
              "format": "int64"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "Highlight": {
        "type": "object",
        "description": "Highlighted snippets from content, name and externalId fields which show where the query matches are.",
        "properties": {
          "name": {
            "type": "array",
            "description": "Matches in name.",
            "items": {
              "type": "string"
            }
          },
          "content": {
            "type": "array",
            "description": "Matches in content.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AssetIds": {
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "uniqueItems": true,
        "description": "IDs of assets related to the file.",
        "example": [363848954441724, 793045462540095, 1261042166839739],
        "items": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "AssetIdsFilter": {
        "description": "Only include files that reference these specific asset IDs.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContainsAllIds"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyId"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "AssetExternalIdsFilter": {
        "description": "Only include files that reference these specific asset externalIds.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContainsAllExternalIds"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyExternalIds"
          }
        ]
      },
      "AssetSubtreeIdsFilter": {
        "description": "Only include documents with a related asset in a subtree rooted at any of these asset IDs, including the roots given. Returns an error if the total size of the given subtrees exceeds 10,000 assets. Usage of this field requires `[\"assetsAcl:READ\"]` capability.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContainsAnyId"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "DocumentsLabelFilter": {
        "description": "Return only the resource matching the specified label constraints.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelContainsAllFilter"
          },
          {
            "$ref": "#/components/schemas/LabelContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "ShapeType": {
        "description": "Type of the shape. Currently we support \"polygon\", \"linestring\" and \"point\".",
        "type": "string"
      },
      "ShapeCoordinates": {
        "description": "Coordinates of the shape.",
        "type": "array"
      },
      "GeometryCollection": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ShapeType"
          },
          "coordinates": {
            "$ref": "#/components/schemas/ShapeCoordinates"
          }
        }
      },
      "DocumentGeoLocation": {
        "description": "GeoJson representation of a geometry.",
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ShapeType"
          },
          "coordinates": {
            "$ref": "#/components/schemas/ShapeCoordinates"
          },
          "geometries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeometryCollection"
            }
          }
        }
      },
      "Relation": {
        "description": "Spatial relation which will be used at search time. Currently we support `intersects`, `disjoint`, and `within`. For guidance regarding relations, see [this Wikipedia article](https://en.wikipedia.org/wiki/Spatial_relation#Topological_relations).",
        "type": "string",
        "default": "intersects"
      },
      "DocumentGeoLocationFilter": {
        "description": "Filter on files which have the specified spatial relation with the specified geometry shape.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ValueMissing"
          },
          {
            "type": "object",
            "title": "shape",
            "properties": {
              "shape": {
                "$ref": "#/components/schemas/DocumentGeoLocation"
              },
              "relation": {
                "$ref": "#/components/schemas/Relation"
              }
            },
            "required": ["shape"]
          }
        ]
      },
      "IntIn": {
        "type": "object",
        "required": ["in"],
        "properties": {
          "in": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "Int value must be a value in this array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "StringIn": {
        "type": "object",
        "required": ["in"],
        "properties": {
          "in": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "String value must be a value in this array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "StringEquals": {
        "type": "object",
        "required": ["equals"],
        "properties": {
          "equals": {
            "type": "string",
            "description": "String value must match this value"
          }
        }
      },
      "ValueMissing": {
        "type": "object",
        "required": ["missing"],
        "properties": {
          "missing": {
            "type": "boolean",
            "description": "Value for the field is missing"
          }
        }
      },
      "IntEquals": {
        "type": "object",
        "required": ["equals"],
        "properties": {
          "equals": {
            "type": "integer",
            "description": "Int value must match this value"
          }
        }
      },
      "ContainsAllStrings": {
        "type": "object",
        "properties": {
          "containsAll": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "Values for this field must match all values in this array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ContainsAnyString": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "Values for this field must match with at least one of the values in this array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ContainsAllIds": {
        "type": "object",
        "properties": {
          "containsAll": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match all values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "ContainsAnyId": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match with at least one of the values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "ContainsAllExternalIds": {
        "type": "object",
        "properties": {
          "containsAll": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match all values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        }
      },
      "ContainsAnyExternalIds": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match with at least one of the values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        }
      },
      "IntPredicate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/IntIn"
          },
          {
            "$ref": "#/components/schemas/IntEquals"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "StringPredicate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/StringIn"
          },
          {
            "$ref": "#/components/schemas/StringEquals"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "DocumentsPipelineArrayOf1To10Strings": {
        "type": "array",
        "maxItems": 10,
        "minItems": 1,
        "items": {
          "type": "string"
        }
      },
      "DocumentsPipelineArrayOf1To10ExternalIds": {
        "type": "array",
        "maxItems": 10,
        "minItems": 1,
        "items": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "DocumentsPipelineArrayOf1To10StringsUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
              }
            }
          },
          {
            "title": "add and/or remove",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
              },
              "remove": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
              }
            }
          }
        ]
      },
      "DocumentsPipelineArrayOf1To10ExternalIdsUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
              }
            }
          },
          {
            "title": "add and/or remove",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
              },
              "remove": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
              }
            }
          }
        ]
      },
      "DocumentsPipelineSourceFile": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "directory": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "content": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
            }
          }
        }
      },
      "DocumentsPipelineFieldMappings": {
        "type": "object",
        "properties": {
          "title": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "author": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "mimeType": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "type": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "labelsExternalIds": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentsPipelineSourceFile"
          }
        },
        "example": {
          "title": ["TERMS"],
          "author": ["TERMS"],
          "type": ["TERMS", "TYPES"],
          "sourceFile": {
            "name": ["TERMS"],
            "content": ["TERMS", "TYPES"],
            "directory": ["DIRECTORIES"]
          }
        }
      },
      "DocumentsPipelineSensitivityMatcher": {
        "type": "object",
        "properties": {
          "matchLists": {
            "type": "object",
            "description": "Dictionary object. Name of match lists as keys, lists of matching words as values.",
            "example": {
              "DIRECTORIES": ["secret"],
              "TYPES": ["contracts", "emails"],
              "TERMS": ["secret", "confidential", "sensitive"]
            },
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "fieldMappings": {
            "$ref": "#/components/schemas/DocumentsPipelineFieldMappings"
          },
          "filterPasswords": {
            "type": "boolean",
            "description": "Whether or not a file is marked sensitive if it contains text that looks like a password.",
            "default": true
          },
          "sensitiveSecurityCategory": {
            "type": "integer",
            "description": "The security category id to attach to sensitive documents.",
            "format": "int64",
            "example": 345341343656745
          },
          "restrictToSources": {
            "type": "array",
            "description": "Only documents from these sources will be evaluated if they are sensitive. If the field is empty, all documents will be evaluated.",
            "items": {
              "type": "string",
              "example": "my source"
            }
          }
        }
      },
      "DocumentsPipelineClassifier": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "A descriptive name of the classifier."
          },
          "trainingLabels": {
            "$ref": "#/components/schemas/LabelList"
          },
          "activeClassifierId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "lastTrainedAt": {
            "type": "number",
            "format": "int64",
            "description": "Timestamp when the classifier was last trained"
          }
        }
      },
      "DocumentsPipeline": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "sensitivityMatcher": {
            "$ref": "#/components/schemas/DocumentsPipelineSensitivityMatcher"
          },
          "classifier": {
            "$ref": "#/components/schemas/DocumentsPipelineClassifier"
          }
        }
      },
      "DocumentsPipelineItems": {
        "description": "A list of pipeline configuration objects.",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsPipeline"
            }
          }
        }
      },
      "LabelListUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/LabelList"
              }
            }
          },
          {
            "title": "add and/or remove",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/LabelList"
              },
              "remove": {
                "$ref": "#/components/schemas/LabelList"
              }
            }
          }
        ]
      },
      "DocumentsPipelineSourceFileUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineSourceFile"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": ["modify"],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "directory": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "content": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "metadata": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": ["set"],
                        "description": "Replaces all metadata values",
                        "properties": {
                          "set": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      {
                        "title": "add and/or remove",
                        "type": "object",
                        "properties": {
                          "add": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "remove": {
                            "type": "array",
                            "description": "list of keys to remove",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "SensitivityMatcherFieldMappingsUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineFieldMappings"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": ["modify"],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "title": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "author": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "mimeType": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "type": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "labelsExternalIds": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIdsUpdate"
                  },
                  "sourceFile": {
                    "$ref": "#/components/schemas/DocumentsPipelineSourceFileUpdate"
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsPipelineSensitivityMatcherUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineSensitivityMatcher"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": ["modify"],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "fieldMappings": {
                    "$ref": "#/components/schemas/SensitivityMatcherFieldMappingsUpdate"
                  },
                  "matchLists": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": ["set"],
                        "properties": {
                          "set": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      {
                        "title": "add and/or remove",
                        "type": "object",
                        "properties": {
                          "add": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "remove": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    ]
                  },
                  "filterPasswords": {
                    "type": "object",
                    "required": ["set"],
                    "properties": {
                      "set": {
                        "type": "boolean"
                      }
                    }
                  },
                  "sensitiveSecurityCategory": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": ["set"],
                        "properties": {
                          "set": {
                            "type": "integer",
                            "format": "int64",
                            "example": 345341343656745
                          }
                        }
                      },
                      {
                        "title": "nullSetter",
                        "type": "object",
                        "required": ["setNull"],
                        "properties": {
                          "setNull": {
                            "type": "boolean",
                            "default": false
                          }
                        }
                      }
                    ]
                  },
                  "restrictToSources": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": ["set"],
                        "properties": {
                          "set": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      {
                        "title": "add and/or remove",
                        "type": "object",
                        "properties": {
                          "add": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "remove": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsPipelineClassifierUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineClassifier"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": ["modify"],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "object",
                    "required": ["set"],
                    "properties": {
                      "set": {
                        "type": "string",
                        "description": "A new name for the classifier."
                      }
                    }
                  },
                  "trainingLabels": {
                    "$ref": "#components/schemas/LabelListUpdate"
                  },
                  "activeClassifierId": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": ["set"],
                        "properties": {
                          "set": {
                            "$ref": "#/components/schemas/CogniteInternalId"
                          }
                        }
                      },
                      {
                        "title": "nullSetter",
                        "type": "object",
                        "required": ["setNull"],
                        "properties": {
                          "setNull": {
                            "type": "boolean"
                          }
                        }
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsPipelineUpdate": {
        "type": "object",
        "required": ["externalId", "update"],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "type": "object",
            "properties": {
              "sensitivityMatcher": {
                "$ref": "#/components/schemas/DocumentsPipelineSensitivityMatcherUpdate"
              },
              "classifier": {
                "$ref": "#/components/schemas/DocumentsPipelineClassifierUpdate"
              }
            }
          }
        }
      },
      "DocumentsPipelineItemsUpdate": {
        "description": "A list of update pipeline configuration objects.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsPipelineUpdate"
            }
          }
        }
      },
      "DocumentsClassifier": {
        "type": "object",
        "required": [
          "id",
          "projectId",
          "name",
          "createdAt",
          "status",
          "active"
        ],
        "properties": {
          "projectId": {
            "$ref": "#/components/schemas/CogniteInternalId",
            "description": "Project id"
          },
          "name": {
            "type": "string",
            "description": "Name of the classifier"
          },
          "createdAt": {
            "type": "number",
            "format": "int64",
            "description": "Timestamp when the classifier is created"
          },
          "status": {
            "type": "string",
            "description": "Status of the creating classifier job. Can be one of `QUEUING`, `TRAINING`, `FINISHED`, `FAILED`"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the classifier is currently used for predicting labels"
          },
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId",
            "description": "Classifier id"
          },
          "metrics": {
            "$ref": "#/components/schemas/DocumentsClassifierMetrics"
          },
          "trainingSetSize": {
            "type": "number",
            "format": "int64",
            "description": "The number of documents used for training the classifier"
          }
        }
      },
      "DocumentsClassifierMetrics": {
        "type": "object",
        "properties": {
          "precision": {
            "type": "number",
            "format": "float"
          },
          "recall": {
            "type": "number",
            "format": "float"
          },
          "f1Score": {
            "type": "number",
            "format": "float"
          },
          "confusionMatrix": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              }
            }
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "DocumentsClassifierItems": {
        "description": "A list of classifiers.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifier"
            }
          }
        }
      },
      "DocumentsClassifierCreate": {
        "type": "object",
        "required": ["name"],
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "DocumentsClassifierCreateItems": {
        "description": "A list of classifiers.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifierCreate"
            }
          }
        }
      },
      "DocumentsClassifierListByIds": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DocumentsClassifierListByIdsItems": {
        "description": "A list of classifier ids.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifierListByIds"
            }
          }
        }
      },
      "DocumentsClassifierDelete": {
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DocumentsClassifierDeleteItems": {
        "description": "A list of classifier ids.",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifierDelete"
            }
          }
        }
      },
      "FeedbackLabel": {
        "type": "object",
        "description": "Label to add to, or remove from a file",
        "allOf": [
          {
            "$ref": "#/components/schemas/LabelDefinitionExternalId"
          }
        ]
      },
      "DocumentId": {
        "$ref": "#/components/schemas/CogniteInternalId",
        "description": "Internal ID of the CDF file/document",
        "example": 1066
      },
      "FeedbackId": {
        "$ref": "#/components/schemas/CogniteInternalId",
        "description": "Server-generated identifier for the feedback object",
        "example": 42
      },
      "FeedbackAction": {
        "type": "string",
        "description": "What to do with the label on the file",
        "enum": ["ATTACH", "DETACH"]
      },
      "FeedbackStatus": {
        "type": "string",
        "enum": ["CREATED", "ACCEPTED", "REJECTED", "STALE"],
        "example": "ACCEPTED",
        "description": "Status of the feedback, complying with the lifecycle described below.\n\n## Feedback lifecycle\n- It is initially `CREATED`.\n- If the administrator accepts the feedback, it moves to `ACCEPTED`.\n  Once in this state, it cannot move to another state.\n- If the administrator rejects the feedback, it moves to `REJECTED`.\n  Once in this state, it cannot move to another state.\n- If the feedback object has become _invalid_, it moves to `STALE`.\n  Once in this state, it cannot move to another state.\n\n## Definition of feedback _invalidity_\n- If the action was `ATTACH`, and the label to attach does not exist anymore.\n- If the action was `ATTACH`, and the label is already attached to the file.\n- If the action was `DETACH`, and the label is not attached to the file anymore."
      },
      "ReporterInfo": {
        "type": "string",
        "nullable": true,
        "description": "**Optional** information about the reporter. This could be a name\nor an email. Please note that this field is free text – it is not\nchecked for integrity at any time.",
        "example": "Jane Doe"
      },
      "DocumentFeedbackCreateRequest": {
        "description": "A list of feedback objects, not yet written to the API",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentFeedbackCreateItem"
            }
          }
        }
      },
      "DocumentFeedbackCreateItem": {
        "description": "A new feedback object, not yet written to the API",
        "type": "object",
        "required": ["documentId", "label", "action"],
        "properties": {
          "documentId": {
            "$ref": "#/components/schemas/DocumentId"
          },
          "label": {
            "$ref": "#/components/schemas/FeedbackLabel"
          },
          "action": {
            "$ref": "#/components/schemas/FeedbackAction"
          },
          "reporterInfo": {
            "$ref": "#/components/schemas/ReporterInfo"
          }
        }
      },
      "DocumentFeedback": {
        "description": "A feedback object",
        "type": "object",
        "required": [
          "documentId",
          "label",
          "action",
          "feedbackId",
          "createdAt",
          "status"
        ],
        "properties": {
          "documentId": {
            "$ref": "#/components/schemas/DocumentId"
          },
          "label": {
            "$ref": "#/components/schemas/FeedbackLabel"
          },
          "action": {
            "$ref": "#/components/schemas/FeedbackAction"
          },
          "feedbackId": {
            "$ref": "#/components/schemas/FeedbackId"
          },
          "reporterInfo": {
            "$ref": "#/components/schemas/ReporterInfo"
          },
          "createdAt": {
            "description": "When this feedback object was created by the end-user.\n\nA UTC-based [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp string.",
            "type": "string",
            "example": "2021-02-04T16:24:23.284407"
          },
          "reviewedAt": {
            "description": "When this feedback object moved from `CREATED` to another state.\nThis field is only present if the status is not `CREATED`.\n\nA UTC-based [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp string.",
            "type": "string",
            "nullable": true,
            "example": "2021-02-05T14:28:27"
          },
          "status": {
            "$ref": "#/components/schemas/FeedbackStatus"
          }
        }
      },
      "AggregateField": {
        "type": "string",
        "description": "A feedback field to aggregate on.\n\nYou can find extensive description of the available fields in the\n[List Feedback](#operation/documentsListFeedback) endpoint response.",
        "enum": ["action", "status"],
        "example": "action"
      },
      "DocumentFeedbackAggregateRequest": {
        "description": "A query object for the aggregation endpoint",
        "type": "object",
        "required": ["field"],
        "properties": {
          "field": {
            "$ref": "#/components/schemas/AggregateField"
          }
        }
      },
      "AggregateGroup": {
        "description": "A value/count aggregation object",
        "type": "object",
        "required": ["value", "count"],
        "properties": {
          "value": {
            "type": "string",
            "description": "A value of the `field`"
          },
          "count": {
            "type": "integer",
            "description": "The count of records with the `value` for the `field`"
          }
        }
      },
      "DocumentFeedbackAcceptRejectRequest": {
        "description": "A query object for the accept/reject endpoints",
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentFeedbackAcceptRejectItem"
            }
          }
        }
      },
      "DocumentFeedbackAcceptRejectItem": {
        "description": "An id of the accepted / rejected feedback",
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/FeedbackId"
          }
        }
      },
      "AnnotationsV2SuggestSchema": {
        "type": "object",
        "required": [
          "annotatedResourceType",
          "annotatedResourceId",
          "annotationType",
          "creatingApp",
          "creatingAppVersion",
          "creatingUser",
          "data"
        ],
        "properties": {
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotatedResourceId": {
            "$ref": "#/components/schemas/AnnotatedResourceId"
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "data": {
            "$ref": "#/components/schemas/AnnotationData"
          }
        }
      },
      "AnnotationsV2CreateSchema": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AnnotationsV2SuggestSchema"
          },
          {
            "type": "object",
            "required": ["status"],
            "properties": {
              "status": {
                "$ref": "#/components/schemas/Status"
              }
            }
          }
        ]
      },
      "AnnotationsV2ListResponseSchema": {
        "type": "object",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "description": "A list of annotations",
            "items": {
              "$ref": "#/components/schemas/AnnotationsV2ResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ResponseSchema": {
        "type": "object",
        "required": [
          "id",
          "createdTime",
          "lastUpdatedTime",
          "annotatedResourceType",
          "annotationType",
          "creatingApp",
          "creatingAppVersion",
          "creatingUser",
          "data",
          "status"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/AnnotationId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotatedResourceId": {
            "$ref": "#/components/schemas/AnnotatedResourceId"
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "data": {
            "$ref": "#/components/schemas/AnnotationData"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          }
        }
      },
      "AnnotationsV2ReferenceSchema": {
        "type": "object",
        "description": "A reference to an existing annotation",
        "required": ["id"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/AnnotationId"
          }
        }
      },
      "AnnotationsV2FilterSchema": {
        "type": "object",
        "description": "A filter to apply on annotations",
        "required": ["annotatedResourceType", "annotatedResourceIds"],
        "properties": {
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotatedResourceIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResourceReference"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          },
          "data": {
            "description": "Filter annotations by their data keys and values (case-sensitive). Concretely, by providing this field, we check for all annotations that contains the data filter as a subset.\nIf `annotationType` is not specified, the data filter will applied across all annotation types.",
            "example": {
              "label": "cat",
              "fileRef": {
                "externalId": "abc"
              }
            },
            "type": "object"
          }
        },
        "example": {
          "annotatedResourceType": "file",
          "annotatedResourceIds": ["abc-1066"],
          "status": "approved",
          "data": {
            "label": "cat"
          }
        }
      },
      "AnnotationsV2CursoredListResponseSchema": {
        "type": "object",
        "description": "A cursored list of existing annotations",
        "required": ["items"],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotationsV2ResponseSchema"
            }
          },
          "nextCursor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Cursor"
              }
            ],
            "nullable": true,
            "example": null
          }
        }
      },
      "AnnotationsV2UpdateItemSchema": {
        "type": "object",
        "description": "An update object to apply to an annotation",
        "required": ["id", "update"],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/AnnotationId"
          },
          "update": {
            "$ref": "#/components/schemas/AnnotationsV2UpdateDataSchema"
          }
        }
      },
      "AnnotationsV2UpdateDataSchema": {
        "type": "object",
        "description": "Each fields represent a \"delta\" that will be applied onto the corresponding field of the original\nannotation.\n\n\n### Updating Annotation Type or Data\nEnsure that the new annotation data conforms to the new annotation type, otherwise the call will fail.",
        "properties": {
          "annotationType": {
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/AnnotationType"
              }
            }
          },
          "data": {
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/AnnotationData"
              }
            }
          },
          "status": {
            "type": "object",
            "required": ["set"],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/Status"
              }
            }
          }
        },
        "example": {
          "data": {
            "set": {
              "assetRef": {
                "externalId": "abc"
              },
              "symbolRegion": {
                "xMin": 0.1,
                "xMax": 0.2,
                "yMin": 0.1,
                "yMax": 0.2
              },
              "textRegion": {
                "xMin": 0.4,
                "xMax": 0.5,
                "yMin": 0.4,
                "yMax": 0.5
              },
              "pageNumber": 43
            }
          }
        }
      },
      "AnnotatedResourceType": {
        "type": "string",
        "description": "The annotated CDF resource. Files are supported.",
        "enum": ["file"],
        "example": "file"
      },
      "AnnotatedResourceId": {
        "description": "The internal ID of the annotated resource.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ],
        "example": 1337
      },
      "Application": {
        "type": "string",
        "description": "The application name or identifier. This is neither checked nor enforced.",
        "example": "cognite-vision",
        "minLength": 1,
        "maxLength": 255
      },
      "User": {
        "type": "string",
        "description": "A username, or email, or name. This is not checked nor enforced. If the value is null, it means the\nannotation was created by a service.",
        "nullable": true,
        "example": "john.doe@cognite.com",
        "minLength": 1,
        "maxLength": 255
      },
      "SemanticVersion": {
        "type": "string",
        "description": "A version number in the SemVer sense. See [semver.org](https://semver.org/) for the specification.",
        "example": "1.2.1",
        "minLength": 1,
        "maxLength": 255
      },
      "AnnotationId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ],
        "description": "Server-generated identifier for the annotation",
        "example": 4096
      },
      "AnnotationType": {
        "type": "string",
        "description": "The type of the annotation. This uniquely decides what the structure of the `data` block will be.",
        "enum": [
          "images.ObjectDetection",
          "images.Classification",
          "images.KeypointCollection",
          "images.AssetLink",
          "images.TextRegion",
          "diagrams.AssetLink",
          "diagrams.FileLink",
          "diagrams.UnhandledTextObject",
          "diagrams.UnhandledSymbolObject",
          "diagrams.PipeSymbol",
          "documents.ExtractedText",
          "diagrams.Line",
          "diagrams.Junction",
          "forms.Detection"
        ],
        "example": "images.ObjectDetection"
      },
      "AnnotationData": {
        "description": "The annotation information. The format of this object is decided by and validated against the `annotationType`\nattribute.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Annotations.ObjectDetection"
          },
          {
            "$ref": "#/components/schemas/Annotations.Classification"
          },
          {
            "$ref": "#/components/schemas/Annotations.KeypointCollection"
          },
          {
            "$ref": "#/components/schemas/Annotations.cognite__annotation_types__images__AssetLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.TextRegion"
          },
          {
            "$ref": "#/components/schemas/Annotations.cognite__annotation_types__diagrams__AssetLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.FileLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.UnhandledTextObject"
          },
          {
            "$ref": "#/components/schemas/Annotations.UnhandledSymbolObject"
          },
          {
            "$ref": "#/components/schemas/Annotations.PipeSymbol"
          },
          {
            "$ref": "#/components/schemas/Annotations.ExtractedText"
          },
          {
            "$ref": "#/components/schemas/Annotations.Line"
          },
          {
            "$ref": "#/components/schemas/Annotations.Junction"
          },
          {
            "$ref": "#/components/schemas/Annotations.Detection"
          }
        ],
        "example": {
          "assetRef": {
            "externalId": "abc"
          },
          "symbolRegion": {
            "xMin": 0.1,
            "xMax": 0.2,
            "yMin": 0.1,
            "yMax": 0.2
          },
          "textRegion": {
            "xMin": 0.2,
            "xMax": 0.3,
            "yMin": 0.2,
            "yMax": 0.3
          },
          "pageNumber": 43
        }
      },
      "ResourceReference": {
        "type": "object",
        "description": "A reference to another CDF resource. _Either_ the internal _or_ the external ID _must_ be provided (not both).",
        "properties": {
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "example": null
          },
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ],
            "example": "abc-1066"
          }
        }
      },
      "Status": {
        "type": "string",
        "description": "The status of the annotation",
        "enum": ["suggested", "approved", "rejected"],
        "example": "approved"
      },
      "Annotations.Point": {
        "title": "primitives.geometry2d.Point",
        "description": "Point in a 2D-Cartesian coordinate system with origin at the top-left corner of the page",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "x": {
            "description": "The abscissa of the point in a coordinate system with origin at the top-left corner of the page. Normalized in (0,1).",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "y": {
            "description": "The ordinate of the point in a coordinate system with origin at the top-left corner of the page. Normalized in (0,1).",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": ["x", "y"],
        "additionalProperties": false
      },
      "Annotations.Boolean": {
        "title": "primitives.attributes.Boolean",
        "description": "The boolean value of something",
        "type": "object",
        "properties": {
          "description": {
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "type": {
            "enum": ["boolean"],
            "type": "string"
          },
          "value": {
            "description": "The boolean value",
            "type": "boolean"
          }
        },
        "required": ["type", "value"],
        "additionalProperties": false
      },
      "Annotations.Numerical": {
        "title": "primitives.attributes.Numerical",
        "description": "The numerical value of something",
        "type": "object",
        "properties": {
          "description": {
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "type": {
            "enum": ["numerical"],
            "type": "string"
          },
          "value": {
            "description": "The numerical value",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ]
          }
        },
        "required": ["type", "value"],
        "additionalProperties": false
      },
      "Annotations.Keypoint": {
        "title": "primitives.geometry2d.Keypoint",
        "description": "A point attached with additional information such as a confidence value and\nvarious attribute(s).",
        "type": "object",
        "properties": {
          "attributes": {
            "description": "Additional attributes data for a compound.",
            "type": "object",
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            }
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "point": {
            "description": "The position of the keypoint",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.Point"
              }
            ]
          }
        },
        "required": ["point"],
        "additionalProperties": false
      },
      "Annotations.BoundingBox": {
        "title": "primitives.geometry2d.BoundingBox",
        "description": "A plain rectangle",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "xMin": {
            "description": "Minimum abscissa of the bounding box (left edge). Must be strictly less than x_max.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "xMax": {
            "description": "Maximum abscissa of the bounding box (right edge). Must be strictly more than x_min.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "yMin": {
            "description": "Minimum ordinate of the bounding box (bottom edge). Must be strictly less than y_max.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "yMax": {
            "description": "Maximum ordinate of the bounding box (top edge). Must be strictly more than y_min.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": ["xMin", "xMax", "yMin", "yMax"],
        "additionalProperties": false
      },
      "Annotations.Polygon": {
        "title": "primitives.geometry2d.Polygon",
        "description": "A _closed_ polygon represented by _n_ vertices. In other words, we assume\nthat the first and last vertex are connected.",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "vertices": {
            "minItems": 3,
            "maxItems": 1000,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.Point"
            }
          }
        },
        "required": ["vertices"],
        "additionalProperties": false
      },
      "Annotations.PolyLine": {
        "title": "primitives.geometry2d.PolyLine",
        "description": "A polygonal chain consisting of _n_ vertices",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "vertices": {
            "minItems": 2,
            "maxItems": 1000,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.Point"
            }
          }
        },
        "required": ["vertices"],
        "additionalProperties": false
      },
      "Annotations.Box": {
        "title": "primitives.geometry3d.Box",
        "description": "A box in 3D space, defined by a 4x4 row-major homogeneous transformation matrix that rotates and\ntranslates a unit box centered at the origin to it's location and orientation in 3D space.",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "matrix": {
            "description": "The homogeneous transformation matrix",
            "minItems": 16,
            "maxItems": 16,
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": ["matrix"],
        "additionalProperties": false
      },
      "Annotations.Cylinder": {
        "title": "primitives.geometry3d.Cylinder",
        "description": "A cylinder in 3D space, defined by the centers of two sides and the radius.",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "centerA": {
            "description": "The center of the first cap.",
            "minItems": 3,
            "maxItems": 3,
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "centerB": {
            "description": "The center of the second cap.",
            "minItems": 3,
            "maxItems": 3,
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "radius": {
            "description": "The radius of the cylinder.",
            "minimum": 0,
            "type": "number"
          }
        },
        "required": ["centerA", "centerB", "radius"],
        "additionalProperties": false
      },
      "Annotations.Geometry": {
        "title": "primitives.geometry3d.Geometry",
        "description": "A 3D geometry model represented by exactly *one of* `cylinder` and `box`.",
        "type": "object",
        "properties": {
          "cylinder": {
            "$ref": "#/components/schemas/Annotations.Cylinder"
          },
          "box": {
            "$ref": "#/components/schemas/Annotations.Box"
          }
        },
        "additionalProperties": false
      },
      "Annotations.AssetRef": {
        "title": "primitives.references.AssetRef",
        "description": "A reference to an asset. Either the internal ID or the external ID must be provided (exactly one).",
        "type": "object",
        "properties": {
          "id": {
            "description": "The internal ID of the referenced resource",
            "type": "integer"
          },
          "externalId": {
            "description": "The external ID of the referenced resource",
            "maxLength": 256,
            "type": "string"
          }
        },
        "additionalProperties": false,
        "oneOf": [
          {
            "required": ["id"]
          },
          {
            "required": ["externalId"]
          }
        ]
      },
      "Annotations.FileRef": {
        "title": "primitives.references.FileRef",
        "description": "A reference to a file. Either the internal ID or the external ID must be provided (exactly one).",
        "type": "object",
        "properties": {
          "id": {
            "description": "The internal ID of the referenced resource",
            "type": "integer"
          },
          "externalId": {
            "description": "The external ID of the referenced resource",
            "maxLength": 256,
            "type": "string"
          }
        },
        "additionalProperties": false,
        "oneOf": [
          {
            "required": ["id"]
          },
          {
            "required": ["externalId"]
          }
        ]
      },
      "Annotations.ObjectDetection": {
        "title": "images.ObjectDetection",
        "description": "Models an image object detection represented by a label, a geometry, and\noptionally a confidence value.",
        "type": "object",
        "properties": {
          "boundingBox": {
            "$ref": "#/components/schemas/Annotations.BoundingBox"
          },
          "polygon": {
            "$ref": "#/components/schemas/Annotations.Polygon"
          },
          "polyline": {
            "$ref": "#/components/schemas/Annotations.PolyLine"
          },
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": ["label"],
        "additionalProperties": false
      },
      "Annotations.Classification": {
        "title": "images.Classification",
        "description": "Models an image classification represented by a label, and optionally a\nconfidence value.",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": ["label"],
        "additionalProperties": false
      },
      "Annotations.KeypointCollection": {
        "title": "images.KeypointCollection",
        "description": "Models a collection of keypoints represented by a label, a dictionary of\nkeypoints (mapping from a (unique) label name to a keypoint), and\noptionally a confidence value and an attributes dictionary.",
        "type": "object",
        "properties": {
          "attributes": {
            "description": "Additional attributes data for a compound.",
            "type": "object",
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            }
          },
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "keypoints": {
            "description": "The detected keypoints",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Annotations.Keypoint"
            }
          }
        },
        "required": ["label", "keypoints"],
        "additionalProperties": false
      },
      "Annotations.cognite__annotation_types__images__AssetLink": {
        "title": "images.AssetLink",
        "description": "Models a link to a CDF Asset referenced in an image",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "assetRef": {
            "description": "The asset this annotation is pointing to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.AssetRef"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "description": "The location of the text mentioning the asset",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          }
        },
        "required": ["assetRef", "text", "textRegion"],
        "additionalProperties": false
      },
      "Annotations.TextRegion": {
        "title": "images.TextRegion",
        "description": "Models an extracted text region in an image",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "description": "The location of the extracted text",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          }
        },
        "required": ["text", "textRegion"],
        "additionalProperties": false
      },
      "Annotations.cognite__annotation_types__diagrams__AssetLink": {
        "title": "diagrams.AssetLink",
        "description": "Models a link to a CDF Asset referenced in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "assetRef": {
            "description": "The asset this annotation is pointing to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.AssetRef"
              }
            ]
          },
          "symbolRegion": {
            "description": "The location of the symbol representing the asset",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "textRegion": {
            "description": "The location of the text mentioning the asset",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "The symbol representing the asset",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["assetRef", "textRegion"],
        "additionalProperties": false
      },
      "Annotations.FileLink": {
        "title": "diagrams.FileLink",
        "description": "Models a link to a CDF File referenced in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "fileRef": {
            "description": "The file this annotation is pointing to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.FileRef"
              }
            ]
          },
          "symbolRegion": {
            "description": "The location of the symbol representing the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "textRegion": {
            "description": "The location of the text mentioning the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["fileRef", "textRegion"],
        "additionalProperties": false
      },
      "Annotations.UnhandledTextObject": {
        "title": "diagrams.UnhandledTextObject",
        "description": "Models an extracted text region in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "textRegion": {
            "description": "The location of the text",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["textRegion", "text"],
        "additionalProperties": false
      },
      "Annotations.UnhandledSymbolObject": {
        "title": "diagrams.UnhandledSymbolObject",
        "description": "Models an extracted symbol region in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "symbolRegion": {
            "description": "The location of the symbol",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "symbol": {
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["symbolRegion", "symbol"],
        "additionalProperties": false
      },
      "Annotations.PipeSymbol": {
        "title": "diagrams.PipeSymbol",
        "description": "Models a pipe in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "polyline": {
            "description": "The polyline representing the pipe",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.PolyLine"
              }
            ]
          }
        },
        "required": ["polyline"],
        "additionalProperties": false
      },
      "Annotations.ExtractedText": {
        "title": "documents.ExtractedText",
        "description": "Represents text extracted from a document. Annotations of this type are low-level and not specific to any domain.",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "textRegion": {
            "description": "The location of the extracted text",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "extractedText": {
            "description": "The extracted text",
            "maxLength": 1024,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["textRegion", "extractedText"],
        "additionalProperties": false
      },
      "Annotations.Line": {
        "title": "diagrams.Line",
        "description": "Models a line in an engineering diagram",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "polyline": {
            "description": "The polyline representing the line",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.PolyLine"
              }
            ]
          }
        },
        "required": ["label", "polyline"],
        "additionalProperties": false
      },
      "Annotations.Junction": {
        "title": "diagrams.Junction",
        "description": "Models a junction between lines in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "position": {
            "description": "The point representing the junction",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.Point"
              }
            ]
          }
        },
        "required": ["position"],
        "additionalProperties": false
      },
      "Annotations.Detection": {
        "title": "forms.Detection",
        "description": "Represents a detection of a field value in a form.\nA field is identified by a field_name, optionally component_name and component_type if the field belongs to a subcomponent.\nThe bounding_box indicates the position of the detection. The content of the field is given by the value, and optionally\nan unnormalized_value and the unit.",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "boundingBox": {
            "description": "Bounding box of the detection area",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "componentType": {
            "description": "Type of subcomponent that the detection belongs to",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "componentName": {
            "description": "Name of subcomponent that the detection belongs to",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "fieldName": {
            "description": "Name of field that has been detected",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "value": {
            "description": "The value that has been detected",
            "maxLength": 128,
            "type": "string"
          },
          "valueUnnormalized": {
            "description": "The value that has been detected, before normalization. Optional.",
            "maxLength": 128,
            "type": "string"
          },
          "unit": {
            "description": "The unit of the value field. Optional.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": ["boundingBox", "fieldName", "value"],
        "additionalProperties": false
      },
      "RevokeSessionRequestList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RevokeSessionRequest"
            }
          }
        }
      },
      "RevokeSessionRequest": {
        "description": "",
        "type": "object",
        "required": ["id"],
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          }
        }
      },
      "SessionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Session"
            }
          }
        }
      },
      "Session": {
        "type": "object",
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          },
          "type": {
            "type": "string",
            "description": "Values reserved for future use",
            "anyOf": [
              {
                "enum": ["CLIENT_CREDENTIALS", "TOKEN_EXCHANGE"]
              }
            ]
          },
          "status": {
            "description": "Current status of the session",
            "type": "string",
            "enum": [
              "READY",
              "ACTIVE",
              "CANCELLED",
              "EXPIRED",
              "REVOKED",
              "ACCESS_LOST"
            ]
          },
          "creationTime": {
            "description": "Session creation time, in milliseconds since 1970",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "expirationTime": {
            "description": "Session expiry time, in milliseconds since 1970. This value is updated on refreshing a token",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "clientId": {
            "description": "Client ID in identity provider. Returned only if the session was created using client credentials",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "RawTable": {
        "required": ["dbName", "tableName"],
        "type": "object",
        "properties": {
          "dbName": {
            "minLength": 1,
            "type": "string",
            "description": "Database name"
          },
          "tableName": {
            "minLength": 1,
            "type": "string",
            "description": "Table name"
          }
        }
      },
      "Contact": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Contact name",
            "nullable": true
          },
          "email": {
            "maxLength": 254,
            "minLength": 1,
            "type": "string",
            "description": "Contact email",
            "format": "email",
            "nullable": true
          },
          "role": {
            "type": "string",
            "description": "Contact role",
            "nullable": true
          },
          "sendNotification": {
            "type": "boolean",
            "description": "True, if contact receives email notifications",
            "nullable": true
          }
        }
      },
      "CreateExtPipe": {
        "required": ["dataSetId", "externalId", "name"],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": ["true"],
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          },
          "name": {
            "maxLength": 140,
            "minLength": 1,
            "required": ["true"],
            "type": "string",
            "description": "Name of Extraction Pipeline"
          },
          "description": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline",
            "nullable": true
          },
          "dataSetId": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "required": ["true"],
            "type": "integer",
            "description": "DataSet ID",
            "format": "int64"
          },
          "rawTables": {
            "type": "array",
            "description": "Raw tables",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "schedule": {
            "pattern": "^(On trigger|Continuous)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|µs|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: “On trigger”, “Continuous” or cron expression. If empty then null",
            "nullable": true
          },
          "contacts": {
            "type": "array",
            "description": "Contacts list.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "source": {
            "maxLength": 255,
            "type": "string",
            "description": "Source for Extraction Pipeline",
            "nullable": true
          },
          "documentation": {
            "maxLength": 10000,
            "type": "string",
            "description": "Documentation text field",
            "nullable": true
          }
        }
      },
      "ExtPipe": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateExtPipe"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "maximum": 9007199254740991,
                "minimum": 0,
                "type": "integer",
                "description": "A server-generated ID for the object.",
                "format": "int64"
              },
              "lastSuccess": {
                "type": "integer",
                "description": "Time of last successful run. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "lastFailure": {
                "type": "integer",
                "description": "Time of last failure run. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "lastMessage": {
                "type": "string",
                "description": "Last failure message."
              },
              "lastSeen": {
                "type": "integer",
                "description": "Last seen time. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "createdBy": {
                "type": "string",
                "description": "Extraction Pipeline creator. Usually user email is expected here"
              }
            }
          }
        ]
      },
      "ExtPipes": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipe"
            }
          }
        },
        "description": "List of extraction pipelines"
      },
      "DefaultError": {
        "type": "object",
        "properties": {
          "code": {
            "required": ["true"],
            "type": "integer",
            "description": "HTTP status code",
            "format": "int32"
          },
          "message": {
            "required": ["true"],
            "type": "string",
            "description": "Error message"
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object"
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object"
            }
          }
        },
        "description": "Cognite API error"
      },
      "ItemsRequest_CreateExtPipe_": {
        "required": ["items"],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateExtPipe"
            }
          }
        }
      },
      "ItemsRequest_ExtPipeId_": {
        "required": ["items"],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeId"
            }
          }
        }
      },
      "ExtPipeInternalId": {
        "required": ["id"],
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          }
        }
      },
      "ExtPipeExternalId": {
        "required": ["externalId"],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          }
        }
      },
      "ExtPipeId": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ExtPipeInternalId"
          },
          {
            "$ref": "#/components/schemas/ExtPipeExternalId"
          }
        ]
      },
      "ItemsRequest_ExtPipeUpdate_": {
        "required": ["items"],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeUpdate"
            }
          }
        }
      },
      "ExternalIdUpdateField": {
        "required": ["set"],
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          }
        },
        "description": "Set a new value for the externalId. Must be unique for the resource type."
      },
      "NameUpdateField": {
        "required": ["set"],
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 140,
            "minLength": 1,
            "type": "string",
            "description": "Name of Extraction Pipeline"
          }
        },
        "description": "Set a new value for name."
      },
      "DescriptionUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline",
            "nullable": true
          }
        },
        "description": "Set a new value for description."
      },
      "DataSetIdUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "required": ["true"],
            "type": "integer",
            "description": "DataSet ID",
            "format": "int64"
          }
        },
        "description": "Set a new value for dataSetId."
      },
      "ScheduleUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "pattern": "^(On trigger|Continuous)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|µs|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: “On trigger”, “Continuous” or cron expression. If empty then null",
            "nullable": true
          }
        },
        "description": "Set a new value for schedule."
      },
      "RawTablesUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          }
        }
      },
      "RawTablesUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "remove": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          }
        }
      },
      "RawTablesUpdate": {
        "type": "object",
        "description": "Updates the resource's assigned rawTables. RawTables can be added, removed or replaced (set). ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawTablesUpdateSet"
          },
          {
            "$ref": "#/components/schemas/RawTablesUpdateAddRemove"
          }
        ]
      },
      "ContactsUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "New contacts list",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          }
        }
      },
      "ContactsUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "Contacts to add",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "remove": {
            "type": "array",
            "description": "Contacts to remove",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          }
        }
      },
      "ContactsUpdate": {
        "type": "object",
        "description": "Updates the resource's assigned contacts. Contacts can be added, removed or replaced (set). ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContactsUpdateSet"
          },
          {
            "$ref": "#/components/schemas/ContactsUpdateAddRemove"
          }
        ]
      },
      "MapUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "nullable": true,
            "example": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "MapUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "nullable": true,
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "remove": {
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "MapUpdate": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated extraction pipeline: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/MapUpdateSet"
          },
          {
            "$ref": "#/components/schemas/MapUpdateAddRemove"
          }
        ]
      },
      "SourceUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 255,
            "type": "string",
            "description": "Source for Extraction Pipeline",
            "nullable": true
          }
        },
        "description": "Set a new value for source."
      },
      "DocumentationUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 10000,
            "type": "string",
            "description": "Documentation text field",
            "nullable": true
          }
        },
        "description": "Set a new value for documentation."
      },
      "ExtPipeUpdateData": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/ExternalIdUpdateField"
          },
          "name": {
            "$ref": "#/components/schemas/NameUpdateField"
          },
          "description": {
            "$ref": "#/components/schemas/DescriptionUpdateField"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetIdUpdateField"
          },
          "schedule": {
            "$ref": "#/components/schemas/ScheduleUpdateField"
          },
          "rawTables": {
            "$ref": "#/components/schemas/RawTablesUpdate"
          },
          "contacts": {
            "$ref": "#/components/schemas/ContactsUpdate"
          },
          "metadata": {
            "$ref": "#/components/schemas/MapUpdate"
          },
          "source": {
            "$ref": "#/components/schemas/SourceUpdateField"
          },
          "documentation": {
            "$ref": "#/components/schemas/DocumentationUpdateField"
          }
        },
        "description": "List of updates for Extraction Pipeline"
      },
      "ExtPipeUpdateById": {
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          },
          "update": {
            "$ref": "#/components/schemas/ExtPipeUpdateData"
          }
        }
      },
      "ExtPipeUpdateByExternalId": {
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project.",
            "nullable": true
          },
          "update": {
            "$ref": "#/components/schemas/ExtPipeUpdateData"
          }
        }
      },
      "ExtPipeUpdate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ExtPipeUpdateById"
          },
          {
            "$ref": "#/components/schemas/ExtPipeUpdateByExternalId"
          }
        ]
      },
      "ExtendedItemsRequest_ExtPipeId_": {
        "required": ["items"],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeId"
            }
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore IDs and external IDs that are not found",
            "default": false
          }
        }
      },
      "ExtPipesFilterRequest": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/ExtPipesFilter"
          },
          "limit": {
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "description": "Limits the number of results to return.",
            "format": "int32",
            "default": 100
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "ExtPipesFilter": {
        "type": "object"
      },
      "CreateExtPipeRunResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExtPipeRunResponse"
          },
          {
            "type": "object",
            "properties": {
              "externalId": {
                "type": "string",
                "description": "Extraction Pipeline external Id."
              }
            },
            "description": "Create Extraction Pipeline Runs response."
          }
        ]
      },
      "ItemsResponse_CreateExtPipeRunResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateExtPipeRunResponse"
            }
          }
        },
        "description": "Response with a list of elements."
      },
      "ItemsRequest_ExtPipeRunRequest_": {
        "required": ["items"],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunRequest"
            }
          }
        }
      },
      "ExtPipeRunStatus": {
        "type": "string",
        "enum": ["success", "failure", "seen"]
      },
      "ExtPipeRunRequest": {
        "required": ["externalId", "status"],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": ["true"],
            "type": "string",
            "description": "Extraction pipeline external Id provided by client. Should be unique within the project."
          },
          "status": {
            "$ref": "#/components/schemas/ExtPipeRunStatus"
          },
          "message": {
            "maxLength": 1000,
            "type": "string",
            "description": "Error message.",
            "nullable": true
          },
          "createdTime": {
            "type": "integer",
            "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64",
            "nullable": true
          }
        },
        "description": "Status of the extraction pipeline."
      },
      "RunsFilterRequest": {
        "required": ["filter"],
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/RunsFilter"
          },
          "limit": {
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "description": "Limits the number of results to return.",
            "format": "int32",
            "default": 100
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "RunsFilter": {
        "required": ["externalId"],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": ["true"],
            "type": "string",
            "description": "Extraction pipeline external Id provided by client."
          },
          "statuses": {
            "type": "array",
            "description": "Extraction pipeline statuses list. Expected values: success, failure, seen.",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunStatus"
            }
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "message": {
            "$ref": "#/components/schemas/StringFilter"
          }
        }
      },
      "StringFilter": {
        "type": "object",
        "properties": {
          "substring": {
            "type": "string",
            "description": "Substring to find strings, that contains it ignoring case."
          }
        }
      },
      "ExtPipeRunResponse": {
        "required": ["status"],
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 1,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          },
          "status": {
            "minLength": 1,
            "required": ["true"],
            "type": "string",
            "description": "Extraction Pipeline status."
          },
          "message": {
            "type": "string",
            "description": "Error message."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "description": "Extraction Pipeline Run. Contains extraction pipeline status and message for a moment of time"
      },
      "ItemsResponse_ExtPipeRunResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunResponse"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "Response with a list of elements."
      },
      "ProjectConfigurationProperties": {
        "type": "object",
        "properties": {
          "isOidcEnabled": {
            "type": "boolean",
            "description": "Whether oidc is enabled"
          },
          "isLegacyLoginFlowAndApiKeysEnabled": {
            "type": "boolean",
            "description": "Whether legacy authentication flows are enabled"
          }
        }
      }
    },
    "parameters": {
      "callId": {
        "schema": {
          "type": "integer"
        },
        "name": "callId",
        "in": "path",
        "required": true,
        "description": "The function call id."
      },
      "functionId": {
        "schema": {
          "type": "integer"
        },
        "name": "functionId",
        "in": "path",
        "required": true,
        "description": "The function id."
      },
      "scheduleId": {
        "schema": {
          "type": "integer"
        },
        "name": "scheduleId",
        "in": "path",
        "required": true,
        "description": "The function schedule id."
      },
      "LimitQuery": {
        "name": "limit",
        "description": "Limits the number of results to be returned.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1
        }
      },
      "Limit": {
        "name": "limit",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 1000
        }
      },
      "Cursor": {
        "name": "cursor",
        "in": "query",
        "schema": {
          "type": "string",
          "example": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo"
        }
      },
      "ModelId": {
        "name": "modelId",
        "in": "path",
        "description": "Model ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "RevisionId": {
        "name": "revisionId",
        "in": "path",
        "description": "Revision ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "project": {
        "in": "path",
        "name": "project",
        "required": true,
        "description": "The project name.",
        "schema": {
          "type": "string",
          "example": "publicdata"
        }
      },
      "partition": {
        "in": "query",
        "name": "partition",
        "required": false,
        "description": "Splits the data set into N partitions.\nYou need to follow the cursors within each partition in order to receive all the data.\nExample: 1/10\n",
        "schema": {
          "type": "string",
          "example": "1/10"
        }
      },
      "CogniteInternalId": {
        "in": "path",
        "name": "id",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "IncludeMetadata": {
        "name": "includeMetadata",
        "in": "query",
        "description": "Whether the metadata field should be returned, or not.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "Offset": {
        "name": "offset",
        "description": "Offset from the first result. Sum of limit and offset must not exceed 1000.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 0,
          "minimum": 0,
          "maximum": 1000
        }
      },
      "jobId": {
        "in": "path",
        "name": "jobId",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/JobId"
        }
      },
      "feedbackStatus": {
        "name": "status",
        "in": "query",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/FeedbackStatus"
        }
      },
      "AnnotationId": {
        "name": "annotationId",
        "in": "path",
        "required": true,
        "description": "The internal ID of the annotation",
        "schema": {
          "$ref": "#/components/schemas/AnnotationId"
        }
      },
      "seismicId": {
        "in": "path",
        "name": "seismic_id",
        "required": true,
        "description": "The identifier of a seismic",
        "schema": {
          "type": "integer"
        }
      }
    },
    "responses": {
      "FunctionScheduleDataResponse": {
        "description": "Input data to the associated function.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["id", "data"],
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                },
                "data": {
                  "$ref": "#/components/schemas/data"
                }
              }
            }
          }
        }
      },
      "FunctionErrorResponse": {
        "description": "The response for a failed request.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["error"],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/FunctionErrorBasic"
                }
              }
            }
          }
        }
      },
      "FunctionCallResponse": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["response", "functionId", "callId"],
              "description": "The function response.",
              "properties": {
                "response": {
                  "type": "object"
                },
                "functionId": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                },
                "callId": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            "examples": {
              "Function response example": {
                "value": {
                  "response": {
                    "numAssets": 1234,
                    "someCalculation": 3.14
                  }
                }
              }
            }
          }
        }
      },
      "FunctionScheduleCreated": {
        "description": "Created",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionSchedule"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionScheduleList": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionSchedule"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionCalled": {
        "description": "Created",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          }
        }
      },
      "FunctionCallLog": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionCallLogEntry"
                  }
                }
              }
            },
            "examples": {
              "Example response": {
                "value": {
                  "items": [
                    {
                      "timestamp": 1585350274000,
                      "message": "Did do fancy thing"
                    },
                    {
                      "timestamp": 1585350276000,
                      "message": "Did do another fancy thing"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "FunctionCallList": {
        "description": "List of function calls.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCalls"
            }
          }
        }
      },
      "FunctionCallListWithCursor": {
        "description": "Paged response with list of function calls.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCallsWithCursor"
            }
          }
        }
      },
      "FunctionList": {
        "description": "List of functions.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Function"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionsLimits": {
        "description": "Limits",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "timeoutMinutes",
                "cpuCores",
                "memoryGb",
                "runtimes",
                "responseSizeMb"
              ],
              "properties": {
                "timeoutMinutes": {
                  "type": "integer",
                  "description": "Timeout of each function call.",
                  "example": 15
                },
                "cpuCores": {
                  "type": "object",
                  "$ref": "#/components/schemas/CPURange"
                },
                "memoryGb": {
                  "type": "object",
                  "$ref": "#/components/schemas/MemoryRange"
                },
                "runtimes": {
                  "type": "array",
                  "description": "Available runtimes. Runtime \"py3x\" translates to the latest version of the Python 3.x.y series.",
                  "items": {
                    "type": "string",
                    "example": ["py37", "py38", "py39"]
                  }
                },
                "responseSizeMb": {
                  "type": "integer",
                  "description": "Maximum response size of function calls.",
                  "example": 1
                }
              }
            }
          }
        }
      },
      "FunctionsActivation": {
        "description": "Functions activation status",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["project", "requested", "activated"],
              "properties": {
                "project": {
                  "type": "string",
                  "description": "The project subject to the activation status."
                },
                "requested": {
                  "type": "boolean",
                  "description": "Signifies whether or not Cognite Functions has been requested."
                },
                "activated": {
                  "type": "boolean",
                  "description": "Signifies whether or not Cognite Functions has been activated."
                }
              }
            }
          }
        }
      },
      "CountResponse": {
        "description": "Number of items",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Some required fields are missing.",
              "required": ["count"],
              "properties": {
                "count": {
                  "type": "integer",
                  "description": "Number of items",
                  "format": "int64",
                  "example": 100000
                }
              }
            }
          }
        }
      },
      "AggregateResponse": {
        "description": "Response with list of aggregation results.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AggregateResult"
            }
          }
        }
      },
      "MissingField": {
        "description": "Missing required fields.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Some required fields are missing.",
              "required": ["code", "message", "missingFields"],
              "properties": {
                "code": {
                  "type": "integer",
                  "description": "HTTP status code.",
                  "format": "int32",
                  "example": 400
                },
                "message": {
                  "type": "string",
                  "description": "Error message."
                },
                "missingFields": {
                  "uniqueItems": true,
                  "type": "array",
                  "description": "Fields that are missing.",
                  "items": {
                    "type": "object",
                    "description": "Fields that are missing."
                  }
                }
              }
            }
          }
        }
      },
      "EmptyResponse": {
        "description": "Empty response.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "ErrorResponse": {
        "description": "The response for a failed request.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["error"],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "AuthErrorResponse": {
        "description": "Authorization error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["error"],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "UnprocessableEntityErrorResponse": {
        "description": "Processing error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["error"],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "BadRequestErrorResponse": {
        "description": "Bad request error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["error"],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "IllegalAcceptHeaderErrorResponse": {
        "description": "Illegal \"Accept\" header",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["error"],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "DocumentsClassifiersResponse": {
        "description": "The response for a successful classifier create/list/update operation.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentsClassifierItems"
            }
          }
        }
      },
      "DocumentsTemporaryPreviewLinkResponse": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "description": "A temporary link to download a preview of the document.",
              "type": "object",
              "properties": {
                "temporaryLink": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "DocumentsPipelinesResponse": {
        "description": "The response for a successful pipline create/get/update operation.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentsPipelineItems"
            }
          }
        }
      },
      "DocumentFeedbackCreateResponse": {
        "description": "The response for a successful feedback 'create' operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "documentId",
                      "label",
                      "action",
                      "feedbackId",
                      "createdAt",
                      "status"
                    ],
                    "properties": {
                      "documentId": {
                        "$ref": "#/components/schemas/DocumentId"
                      },
                      "label": {
                        "$ref": "#/components/schemas/FeedbackLabel"
                      },
                      "action": {
                        "$ref": "#/components/schemas/FeedbackAction"
                      },
                      "feedbackId": {
                        "$ref": "#/components/schemas/FeedbackId"
                      },
                      "reporterInfo": {
                        "$ref": "#/components/schemas/ReporterInfo"
                      },
                      "createdAt": {
                        "description": "When this feedback object was created by the end-user.\n\nA UTC-based [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp string.",
                        "type": "string",
                        "example": "2021-02-04T16:24:23.284407"
                      },
                      "status": {
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/FeedbackStatus"
                          },
                          {
                            "example": "CREATED"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "DocumentFeedbackListResponse": {
        "description": "The response for a successful feedback list operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of feedback objects",
                  "items": {
                    "$ref": "#/components/schemas/DocumentFeedback"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentFeedbackAggregateResponse": {
        "description": "The response for a successful aggregated list operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["field", "groups", "total"],
              "properties": {
                "field": {
                  "$ref": "#/components/schemas/AggregateField"
                },
                "groups": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AggregateGroup"
                  }
                },
                "total": {
                  "type": "integer",
                  "description": "The sum of all groups"
                }
              }
            },
            "example": {
              "field": "action",
              "groups": [
                {
                  "value": "ATTACH",
                  "count": 3
                },
                {
                  "value": "DETACH",
                  "count": 2
                }
              ],
              "total": 5
            }
          }
        }
      },
      "DocumentsFilterResponse": {
        "description": "The results of a list.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Document"
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available)."
                }
              }
            }
          }
        }
      },
      "DocumentContentResponse": {
        "description": "Textual content for the requested documents.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentContent"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentsSearchResponse": {
        "description": "The results of a search.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["item"],
                    "properties": {
                      "highlight": {
                        "$ref": "#/components/schemas/Highlight"
                      },
                      "item": {
                        "$ref": "#/components/schemas/Document"
                      }
                    }
                  }
                },
                "aggregates": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": ["name", "groups", "total"],
                    "properties": {
                      "name": {
                        "type": "string",
                        "description": "User defined name for this aggregate"
                      },
                      "groups": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "group": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "oneOf": [
                                  {
                                    "type": "object"
                                  },
                                  {
                                    "$ref": "#/components/schemas/LabelDefinitionExternalId"
                                  }
                                ]
                              }
                            },
                            "value": {
                              "type": "integer",
                              "format": "int32"
                            }
                          }
                        }
                      },
                      "total": {
                        "type": "integer",
                        "format": "int32",
                        "description": "Total number of results for this aggregate"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2CreateResponseSchema": {
        "description": "Successful creation",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ListResponseSchema": {
        "description": "Successful retrieval",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ResponseSchema": {
        "description": "Successful retrieval",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2CursoredListResponseSchema": {
        "description": "Successful retrieval",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2CursoredListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2UpdateResponseSchema": {
        "description": "Successful update",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ListResponseSchema"
            }
          }
        }
      },
      "DownloadSeismicResponse": {
        "description": "The generated SEG-Y file",
        "content": {
          "application/octet-stream": {}
        }
      }
    },
    "requestBodies": {
      "AnnotationsV2SuggestRequestSchema": {
        "description": "A request for suggesting annotations, i.e., creating them with the \"suggested\" `status`",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "A list of annotations to suggest",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2SuggestSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2CreateRequestSchema": {
        "description": "A request for creating annotations",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "A list of annotations to create",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2CreateSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2ByIdsRequestSchema": {
        "description": "A request referencing existing annotations",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "A list of existing annotation references",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2ReferenceSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2ListRequestSchema": {
        "description": "A request specifying the annotation listing behavior",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["filter"],
              "properties": {
                "cursor": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Cursor"
                    }
                  ],
                  "nullable": true
                },
                "limit": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 25,
                  "maximum": 1000
                },
                "filter": {
                  "$ref": "#/components/schemas/AnnotationsV2FilterSchema"
                }
              }
            }
          }
        }
      },
      "AnnotationsV2UpdateRequestSchema": {
        "description": "A request for updating existing annotations",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": ["items"],
              "properties": {
                "items": {
                  "type": "array",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2UpdateItemSchema"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "security": [
    {
      "api-key": []
    },
    {
      "token": []
    },
    {
      "oidc-token": []
    }
  ],
  "x-tagGroups": [
    {
      "name": "Core Resources",
      "tags": [
        "Assets",
        "Events",
        "Files",
        "3D",
        "3D V2",
        "Types",
        "Labels",
        "Relationships",
        "Sequences",
        "Synthetic Time Series",
        "Data sets",
        "Seismic"
      ]
    },
    {
      "name": "Identity and Access Management",
      "tags": ["Sessions", "Projects"]
    },
    {
      "name": "Contextualization",
      "tags": [
        "Contextualization",
        "Entity matching",
        "Engineering diagrams",
        "P&IDs and files",
        "Template completion"
      ]
    },
    {
      "name": "Vision",
      "tags": ["Vision", "Vision AutoML"]
    },
    {
      "name": "Digital Twin",
      "tags": ["Digital Twin"]
    },
    {
      "name": "Data organization",
      "tags": ["Annotations"]
    },
    {
      "name": "Documents",
      "tags": [
        "Documents",
        "Document pipelines",
        "Document preview",
        "Document feedback"
      ]
    },
    {
      "name": "Extraction Pipelines",
      "tags": ["Extraction Pipelines", "Extraction Pipelines Runs"]
    },
    {
      "name": "Functions",
      "tags": ["Functions", "Function calls", "Function schedules"]
    }
  ],
  "tags": [
    {
      "name": "Functions",
      "description": "Functions enables Python code to be hosted and executed in the cloud, on demand or by using a schedule. The Python runtime version is 3.8.3. Execution, status and logs are available through the API. A function is uploaded to the Files API as a zip file with at least a Python file called `handler.py` (unless specified otherwise through the `functionPath`-argument) that must contain a function named `handle` with any of the following arguments: `data`, `client`, `secrets`, or 'function_call_info', which are passed into the function. \nThe latest version of Cognite SDK's are available, and additional python packages and version specifications can be defined in a `requirements.txt` in the root of the zip."
    },
    {
      "name": "Function calls",
      "description": "Function calls let you execute functions asynchronously with a timeout of 15 minutes."
    },
    {
      "name": "Function schedules",
      "description": "Function schedules allow you to run functions with a specific input at intervals defined by a cron expression. These function calls will be asynchronous and show up in the function call list. Visit http://www.cronmaker.com to generate a cron expression with a UI."
    },
    {
      "name": "3D",
      "description": "We organize 3D data into models and revisions. A model is just a placeholder for a set of revisions. Revisions contains the actual 3D data. For example you can have a model named Compressor and you can upload a revision under that model. When you create a revision you need to attach a 3D file. For every new version of the 3D model you upload a new revision under the placeholder model. You can then easily track the history of a model by browsing the different revisions.\n\nWhen you upload a new revision Cognite need to process the 3D data to optimize it for rendering. This can take some time and we therefore give you a status string back in the revision object. You can then follow the process while you wait.\n\nA 3D model is typically built up by a hierarchical structure. This looks very similar to how we organize our internal asset hierarchy. We support endpoints to extract the 3D node hierarchy and endpoints to make mappings from the 3D nodes to nodes in Cognite's asset hierarchy. We assign a random ID, nodeId, to each node in the 3D hierarchy. This is the ID representing the object in the viewer. When a user click on a object in the viewer it returns the ID for the object that was clicked. You can then use that ID to look up which node in the hierarchy the user clicked on.\n\nWe also deliver a [web based 3D viewer](https://www.npmjs.com/package/@cognite/3d-viewer) to embed the 3D model in your own web page."
    },
    {
      "name": "3D V2"
    },
    {
      "name": "Digital Twin",
      "description": ""
    },
    {
      "name": "Contextualization",
      "description": "The contextualization endpoints lets you match, enrich and compare data in CDF.  For example, you can match time series to assets (or other resource types) using entity matching or create interactive engineering diagrams."
    },
    {
      "name": "Entity matching",
      "description": "The entity matching contextualization endpoints lets you match CDF resources. Note: The majority of the entity matching API has moved to our stable API, please see https://docs.cognite.com/api/v1/#tag/Entity-matching"
    },
    {
      "name": "Engineering diagrams",
      "description": "The engineering diagram contextualization endpoints let you find CDF resources from engineering diagrams and create SVGs of the diagrams. The POST endpoints start jobs and the associated GET endpoints to retrieve the job statuses and the results."
    },
    {
      "name": "Vision",
      "description": "The Vision contextualization endpoints enable extraction of information from imagery data based on their visual content. For example, you can detect external ID or name of assets, detect and read value of gauges or identify common industrial objects in images. \n\nVision contextualization endpoints have support for batch processing which enables processing of multiple files via an asynchronous prediction request. A new contextualization job is triggered by sending a POST request to one of the Vision endpoints. The response of the POST request contains a job ID, which can then be used to make subsequent calls to check the status and retrieve the results of the job once it is completed. "
    },
    {
      "name": "Vision AutoML",
      "description": "**Note: The Vision AutoML service is currently in closed-alpha. You can request access to this service via [Vision Early Adopter Program](https://hub.cognite.com/groups/vision-early-adopter-205) at [Cognite Hub](https://hub.cognite.com/).**\n\nThe Vision Automated Machine Learning (AutoML) service enables you to train and deploy specialized computer vision models (in you CDF project) tailored for a particular use case. You can train classification models (what is contained in an image) or object detection models (what is contained in an image and where is it in the image) by providing a set of annotated images stored in Cognite Data Fusion. Images can be annotated using the UI at [https://fusion.cognite.com](https://fusion.cognite.com) (for more details and guides visit [Vision Early Adopter Program](https://hub.cognite.com/groups/vision-early-adopter-205)). \n\nOnce the training is completed, the model will be deployed in your project and made available for you to analyze new data (read more [here](#operation/visionAutoMLPredict)). Alternatively, you can download the model as e.g. a Tensorflow Lite file (`.tflite`) for offline usage (read more [here](#operation/visionAutoMLDownload))."
    },
    {
      "name": "Documents",
      "description": "Note! We are in the process of deprecating playground support. Endpoints marked deprecated are superseded by endpoints found in v1.\n\nA document is a file that has been indexed by a document processing pipeline.\nThese pipelines are able to extract content from a variety of document types,\nand perform classification, contextualization and other operations on the file.\nThe result is a document.\n\nThe document structure consists of a selection of derived fields, such as the\ntitle, author and language of the document, plus some of the original fields\nfrom the raw file. The fields from the raw file can be found in the\n`sourceFile` structure.\n\n### File type support\nDocuments can be created from the following types of files:\n- PDF files\n- Plain text files\n- Spreadsheets, documents, and presentations from the Microsoft, Open Office and macOS office suites\n- Images"
    },
    {
      "name": "Document pipelines",
      "description": "The document processing pipelines ensure that all files uploaded to CDF are\nparsed and processed automatically.\n\nNote that it is currently only possible to define a single pipeline per project. Support for multiple pipelines may be added in the future.\nIf no pipelines have been created, files will be indexed with the default configuration settings.\nThe default settings are listed for each configuration category below.\n\nCurrently, the pipeline configuration objects lets you configure the settings for the sensitivity matcher, and specify training data for the classifier.\nMore configuration categories will be added in the future.\n\n### The sensitivity matcher\nThe sensitivity matcher lets you provide one or more matchlists and specify fields to match.\nCDF also provides default matchlists which you can use.\nIf a match is found in any of the configured fields, the document can be marked as sensitive.\nFor instance, if you want to match the terms \"top secret\", \"classified\" and \"sensitive\" in\nthe documents, you first create a matchlist containing these terms:\n\n```\n  \"matchLists\": {\n    \"my-terms\": [\n      \"top secret\",\n      \"classified\",\n      \"sensitive\"\n    ]\n  }\n```\n\nNow that we have a matchlist containing our terms, we need to specify which fields to search for the terms in.\nFor instance, if we want to search in the title and in the content of the documents, we can do:\n\n```\n  \"fieldMappings\": {\n    \"title\": [\"my-terms\"],\n    \"sourceFile\": {\n      \"content\": [\"my-terms\"]\n    }\n  }\n```\n\n### Classifiers\nThe classifier field lets you provide a list of labels to be used to train the document classifier.\nThe labels must have been created using the Labels API in order for this operation to succeed.\n\n```\n  \"classifier\": {\n    \"name\": \"Document Type\"\n    \"trainingLabels\": [{\"externalId\": \"label1\"}, {\"externalId\": \"label2\"}]\n  }\n```\n\n### Defaults\nIf no sensitivity matcher configuration is provided, the sensitivity matcher will be disabled,\nand no documents will be automatically marked as sensitive.\n\nIf no classifier is provided, no classifier will be trained for this pipeline."
    },
    {
      "name": "Document preview",
      "x-displayName": "Preview",
      "description": "The preview service is a utility API that can convert most document types into PDF or PNG. This can\nbe very helpful if you want to display a preview of a file in a frontend, or for other tasks that\nrequire conversion of documents into one of these formats.\n\nFor conversion into PDF, the whole document is converted. For PNG, one file is created per page."
    },
    {
      "name": "Document feedback",
      "x-displayName": "Feedback",
      "description": "The document feedback mechanism lets you continuously improve the correctness of the document labels."
    },
    {
      "name": "Annotations",
      "description": "Annotations reflect contextual information in base CDF resource types, such as Files and Time series, that are not\npresent on the object itself. The benefits of the annotations concept are threefold:\n\n- The annotations concept is a good fit for enriching the base resources themselves, so that the overall data\n  quality is higher in a given project.\n- It is also a good fit for building reference datasets for data problems uniformly across customer projects.\n  Product teams can then use those reference datasets to train machine learning models or validate the\n  performance of their algorithms on actual customer data.\n- Given a uniform way of labelling similar concepts across projects, it becomes easy for apps to agree on a consistent\n  visual representation of those concepts."
    },
    {
      "name": "Sessions",
      "description": "Sessions are used to maintain access to CDF resources for an extended period of time beyond the initial access granted to an internal service. The methods available to extend a sessions lifetime are client credentials and token exchange."
    },
    {
      "name": "Extraction Pipelines",
      "description": "Extraction Pipeline objects represent the applications and software that are deployed to ingest operational data into CDF.  An extraction pipeline can consist of a number of different software components between the source system and CDF. The extraction pipeline object represents the software component that actually sends the data to CDF. Two examples are Cognite extractors and third party ETL tools such as Microsoft Azure or Informatica PowerCenter"
    },
    {
      "name": "Extraction Pipelines Runs",
      "description": "Extraction Pipelines Runs are CDF objects to store statuses related to an extraction pipeline. The supported statuses are: success, failure and seen. The statuses are related to two different types of operation of the extraction pipeline. Success and failure indicate the status for a particular EP run where the EP attempts to send data to CDF. If the data is successfully posted to CDF the status of the run is ‘success’; if the run has been unsuccessful and the data is not posted to CDF, the status of the run is ‘failure’. Message can be stored to explain run status. Seen is a heartbeat status that indicates that the extraction pipeline is alive. This message is sent periodically on a schedule and indicates that the extraction pipeline is working even though data may not have been sent to CDF by the extraction pipeline."
    },
    {
      "name": "Projects",
      "description": "Projects are used to isolate data in CDF from each other. All objects in CDF belong to a single project, and objects in different projects are isolated from each other.\n"
    },
    {
      "name": "Seismic",
      "description": "Seismic is a no-copy view into seismic stores. Once it has been defined, either via a polygon to \"cut out\" from the origin seismic store or via an explicit trace-by-trace mapping, you cannot modify it. Seismics can be assigned to partitions, and you can restrict user access to particular partitions. Thus, they serve as the most granular unit of access control. Each seismic has one corresponding partition, and if a user is restricted to a particular partition, they will only be able to view the seismics that have been assigned to the partition."
    }
  ]
}
