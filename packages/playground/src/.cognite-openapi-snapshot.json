{
  "openapi": "3.0.1",
  "info": {
    "title": "Cognite playground APIs",
    "description": "# Introduction\nThis is a collection of APIs that are highly experimental and is meant as a way to communicate a few things we're experimenting with.\nPlease use these APIs with care, as we issue no guarantees these APIs won't break. Have fun!\n\n# Postman\nYou can download our postman collection [here](https://storage.googleapis.com/cognite-postman-collections/playground.json).\nOpen Postman, click `Import -> Import From Link`, insert the link and import.\n\nYou can read more about how to use Postman [here](https://docs.cognite.com/dev/guides/postman/)\n\n# Pagination\nMost resource types can be paginated, indicated by the field `nextCursor` in the response.\nBy passing the value of `nextCursor` as the cursor you will get the next page of `limit` results.\nNote that all parameters except `cursor` has to stay the same.\n\n# Parallel retrieval\nIf you want to download a lot of resources (let's say events), paginating through millions of records can be slow.\nWe support parallel retrieval through the `partition` parameter, which has the format `m/n` where `n` is the amount of partitions you would like to split the entire data set into.\nIf you want to download the entire data set by splitting it into 10 partitions, you would do the following in parallel with `m` running from 1 to 10:\n  - Make a request to `/events` with `partition=m/10`.\n  - Paginate through the response by following the cursor as explained above. Note that the `partition` parameter needs to be passed to all subqueries.\n",
    "version": "playground"
  },
  "servers": [
    {
      "url": "https://api.cognitedata.com"
    }
  ],
  "paths": {
    "/api/playground/projects/{project}/functions": {
      "get": {
        "deprecated": true,
        "tags": [
          "Functions"
        ],
        "summary": "List functions",
        "operationId": "getFunctions",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/LimitQuery"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "List functions.",
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "functions = client.functions.list(limit=5)"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "summary": "Create functions",
        "operationId": "postFunctions",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "You can only create one function per request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "description": "Array of functions to create.",
                    "maxItems": 1,
                    "minItems": 1,
                    "items": {
                      "$ref": "#/components/schemas/Function"
                    }
                  }
                },
                "required": [
                  "items"
                ]
              },
              "examples": {
                "Minimal function": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343
                      }
                    ]
                  }
                },
                "With API key": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343,
                        "apiKey": "ABCMYKEY"
                      }
                    ]
                  }
                },
                "With secrets": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343,
                        "secrets": {
                          "key1": "secret1",
                          "key2": "secret2"
                        }
                      }
                    ]
                  }
                },
                "Full example": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "description": "This function does some things",
                        "owner": "user@cognite.com",
                        "fileId": 5467347282343,
                        "externalId": "my-function",
                        "metadata": {
                          "key1": "value1",
                          "key2": "value2"
                        },
                        "secrets": {
                          "key1": "secret1",
                          "key2": "secret2"
                        },
                        "functionPath": "myfunction/handler.py",
                        "envVars": {
                          "ENV_VAR": "value"
                        },
                        "cpu": 0.2,
                        "memory": 0.4,
                        "runtime": "py38",
                        "indexUrl": "https://pypi.org",
                        "extraIndexUrls": [
                          "https://user:password@some.index.org"
                        ]
                      }
                    ]
                  }
                }
              }
            }
          },
          "description": ""
        },
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Create function from folder\nfunction = client.functions.create(name=\"my-function\", folder=\"/path/to/code\")\n\n# Create function with function_handle\n def handle():\n    print(\"Hello World\")\n    return True\n\nfunction = client.functions.create(name=\"my-function\", function_handle=handle)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/limits": {
      "get": {
        "deprecated": true,
        "tags": [
          "Functions"
        ],
        "summary": "Functions limits",
        "description": "Service limits for the associated project.",
        "operationId": "functionsLimits",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionsLimits"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "limits = client.functions.limits()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/list": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Filter functions",
        "operationId": "listFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find functions.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionListScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "status": "Queued",
                      "createdTime": {
                        "min": 10,
                        "max": 199
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Functions"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "functions = client.functions.list(limit=5, status=\"Ready\")"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/delete": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Delete functions",
        "operationId": "deleteFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Delete functions. You can delete a maximum of 10 functions per request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionDeleteRequest"
              }
            }
          }
        },
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.functions.delete(id=[1,2,3], external_id=\"function3\")"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/call": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "deprecated": true,
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "summary": "Call a function asynchronously",
        "operationId": "postFunctionsCall",
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionCalled"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Perform a function call. To provide input data to the function, add the data in an object called `data` in the request body. It will be available as the `data` argument into the function. Info about the function call at runtime can be obtained through the `function_call_info` argument if added in the function handle. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionCallRequest"
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Call a function by id:\ncall = client.functions.call(id=1)\n\n# Call a function directly on the Function object:\nfunction = client.functions.retrieve(id=1)\ncall = function.call()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/calls": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        },
        {
          "$ref": "#/components/parameters/LimitQuery"
        },
        {
          "$ref": "#/components/parameters/Cursor"
        }
      ],
      "get": {
        "deprecated": true,
        "summary": "List function calls",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallListWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionCalls",
        "description": "List function calls.",
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# List function calls by function id:\ncalls = client.functions.calls.list(function_id=1)\n\n# List function calls directly on a function object\nfunction = client.functions.retrieve(id=1)\ncalls = function.list_calls()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/calls/byids": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Retrieve calls",
        "requestBody": {
          "description": "List of IDs of calls to retrieve. Must be up to a maximum of 10000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FunctionCallIds"
                  },
                  {
                    "$ref": "#/components/schemas/IgnoreUnknownIdsField"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "byIdsFunctionCalls",
        "description": "Retrieve function calls by call ids.",
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Retrieve single function call by id:\ncall = client.functions.calls.retrieve(call_id=2, function_id=1)\n\n# Retrieve function call directly on a function object:\nfunction = client.functions.retrieve(id=1)\ncall = function.retrieve_call(id=2)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/calls/{callId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "deprecated": true,
        "operationId": "getFunctionCall",
        "description": "Retrieve function calls.",
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve a function call by its id",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionCall"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Retrieve single function call by id:\ncall = client.functions.calls.retrieve(call_id=2, function_id=1)\n\n# Retrieve function call directly on a function object:\nfunction = client.functions.retrieve(id=1)\ncall = function.retrieve_call(id=2)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/calls/{callId}/logs": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "deprecated": true,
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve logs for function call",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallLog"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionCallLogs",
        "description": "Get logs from a function call.",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Retrieve function call logs by call id:\nlogs = client.functions.calls.get_logs(call_id=2, function_id=1)\n\n# Retrieve function call logs directly on a call object:\ncall = client.functions.calls.retrieve(call_id=2, function_id=1)\nlogs = call.get_logs()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "deprecated": true,
        "operationId": "getFunction",
        "description": "Retrieve a function by its id. If you want to retrieve functions by names, use Retrieve functions instead.",
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve a function by its id",
        "tags": [
          "Functions"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Function"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "function = client.functions.retrieve(id=1)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/byids": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "description": "Retrieve functions by ids.",
        "summary": "Retrieve functions",
        "operationId": "byIdsFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionIdEitherList"
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "functions = client.functions.retrieve_multiple(ids=[1, 2, 3])"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/status": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Activate Functions",
        "responses": {
          "202": {
            "$ref": "#/components/responses/FunctionsActivation"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "postFunctionsStatus",
        "description": "Activate Cognite Functions. This will create the necessary backend infrastructure for Cognite Functions.",
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ]
      },
      "get": {
        "deprecated": true,
        "summary": "Get activation status",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionsActivation"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionsStatus",
        "description": "Get activation status",
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/functions/schedules": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "get": {
        "deprecated": true,
        "parameters": [
          {
            "$ref": "#/components/parameters/LimitQuery"
          }
        ],
        "operationId": "getFunctionSchedules",
        "description": "List function schedules in project.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "List schedules",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# List funtion schedules:\nschedules = client.functions.schedules.list()\n\n# List schedules directly on a function object to get only schedules associated with this particular function:\nfunction = client.functions.retrieve(id=1)\nschedules = function.list_schedules()"
          }
        ]
      },
      "post": {
        "deprecated": true,
        "description": "Create function schedules. Function schedules trigger asynchronous calls with specific input data, based on a cron expression that determines when these triggers should be fired. Use e.g. http://www.cronmaker.com to be guided on how to generate a cron expression. One of `FunctionId` or `FunctionExternalId` (deprecated) must be set (but not both). When creating a schedule with a session, i.e. with a `nonce`, `FunctionId` must be used. The `nonce` will be used to bind the session before function execution, and the session will be kept alive for the lifetime of the schedule. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "summary": "Create schedules",
        "operationId": "postFunctionSchedules",
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionScheduleCreated"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/FunctionSchedule"
                    }
                  }
                }
              }
            }
          },
          "description": ""
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "schedule = client.functions.create(name=\"My Schedule\", function_id=1, cron_expression=\"0 0 * * *\", client_credentials={\"client_id\": \"...\", \"client_secret\": \"...\", description=\"Some description.\")"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/schedules/list": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Filter function schedules",
        "operationId": "listFunctionSchedules",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find function schedules.  At most one of `FunctionId` or `FunctionExternalId` can be specified.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionScheduleScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "name": "MySchedule",
                      "cronExpression": "5 4 * * *"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Function schedules"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# List funtion schedules:\nschedules = client.functions.schedules.list()\n\n# List schedules directly on a function object to get only schedules associated with this particular function:\nfunction = client.functions.retrieve(id=1)\nschedules = function.list_schedules()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/schedules/{scheduleId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/scheduleId"
        }
      ],
      "get": {
        "deprecated": true,
        "operationId": "getFunctionSchedule",
        "description": "Retrieve a function schedule by its id.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve a function schedule by its id",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionSchedule"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Get function schedule by id:\nschedule = client.functions.schedules.retrieve(id=1)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/schedules/byids": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Retrieve schedules",
        "requestBody": {
          "description": "List of IDs of schedules to retrieve. Must be up to a maximum of 10000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FunctionScheduleIds"
                  },
                  {
                    "$ref": "#/components/schemas/IgnoreUnknownIdsField"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "byIdsFunctionSchedules",
        "description": "Retrieve function schedules by schedule ids.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Get function schedule by id:\nschedule = client.functions.schedules.retrieve(id=1)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/schedules/delete": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "deprecated": true,
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "summary": "Delete schedules",
        "operationId": "deleteFunctionSchedules",
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Delete function schedules. You can delete a maximum of 100 function schedules per request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionScheduleIdArray"
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.functions.schedules.delete(id=1)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/schedules/{scheduleId}/input_data": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/scheduleId"
        }
      ],
      "get": {
        "deprecated": true,
        "operationId": "getFunctionScheduleInputData",
        "description": "Retrieve the input data to the associated function.",
        "summary": "Retrieve function input data",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "data = client.functions.schedules.get_input_data(id=1)"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/calls/{callId}/response": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "deprecated": true,
        "summary": "Retrieve response for function call",
        "tags": [
          "Function calls"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionCallResponse",
        "parameters": [],
        "description": "Retrieve response from a function call.",
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Retrieve function call response by call id:\nresponse = client.functions.calls.get_response(call_id=2, function_id=1)\n\n# Retrieve function call response directly on a call object:\ncall = client.functions.calls.retrieve(call_id=2, function_id=1)\nresponse = call.get_response()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/functions/{functionId}/calls/list": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "deprecated": true,
        "summary": "Filter function calls",
        "operationId": "listFunctionCalls",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallListWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find function calls.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionCallListScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "status": "Running",
                      "scheduleId": 123,
                      "startTime": {
                        "min": 1234,
                        "max": 5678
                      }
                    },
                    "limit": 10
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Function calls"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# List function calls by function id:\ncalls = client.functions.calls.list(function_id=1)\n\n# List function calls directly on a function object\nfunction = client.functions.retrieve(id=1)\ncalls = function.list_calls()"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/3d/experimental/revisions/byids": {
      "post": {
        "tags": [
          "3D"
        ],
        "summary": "Retrieve revisions by id",
        "description": "Returns revision information for a list of revision IDs.",
        "requestBody": {
          "description": "Identifiers for the revisions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExperimentalRevisionIdList"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of revisions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentalRevisionList"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/3d/experimental/revisions": {
      "post": {
        "tags": [
          "3D"
        ],
        "summary": "Create revisions",
        "description": "Creates revisions, with the possibility of generating walkable path data",
        "requestBody": {
          "description": "Describers for the revisions",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExperimentalCreateRevisionList"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of revisions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentalRevisionList"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/3d/pathfinder/transit": {
      "post": {
        "tags": [
          "3D"
        ],
        "summary": "Find transit path",
        "description": "Find a path from one place to another",
        "requestBody": {
          "description": "Transit query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PathTransitQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The identified paths",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PathResultList"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/3d/pathfinder/roundtrip": {
      "post": {
        "tags": [
          "3D"
        ],
        "summary": "Find roundtrip path",
        "description": "Try to find an efficient path starting and ending at a base, and visiting all the target positions.",
        "requestBody": {
          "description": "Roundtrip query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PathRoundtripRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The identified path",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PathResult"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/3d/raycast": {
      "post": {
        "tags": [
          "3D"
        ],
        "summary": "Ray cast",
        "description": "Find the ray–point intersection.",
        "requestBody": {
          "description": "Raycast query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RaycastRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The ray–surface intersection",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RayCastResultList"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/3d/pointcloud/cropbox": {
      "post": {
        "tags": [
          "3D"
        ],
        "summary": "Retrieve points within a bounding box in a point cloud model",
        "description": "Retrieve points within a bounding box in a point cloud model.",
        "requestBody": {
          "description": "Cropbox query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CropboxRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Point cloud data for the bounding box",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string",
                  "description": "The raw contents of the file.",
                  "format": "binary"
                }
              }
            },
            "headers": {
              "Content-Type": {
                "schema": {
                  "type": "string"
                },
                "description": "The media type of the file."
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/3d/v2/models": {
      "get": {
        "tags": [
          "3D V2"
        ],
        "summary": "List 3D models",
        "description": "",
        "operationId": "list3DModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Model3DList"
                    },
                    {
                      "$ref": "#/components/schemas/NextCursorData"
                    }
                  ]
                }
              }
            }
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/models/byids": {
      "post": {
        "tags": [
          "3D V2"
        ],
        "summary": "Get 3D models by IDs",
        "description": "",
        "operationId": "get3DModelsByIds",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/DataIdentifier"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DList"
                }
              }
            }
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/models/update": {
      "post": {
        "tags": [
          "3D V2"
        ],
        "summary": "Update 3D models",
        "description": "",
        "operationId": "update3DModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Model3DUpdateList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DList"
                }
              }
            }
          }
        },
        "x-capability": [
          "threedAcl:UPDATE"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/models/delete": {
      "post": {
        "tags": [
          "3D V2"
        ],
        "summary": "Delete 3D models",
        "operationId": "delete3DModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/DataIdentifier"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "threedAcl:DELETE"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/models/upload": {
      "post": {
        "tags": [
          "3D V2"
        ],
        "summary": "Upload 3D models",
        "description": "",
        "operationId": "upload3DModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Model3DUploadList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DList"
                }
              }
            }
          }
        },
        "x-ca  pability": [
          "threedAcl:CREATE"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/models/{modelId}/revisions/{revisionId}/nodes/boundingbox": {
      "post": {
        "tags": [
          "3D V2"
        ],
        "summary": "Filter 3D Nodes with Bounding Box",
        "description": "List nodes in a model revision filtered by a specified bounding box, returning nodes that are either intersecting or fully inside the provided box. Note: If a node is fully inside the bounding box, none of the other nodes in its subtree are returned. This is the case regardless of the value of the `fullyContainedOnly` parameter.",
        "operationId": "boundingBox3DNodes",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          }
        ],
        "requestBody": {
          "description": "The bounding box by which to filter the nodes.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Node3DBoundingBoxFilterBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of nodes that are either intersecting or contained within the bounding box.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Node3DListWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "treedAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/blobs/{blobId}": {
      "get": {
        "tags": [
          "3D V2"
        ],
        "summary": "Get raw data for an output",
        "description": "This endpoint can also be given one or more `subpath` parameters after the `blobId` component,\nto get files contained in the blob if it is a directory-type blob.\n",
        "operationId": "read3DOutputData",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "name": "blobId",
            "in": "path",
            "description": "",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string",
                  "description": "The raw contents of the file.",
                  "format": "binary"
                }
              }
            },
            "headers": {
              "Content-Type": {
                "schema": {
                  "type": "string"
                },
                "description": "The media type of the file."
              }
            }
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/3d/v2/outputs": {
      "post": {
        "tags": [
          "3D V2"
        ],
        "summary": "List available outputs",
        "description": "Retrieve a list of available outputs for a processed 3D model. An output can be a format that can be consumed by a viewer (e.g. Reveal) or import in external tools. Each of the outputs will have an assosciated version which is used to identify the version of output format (not the revision of the processed output). Note that the structure of the outputs will vary and is not covered here.",
        "operationId": "list3dModelOutputs",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "A list of models to retrieve available outputs for.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Model3DOutputRequestList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns a list of outputs and available versions per output for a given model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DOutputResponseList"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/twins": {
      "get": {
        "tags": [
          "Digital Twin"
        ],
        "summary": "List digital twins",
        "description": "List all digital twins.",
        "operationId": "listDigitalTwins",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DigitalTwinConfigList"
                    },
                    {
                      "$ref": "#/components/schemas/NextCursorData"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      },
      "post": {
        "tags": [
          "Digital Twin"
        ],
        "summary": "Create digital twins",
        "description": "Create one or more digital twins.",
        "operationId": "createDigitalTwins",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "List of digital twins to create.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/CreateDigitalTwinConfig"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of created digital twins.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DigitalTwinConfigList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "digitalTwinAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/twins/{twinId}": {
      "get": {
        "tags": [
          "Digital Twin"
        ],
        "summary": "Retrieve digital twin",
        "description": "Retrieve a single digital twin by its ID.",
        "operationId": "getDigitalTwin",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "name": "twinId",
            "in": "path",
            "description": "The ID of the digital twin to retrieve.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The retrieved digital twin.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DigitalTwinConfig"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/twins/byids": {
      "post": {
        "tags": [
          "Digital Twin"
        ],
        "summary": "Retrieve multiple digital twins",
        "description": "Retrieve multiple digital twins by their IDs.",
        "operationId": "getDigitalTwins",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "List of IDs of the digital twins to retrieve.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataLong"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "List of retrieved digital twins.",
            "content": {
              "applciation/json": {
                "schema": {
                  "$ref": "#/components/schemas/DigitalTwinConfigList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/twins/update": {
      "post": {
        "tags": [
          "Digital Twin"
        ],
        "summary": "Update digital twins",
        "description": "Update digital twins.",
        "operationId": "updateDigitalTwins",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "List of digital twins to update.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/UpdateDigitalTwinConfig"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "List of updated digital twins.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DigitalTwinConfigList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "digitalTwinAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/twins/delete": {
      "post": {
        "tags": [
          "Digital Twin"
        ],
        "summary": "Delete digital twins",
        "description": "Delete digital twins.",
        "operationId": "deleteDigitalTwins",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "List of IDs of the digital twins to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataLong"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "digitalTwinAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/context/diagram/detect/": {
      "post": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Detect annotations in engineering diagrams",
        "description": "Detect annotations in engineering diagrams. Note: All users in a CDF project with assets read-all and files read-all capabilities can access data sent to this endpoint.",
        "operationId": "diagramDetect",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items",
                  "entities"
                ],
                "allOf": [
                  {
                    "properties": {
                      "items": {
                        "type": "array",
                        "description": "Files to run entity detection on.",
                        "minItems": 1,
                        "maxItems": 50,
                        "items": {
                          "$ref": "#/components/schemas/OneOfFileId"
                        }
                      },
                      "entities": {
                        "$ref": "#/components/schemas/DiagramDetectEntities"
                      }
                    }
                  },
                  {
                    "$ref": "#/components/schemas/DiagramDetectConfig"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/OneOfFileId"
                          }
                        },
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramDetectConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/diagram/detect/{jobId}": {
      "get": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Retrieve engineering diagram detect results",
        "description": "Get the results from an engineering diagram detect job.",
        "operationId": "diagramDetectResults",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        },
                        "items": {
                          "$ref": "#/components/schemas/DiagramDetectResultSchema"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramDetectConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/diagram/convert/": {
      "post": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Convert a diagram to image format",
        "description": "Convert interactive engineering diagrams to image format, with highlighted annotations.\n\nSupported image formats are PNG and SVG.",
        "operationId": "diagramConvert",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "allOf": [
                  {
                    "properties": {
                      "items": {
                        "$ref": "#/components/schemas/DiagramConvertRequestSchema"
                      }
                    }
                  },
                  {
                    "$ref": "#/components/schemas/DiagramConvertConfig"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/OneOfFileId"
                          }
                        },
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramConvertConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/diagram/convert/{jobId}": {
      "get": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Get the results for converting an engineering diagram to an image",
        "description": "Get the results for converting an engineering diagram to SVG and PNG formats.",
        "operationId": "diagramConvertResults",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        },
                        "items": {
                          "$ref": "#/components/schemas/DiagramConvertResultSchema"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramConvertConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/diagram/convert/{jobId}/download": {
      "get": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Download a converted engineering diagram as an image",
        "description": "Downloads a engineering diagram as an image, with highlighted annotations.\n\nThe diagram must have been converted as part of an image conversion job, using the\n[diagram conversion](#operation/diagramConvert) endpoint.\nThe job must have completed, before the results can be downloaded using this endpoint.\n\nThe resulting file in the requested format will be streamed to the client.\n\n## Supported image formats\nThe following image formats are supported. The corresponding MIME types are provided for reference.\n- PNG: `image/png`\n- SVG: `image/svg+xml`\n\nThe choice of image format can be input as the `Accept` header. See the specification further down.",
        "operationId": "diagramConvertDownload",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          },
          {
            "in": "query",
            "name": "fileId",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/FileId"
            }
          },
          {
            "in": "query",
            "name": "page",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/Page"
                },
                {
                  "default": 1
                }
              ]
            }
          },
          {
            "in": "header",
            "name": "Accept",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "image/png",
                "image/svg+xml"
              ],
              "default": "image/png",
              "description": "The format of the image to return"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful download",
            "content": {
              "image/png": {
                "schema": {
                  "description": "The converted diagram in PNG format",
                  "type": "string",
                  "format": "binary"
                }
              },
              "image/svg+xml": {
                "schema": {
                  "description": "The converted diagram in SVG format",
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "404": {
            "description": "Download failed, because\n- File not found, or\n- File not part of conversion job, or\n- Conversion job has not yet completed, or \n- Page not found in file"
          },
          "406": {
            "description": "Illegal \"Accept\" header"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/pnid/extractpattern": {
      "post": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Extract tags from P&ID based on a pattern",
        "description": "Extract tags from single-page P&ID in PDF format using regular expression patterns. Returns clusters of text matching the patterns. The regular expression is limited to simple expressions without wildcards, anchors, or repetition symbols, and must include groups of letters or digits to look for. A group is defined by a pattern in parenthesis `()` and can match either letters or numbers, but not both. Examples of valid groups are `([A-Z]{2,5})`, `([0-9]{4})`, `(TAG)`. You can optionally separate the groups in the pattern by a separator character like `-` or `_`. The resulting tags will then include the separator character between the matching groups.",
        "operationId": "pnidExtract",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "patterns"
                ],
                "oneOf": [
                  {
                    "type": "object",
                    "required": [
                      "fileId"
                    ],
                    "properties": {
                      "fileId": {
                        "$ref": "#/components/schemas/FileId"
                      },
                      "patterns": {
                        "$ref": "#/components/schemas/Patterns"
                      }
                    }
                  },
                  {
                    "type": "object",
                    "required": [
                      "fileExternalId"
                    ],
                    "properties": {
                      "fileExternalId": {
                        "$ref": "#/components/schemas/FileExternalId"
                      },
                      "patterns": {
                        "$ref": "#/components/schemas/Patterns"
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContextJobSchema"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/pnid/extractpattern/{jobId}": {
      "get": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Retrieve extracted tags based on a pattern in P&ID",
        "description": "Retrieve the results from an extract patterns job.",
        "operationId": "pnidRetrieveExtract",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status",
                    "items",
                    "fileId",
                    "fileExternalId"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "status": {
                      "$ref": "#/components/schemas/JobStatus"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of annotations representing the entities detected in the P&ID.",
                      "items": {
                        "$ref": "#/components/schemas/Annotation"
                      }
                    },
                    "fileId": {
                      "$ref": "#/components/schemas/FileId"
                    },
                    "fileExternalId": {
                      "$ref": "#/components/schemas/FileExternalId"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/pnid/ocr": {
      "post": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Retrieve raw OCR result from P&IDs",
        "description": "Retrieve the stored raw OCR result.",
        "operationId": "pnidOcr",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "fileId"
                ],
                "properties": {
                  "fileId": {
                    "$ref": "#/components/schemas/FileId"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "items"
                  ],
                  "properties": {
                    "items": {
                      "type": "array",
                      "description": "List of annotations for OCR detected in the P&ID.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "annotations": {
                            "type": "array",
                            "items": {
                              "$ref": "#/components/schemas/Annotation"
                            }
                          },
                          "width": {
                            "type": "number",
                            "example": 640
                          },
                          "height": {
                            "type": "number",
                            "example": 480
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/pnidobjects/findobjects": {
      "post": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Detect objects in P&ID",
        "description": "Detect shapes representing common objects in a P&ID and return bounding box for each detection. Currently, we support a static set of 20 different object types (valve, indicator, shared indicator, ball valve, diamond, tag, triangle, square with diagonal line, pump or centrifuge, flange, reducer, rotameter, slope, cloud, heat exchanger, note, logo, table, spectacle blind, object.) The P&ID must be a single-page `PDF` file or an image with `JPEG`, `PNG`, `TIFF` format.",
        "operationId": "pnidObjectFindObjects",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "fileId"
                ],
                "properties": {
                  "fileId": {
                    "$ref": "#/components/schemas/FileId"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContextJobSchema"
                }
              }
            }
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/pnidobjects/findobjects/{jobId}": {
      "get": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Retrieve P&ID object detection results",
        "description": "Retrieve the results for a P&ID object detection job.",
        "operationId": "pnidObjectFindObjectsRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status",
                    "items",
                    "fileId"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "status": {
                      "$ref": "#/components/schemas/JobStatus"
                    },
                    "errorMessage": {
                      "$ref": "#/components/schemas/ErrorMessage"
                    },
                    "fileId": {
                      "$ref": "#/components/schemas/FileId"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of annotations for objects detected in the P&ID.",
                      "items": {
                        "description": "Annotation representing a detected object.",
                        "type": "object",
                        "required": [
                          "type",
                          "boundingBox",
                          "score"
                        ],
                        "properties": {
                          "type": {
                            "type": "string",
                            "description": "one of `valve`, `indicator`, `shared indicator`, `ball valve`, `diamond`, `tag`, `triangle`, `square with diagonal line`, `pump or centrifuge`, `flange`, `reducer`, `rotameter`, `slope`, `cloud`, `heat exchanger`, `note`, `logo`, `table`, `spectacle blind`, `object`.",
                            "example": "indicator"
                          },
                          "boundingBox": {
                            "$ref": "#/components/schemas/BoundingBox"
                          },
                          "score": {
                            "type": "number",
                            "description": "the estimated probability of the existence of the proposed object.",
                            "example": 0.9989039897918701,
                            "minimum": 0,
                            "maximum": 1
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "x-capability": [
            "filesAcl:READ"
          ]
        }
      }
    },
    "/api/playground/projects/{project}/context/pnidobjects/findsimilar": {
      "post": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Find similar objects to a template in a P&ID",
        "description": "This endpoint detects similar objects in a P&ID given a template within the same P&ID. The P&ID must be a single-page `PDF` file or an image with `JPEG`, `PNG`, `TIFF` format.",
        "operationId": "pnidObjectFindSimilar",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "fileId",
                  "template"
                ],
                "properties": {
                  "fileId": {
                    "$ref": "#/components/schemas/FileId"
                  },
                  "template": {
                    "type": "object",
                    "required": [
                      "type",
                      "boundingBox"
                    ],
                    "properties": {
                      "type": {
                        "type": "string",
                        "example": "indicator"
                      },
                      "boundingBox": {
                        "$ref": "#/components/schemas/BoundingBox"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContextJobSchema"
                }
              }
            }
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/pnidobjects/findsimilar/{jobId}": {
      "get": {
        "tags": [
          "P&IDs and files"
        ],
        "summary": "Retrieve P&ID find similar object detection results.",
        "description": "Retrieve the results for a P&ID find similar object detection job.",
        "operationId": "pnidObjectFindSimilarRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status",
                    "items",
                    "fileId"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "status": {
                      "$ref": "#/components/schemas/JobStatus"
                    },
                    "errorMessage": {
                      "$ref": "#/components/schemas/ErrorMessage"
                    },
                    "fileId": {
                      "$ref": "#/components/schemas/FileId"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of annotations for objects detected in the P&ID.",
                      "items": {
                        "description": "Annotation representing a detected object.",
                        "type": "object",
                        "required": [
                          "type",
                          "boundingBox",
                          "score"
                        ],
                        "properties": {
                          "type": {
                            "type": "string",
                            "example": "indicator"
                          },
                          "boundingBox": {
                            "$ref": "#/components/schemas/BoundingBox"
                          },
                          "score": {
                            "type": "number",
                            "description": "the estimated probability of the existence of the proposed object.",
                            "example": 0.9989039897918701,
                            "minimum": 0,
                            "maximum": 1
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "x-capability": [
            "filesAcl:READ"
          ]
        }
      }
    },
    "/api/playground/projects/{project}/context/matchrules/suggest": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Suggest matching rules",
        "description": "Suggest matching rules from existing matches between two sets of entities (sources and targets).\nReturns a list of rules to encode the logic behind the matches.",
        "operationId": "suggestMatchRules",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SuggestPriorityRulesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "entitymatchingAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/context/matchrules/suggest/{jobId}": {
      "get": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Suggested rules result",
        "description": "Retrieve suggested rules",
        "operationId": "retrieveSuggestedRulesResult",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "rules": {
                          "description": "A list of rules with priorities. Each rule describes its conditions for two entities to match, but not conditions to not match. It is enough that one rule implies a match, but if two rules matches a source entity with different target entities, the highest priority rule prevails. Rules can be applied in the /apply endpoint in order to retrieve the matches they imply.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "$ref": "#/components/schemas/MatchRule"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/matchrules/apply": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Apply match rules",
        "description": "Apply a prioritized list of rules to match source entities with target entities.\nThe result is a list of matches per rule and information about overlapping and conflicting rules.\nFor each source entity, the match(es) from the highest prioritized rules are returned. Overlapping occurs when two rules with the same priority match a source entity with the _same_ target entity. Conflicting occurs when two rules with the same priority match a source entity with _different_ target entities.",
        "operationId": "applyMatchRules",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ApplyPriorityRulesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "entitymatchingAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/context/matchrules/apply/{jobId}": {
      "get": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Applied rules result",
        "description": "Retrieve match results from applied rules.",
        "operationId": "retrieveAppliedRulesResult",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AppliedRulesItem"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Create entity matcher model",
        "description": "Playground extensions to entity matching, currently includes the replacements parameter.",
        "operationId": "entityMatchingCreate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "sources",
                  "targets"
                ],
                "properties": {
                  "sources": {
                    "$ref": "#/components/schemas/Sources"
                  },
                  "targets": {
                    "$ref": "#/components/schemas/Targets"
                  },
                  "trueMatches": {
                    "$ref": "#/components/schemas/TrueMatches"
                  },
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  },
                  "name": {
                    "$ref": "#/components/schemas/ModelName"
                  },
                  "description": {
                    "$ref": "#/components/schemas/ModelDescription"
                  },
                  "featureType": {
                    "description": "Each feature type defines one combination of features that will be created and used in the entity matcher model. All features are based on matching tokens. Tokens are defined at the top of the Entity matching section.\nThe options are:\n  * Simple: Calculates the cosine-distance similarity score for each of the pairs of fields defined in `matchFields`. This is the fastest option.\n  * Insensitive: Similar to Simple, but ignores lowercase/uppercase differences.\n  * Bigram: Similar to `simple`, but adds similarity score based on matching bigrams of the tokens.\n  * FrequencyWeightedBigram: Similar to `bigram`, but give higher weights to less commonly occurring tokens.\n  * BigramExtraTokenizers: Similar to `bigram`, but able to learn that leading zeros, spaces, and uppercase/lowercase differences should be ignored in matching.\n  * BigramCombo: Calculates all of the above options, relying on the model to determine the appropriate features to use.\n  Hence, this option is only appropriate if there are  labeled data/trueMatches. This is the slowest option.\n",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/FeatureType"
                      }
                    ]
                  },
                  "matchFields": {
                    "$ref": "#/components/schemas/MatchFields"
                  },
                  "classifier": {
                    "$ref": "#/components/schemas/Classifier"
                  },
                  "ignoreMissingFields": {
                    "$ref": "#/components/schemas/IgnoreMissingFields"
                  },
                  "replacements": {
                    "$ref": "#/components/schemas/PipelineReplacements"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "entitymatchingAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Create Entity Matching Pipeline",
        "description": "Create a rerunnable entity matching pipeline. Entity matching pipelines support expert knowledge (confirmed and/or rejected matches), regex rules (match rules) and entity matching models. To run the pipeline use the pipelines/run-endpoint.\n",
        "operationId": "entityMatchingPipelineCreate",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityMatcherPipelinesSchema"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityMatcherPipelinesSchema"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:WRITE",
          "assetsAcl:READ",
          "timeSeriesAcl:READ",
          "eventsAcl:READ",
          "sequencesAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/list": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "List pipelines",
        "operationId": "entityMatchingPipelinesList",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "filter"
                ],
                "properties": {
                  "limit": {
                    "description": "Limits the maximum number of results to be returned by single request.",
                    "type": "integer",
                    "format": "int32",
                    "minimum": 1,
                    "default": 100,
                    "example": 25
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/EntityMatcherPipelinesSchema"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "assetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/update": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Update entity matching pipelines",
        "description": "Update entity matching pipelines by IDs or external IDs.",
        "operationId": "entityMatchingPipelinesUpdate",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/PipelineChange"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/EntityMatcherPipelinesSchema"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:WRITE",
          "assetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/byids": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Retrieve pipelines",
        "description": "Retrieve entity matching pipelines by IDs or external IDs.",
        "operationId": "entityMatchingPipelineRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "object",
                    "$ref": "#/components/schemas/ContextModelReferenceSchema"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "assetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/run": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Run pipeline",
        "description": "Run an entity matching pipeline. When a pipeline is run data is downloaded from CDF and an entity matching model is fit according to the parameters specified when the pipeline was created. Which matches are returned are then decided based on the sources the pipeline trusts the most: 1. If a source has a confirmed match in the confirmedMatches object, this match is returned. 2. If not 1., but a match is found using one of the regex-rules in rules and the match found is not in rejectedMatches, this match is returned. 3. If not 1. or 2., but the entity matching model find a match with score above scoreThreshold and the match found is not in rejectedMatches, this match is returned. 4. If not 1., 2. or 3. no match is returned for a given source. If additional matches are confirmed and added to confirmedMatches or rejectedMatches or additional rules are confirmed and added to rules through the update-endpoint, rerunning the pipeline should give new and improved results.\n",
        "operationId": "entityMatchingPipelineRun",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContextModelReferenceSchema"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "assetsAcl:READ",
          "timeSeriesAcl:READ",
          "eventsAcl:READ",
          "sequencesAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/run/{jobId}": {
      "get": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Retrieve results from run pipeline",
        "description": "Retrieve results from run pipeline",
        "operationId": "entityMatchingPipelineRunGet",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "pipelineId": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        },
                        "matches": {
                          "type": "array",
                          "description": "List of matches",
                          "items": {
                            "type": "object",
                            "properties": {
                              "source": {
                                "type": "object",
                                "example": {
                                  "field": "value",
                                  "ignoredfield": {
                                    "key": "value"
                                  }
                                },
                                "description": "The source item."
                              },
                              "target": {
                                "type": "object",
                                "example": {
                                  "field": "value",
                                  "ignoredfield": {
                                    "key": "value"
                                  }
                                },
                                "description": "The target item."
                              },
                              "score": {
                                "type": "number",
                                "example": 0.98,
                                "description": "The confidence in the match."
                              },
                              "matchType": {
                                "type": "string",
                                "example": "model",
                                "enum": [
                                  "previously_mapped",
                                  "model",
                                  "rule_rule_input_pattern->rule_predict_pattern"
                                ],
                                "description": "Which source was used to create the match."
                              }
                            }
                          }
                        },
                        "suggestedRules": {
                          "type": "array",
                          "description": "Suggested rules based on matches.",
                          "allOf": [
                            {
                              "$ref": "#/components/schemas/MatchRule"
                            },
                            {
                              "properties": {
                                "numMatches": {
                                  "type": "integer",
                                  "example": 10,
                                  "description": "The number of matches belonging to the rule."
                                }
                              }
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "assetsAcl:READ",
          "timeSeriesAcl:READ",
          "eventsAcl:READ",
          "sequencesAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/run/list": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "List runs of a pipeline",
        "description": "Retrieve runs of an entity matching pipeline run by IDs or external IDs.",
        "operationId": "entityMatchingPipelineListRuns",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "$ref": "#/components/schemas/ContextModelReferenceSchema"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "assetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/entitymatching/pipelines/run/latest": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Retrieve latest run of pipelines",
        "description": "Retrieve last entity matching pipelines run by IDs or external IDs. Note that if there is no run, it will not be returned, so results may not be aligned with input.",
        "operationId": "entityMatchingPipelineRetrieveLatestRun",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "object",
                    "$ref": "#/components/schemas/ContextModelReferenceSchema"
                  },
                  "includeSkipped": {
                    "type": "boolean",
                    "example": false,
                    "default": false,
                    "description": "If false, retrieves the latest run that generated results. If true, retrieve the latest run even if it was a scheduled run that was skipped due to no new resources being present."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "assetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/entitymatching/suggestfields": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Suggest Match Fields for Entity Matching",
        "description": "Suggest which source and target fields to use for entity matching. Best used with a sample of sources and targets that contain matches. This is a synchronous endpoint that returns results immediately, and therefore has a limit of at most 10,000 sources/targets.",
        "operationId": "suggestFields",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "sources",
                  "targets"
                ],
                "properties": {
                  "sources": {
                    "$ref": "#/components/schemas/Sources"
                  },
                  "targets": {
                    "$ref": "#/components/schemas/Targets"
                  },
                  "scoreThreshold": {
                    "type": "number",
                    "example": 0.5,
                    "default": 0.5,
                    "description": "Only return suggestions rated above this threshold. Score is not related to values used elsewhere."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "source": {
                            "type": "string",
                            "description": "field of the source entities"
                          },
                          "target": {
                            "type": "string",
                            "description": "field of the target entities"
                          },
                          "score": {
                            "type": "number",
                            "description": "score indicating how many tokens tend to appear in common between random pairs of source, target"
                          },
                          "exampleTokens": {
                            "type": "array",
                            "description": "a list of up to 25 example tokens that match"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "x-capability": [
            "assetsAcl:READ"
          ]
        }
      }
    },
    "/api/playground/projects/{project}/context/schemas/domain": {
      "post": {
        "tags": [
          "Template completion"
        ],
        "summary": "Suggest and check entries in a template defined by a template group",
        "description": "The algorithm searchs patterns in assets' fields and make patterns for resources' (e.g. timeseries) names and suggests resources to fill the template.",
        "operationId": "schemaDomainCompletion",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "externalId",
                  "templateName"
                ],
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TemplateReference"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContextJobSchema"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/schemas/{jobId}": {
      "get": {
        "tags": [
          "Template completion"
        ],
        "summary": "Retrieve template completion results",
        "description": "Retrieve the results for a template completion job.",
        "operationId": "schemaCompletionRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "properties"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ContextJobSchema"
                    },
                    {
                      "properties": {
                        "properties": {
                          "$ref": "#/components/schemas/Properties"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/schemas/instancesuggestion": {
      "post": {
        "tags": [
          "Template completion"
        ],
        "summary": "Suggest instances given a template.",
        "description": "The algorithm finds patterns from the existing instances in a template and search for candidates that match the patterns.",
        "operationId": "instanceSuggestion",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "externalId",
                  "templateName"
                ],
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TemplateReference"
                  },
                  {
                    "properties": {
                      "assetSubtreeIds": {
                        "description": "asset subtree ids to scope the search space",
                        "type": "array",
                        "items": {
                          "type": "integer"
                        }
                      },
                      "assetSubtreeExternalIds": {
                        "description": "asset subtree external ids to scope the search space",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ContextJobSchema"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/schemas/instancesuggestion/{jobId}": {
      "get": {
        "tags": [
          "Template completion"
        ],
        "summary": "Retrieve instance suggestion results",
        "description": "Retrieve the results for a instance suggestion job.",
        "operationId": "instanceSuggestionRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "properties"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ContextJobSchema"
                    },
                    {
                      "properties": {
                        "items": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "field",
                              "pattern",
                              "suggestions"
                            ],
                            "properties": {
                              "field": {
                                "type": "string",
                                "description": "field used to find patterns",
                                "example": "external_id"
                              },
                              "pattern": {
                                "type": "string",
                                "description": "regular expression of the pattern",
                                "example": "^WELL\\\\ (.*?)$"
                              },
                              "suggestions": {
                                "type": "array",
                                "description": "ids of suggested instances",
                                "items": {
                                  "type": "integer",
                                  "example": 1234
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/extract": {
      "post": {
        "tags": [
          "Vision"
        ],
        "summary": "Extract features from images",
        "description": "Start an asynchronous prediction job for extracting features such as text, asset tags or industrial objects from images.\nThe response of the POST request contains a job ID, which can be used to make subsequent (GET) calls \nto check the status and retrieve the results of the job \n(see [Retrieve results from a feature extraction job](#operation/getVisionExtract)).\n\nIt is possible to have up to 20 concurrent jobs per CDF project.\n\nThe files referenced by `items` in the request body must fulfill the following requirements:\n\n* Must have file extension: `.jpeg`, `.jpg` or `.png`\n* Must have `image/png` or `image/jpeg` as `mimeType`\n\nNew feature extractors will be continuously added. \n",
        "operationId": "postVisionExtract",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/VisionExtractPostRequestSchema"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/VisionExtractPostResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.experimental.data_classes.vision import Feature\n\nextract_job = client.vision.extract(features=Feature.ASSET_TAG_DETECTION, file_ids=[1])"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/context/vision/extract/{jobId}": {
      "get": {
        "tags": [
          "Vision"
        ],
        "summary": "Retrieve results from a feature extraction job on images",
        "description": "Retrieve results from a feature extraction job on images.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`.\nAdditionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.\n",
        "operationId": "getVisionExtract",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/VisionExtractGetResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "# Get an existing job, wait for completion and then get the parsed results\nextract_job = client.vision.get_extract_job(job_id=1)\nextract_job.wait_for_completion()\nfor item in extract_job.items:\n    predictions = item.predictions\n    # do something with the predictions"
          }
        ]
      }
    },
    "/api/playground/projects/{project}/context/vision/ocr": {
      "post": {
        "deprecated": true,
        "tags": [
          "Vision"
        ],
        "summary": "Run OCR on images",
        "description": "Start an asynchronous prediction job for Optical Character Recognition (OCR) on images. The response of the POST request contains a job ID, which can be used to make subsequent (GET) calls to check the status and retrieve the results of the job (see [Retrieve results from OCR job](#operation/visionOcrRetrieve)). \n",
        "operationId": "visionOcr",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/FileReference"
                    }
                  },
                  "useCache": {
                    "type": "boolean",
                    "description": "If True, uses cached result if the file has previously been analyzed.",
                    "default": true
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AllOfFileId"
                          }
                        },
                        "useCache": {
                          "type": "boolean",
                          "description": "If True, uses cached result if the file has previously been analyzed.",
                          "default": true
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/ocr/{jobId}": {
      "get": {
        "deprecated": true,
        "tags": [
          "Vision"
        ],
        "summary": "Retrieve results from OCR job",
        "description": "Retrieve results from an OCR prediction job on images.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`.\nAdditionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.\n",
        "operationId": "visionOcrRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "useCache": {
                          "type": "boolean",
                          "description": "If True, uses cached result if the file has previously been analyzed.",
                          "default": true
                        },
                        "items": {
                          "type": "array",
                          "description": "List of entity annotations for the entities detected in the file.",
                          "items": {
                            "type": "object",
                            "required": [
                              "fileId"
                            ],
                            "properties": {
                              "annotations": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/components/schemas/VisionAnnotation"
                                }
                              },
                              "fileId": {
                                "$ref": "#/components/schemas/ContextFileId"
                              },
                              "fileExternalId": {
                                "$ref": "#/components/schemas/ContextFileExternalId"
                              },
                              "width": {
                                "type": "number",
                                "description": "Image width.",
                                "example": 640
                              },
                              "height": {
                                "type": "number",
                                "description": "Image height.",
                                "example": 480
                              }
                            }
                          }
                        },
                        "failedItems": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/FailedBatch"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/tagdetection": {
      "post": {
        "deprecated": true,
        "tags": [
          "Vision"
        ],
        "summary": "Detect external ID or name of assets in images",
        "description": "Start an asynchronous prediction job for detecting external ID or name of assets in images. The response of the POST request contains a job ID, which can be used to make subsequent (GET) calls to check the status and retrieve the results of the job (see [Retrieve results from tag detection job](#operation/visionTagDetectionRetrieve)). \n",
        "operationId": "visionTagDetection",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/FileReference"
                    }
                  },
                  "useCache": {
                    "type": "boolean",
                    "description": "If True, uses cached result if the file has previously been analyzed.",
                    "default": true
                  },
                  "partialMatch": {
                    "type": "boolean",
                    "description": "Allow partial (fuzzy) matching of detected external IDs in the file. Will only match when it is possible to do so unambiguously.",
                    "default": false
                  },
                  "assetSubtreeIds": {
                    "type": "array",
                    "description": "Search for external ID or name of assets that are in a subtree rooted at one of the assetSubtreeIds (including the roots given).",
                    "items": {
                      "$ref": "#/components/schemas/CogniteInternalId"
                    },
                    "example": [
                      1234,
                      8888
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AllOfFileId"
                          }
                        },
                        "useCache": {
                          "type": "boolean",
                          "description": "If True, uses cached result if the file has previously been analyzed.",
                          "default": true
                        },
                        "partialMatch": {
                          "type": "boolean",
                          "description": "Allow partial (fuzzy) matching of detected external IDs in the file. Will only match when it is possible to do so unambiguously.",
                          "default": false
                        },
                        "assetSubtreeIds": {
                          "type": "array",
                          "description": "Search for external ID of assets that are in a subtree rooted at one of the assetSubtreeIds (including the roots given).",
                          "items": {
                            "$ref": "#/components/schemas/CogniteInternalId"
                          },
                          "example": [
                            1234,
                            8888
                          ]
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/tagdetection/{jobId}": {
      "get": {
        "deprecated": true,
        "tags": [
          "Vision"
        ],
        "summary": "Retrieve results from asset detection job",
        "description": "Retrieve results from an asset detection job on images or single-page pdf files.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`.\nAdditionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.\n",
        "operationId": "visionTagDetectionRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "useCache": {
                          "type": "boolean",
                          "description": "If True, uses cached result if the file has previously been analyzed.",
                          "default": true
                        },
                        "partialMatch": {
                          "type": "boolean",
                          "description": "Allow partial (fuzzy) matching of detected external IDs in the file. Will only match when it is possible to do so unambiguously.",
                          "default": false
                        },
                        "assetSubtreeIds": {
                          "type": "array",
                          "description": "Search for external ID of assets that are in a subtree rooted at one of the assetSubtreeIds (including the roots given).",
                          "items": {
                            "$ref": "#/components/schemas/CogniteInternalId"
                          },
                          "example": [
                            1234,
                            8888
                          ]
                        },
                        "items": {
                          "type": "array",
                          "description": "List of entity annotations for the entities detected in the file.",
                          "items": {
                            "type": "object",
                            "required": [
                              "fileId"
                            ],
                            "properties": {
                              "annotations": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/components/schemas/VisionTagDetectionAnnotation"
                                }
                              },
                              "fileId": {
                                "$ref": "#/components/schemas/ContextFileId"
                              },
                              "fileExternalId": {
                                "$ref": "#/components/schemas/ContextFileExternalId"
                              },
                              "width": {
                                "type": "number",
                                "description": "Image width.",
                                "example": 640
                              },
                              "height": {
                                "type": "number",
                                "description": "Image height.",
                                "example": 480
                              }
                            }
                          }
                        },
                        "failedItems": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/FailedBatch"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/gaugereader": {
      "post": {
        "tags": [
          "Vision"
        ],
        "summary": "Read value of analog, digital and level gauges",
        "description": "Start an asynchronous prediction job for reading value of gauges in images. The response of the POST request contains a job ID, which can be used to make subsequent (GET) calls to check the status and retrieve the results of the job (see [Retrieve results from gauge reader job](#operation/visionGaugeReaderRetrieve)). ",
        "operationId": "visionGaugeReader",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/FileReference"
                    }
                  },
                  "gaugeType": {
                    "$ref": "#/components/schemas/GaugeType"
                  },
                  "unit": {
                    "$ref": "#/components/schemas/Unit"
                  },
                  "deadAngle": {
                    "$ref": "#/components/schemas/DeadAngle"
                  },
                  "minLevel": {
                    "$ref": "#/components/schemas/MinLevel"
                  },
                  "maxLevel": {
                    "$ref": "#/components/schemas/MaxLevel"
                  },
                  "minNumDigits": {
                    "$ref": "#/components/schemas/MinNumDigits"
                  },
                  "maxNumDigits": {
                    "$ref": "#/components/schemas/MaxNumDigits"
                  },
                  "commaPos": {
                    "$ref": "#/components/schemas/CommaPos"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AllOfFileId"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/gaugereader/{jobId}": {
      "get": {
        "tags": [
          "Vision"
        ],
        "summary": "Retrieve results from gauge reader job",
        "description": "Retrieve results from a gauge reader job on images.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`. Additionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.",
        "operationId": "visionGaugeReaderRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status",
                    "gaugeType",
                    "fileId",
                    "gaugeValue"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "description": "List of entity annotations for the entities detected in the file.",
                          "items": {
                            "type": "object",
                            "required": [
                              "fileId"
                            ],
                            "properties": {
                              "annotations": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/components/schemas/GaugeReadingAnnotation"
                                }
                              },
                              "fileId": {
                                "$ref": "#/components/schemas/ContextFileId"
                              },
                              "fileExternalId": {
                                "$ref": "#/components/schemas/ContextFileExternalId"
                              },
                              "width": {
                                "type": "number",
                                "description": "Image width.",
                                "example": 640
                              },
                              "height": {
                                "type": "number",
                                "description": "Image height.",
                                "example": 480
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/valvereader": {
      "post": {
        "tags": [
          "Vision"
        ],
        "summary": "Detect and read state of valves",
        "description": "Start an asynchronous prediction job for reading state (on, off or undefined) of valves in images. The response of the POST request contains a job ID, which can be used to make subsequent (GET) calls to check the status and retrieve the results of the job (see [Retrieve results from valve state reader job](#operation/visionValveReaderRetrieve)). ",
        "operationId": "visionValveReader",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/FileReference"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AllOfFileId"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/valvereader/{jobId}": {
      "get": {
        "tags": [
          "Vision"
        ],
        "summary": "Retrieve results from valve state reader job",
        "description": "Retrieve the response of an valve state reader job. The state is given under the data parameter in every annotation.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`. Additionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.",
        "operationId": "visionValveReaderRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "status",
                    "fileId",
                    "state"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "description": "List of entity annotations for the entities detected in the file.",
                          "items": {
                            "type": "object",
                            "required": [
                              "fileId"
                            ],
                            "properties": {
                              "annotations": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/components/schemas/ValveReadingAnnotation"
                                }
                              },
                              "fileId": {
                                "$ref": "#/components/schemas/ContextFileId"
                              },
                              "fileExternalId": {
                                "$ref": "#/components/schemas/ContextFileExternalId"
                              },
                              "width": {
                                "type": "number",
                                "description": "Image width.",
                                "example": 640
                              },
                              "height": {
                                "type": "number",
                                "description": "Image height.",
                                "example": 480
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/automl": {
      "post": {
        "tags": [
          "Vision AutoML"
        ],
        "summary": "Train a custom computer vision model",
        "description": "Train a custom computer vision model for classification or object detection. Training duration depends on number of files used to train the model and can take up to 24 hours. The response of the POST request contains a job ID, which can be used to make subsequent (GET) calls to check the status of the training job (see [Retrieve status and results of AutoML training job](#operation/visionAutoMLRetrieve)). \n\nThe files referenced by `items` in the request body must fullfil the following requirements:\n\n* Must have file extension: `.jpeg`, `.jpg` or `.png`\n* Must have `image/png` or `image/jpeg` as `mimeType`\n* Files cannot be identical (even if they have different file IDs)\n* Min image height/width in pixels: 256\n* Max image height/width in pixels: 1024\n* Max image size: 6MB\n\n\nIn addition, images must be annotated. This can be done using a UI at [https://fusion.cognite.com](https://fusion.cognite.com) (for more details and guides visit [Vision Early Adopter Program](https://hub.cognite.com/groups/vision-early-adopter-205))\n\nAnnotation requirements:\n\n* Classification: \n  * Each image can at most have one annotation.\n  * There must at least be 10 images per annotation class (1000 training images per class is recommended).\n\n* Object detection: \n  * There must at least be 15 images per annotation class (1000 annotations per class is recommended). \n  * Each annotation must have a corresponding bounding box with normalized coordinates.\n  * Each image can maximally have 300 annotations.\n  * Bounding box edge length must be at least `0.01 * length` of a side of an image.",
        "operationId": "visionAutoML",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items",
                  "modelType",
                  "name"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 7500,
                    "items": {
                      "$ref": "#/components/schemas/FileReference"
                    }
                  },
                  "modelType": {
                    "type": "string",
                    "enum": [
                      "classification",
                      "objectdetection"
                    ],
                    "description": "Computer vision model type."
                  },
                  "name": {
                    "type": "string",
                    "description": "The name of the computer vision model."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "modelType",
                    "name"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AllOfFileId"
                          }
                        },
                        "modelType": {
                          "type": "string",
                          "enum": [
                            "classification",
                            "objectdetection"
                          ],
                          "description": "Computer vision model type."
                        },
                        "name": {
                          "type": "string",
                          "description": "The name of the computer vision model."
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ",
          "visionmodelAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/context/vision/automl/{jobId}": {
      "get": {
        "tags": [
          "Vision AutoML"
        ],
        "summary": "Retrieve status and results of AutoML training job",
        "description": "Retrieve status and results of AutoML training job. ",
        "operationId": "visionAutoMLRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "modelType",
                    "name"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "modelType": {
                          "type": "string",
                          "enum": [
                            "classification",
                            "objectdetection"
                          ],
                          "description": "Computer vision model type."
                        },
                        "modelEvaluation": {
                          "$ref": "#/components/schemas/ModelEvaluationSchema"
                        },
                        "name": {
                          "type": "string",
                          "description": "The name of the computer vision model."
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "visionmodelAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/vision/automl/list": {
      "get": {
        "tags": [
          "Vision AutoML"
        ],
        "summary": "List AutoML training jobs.",
        "description": "List the computer vision model training jobs in the current project.",
        "operationId": "visionAutoMLList",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "items"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "items": {
                          "type": "array",
                          "description": "Training job data.",
                          "items": {
                            "type": "object",
                            "required": [
                              "jobId",
                              "name",
                              "modelType",
                              "status"
                            ],
                            "properties": {
                              "jobId": {
                                "$ref": "#/components/schemas/JobId"
                              },
                              "name": {
                                "type": "string",
                                "description": "The name of the computer vision model."
                              },
                              "modelType": {
                                "type": "string",
                                "enum": [
                                  "classification",
                                  "objectdetection"
                                ],
                                "description": "Computer vision model type."
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "visionmodelAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/vision/automl/{jobId}/download": {
      "get": {
        "tags": [
          "Vision AutoML"
        ],
        "summary": "Download model file for an AutoML training job",
        "description": "Download model file for an AutoML training job for offline prediction (see [here](#operation/visionAutoMLPredict) for running predictions on cloud). The training job can take several hours, but once completed the resulting model weight file, represented as a [Tensorflow Lite file](https://www.tensorflow.org/lite/guide) (`.tflite`), will be returned as a signed url. ",
        "operationId": "visionAutoMLDownload",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          },
          {
            "in": "query",
            "name": "exportFormat",
            "schema": {
              "type": "string",
              "default": "tflite",
              "enum": [
                "tflite",
                "tf-saved-model"
              ]
            },
            "description": "Export format for model weight file."
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "model_url"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "modelUrl": {
                          "type": "string",
                          "description": "Download url."
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "visionmodelAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/context/vision/automl/prediction": {
      "post": {
        "tags": [
          "Vision AutoML"
        ],
        "summary": "Make predictions using a pre-trained AutoML model",
        "description": "Start an asynchronous prediction job using custom pre-trained AutoML model for classification or object detection.\n\nThe response of the POST request contains a job ID, which can be used to make subsequent (GET) calls to check the status and retrieve the results of the job (see [Retrieve results from a prediction job with a pre-trained AutoML model](#operation/visionAutoMLPredictRetrieve))\n",
        "operationId": "visionAutoMLPredict",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "x-capability": [
          "filesAcl:READ",
          "visionmodelAcl:READ"
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items",
                  "modelFile",
                  "modelJobId"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1000,
                    "items": {
                      "$ref": "#/components/schemas/FileReference"
                    }
                  },
                  "modelJobId": {
                    "$ref": "#/components/schemas/JobId"
                  },
                  "threshold": {
                    "type": "number",
                    "example": 0.7,
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Only return suggestions rated above this threshold."
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "modelFile",
                    "modelJobId"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/AllOfFileId"
                          }
                        },
                        "modelJobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "threshold": {
                          "type": "number",
                          "example": 0.7,
                          "minimum": 0,
                          "maximum": 1,
                          "description": "Only return suggestions rated above this threshold."
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/context/vision/automl/prediction/{jobId}": {
      "get": {
        "tags": [
          "Vision AutoML"
        ],
        "summary": "Retrieve results from a prediction job with a pre-trained AutoML model",
        "description": "Retrieve results from a prediction job using a pre-trained AutoML model.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`.\nAdditionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.\n",
        "operationId": "visionAutoMLPredictRetrieve",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "x-capability": [
          "visionmodelAcl:READ"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "modelFile"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "items": {
                          "type": "array",
                          "description": "List of entity annotations for the entities detected in the file.",
                          "items": {
                            "type": "object",
                            "required": [
                              "fileId"
                            ],
                            "properties": {
                              "annotations": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/components/schemas/VisionAnnotation"
                                }
                              },
                              "fileId": {
                                "$ref": "#/components/schemas/ContextFileId"
                              },
                              "fileExternalId": {
                                "$ref": "#/components/schemas/ContextFileExternalId"
                              },
                              "width": {
                                "type": "number",
                                "description": "Image width.",
                                "example": 640
                              },
                              "height": {
                                "type": "number",
                                "description": "Image height.",
                                "example": 480
                              }
                            }
                          }
                        },
                        "modelJobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "threshold": {
                          "type": "number",
                          "example": 0.7,
                          "minimum": 0,
                          "maximum": 1,
                          "description": "Only return suggestions rated above this threshold."
                        },
                        "failedItems": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/FailedBatch"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/documents/search": {
      "post": {
        "deprecated": true,
        "tags": [
          "Documents"
        ],
        "summary": "Search for documents",
        "description": "This endpoint lets you search for documents by using advanced filters and free text queries.\nFree text queries are matched against the documents' filenames and contents.\n\n### Free text query syntax\n\n#### Boolean operators\nThe `+` symbol signifies an AND operation, and the `|` symbol signifies an OR.\nSearching for `lorem + ipsum` will match documents containing both \"lorem\" AND \"ipsum\" in the filename or content.\nSimilarly, searching for `lorem | ipsum` will match documents containing either \"lorem\" OR \"ipsum\" in the filename or content.\n\nThe default operator between the search keywords is AND.\nThat means that searching for two terms without any operator, like so: `lorem ipsum`, will\nmatch documents containing both the words \"lorem\" and \"ipsum\" in the filename or content.\n\nTo exclude documents containing a specific word, you can use the operator `-`.\nFor instance, the search `lorem -ipsum` will match documents that contain the word \"lorem\", but does NOT contain the word \"ipsum\".\n\n#### Phrases\nEnclose multiple words inside double quotes `\"` to group these words together.\nNormally, the search query `lorem ipsum` will match not only \"lorem ipsum\" but also \"lorem cognite ipsum\",\nand in general there can be any number of words between the two words in the query.\nThe search query `\"lorem ipsum\"`, however, will match only exactly \"lorem ipsum\" and not \"lorem cognite ipsum\".\n\n#### Escape\nTo search for the special characters (`+`, `|`, `-`, `\"`), escape with a preceding backslash (\\).\n\n### Ordering\nWhen you search for a term, we try to return the most relevant documents first, and less relevant documents further down the list.\nThere are a few factors that determine the relevance of a document:\n- If the search terms are found multiple times within a document, the relevance of that document is higher.\n- For searches with multiple terms, documents that contain all of the terms are considered more relevant than documents that only contain some of the terms.\n- Matches of the terms in the filename field of the document, count for more than matches in the content of the document.\n\n### Request examples\n```\n{\n    \"search\": {\n        \"query\": \"cognite \\\"lorem ipsum\\\"\"\n    }\n}\n```\nThis request will return documents matching the search query, where the query behaves as described above.\n\n```\n{\n    \"filter\": {\n        \"externalIdPrefix\": {\"in\": [\"1\", \"2\", \"3\"]},\n        \"title\": {\"in\": [\"My Document\", \"My Other Document\"]},\n        \"sourceFile\": {\"createdTime\": {\"max\": 10000000}}\n    }\n}\n```\nThis request will match all documents where all of the below are satisfied:\n- the external id starts with \"1\", or \"2\", or \"3\"\n- the `createdTime` is at most 10000000\n- the derived title is either \"My Document\" or \"My Other Document\"\n\n```\n{\n    \"search\": {\n        \"query\": \"cognite \\\"lorem ipsum\\\"\"\n    },\n    \"filter\": {\n        \"externalIdPrefix\": {\"in\": [\"1\", \"2\", \"3\"]},\n        \"title\": {\"in\": [\"My Document\", \"My Other Document\"]},\n        \"sourceFile\": {\"createdTime\": {\"max\": 10000000}}\n    }\n}\n```\nThis example combines the two above. This search request will return documents\nmatching the search query, if they satisfy the specified filter.",
        "operationId": "documentsSearch",
        "parameters": [
          {
            "in": "path",
            "name": "project",
            "required": true,
            "description": "The project name.",
            "schema": {
              "type": "string",
              "example": "publicdata"
            }
          }
        ],
        "requestBody": {
          "description": "Fields to be set for the search request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsSearchResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/list": {
      "post": {
        "deprecated": true,
        "tags": [
          "Documents"
        ],
        "summary": "Filter documents",
        "description": "Retrieves a list of all documents in a project. Criteria can be supplied to select a subset of documents. This operation supports pagination with cursors.",
        "operationId": "documentsFilter",
        "parameters": [
          {
            "in": "path",
            "name": "project",
            "required": true,
            "description": "The project name.",
            "schema": {
              "type": "string",
              "example": "publicdata"
            }
          }
        ],
        "requestBody": {
          "description": "Fields to be set for the list request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsFilterRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsFilterResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/content": {
      "post": {
        "deprecated": true,
        "tags": [
          "Documents"
        ],
        "summary": "Retrieve document content",
        "description": "Returns extracted textual information for the given document ids.\n\nThe documents pipeline extract up to 1MiB of textual information from each processed document. This is useful to gain more insight as other \nendpoints currently truncate the text to around 155 character to reduce the json payload.",
        "operationId": "documentsContent",
        "parameters": [
          {
            "in": "path",
            "name": "project",
            "required": true,
            "description": "The project name.",
            "schema": {
              "type": "string",
              "example": "publicdata"
            }
          }
        ],
        "requestBody": {
          "description": "Array of document ids.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentContentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentContentResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/pipelines": {
      "post": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "Create a pipeline configuration object",
        "description": "Create a pipeline configuration object.\n\nThis endpoint requires that the caller has the `All` scope set on the `labelsAcl:READ` capability.",
        "operationId": "documentsCreatePipelines",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsPipelineItems"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsPipelinesResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:WRITE",
          "labelsAcl:READ"
        ]
      },
      "get": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "Get pipeline configuration",
        "description": "Get the list of pipeline configuration objects.",
        "operationId": "documentsGetPipelines",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsPipelinesResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/pipelines/update": {
      "post": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "Update pipeline configuration",
        "description": "This endpoint lets you update your pipeline configuration.\n\nThis endpoint requires that the caller has the `All` scope set on the `labelsAcl:READ` capability.",
        "operationId": "documentsUpdatePipelines",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsPipelineItemsUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsPipelinesResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:WRITE",
          "labelsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/pipelines/delete": {
      "post": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "Delete pipeline configuration",
        "operationId": "documentsDeletePipelines",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "description": "This endpoint lets you delete your custom pipeline configuration. This will\nrevert you back to the default document indexing settings.",
        "requestBody": {
          "description": "A list of pipeline configuration ids to delete",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/feedback": {
      "post": {
        "tags": [
          "Document feedback"
        ],
        "summary": "Create feedback on document",
        "description": "Report feedback on documents' labels.\n\n## Derived labels and labels attached to the CDF file\nThe feedback API supports feedback on both labels that are directly attached to the CDF file\n(`item.sourceFile.labels`), and labels that were derived from classification (`item.labels`).\n\n## Attaching and detaching labels\nYou can suggest that a label be attached to a file, or detached from a file.\nThe feedback will be reviewed by an administrator/data manager. Upon approbation of your\nfeedback record, the action (`ATTACH` or `DETACH` the label) will be performed on the file.\n\n### Detaching a label\nA label that has been detached will not come back as part of the predicted labels later on.\nIf the label you want to detach is on the CDF file, it will be removed from the CDF file.\n\n## Preconditions\nYour new feedback record must meet the following preconditions:\n- `documentId` needs to refer to a document that exists\n- If the `action` is `ATTACH`:\n    - the label definition needs to [exist](#operation/listLabels) in CDF\n    - the label must not already be attached to the CDF file\n- If the `action` is `DETACH`, the label needs to be attached to the CDF file, and/or be a derived label of the document.\n\nPlease note that the `reporterInfo` field is not managed, so it should be treated as non-checked free text.\n\nThis endpoint requires that the caller has the `All` scope set on the `labelsAcl:READ` capability.",
        "operationId": "documentsReportFeedback",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentFeedbackCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentFeedbackCreateResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentFeedbackAcl:CREATE",
          "labelsAcl:READ",
          "filesAcl:READ"
        ]
      },
      "get": {
        "tags": [
          "Document feedback"
        ],
        "summary": "List feedback",
        "description": "Get all feedback objects from the project.\n\nYou can also filter on the feedback's status.\n\nThis endpoint requires that the caller has the `All` scope set on the `labelsAcl:READ` capability.",
        "operationId": "documentsListFeedback",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/feedbackStatus"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentFeedbackListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentFeedbackAcl:READ",
          "labelsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/feedback/aggregates": {
      "post": {
        "tags": [
          "Document feedback"
        ],
        "summary": "Aggregate by field",
        "description": "Group all feedback objects in the project by field, and count the number of objects per group.\nAvailable fields for grouping are currently `status` and `action`.\n\nThis endpoint requires that the caller has the `All` scope set on the `labelsAcl:READ` capability.",
        "operationId": "documentFeedbackAggregates",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentFeedbackAggregateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentFeedbackAggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentFeedbackAcl:READ",
          "labelsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/feedback/accept": {
      "post": {
        "tags": [
          "Document feedback"
        ],
        "summary": "Accept feedback",
        "description": "Marks feedback objects as approved and performs the action contained in them.\n\nBefore you use this endpoint on feedback records, ensure the following pre-conditions are met on each of them:\n- If the `action` is `ATTACH`:\n    - the label definition needs to still [exist](#operation/listLabels) in CDF\n    - the label must not already be attached to the CDF file\n- If the `action` is `DETACH`, the label needs to be attached to the CDF file, and/or be a derived label of the document.\n\nIn case one or more preconditions are not met, the feedback object will move to the `STALE` state.\nThe action contained in the feedback record will not be performed, and this endpoint returns an error.\n\nThis endpoint requires that the caller has the `All` scope set on the `labelsAcl:READ` capability.",
        "operationId": "documentFeedbackApprove",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentFeedbackAcceptRejectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentFeedbackListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentFeedbackAcl:READ",
          "documentFeedbackAcl:DELETE",
          "labelsAcl:READ",
          "filesAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/feedback/reject": {
      "post": {
        "tags": [
          "Document feedback"
        ],
        "summary": "Reject feedback",
        "description": "Marks feedback objects as rejected, and consequently does not perform the action contained in them.",
        "operationId": "documentFeedbackReject",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentFeedbackAcceptRejectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentFeedbackListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentFeedbackAcl:READ",
          "documentFeedbackAcl:DELETE"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/preview": {
      "get": {
        "deprecated": true,
        "tags": [
          "Document preview"
        ],
        "summary": "Preview a specific file",
        "operationId": "documentsPreview",
        "description": "This endpoint returns a preview for the specified document id. The document is converted to a PNG or PDF,\ndepending on your `accept` header field. When the `accept` value is `image/png` or empty, the endpoint will\nreturn a single PNG image, respecting the `page` parameter. If you specify `application/pdf`, in the\n`accept` header, the endpoint returns the entire document as a PDF file. \n\nAny unsupported `accept` values, such as `application/json`, will yield a http 406 error.\n\nCurrently only the first 3 pages can be previewed as a PNG.",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "in": "query",
            "name": "page",
            "schema": {
              "type": "integer",
              "minimum": 0,
              "maximum": 2,
              "default": 0
            },
            "required": false,
            "description": "Page number to preview"
          },
          {
            "in": "query",
            "name": "documentId",
            "schema": {
              "type": "integer"
            },
            "required": true,
            "description": "Internal id for document to preview"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/pdf": {
                "schema": {
                  "description": "Returns the entire document, converted to PDF.",
                  "type": "string",
                  "format": "binary"
                }
              },
              "image/png": {
                "schema": {
                  "description": "Returns the given page of the document, converted to a PNG image.",
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/BadRequestErrorResponse"
          },
          "401": {
            "$ref": "#/components/responses/AuthErrorResponse"
          },
          "406": {
            "$ref": "#/components/responses/IllegalAcceptHeaderErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/UnprocessableEntityErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/preview/temporaryLink": {
      "get": {
        "deprecated": true,
        "tags": [
          "Document preview"
        ],
        "summary": "Get a temporary link to the preview of a file",
        "operationId": "documentsTemporaryPreviewLink",
        "description": "This endpoint returns a temporary link to download a preview for the specified document id. The temporary link is unauthenticated,\nexpires after 120 seconds and returns the entire document as a PDF. Calling the temporary link will time out after 60 seconds if the document preview has not been generated in that time.",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "in": "query",
            "name": "documentId",
            "schema": {
              "type": "integer"
            },
            "required": true,
            "description": "Internal id for document to preview"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsTemporaryPreviewLinkResponse"
          },
          "400": {
            "$ref": "#/components/responses/BadRequestErrorResponse"
          },
          "401": {
            "$ref": "#/components/responses/AuthErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/classifiers": {
      "post": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "Create a classifier",
        "description": "Create a document classifier which can be used to predict labels for documents.\n\nTo create a classifier, `trainingLabels` needs to be configured in the pipeline configuration object.\nDocuments attached with labels which are in the `trainingLabels` will be used as training set to create a classifier.\nCreating (or training) a classifier takes time. Depending on the size of the training set, creating a classifier can take a few minutes or more.\nBecause there is only one configuration, it is currently only possible to create a single classifier per project at a time. You can create more classifiers if there is no classifier currently being created.\nSupport for creating multiple classifiers with different configurations may be added in the future.\n\nTo set a classifier active, you need to set `activeClassifierId` in the pipeline configuration object to the id of the selecte classifier.",
        "operationId": "documentsCreateClassifiers",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsClassifierCreateItems"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsClassifiersResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:WRITE"
        ]
      },
      "get": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "List classifiers",
        "description": "Get the list of classifier objects.",
        "operationId": "documentsGetClassifiers",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsClassifiersResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/classifiers/byids": {
      "post": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "List classifiers by ids",
        "operationId": "documentsListClassifiersByids",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsClassifierListByIdsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsClassifiersResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/documents/classifiers/delete": {
      "post": {
        "tags": [
          "Document pipelines"
        ],
        "summary": "Delete classifiers",
        "operationId": "documentsDeleteClassifiers",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "description": "This endpoint lets you delete your classifiers.",
        "requestBody": {
          "description": "A list of classifier ids to delete",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentsClassifierDeleteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "documentPipelinesAcl:WRITE"
        ]
      }
    },
    "/api/playground/projects/{project}/sessions/revoke": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ],
      "post": {
        "x-capability": "sessionsAcl:DELETE",
        "tags": [
          "Sessions"
        ],
        "operationId": "revokeSessions",
        "summary": "Revoke sessions",
        "description": "Revoke access to a session.\nRevocation of a session may in some cases take up to 1 hour to take effect.\n",
        "requestBody": {
          "description": "A request containing the information needed to revoke sessions.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeSessionRequestList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of revoked sessions.\nIf the user does not have the `sessionsAcl:LIST` capability, then only the session IDs will be present in the response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionList"
                },
                "example": {
                  "items": [
                    {
                      "id": 0,
                      "type": "CLIENT_CREDENTIALS",
                      "status": "REVOKED",
                      "creationTime": 1638795554528,
                      "expirationTime": 1638795554528,
                      "clientId": 0
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/playground/projects/{project}/extpipes": {
      "get": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "List extraction pipelines",
        "description": "Returns a list of all extraction pipelines for a given project",
        "operationId": "list",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ]
      },
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Create extraction pipelines",
        "description": "Creates multiple new extraction pipelines. A maximum of 1000 extraction pipelines can be created per request.",
        "operationId": "create",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_CreateExtPipe_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:WRITE",
          "datasetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes/delete": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Delete extraction pipelines",
        "description": "Delete extraction pipelines for given list of ids and externalIds. When the extraction pipeline is deleted, all extraction pipeline runs related to the extraction pipeline are automatically deleted.",
        "operationId": "delete",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_ExtPipeId_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:WRITE",
          "datasetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes/update": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Update extraction pipelines",
        "description": "Update information for a list of extraction pipelines. Fields that are not included in the request, are not changed.",
        "operationId": "update",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_ExtPipeUpdate_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of updated extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:WRITE",
          "datasetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes/{id}": {
      "get": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Retrieve an extraction pipeline by its ID.",
        "description": "Retrieve an extraction pipeline by its ID. If you want to retrieve extraction pipelines by externalIds, use Retrieve extraction pipelines instead.",
        "operationId": "show",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/CogniteInternalId"
          }
        ],
        "responses": {
          "200": {
            "description": "Single extraction pipeline response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipe"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes/byids": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Retrieve extraction pipelines",
        "description": "Retrieves information about multiple extraction pipelines in the same project. All ids and externalIds must be unique.",
        "operationId": "byids",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExtendedItemsRequest_ExtPipeId_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes//list": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Filter extraction pipelines",
        "description": "Use advanced filtering options to find extraction pipelines.",
        "operationId": "filter",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExtPipesFilterRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes/runs": {
      "get": {
        "tags": [
          "Extraction Pipelines Runs"
        ],
        "summary": "List extraction pipeline runs",
        "description": "List of all extraction pipeline runs for a given extraction pipeline. Sorted by createdTime value with descendant order.",
        "operationId": "runs",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "name": "externalId",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response with list of extraction pipeline runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_ExtPipeRunResponse_"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionrunsAcl:READ"
        ]
      },
      "post": {
        "tags": [
          "Extraction Pipelines Runs"
        ],
        "summary": "Create extraction pipeline runs",
        "description": "Create multiple extraction pipeline runs. Current version supports one extraction pipeline run per request. Extraction pipeline runs support three statuses: success, failure, seen. The content of the Error Message parameter is configurable and will contain any messages that have been configured within the extraction pipeline.",
        "operationId": "createRuns",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_ExtPipeRunRequest_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of extraction pipeline runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_CreateExtPipeRunResponse_"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionrunsAcl:WRITE",
          "datasetsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/extpipes/runs/list": {
      "post": {
        "tags": [
          "Extraction Pipelines Runs"
        ],
        "summary": "Filter extraction pipeline runs",
        "description": "Use advanced filtering options to find extraction pipeline runs. Sorted by createdTime value with descendant order.",
        "operationId": "filterRuns",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunsFilterRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of extraction pipeline runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_ExtPipeRunResponse_"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionrunsAcl:READ"
        ]
      }
    },
    "/api/playground/projects/{project}/configuration": {
      "get": {
        "tags": [
          "Projects"
        ],
        "summary": "List project configuration properties",
        "description": "List the configuration properties for a project. These properties are in playground because we expect these properties to be temporary for project migration, and this endpoint will be removed as legacy authentication is removed.",
        "responses": {
          "200": {
            "description": "Project configuration properties",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectConfigurationProperties"
                }
              }
            }
          }
        }
      }
    },
    "/api/playground/projects/{project}/seismic/seismics/segy/{seismic_id}": {
      "get": {
        "tags": [
          "Seismic"
        ],
        "summary": "Download a seismic as a SEG-Y file",
        "description": "Retrieves a SEG-Y file containing all traces contained within the given seismic.",
        "operationId": "downloadSeismic",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          },
          {
            "$ref": "#/components/parameters/seismicId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DownloadSeismicResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "seismicAcl:READ"
        ]
      }
    }
  },
  "components": {
    "securitySchemes": {
      "api-key": {
        "type": "apiKey",
        "description": "An admin can create API keys in the Cognite console.",
        "name": "api-key",
        "in": "header"
      },
      "oidc-token": {
        "type": "http",
        "description": "Access token issued by the CDF project's configured identity provider. Access token must be an OpenID Connect token, and the project must be configured to accept OpenID Connect tokens. Use a header key of 'Authorization' with a value of 'Bearer $accesstoken'",
        "scheme": "bearer"
      },
      "token": {
        "type": "http",
        "scheme": "bearer",
        "description": "Human users log in via an OpenId/OAuth flow. Use the /login/redirect flow to obtain a bearer access token. Use a header key of 'Authorization' with a value of 'Bearer $accesstoken'"
      }
    },
    "schemas": {
      "CPURange": {
        "type": "object",
        "description": "The number of CPU cores per function exectuion (i.e. function call).",
        "required": [
          "min",
          "max",
          "default"
        ],
        "properties": {
          "min": {
            "type": "number",
            "example": 0.1,
            "description": "The minimum value you can request when creating a function."
          },
          "max": {
            "type": "number",
            "example": 0.6,
            "description": "The maximum value you can request when creating a function."
          },
          "default": {
            "type": "number",
            "example": 0.25,
            "description": "The default value when creating a function."
          }
        }
      },
      "MemoryRange": {
        "type": "object",
        "description": "The amount of available memory in GB per function execution (i.e. function call).",
        "required": [
          "min",
          "max",
          "default"
        ],
        "properties": {
          "min": {
            "type": "number",
            "example": 0.1,
            "description": "The minimum value you can request when creating a function."
          },
          "max": {
            "type": "number",
            "example": 2.5,
            "description": "The maximum value you can request when creating a function."
          },
          "default": {
            "type": "number",
            "example": 1,
            "description": "The default value when creating a function."
          }
        }
      },
      "IgnoreUnknownIdsField": {
        "type": "object",
        "properties": {
          "ignoreUnknownIds": {
            "description": "Ignore IDs that are not found",
            "type": "boolean",
            "default": false
          }
        }
      },
      "FunctionBuildError": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite Function API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 400
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not build function."
          }
        }
      },
      "FunctionErrorBasic": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite Function API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 400
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          }
        }
      },
      "FunctionCallError": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Error occuring due to user's function code.",
        "properties": {
          "trace": {
            "type": "string",
            "description": "Stack trace of exception, useful for debugging.",
            "example": "Cannot assign foo to bar."
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          }
        }
      },
      "FunctionScheduleCronExpression": {
        "type": "string",
        "example": "* * * * *",
        "maxLength": 1024,
        "description": "Cron expression describes when the function should be called. Use http://www.cronmaker.com to create a cron expression."
      },
      "FunctionScheduleDescription": {
        "type": "string",
        "example": "This is a nice schedule",
        "maxLength": 500,
        "description": "Description of function schedule."
      },
      "FunctionScheduleName": {
        "type": "string",
        "description": "Name of function schedule.",
        "example": "My schedule",
        "minLength": 1,
        "maxLength": 140
      },
      "FunctionScheduleWhen": {
        "type": "string",
        "description": "When the schedule will trigger, in human readable text.",
        "example": "Every hour"
      },
      "SessionId": {
        "description": "Id of the session.",
        "type": "string"
      },
      "FunctionName": {
        "type": "string",
        "description": "The name of the function.",
        "example": "myfunction",
        "minLength": 1,
        "maxLength": 140
      },
      "FunctionOwner": {
        "type": "string",
        "example": "user@cognite.com",
        "maxLength": 128,
        "description": "Owner of this function. Typically used to know who created it."
      },
      "FunctionId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "The ID of the function."
      },
      "FunctionExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "description": "The external ID of the function. Should be unique for the project."
      },
      "FunctionCallId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "FunctionCallIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FunctionCallId"
                },
                "maxItems": 10000,
                "minItems": 1
              }
            }
          }
        ]
      },
      "FunctionScheduleId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "The ID of the function schedule."
      },
      "FunctionIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FunctionId"
          },
          {
            "$ref": "#/components/schemas/FunctionExternalId"
          }
        ]
      },
      "FunctionScheduleIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      ]
                    }
                  }
                },
                "maxItems": 10000,
                "minItems": 1
              }
            }
          }
        ]
      },
      "FunctionCallStatus": {
        "type": "string",
        "description": "Status of the function call.",
        "enum": [
          "Running",
          "Completed",
          "Failed",
          "Timeout"
        ],
        "example": "Running"
      },
      "FunctionStatus": {
        "type": "string",
        "enum": [
          "Queued",
          "Deploying",
          "Ready",
          "Failed"
        ],
        "example": "Queued",
        "description": "Status of the function. It starts in a Queued state, is then Deploying before it is either Ready or Failed. If the function is Ready, it can be called."
      },
      "FunctionListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          }
        ]
      },
      "LimitList": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to be returned.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "default": 100
          }
        }
      },
      "FunctionFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionFilter",
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FunctionName"
              },
              "owner": {
                "$ref": "#/components/schemas/FunctionOwner"
              },
              "fileId": {
                "$ref": "#/components/schemas/FunctionFileId"
              },
              "status": {
                "$ref": "#/components/schemas/FunctionStatus"
              },
              "externalIdPrefix": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "metadata": {
                "$ref": "#/components/schemas/MetaData"
              }
            }
          }
        }
      },
      "FunctionCallFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionCallFilter",
            "type": "object",
            "properties": {
              "scheduleId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "status": {
                "$ref": "#/components/schemas/FunctionCallStatus"
              },
              "startTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "endTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              }
            },
            "description": ""
          }
        }
      },
      "FunctionCallListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionCallFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "FunctionScheduleFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionScheduleFilter",
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FunctionScheduleName"
              },
              "FunctionId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "FunctionExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "cronExpression": {
                "$ref": "#/components/schemas/FunctionScheduleCronExpression"
              }
            },
            "description": ""
          }
        }
      },
      "FunctionScheduleScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionScheduleFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          }
        ]
      },
      "FunctionScheduleIdArray": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 10,
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/FunctionScheduleId"
            }
          }
        }
      },
      "FunctionIdEitherList": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "maxItems": 10,
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/FunctionIdEither"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FunctionSchedule": {
        "allOf": [
          {
            "title": "Funtion Schedule",
            "type": "object",
            "description": "",
            "properties": {
              "id": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                ],
                "readOnly": true
              },
              "name": {
                "$ref": "#/components/schemas/FunctionScheduleName"
              },
              "createdTime": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EpochTimestamp"
                  }
                ],
                "readOnly": true
              },
              "description": {
                "$ref": "#/components/schemas/FunctionScheduleDescription"
              },
              "cronExpression": {
                "$ref": "#/components/schemas/FunctionScheduleCronExpression"
              },
              "when": {
                "$ref": "#/components/schemas/FunctionScheduleWhen"
              },
              "functionId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "functionExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "sessionId": {
                "$ref": "#/components/schemas/SessionId"
              },
              "data": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/data"
                  }
                ],
                "writeOnly": true
              },
              "nonce": {
                "$ref": "#/components/schemas/nonce"
              }
            }
          }
        ],
        "required": [
          "id",
          "name",
          "createdTime",
          "cronExpression",
          "when",
          "sessionId"
        ]
      },
      "FunctionCallLogEntry": {
        "title": "FunctionCallLogEntry",
        "type": "object",
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "message": {
            "type": "string",
            "description": "Single line from stdout / stderr.",
            "example": "Did something great"
          }
        }
      },
      "FunctionCall": {
        "title": "FunctionCall",
        "type": "object",
        "required": [
          "id",
          "status",
          "startTime",
          "functionId"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "status": {
            "$ref": "#/components/schemas/FunctionCallStatus"
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "error": {
            "$ref": "#/components/schemas/FunctionCallError"
          },
          "scheduleId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "functionId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "scheduledTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "FunctionCalls": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          }
        }
      },
      "FunctionCallsWithCursor": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "FunctionDeleteRequest": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "maxItems": 10,
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/FunctionIdEither"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FunctionCallRequest": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/data"
          },
          "nonce": {
            "$ref": "#/components/schemas/nonce"
          }
        }
      },
      "FunctionFileId": {
        "description": "The file ID to a file uploaded to Cognite's Files API. This file must be a zip file and contain a file called `handler.py` in the root folder (unless otherwise specified in the `functionPath` argument). This file must contain a function named `handle` with any of the following arguments: `data`, `client`, `secrets` and `function_call_info`, which are passed into the function. The zip file can contain other files as well (model binary data, libraries etc).\n\nCustom packages can be pip installed by providing a requirements.txt file in the root of the zip file. The latest version of the Cognite Python SDK is automatically installed. If a specific version is needed, please specify this in the requirements.txt file.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "MetaData": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32, value 512 characters, up to 16 key-value pairs. Maximum size of entire metadata is 4096 bytes."
      },
      "Function": {
        "type": "object",
        "required": [
          "id",
          "createdTime",
          "status",
          "name",
          "fileId"
        ],
        "properties": {
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "readOnly": true
          },
          "createdTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ],
            "readOnly": true,
            "example": 123455234
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionStatus"
              }
            ],
            "readOnly": true
          },
          "name": {
            "$ref": "#/components/schemas/FunctionName"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "fileId": {
            "$ref": "#/components/schemas/FunctionFileId"
          },
          "owner": {
            "$ref": "#/components/schemas/FunctionOwner"
          },
          "description": {
            "type": "string",
            "example": "My fantastic function with advanced ML",
            "maxLength": 500,
            "description": "Description of the function."
          },
          "metadata": {
            "$ref": "#/components/schemas/MetaData"
          },
          "apiKey": {
            "type": "string",
            "description": "(Deprecated) API key that can be used inside the function to access data in CDF. This is deprecated and will be replaced by OIDC tokens. With OIDC tokens, a session is created on behalf of the user/service principal at the point when either (1) the function is called directly, or (2) when a schedule is created for the function.",
            "maxLength": 50,
            "example": "***"
          },
          "secrets": {
            "type": "object",
            "description": "Object with additional secrets as key/value pairs. These can e.g. password to simulators or other data sources. Keys must be lowercase characters, numbers or dashes (-) and at most 15 characters. You can create at most 30 secrets, all keys must be unique, and cannot be `apikey`, `indexUrl` or `extraIndexUrls`.",
            "maxProperties": 30,
            "example": {
              "MySecret": "***"
            }
          },
          "functionPath": {
            "type": "string",
            "example": "myfunction/handler.py",
            "maxLength": 500,
            "description": "Relative path from the root folder to the file containing the `handle` function. Defaults to `handler.py`. Must be on POSIX path format."
          },
          "envVars": {
            "type": "object",
            "description": "Object with environment variables as key/value pairs. Keys can contain only letters, numbers or the underscore character. You can create at most 100 environment variables.",
            "maxProperties": 100,
            "example": {
              "MyKey": "MyValue"
            }
          },
          "cpu": {
            "type": "number",
            "format": "float",
            "example": 0.25,
            "description": "Number of CPU cores per function (not available in Azure). Defaults to 0.25. Allowed values are in the range [0.1, 0.6]."
          },
          "memory": {
            "type": "number",
            "format": "float",
            "example": 1,
            "description": "Memory per function measured in GB (not available in Azure). Defaults to 1. Allowed values are in the range [0.1, 2.5]."
          },
          "runtime": {
            "type": "string",
            "example": "py38",
            "default": "py38",
            "enum": [
              "py37",
              "py38",
              "py39"
            ],
            "description": "The runtime of the function. For exmple, runtime \"py38\" translates to the latest version of the Python 3.8 series."
          },
          "runtimeVersion": {
            "type": "string",
            "example": "Python 3.8.13",
            "readOnly": true,
            "description": "The complete specification of the function runtime with major, minor and patch version numbers."
          },
          "error": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionBuildError"
              }
            ],
            "readOnly": true
          },
          "indexUrl": {
            "description": "Specify a different python package index, allowing for packages published in private repositories.\nSupports basic HTTP authentication as described in [pip basic authentication](https://pip.pypa.io/en/stable/topics/authentication/#basic-http-authentication).\nSee the\n[documentation](https://docs.cognite.com/cdf/functions/#additional-arguments)\nfor additional information related to the security risks of using this\noption. ",
            "example": "https://username:password@pypi.company.com/simple",
            "type": "string",
            "writeOnly": true
          },
          "extraIndexUrls": {
            "description": "Extra package index URLs to use when building the function, allowing for packages published in private repositories.\nSupports basic HTTP authentication as described in [pip basic\nauthentication](https://pip.pypa.io/en/stable/topics/authentication/#basic-http-authentication).\nSee the\n[documentation](https://docs.cognite.com/cdf/functions/#additional-arguments)\nfor additional information related to the security risks of using this\noption. ",
            "example": [
              "https://username:password@pypi.company.com/simple",
              "https://token@pypi.company.com/simple",
              "https://pypi.company.com/simple"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "writeOnly": true
          }
        }
      },
      "data": {
        "type": "object",
        "description": "Input data to the function. This data is passed deserialized into the function through one of the arguments called `data`. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.'",
        "example": {
          "timeSeriesId1": 13435351,
          "maxValue": 4
        }
      },
      "nonce": {
        "type": "string",
        "description": "Nonce retrieved from sessions API when creating a session. This will be used to bind the session before executing the function.",
        "writeOnly": true
      },
      "CreatedTime": {
        "type": "integer",
        "description": "The creation time of the resource, in milliseconds since January 1, 1970 at 00:00 UTC.",
        "format": "int64",
        "example": 0,
        "readOnly": true
      },
      "ExperimentalRevisionIdList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentalRevisionId"
            },
            "minItems": 1,
            "maxItems": 1
          }
        }
      },
      "ExperimentalRevisionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentalRevision"
            }
          }
        }
      },
      "ExperimentalRevision": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the revision.",
            "format": "int64",
            "example": 1000
          },
          "fileId": {
            "type": "integer",
            "description": "The file id.",
            "format": "int64",
            "example": 1000
          },
          "published": {
            "type": "boolean",
            "description": "True if the revision is marked as published.",
            "default": false
          },
          "rotation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            }
          },
          "camera": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          },
          "status": {
            "type": "string",
            "enum": [
              "Queued",
              "Processing",
              "Done",
              "Failed"
            ],
            "description": "The status of the revision.",
            "example": "Done"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          },
          "thumbnailThreedFileId": {
            "type": "integer",
            "description": "The threed file ID of a thumbnail for the revision. Use /3d/files/{id} to retrieve the file.",
            "format": "int64",
            "example": 1000
          },
          "thumbnailURL": {
            "type": "string",
            "description": "The URL of a thumbnail for the revision.",
            "example": "https://api.cognitedata.com/api/v1/project/myproject/3d/files/1000"
          },
          "assetMappingCount": {
            "type": "integer",
            "description": "The number of asset mappings for this revision.",
            "format": "int64",
            "example": 0
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "walkablePathFiles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VersionedThreedFile"
            }
          }
        }
      },
      "ExperimentalCreateRevisionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentalCreateRevision"
            }
          }
        }
      },
      "ExperimentalCreateRevision": {
        "type": "object",
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "The ID of the model this revision is for.",
            "format": "int64",
            "example": 1000
          },
          "fileId": {
            "type": "integer",
            "description": "The file id.",
            "format": "int64",
            "example": 1000
          },
          "published": {
            "type": "boolean",
            "description": "True if the revision is marked as published.",
            "default": false
          },
          "rotation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            }
          },
          "camera": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          },
          "creationParams": {
            "type": "object",
            "properties": {
              "walkablePath": {
                "type": "boolean",
                "description": "Set to generate walkable path files for this revision",
                "default": false
              }
            }
          }
        }
      },
      "VersionedThreedFile": {
        "type": "object",
        "properties": {
          "version": {
            "type": "integer",
            "description": "The version of the filetype in question",
            "format": "int64",
            "example": 1
          },
          "fileId": {
            "type": "integer",
            "description": "The id to use against the 3d file endpoint to get access to the refered file.",
            "format": "int64",
            "example": 12345654321
          }
        }
      },
      "ExperimentalRevisionId": {
        "type": "object",
        "properties": {
          "modelId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "revisionId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "RevisionCameraProperties": {
        "type": "object",
        "properties": {
          "target": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "description": "Initial camera target.",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "position": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "description": "Initial camera position.",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "description": "Initial camera position and target."
      },
      "RaycastRequest": {
        "type": "object",
        "description": "Set of raycasting queries on a model",
        "required": [
          "modelId",
          "items",
          "tolerance"
        ],
        "properties": {
          "model": {
            "description": "Internal or external identifier of the model",
            "$ref": "#/components/schemas/DataIdentifier"
          },
          "tolerance": {
            "type": "number",
            "format": "double",
            "description": "How far away the ray can be from a point in order for it to be considdered a hit."
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RaycastRequestItems"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "RaycastRequestItems": {
        "type": "object",
        "required": [
          "origin",
          "direction"
        ],
        "example": {
          "origin": {
            "x": 0,
            "y": 0,
            "z": 0
          },
          "direction": {
            "x": 1,
            "y": 1,
            "z": 1
          }
        },
        "properties": {
          "origin": {
            "$ref": "#/components/schemas/Point3D"
          },
          "direction": {
            "$ref": "#/components/schemas/Point3D"
          }
        }
      },
      "RayCastResultList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Point3D"
            }
          }
        }
      },
      "CropboxRequest": {
        "type": "object",
        "description": "Cropbox request",
        "required": [
          "modelId",
          "boundingBox"
        ],
        "properties": {
          "model": {
            "description": "Internal or external identifier of the model",
            "$ref": "#/components/schemas/DataIdentifier"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          },
          "maxDepth": {
            "type": "integer",
            "format": "int64"
          },
          "maxNumberOfPoints": {
            "type": "integer",
            "format": "int64"
          },
          "format": {
            "type": "string"
          }
        }
      },
      "PathTransitQuery": {
        "type": "object",
        "description": "Set of transit queries on a model",
        "required": [
          "modelId",
          "items"
        ],
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "model to find path in"
          },
          "walkableAreaOverride": {
            "$ref": "#/components/schemas/WalkableAreaOverride"
          },
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathTransitRequest"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "PathTransitRequest": {
        "type": "object",
        "required": [
          "from",
          "to"
        ],
        "properties": {
          "from": {
            "$ref": "#/components/schemas/PathRequestItem"
          },
          "to": {
            "$ref": "#/components/schemas/PathRequestItem"
          },
          "movingObjectSize": {
            "$ref": "#/components/schemas/PathRequestObjectSize"
          }
        }
      },
      "PathRoundtripRequest": {
        "type": "object",
        "required": [
          "modelId",
          "base",
          "visit"
        ],
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "The model to do the pathfinding on",
            "format": "int64"
          },
          "walkableAreaOverride": {
            "$ref": "#/components/schemas/WalkableAreaOverride"
          },
          "base": {
            "$ref": "#/components/schemas/PathRequestItem"
          },
          "visit": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathRequestItem"
            },
            "minItems": 1,
            "maxItems": 10
          },
          "movingObjectSize": {
            "$ref": "#/components/schemas/PathRequestObjectSize"
          }
        }
      },
      "PathRequestItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/Point3D"
          },
          {
            "$ref": "#/components/schemas/NodeId"
          }
        ]
      },
      "NodeId": {
        "type": "object",
        "required": [
          "nodeId"
        ],
        "properties": {
          "nodeId": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "PathRequestObjectSize": {
        "type": "object",
        "description": "Optional object size. If not set, assumes height 2.10 and diameter 0.50",
        "required": [
          "diameter",
          "height"
        ],
        "properties": {
          "diameter": {
            "type": "number",
            "format": "double"
          },
          "height": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "WalkableAreaOverride": {
        "type": "object",
        "properties": {
          "blockers": {
            "$ref": "#/components/schemas/PathBlocker"
          },
          "passages": {
            "$ref": "#/components/schemas/PathPassage"
          }
        }
      },
      "PathBlocker": {
        "type": "object",
        "properties": {
          "minX": {
            "type": "number",
            "format": "double"
          },
          "minY": {
            "type": "number",
            "format": "double"
          },
          "minZ": {
            "type": "number",
            "format": "double"
          },
          "maxX": {
            "type": "number",
            "format": "double"
          },
          "maxY": {
            "type": "number",
            "format": "double"
          },
          "maxZ": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "PathPassage": {
        "type": "object",
        "required": [
          "point1",
          "point2"
        ],
        "properties": {
          "point1": {
            "$ref": "#/components/schemas/Point3D"
          },
          "point2": {
            "$ref": "#/components/schemas/Point3D"
          },
          "weight": {
            "type": "number",
            "format": "double",
            "default": 1,
            "description": "Factor multiplied with distance to determine cost of using path."
          }
        }
      },
      "PathResultList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathResult"
            }
          }
        }
      },
      "PathResult": {
        "type": "object",
        "properties": {
          "segments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PathSegment"
            }
          }
        }
      },
      "PathSegment": {
        "type": "object",
        "description": "The path from one object to the next",
        "properties": {
          "sourceIndex": {
            "type": "integer",
            "format": "int64",
            "example": 0
          },
          "destinationIndex": {
            "type": "integer",
            "format": "int64",
            "example": 1
          },
          "path": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Point3D"
            }
          }
        }
      },
      "Point3D": {
        "type": "object",
        "required": [
          "x",
          "y",
          "z"
        ],
        "properties": {
          "x": {
            "type": "number",
            "format": "double"
          },
          "y": {
            "type": "number",
            "format": "double"
          },
          "z": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "Metadata3D": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
        "additionalProperties": {
          "type": "string"
        }
      },
      "NextCursorData": {
        "type": "object",
        "properties": {
          "nextCursor": {
            "type": "string"
          }
        }
      },
      "DataIdentifier": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "type": "string"
              }
            }
          }
        ]
      },
      "Model3D": {
        "type": "object",
        "required": [
          "id",
          "name",
          "source",
          "createdTime"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "externalId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "source": {
            "$ref": "#/components/schemas/Model3DSource"
          },
          "options": {
            "type": "object"
          },
          "createdTime": {
            "type": "integer",
            "format": "int64"
          },
          "status": {
            "type": "string",
            "enum": [
              "None",
              "Queued",
              "Processing",
              "Done",
              "Failed"
            ]
          }
        }
      },
      "Model3DSource": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "fileId"
            ],
            "properties": {
              "fileId": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "fileIds"
            ],
            "properties": {
              "fileIds": {
                "type": "array",
                "items": {
                  "type": "integer",
                  "format": "int64"
                }
              }
            }
          }
        ]
      },
      "Model3DPipeline": {
        "type": "object",
        "required": [
          "stages"
        ],
        "properties": {
          "stages": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string"
                },
                "after": {
                  "type": "string"
                },
                "status": {
                  "type": "string",
                  "enum": [
                    "None",
                    "Queued",
                    "Processing",
                    "Done",
                    "Failed"
                  ]
                }
              }
            }
          }
        }
      },
      "Model3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3D"
            }
          }
        }
      },
      "Model3DUpdate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataIdentifier"
          },
          {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/SetModel3DNameField"
                  },
                  "externalId": {
                    "$ref": "#/components/schemas/UpdateExternalId"
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/ObjectPatch"
                  }
                }
              }
            }
          }
        ]
      },
      "UpdateExternalId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "set",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "type": "string"
              }
            }
          },
          {
            "title": "remove",
            "type": "object",
            "required": [
              "setNull"
            ],
            "properties": {
              "setNull": {
                "type": "boolean",
                "example": true
              }
            }
          }
        ]
      },
      "SetModel3DNameField": {
        "type": "object",
        "properties": {
          "set": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          }
        }
      },
      "Model3DUpdateList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DUpdate"
            }
          }
        }
      },
      "Model3DUpload": {
        "type": "object",
        "required": [
          "name",
          "source"
        ],
        "properties": {
          "externalId": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "source": {
            "$ref": "#/components/schemas/Model3DSource"
          },
          "options": {
            "type": "object"
          }
        }
      },
      "Model3DOutputRequestList": {
        "type": "object",
        "required": [
          "models"
        ],
        "properties": {
          "models": {
            "description": "Array of model identifiers to list outputs for",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "model": {
                  "description": "Internal or external identifier of a model",
                  "$ref": "#/components/schemas/DataIdentifier"
                }
              }
            },
            "example": [
              {
                "id": 10
              },
              {
                "externalId": "my-unique-model-id"
              }
            ]
          },
          "formats": {
            "description": "A list of named output formats to retrieve. Omit parameter to return list of public formats.",
            "example": [
              "ept-pointcloud"
            ],
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "Model3DOutputResponseList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "description": "One item per model in the request payload.",
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "model",
                "outputs"
              ],
              "properties": {
                "model": {
                  "allOf": [
                    {
                      "description": "Internal or external identifier of a model"
                    },
                    {
                      "$ref": "#/components/schemas/DataIdentifier"
                    }
                  ]
                },
                "outputs": {
                  "description": "A list of named and versioned outputs for the model. Note that the list is not sorted.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "format",
                      "version",
                      "blobId"
                    ],
                    "properties": {
                      "format": {
                        "description": "Format identifier, e.g. 'ept-pointcloud' (point cloud).",
                        "example": "ept-pointcloud",
                        "type": "string"
                      },
                      "version": {
                        "description": "Version of the output format, starting at 1.",
                        "example": 1,
                        "type": "integer"
                      },
                      "blobId": {
                        "description": "Reference to blob containing output. Blob can either be a single file or folder.",
                        "$ref": "#/components/schemas/CogniteInternalId"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "Model3DUploadList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DUpload"
            }
          }
        }
      },
      "Node3D": {
        "type": "object",
        "required": [
          "id",
          "treeIndex",
          "subtreeSize",
          "depth",
          "name"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1000
          },
          "treeIndex": {
            "type": "integer",
            "minimum": 0,
            "description": "The index of the node in the 3D model hierarchy, starting from 0. The tree is traversed in a depth-first order.",
            "format": "int64",
            "example": 3
          },
          "parentId": {
            "type": "integer",
            "description": "The parent of the node, null if it is the root node.",
            "format": "int64",
            "example": 2
          },
          "depth": {
            "type": "integer",
            "description": "The depth of the node in the tree, starting from 0 at the root node.",
            "format": "int64",
            "example": 2
          },
          "name": {
            "type": "string",
            "description": "The name of the node.",
            "example": "Node name"
          },
          "subtreeSize": {
            "type": "integer",
            "description": "The number of descendants of the node, plus one (counting itself).",
            "format": "int64",
            "example": 4
          },
          "properties": {
            "$ref": "#/components/schemas/Node3DProperties"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          }
        }
      },
      "Node3DFilter": {
        "type": "object",
        "description": "Property specification in filter, with property categories containing a list of filter values for each property.",
        "example": {
          "PDMS": {
            "Area": [
              "AB76",
              "AB77",
              "AB78"
            ],
            "Type": [
              "PIPE",
              "BEND",
              "PIPESUP"
            ]
          }
        }
      },
      "Node3DProperties": {
        "type": "object",
        "description": "Properties extracted from 3D model, with property categories containing key/value string pairs.",
        "example": {
          "PDMS": {
            "Area": "AB78",
            "Type": "PIPE"
          }
        }
      },
      "Node3DListWithCursorResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Node3DList"
          },
          {
            "$ref": "#/components/schemas/NextCursorData"
          }
        ]
      },
      "Node3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Node3D"
            }
          }
        }
      },
      "Node3DFilterBody": {
        "type": "object",
        "required": [
          "filters"
        ],
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/Node3DFilter"
          }
        }
      },
      "Node3DBoundingBoxFilterBody": {
        "type": "object",
        "required": [
          "boundingBox"
        ],
        "properties": {
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          },
          "fullyContainedOnly": {
            "type": "boolean",
            "example": true,
            "description": "Determines whether to only include nodes within the bounding box or not. Set to `true` to retrieve nodes that are fully inside the query bounding box. Set to `false` to retrieve nodes with a bounding box that intersects the query bounding box."
          }
        }
      },
      "Model3DOutput": {
        "type": "object",
        "required": [
          "versions"
        ],
        "properties": {
          "versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DOutputVersion"
            }
          }
        }
      },
      "Model3DOutputVersion": {
        "type": "object",
        "required": [
          "version",
          "blobs"
        ],
        "properties": {
          "version": {
            "type": "integer",
            "format": "int64"
          },
          "blobs": {
            "type": "object",
            "additionalProperties": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "Sector3D": {
        "type": "object",
        "required": [
          "id",
          "path",
          "depth"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "parentId": {
            "type": "integer",
            "format": "int64"
          },
          "path": {
            "type": "string"
          },
          "depth": {
            "type": "integer",
            "format": "int64"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          },
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3DOutput"
            }
          }
        }
      },
      "BoundingBox3D": {
        "type": "object",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "min": {
            "type": "array",
            "minLength": 3,
            "maxLength": 3,
            "example": [
              0,
              1,
              2
            ],
            "items": {
              "type": "number"
            }
          },
          "max": {
            "type": "array",
            "minLength": 3,
            "maxLength": 3,
            "example": [
              3,
              4,
              5
            ],
            "items": {
              "type": "number"
            }
          }
        }
      },
      "CogniteExternalIdPrefix": {
        "description": "Filter by this (case-sensitive) prefix for the external ID.",
        "type": "string",
        "maxLength": 255,
        "example": "my.known.prefix"
      },
      "DataLong": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "example": [
              23872937137,
              1238712837,
              128371973
            ],
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "Error": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code",
            "format": "int32",
            "example": 401
          },
          "message": {
            "type": "string",
            "description": "Error message",
            "example": "Could not authenticate."
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "ArrayPatchLongSet": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "ArrayPatchLongAddOrRemove": {
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "ArrayPatchLong": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ArrayPatchLongSet"
          },
          {
            "$ref": "#/components/schemas/ArrayPatchLongAddOrRemove"
          }
        ],
        "description": "Change that will be applied to the array object."
      },
      "SinglePatchBoolean": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        }
      },
      "ObjectPatch": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemove"
          }
        ]
      },
      "ObjectPatchSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchEvent": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated event: Maximum length of key is 128 bytes, value 128000 bytes, up to 256 key-value pairs, of total size at most 200000.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchEventSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchEventAddRemove"
          }
        ]
      },
      "ObjectPatchEventSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 128000
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 200000,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchEventAddRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 128000
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 200000,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "JsonArrayInt64": {
        "type": "string",
        "format": "jsonArray(int64)",
        "example": [
          1238712837,
          238712361376,
          23786237623
        ]
      },
      "JsonArrayString": {
        "type": "string",
        "format": "jsonArray(string)"
      },
      "EpochTimestamp": {
        "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
        "type": "integer",
        "minimum": 0,
        "format": "int64",
        "example": 1638795554528
      },
      "EpochTimestampRange": {
        "description": "Range between two timestamps.",
        "type": "object",
        "properties": {
          "max": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "min": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "Partition": {
        "type": "object",
        "properties": {
          "partition": {
            "description": "Splits the data set into N partitions.\nYou need to follow the cursors within each partition in order to receive all the data.\nExample: 1/10\n",
            "type": "string",
            "example": "1/10"
          }
        }
      },
      "CogniteInternalId": {
        "description": "A server-generated ID for the object.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "Version": {
        "description": "A server-generated ID for the object.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "CogniteExternalId": {
        "description": "External Id provided by client. Should be unique within a given project/resource combination.",
        "type": "string",
        "maxLength": 255
      },
      "InternalIdList": {
        "type": "object",
        "required": [
          "internalIds"
        ],
        "properties": {
          "internalIds": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "ExternalIdList": {
        "type": "object",
        "required": [
          "externalIds"
        ],
        "properties": {
          "externalIds": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        }
      },
      "ResourceType": {
        "type": "string",
        "enum": [
          "asset",
          "event",
          "timeseries",
          "sequence"
        ]
      },
      "ResourceInternalId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "resourceType": {
            "$ref": "#/components/schemas/ResourceType"
          },
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "ResourceExternalId": {
        "type": "object",
        "properties": {
          "resourceType": {
            "$ref": "#/components/schemas/ResourceType"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "ResourceIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ResourceInternalId"
          },
          {
            "$ref": "#/components/schemas/ResourceExternalId"
          }
        ]
      },
      "Cursor": {
        "type": "object",
        "properties": {
          "cursor": {
            "description": "Cursor for paging through results.",
            "type": "string"
          }
        }
      },
      "Limit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to return.",
            "type": "integer",
            "default": 100,
            "minimum": 1,
            "maximum": 1000
          }
        }
      },
      "ExternalIdPrefixFilter": {
        "description": "filter external ids starting with the prefix specified",
        "type": "string",
        "maxLength": 255
      },
      "CountAggregateResult": {
        "description": "Count aggregation result.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "description": "Number of items in this aggregation group.",
                  "format": "int64"
                }
              }
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 10
            }
          ]
        }
      },
      "StringValue": {
        "description": "A unique string value in the field.",
        "type": "object",
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "IntegerValue": {
        "description": "A unique integer value in the field.",
        "type": "object",
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "ValuesAggregateResult": {
        "description": "Values aggregation result.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "allOf": [
                {
                  "type": "object",
                  "required": [
                    "count"
                  ],
                  "properties": {
                    "count": {
                      "description": "Number of items in this aggregation group.",
                      "type": "integer",
                      "format": "int64"
                    }
                  }
                },
                {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/StringValue"
                    },
                    {
                      "$ref": "#/components/schemas/IntegerValue"
                    }
                  ]
                }
              ]
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 5,
              "value": "value_1"
            },
            {
              "count": 10,
              "value": "value_2"
            }
          ]
        }
      },
      "AggregateResult": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/CountAggregateResult"
          },
          {
            "$ref": "#/components/schemas/ValuesAggregateResult"
          }
        ]
      },
      "ResourceDescription": {
        "type": "string",
        "description": "The description of the resource type.",
        "maxLength": 500
      },
      "ObjectPatchAsset": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated asset: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSetAsset"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemoveAsset"
          }
        ]
      },
      "ObjectPatchSetAsset": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemoveAsset": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchDataSet": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated asset: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSetDataSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemoveDataSet"
          }
        ]
      },
      "ObjectPatchSetDataSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemoveDataSet": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchStringSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchStringAddOrRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchString": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ArrayPatchStringSet"
          },
          {
            "$ref": "#/components/schemas/ArrayPatchStringAddOrRemove"
          }
        ],
        "description": "Change that will be applied to the array."
      },
      "IsNull": {
        "type": "object",
        "properties": {
          "isNull": {
            "type": "boolean",
            "example": true,
            "description": "Set to true if you want to search for data with field value not set, false to search for cases where some value is present."
          }
        }
      },
      "PartitionObject": {
        "type": "object",
        "properties": {
          "partition": {
            "$ref": "#/components/schemas/Partition"
          }
        }
      },
      "SetLongField": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SetStringField": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "string"
          }
        }
      },
      "SetIntegerField": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "integer"
          }
        }
      },
      "SetBooleanField": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        }
      },
      "GeoLocationFilter": {
        "description": "Only include files matching the specified geographic relation.",
        "type": "object",
        "required": [
          "relation",
          "shape"
        ],
        "properties": {
          "relation": {
            "type": "string",
            "enum": [
              "INTERSECTS",
              "DISJOINT",
              "WITHIN"
            ],
            "description": "One of the supported queries."
          },
          "shape": {
            "type": "object",
            "description": "Represents the points, curves and surfaces in the coordinate space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/Point"
              },
              {
                "$ref": "#/components/schemas/LineString"
              },
              {
                "$ref": "#/components/schemas/Polygon"
              },
              {
                "$ref": "#/components/schemas/MultiLineString"
              },
              {
                "$ref": "#/components/schemas/MultiPolygon"
              }
            ],
            "discriminator": {
              "propertyName": "type"
            }
          }
        }
      },
      "GeoLocationGeometry": {
        "type": "object",
        "required": [
          "type"
        ],
        "description": "Represents the points, curves and surfaces in the coordinate space.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Point"
          },
          {
            "$ref": "#/components/schemas/LineString"
          },
          {
            "$ref": "#/components/schemas/Polygon"
          },
          {
            "$ref": "#/components/schemas/MultiPoint"
          },
          {
            "$ref": "#/components/schemas/MultiLineString"
          },
          {
            "$ref": "#/components/schemas/MultiPolygon"
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "Point": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Point"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/PointCoordinates"
          }
        }
      },
      "PointCoordinates": {
        "description": "Coordinates of a point in 2D space, described as an array of 2 numbers.\n\nExample: `[4.306640625, 60.205710352530346]`\n",
        "type": "array",
        "minItems": 2,
        "maxItems": 2,
        "items": {
          "type": "number"
        }
      },
      "LineString": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "LineString"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/LineStringCoordinates"
          }
        }
      },
      "LineStringCoordinates": {
        "description": "Coordinates of a line described by a list of two or more points.\nEach point is defined as a pair of two numbers in an array, representing coordinates of a point in 2D space.\n\nExample: `[[30, 10], [10, 30], [40, 40]]`\n",
        "type": "array",
        "minItems": 2,
        "items": {
          "$ref": "#/components/schemas/PointCoordinates"
        }
      },
      "Polygon": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Polygon"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/PolygonCoordinates"
          }
        }
      },
      "PolygonCoordinates": {
        "description": "List of one or more linear rings representing a shape.\n\nA linear ring is the boundary of a surface or the boundary of a hole in a surface. It is defined as a list consisting of 4 or more Points, where the first and last Point is equivalent.\n\nEach Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]], [[20, 30], [35, 35], [30, 20], [20, 30]]]`\n",
        "type": "array",
        "minItems": 2,
        "items": {
          "$ref": "#/components/schemas/LineStringCoordinates"
        }
      },
      "MultiPoint": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "MultiPoint"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiPointCoordinates"
          }
        }
      },
      "MultiPointCoordinates": {
        "description": "List of Points. Each Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[35, 10], [45, 45]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PointCoordinates"
        }
      },
      "MultiLineString": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "MultiLineString"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiLineStringCoordinates"
          }
        }
      },
      "MultiLineStringCoordinates": {
        "description": "List of lines where each line (LineString) is defined as a list of two or more points.\nEach point is defined as a pair of two numbers in an array, representing coordinates of a point in 2D space.\n\nExample: `[[[30, 10], [10, 30]], [[35, 10], [10, 30], [40, 40]]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/LineStringCoordinates"
        }
      },
      "MultiPolygon": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "MultiPolygon"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiPolygonCoordinates"
          }
        }
      },
      "MultiPolygonCoordinates": {
        "description": "List of multiple polygons.\n\nEach polygon is defined as a list of one or more linear rings representing a shape.\n\nA linear ring is the boundary of a surface or the boundary of a hole in a surface. It is defined as a list consisting of 4 or more Points, where the first and last Point is equivalent.\n\nEach Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[[[30, 20], [45, 40], [10, 40], [30, 20]]], [[[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PolygonCoordinates"
        }
      },
      "GeoLocation": {
        "description": "Geographic metadata.",
        "required": [
          "type",
          "geometry"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Feature"
            ],
            "description": "One of the GeoJSON types. Currently only the 'Feature' type is supported."
          },
          "geometry": {
            "$ref": "#/components/schemas/GeoLocationGeometry"
          },
          "properties": {
            "type": "object",
            "description": "Additional properties in a String key -> Object value format."
          }
        }
      },
      "SinglePatchGeoLocation": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetGeoLocation"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the geoLocation, or remove the value."
      },
      "SetGeoLocation": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/GeoLocation"
          }
        }
      },
      "RemoveField": {
        "title": "remove",
        "type": "object",
        "required": [
          "setNull"
        ],
        "properties": {
          "setNull": {
            "type": "boolean",
            "example": true
          }
        }
      },
      "SetExternalId": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "SetDataSetId": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/DataSetId"
          }
        }
      },
      "SetDescription": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ResourceDescription"
          }
        }
      },
      "SinglePatchResourceDescription": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDescription"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchDataSetId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDataSetId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchExternalId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetExternalId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the externalId, or remove the value. Must be unique for the resource type."
      },
      "SinglePatchLong": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetLongField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the long, or remove the value."
      },
      "ModifyPatchInteger": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetIntegerField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the integer, or remove the value"
      },
      "ModifyPatchBoolean": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetBooleanField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the boolean, or remove the value"
      },
      "SinglePatchString": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetStringField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the string, or remove the value."
      },
      "SinglePatchRequiredString": {
        "title": "set",
        "type": "object",
        "properties": {
          "set": {
            "type": "string"
          }
        },
        "description": "Set a new value for the string.",
        "required": [
          "set"
        ]
      },
      "DataSetInternalId": {
        "type": "object",
        "title": "DataSetInternalId",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DataSetExternalId": {
        "type": "object",
        "title": "DataSetExternalId",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "DataSetIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DataSetInternalId"
          },
          {
            "$ref": "#/components/schemas/DataSetExternalId"
          }
        ]
      },
      "DataSetIdEithers": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/DataSetIdEither"
        }
      },
      "DataSetId": {
        "description": "The dataSet Id for the item.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "TimestampOrStringStart": {
        "oneOf": [
          {
            "type": "integer",
            "default": 0
          },
          {
            "type": "string"
          }
        ],
        "description": "Get datapoints starting from, and including, this time. The format is N[timeunit]-ago where\ntimeunit is w,d,h,m,s. Example: '2d-ago' gets datapoints that are up to 2 days\nold. You can also specify time in milliseconds since epoch. Note that for aggregates, the start time is rounded down to a whole granularity unit (in UTC timezone). Daily granularities (d)\nare rounded to 0:00 AM; hourly granularities (h) to the start of the hour, etc."
      },
      "TimestampOrStringEnd": {
        "oneOf": [
          {
            "type": "integer"
          },
          {
            "type": "string",
            "default": "now"
          }
        ],
        "description": "Get datapoints up to, but excluding, this point in time. Same format as for start. Note that when using aggregates, the end will be rounded up such that the last aggregate represents a full aggregation interval containing the original end, where the interval is the granularity unit times the granularity multiplier. For granularity 2d, the aggregation interval is 2 days, if end was originally 3 days after the start, it will be rounded to 4 days after the start."
      },
      "Label": {
        "type": "object",
        "title": "Label",
        "required": [
          "externalId"
        ],
        "description": "A label assigned to a resource.",
        "properties": {
          "externalId": {
            "description": "An external ID to a predefined label definition.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          }
        }
      },
      "LabelList": {
        "type": "array",
        "description": "A list of the labels associated with this resource item.",
        "minItems": 0,
        "maxItems": 10,
        "uniqueItems": true,
        "items": {
          "$ref": "#/components/schemas/Label"
        }
      },
      "LabelFilter": {
        "description": "Return only the resource matching the specified label constraints.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/LabelContainsAllFilter"
          }
        ]
      },
      "LabelContainsAnyFilter": {
        "type": "object",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "description": "The resource item contains at least one of the listed labels.",
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelContainsAllFilter": {
        "type": "object",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "description": "The resource item contains at least all the listed labels.",
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelDefinitionExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "LabelDefinitionExternalIdList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/LabelDefinitionExternalId"
            }
          }
        }
      },
      "LabelsPatch": {
        "description": "Updates the resource's assigned labels.\n\nLabels can be added, removed or replaced (set). Adding an already attached label is an idempotent operation. Removing a label with no matching externalId is silently ignored.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelsAddRemove"
          },
          {
            "$ref": "#/components/schemas/LabelsSet"
          }
        ]
      },
      "LabelsAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "A list of the labels to add to a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          },
          "remove": {
            "type": "array",
            "description": "A list of the labels to remove from a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelsSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "A list of the labels to replace (set) to a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "NextCursor": {
        "type": "string",
        "description": "Cursor to get the next page of results (if available)."
      },
      "DigitalTwinConfig": {
        "type": "object",
        "description": "Digital twin resource.",
        "required": [
          "id",
          "data"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "description": "ID of the digital twin.",
            "format": "int64"
          },
          "data": {
            "$ref": "#/components/schemas/TwinConfiguration"
          }
        }
      },
      "CreateDigitalTwinConfig": {
        "type": "object",
        "description": "Digital twin resource.",
        "required": [
          "data"
        ],
        "properties": {
          "data": {
            "$ref": "#/components/schemas/TwinConfiguration"
          }
        }
      },
      "UpdateDigitalTwinConfig": {
        "type": "object",
        "description": "Digital twin resource.",
        "required": [
          "id",
          "data"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "description": "ID of the digital twin.",
            "format": "int64"
          },
          "data": {
            "$ref": "#/components/schemas/TwinConfiguration"
          }
        }
      },
      "DigitalTwinConfigList": {
        "type": "object",
        "description": "List of digital twins.",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DigitalTwinConfig"
            }
          }
        }
      },
      "TwinConfiguration": {
        "description": "Data structure that fully defines a digital twin in the Cognite Digital Twin Application.",
        "required": [
          "header",
          "assets",
          "scenes"
        ],
        "type": "object",
        "properties": {
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "assets": {
            "$ref": "#/components/schemas/Assets"
          },
          "scenes": {
            "description": "Array of 3D scenes in this available in this twin. Only one scene can be active and visible at any moment",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Scene"
            },
            "minItems": 1
          },
          "hierarchy": {
            "$ref": "#/components/schemas/BaseMenuHierarchy"
          },
          "simulations": {
            "description": "Array of timeseries simulations for this twin",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Simulation"
            }
          },
          "timeseriesFilters": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TimeseriesFilter"
            }
          }
        }
      },
      "Simulation": {
        "type": "object",
        "description": "Data structure that defines a simulation.",
        "required": [
          "displayName",
          "timeseriesMappings"
        ],
        "properties": {
          "displayName": {
            "description": "Name of the simulation, to be shown in the user interface.",
            "type": "string"
          },
          "timeseriesFilterId": {
            "description": "The identifier of the timeseries filter to apply when this simulation is active.",
            "type": "string"
          },
          "timeseriesMappings": {
            "description": "Array of timeseries mappings for this simulataion.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimeSeriesMapping"
            }
          }
        }
      },
      "TimeSeriesMapping": {
        "description": "Mapping between time series in a simulation.",
        "type": "object",
        "required": [
          "mappingFrom",
          "mappingTo"
        ],
        "properties": {
          "mappingFrom": {
            "$ref": "#/components/schemas/ExtendedTimeSeriesId"
          },
          "mappingTo": {
            "$ref": "#/components/schemas/TimeSeriesIdOrConstant"
          }
        }
      },
      "TimeSeriesId": {
        "description": "An ID that uniquely identifies a time series.",
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          }
        }
      },
      "TimeSeriesIdOrConstant": {
        "description": "Represents either a time series ID or a constant value that will be used in place of a time series.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "constantValue": {
            "description": "Constant value to use instead of a time series.",
            "type": "number",
            "format": "double"
          }
        }
      },
      "ExtendedTimeSeriesId": {
        "description": "Represents either a time series ID or an identifier that can be mapped to a time series ID in a simulation.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "simulationIdentifier": {
            "type": "string",
            "description": "An identifier that can be used instead of a time series ID when mapping time series for a simulation.",
            "maxLength": 255
          }
        }
      },
      "ExtendedTimeSeriesIdOrConstant": {
        "description": "Represents either a time series ID, an identifier that can be mapped to a time series ID in a simulation, or a constant value that will be used in place of a time series.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "simulationIdentifier": {
            "type": "string",
            "description": "An identifier that can be used instead of a time series ID when mapping time series for a simulation.",
            "maxLength": 255
          },
          "constantValue": {
            "description": "Constant value to use instead of a time series.",
            "type": "number",
            "format": "double"
          }
        }
      },
      "ExtendedTimeSeriesIdOrFileId": {
        "description": "Represents either a time series ID or a file ID.",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991,
            "description": "A server-generated ID for the object."
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type.",
            "maxLength": 255
          },
          "simulationIdentifier": {
            "type": "string",
            "description": "An identifier that can be used instead of a time series ID when mapping time series for a simulation.",
            "maxLength": 255
          },
          "fileId": {
            "description": "A unique id of a file in the file API.",
            "type": "integer",
            "format": "int64",
            "minimum": 1,
            "maximum": 9007199254740991
          }
        }
      },
      "Header": {
        "description": "Header containing basic information and metadata about the twin.",
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the twin, as it will be shown in the Digital Twin Application.",
            "type": "string"
          },
          "thumbnailImageId": {
            "description": "File API ID of image that will be used as thumbnail for the twin in the Digital Twin Application.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "Assets": {
        "description": "Declaration of the data assets used by this twin. Actors in the twin refer to these assets as data sources.",
        "type": "object",
        "properties": {
          "geometries": {
            "description": "Map of all geometry data used by this digital twin. Keys in this map represent IDs that can be used as references to the data in twin actors.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/GeometryData"
            }
          },
          "splines": {
            "description": "Map of all spline data used by this digital twin. Keys in this map represent IDs that can be used as references to the data in spline actors.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SplineData"
            }
          }
        }
      },
      "GeometryData": {
        "description": "A 3D model asset used by this twin. Contains IDs referencing a 3D model file in the 3D API, and optionally applies a transform to the model. <br> Additional field usage information:\n  * `colorOverride` - color to apply on this 3d model. This color will override any texture information.\n  * `photogrammetryLightingOverride` - Override for how photogrammetry meshes (if any) in this model are affected by lighting.\n",
        "type": "object",
        "required": [
          "modelId",
          "revisionId"
        ],
        "properties": {
          "modelId": {
            "description": "3D API ID of the model.",
            "type": "integer",
            "format": "int64"
          },
          "revisionId": {
            "description": "3D API ID of the revision of the model.",
            "type": "integer",
            "format": "int64"
          },
          "preserveMaterialSlots": {
            "description": "Whether or not to preserve material slots from the original 3D file. Should only be true if the model will use textured material overrides.",
            "type": "boolean"
          },
          "transform": {
            "$ref": "#/components/schemas/RelativeTransform"
          },
          "colorOverride": {
            "$ref": "#/components/schemas/Color"
          },
          "photogrammetryLightingOverride": {
            "$ref": "#/components/schemas/PhotogrammetryLightingType"
          }
        }
      },
      "SplineDataFormat": {
        "type": "string",
        "enum": [
          "noTangents",
          "withTangents"
        ],
        "description": "Describes the format of spline data:\n  * `noTangents` - Sequence of X, Y, Z coordinates for spline points, in centimeters in the local coordinate system of the spline.\n  * `withTangents ` - Sequence of spline points, where each point in the sequence is represented with 9 floating point numbers; all in the local coordinate system of the spline: <br> - X, Y, Z coordinates of the spline point in centimeters. <br> - X, Y, Z components of incoming tangent vector. <br> - X, Y, Z components of outgoing tangent vector.\n"
      },
      "SplineData": {
        "description": "Spline data used by this twin.",
        "type": "object",
        "required": [
          "splinePoints",
          "splineDataFormat"
        ],
        "properties": {
          "splineDataFormat": {
            "$ref": "#/components/schemas/SplineDataFormat"
          },
          "splinePoints": {
            "description": "Array of spline points, with or without tangents.",
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "MenuHierarchyType": {
        "type": "string",
        "enum": [
          "fullAssetHierarchy",
          "customHierarchy"
        ],
        "description": "Source of the hierarchy for the navigation menu:\n  * `fullAssetHierarchy` - \"Full asset hierarchy for the current tenant. Should only be used on tenants with very small asset hierarchies.\"\n  * `customHierarchy` - \"Custom made hierarchy, defined in this file.\"\n"
      },
      "PhotogrammetryLightingType": {
        "type": "string",
        "enum": [
          "unlitRendering",
          "litRendering"
        ],
        "description": "Lighting style for photogrammetry models:\n  * `unlitRendering` - Unlit rendering: The models will not be affected by the lighting in the scene. This is the default setting.\n  * `litRendering` - Lit rendering: The models will be affected by lights and shadows in the scene. This is not recommended, as photogrammetry textures usually have lighting baked into them.\n"
      },
      "GeographicLocation": {
        "description": "Describes a global position using a set of coordinates and an optional Coordinate Reference System (CRS). If no CRS is given, coordinates are assumed to be local Unreal Engine 4 coordinates.",
        "type": "object",
        "required": [
          "coordinates"
        ],
        "properties": {
          "crs": {
            "description": "A Proj.4 formatted string describing a Coordinate Reference System (CRS). Currently, only longlat and utm (for WGS84) are supported.",
            "example": "+proj=utm +zone=31 +units=m",
            "type": "string"
          },
          "coordinates": {
            "description": "An array of three floating-point numbers specifying a coordinate in the given CRS (or in UE4 coordinates if no CRS is given). The third value is always the altitude given in cm.",
            "type": "array",
            "items": {
              "type": "number",
              "format": "double"
            },
            "minItems": 3,
            "maxItems": 3
          }
        }
      },
      "GeographicCoordinateMapping": {
        "description": "Relates the coordinate system in the application with a geographic coordinate system. Sets up a reference point in geographic coordinates, and the corresponding reference point in the coordinate system of the 3D scene.<br> Additional field usage information:\n  * `referencePointGeographicLocation` - A geographic coordinate to be related with a given position in the coordinate system of the 3D scene.\n",
        "type": "object",
        "required": [
          "referencePointGeographicLocation",
          "referencePointSceneCoordinate",
          "northAngle"
        ],
        "properties": {
          "referencePointGeographicLocation": {
            "$ref": "#/components/schemas/GeographicLocation"
          },
          "referencePointSceneCoordinate": {
            "description": "The position in the (Unreal Engine 4) scene coordinate system to be related with the given location in geographic coordinates. Expects an array of three numbers for position (in centimeters) along the XYZ-axes.",
            "type": "array",
            "items": {
              "type": "number",
              "format": "float"
            },
            "minItems": 3,
            "maxItems": 3
          },
          "northAngle": {
            "description": "The angle (in degrees) from the positive X-axis in the 3D scene that describes geographic north. Example: If X-axis in the scene points south, northAngle should be 180. If it points west, northAngle should be 90.",
            "type": "number",
            "format": "float"
          }
        }
      },
      "BaseMenuHierarchy": {
        "description": "Defines a navigation menu hierarchy.<br> Variants:\n  * `fullAssetHierarchy` - Defines a navigation menu hierarchy constructed from the full asset hierarchy of the tenant. Warning: Should only be used on tenants with small asset hierarchies, as this will fetch the full asset hierarchy.\n  * `customMenuHierarchy` - Defines a custom navigation menu hierarchy. The children defined here will be considered root nodes, and each root node can have any number of child nodes and subsequent descendant nodes.\n",
        "type": "object",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "fullAssetHierarchy": "#/components/schemas/FullAssetHierarchy",
            "customHierarchy": "#/components/schemas/CustomMenuHierarchy"
          }
        },
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/MenuHierarchyType"
          }
        }
      },
      "FullAssetHierarchy": {
        "description": "Defines a navigation menu hierarchy constructed from the full asset hierarchy of the tenant. Warning: Should only be used on tenants with small asset hierarchies, as this will fetch the full asset hierarchy.",
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseMenuHierarchy"
          },
          {
            "type": "object",
            "properties": {
              "rootAssetId": {
                "description": "Asset ID of the asset hierarchy node that will be used as root node for the hierarchy.",
                "type": "integer",
                "format": "int64"
              }
            }
          }
        ]
      },
      "CustomMenuHierarchy": {
        "description": "Defines a custom navigation menu hierarchy. The children defined here will be considered root nodes, and each root node can have any number of child nodes and subsequent descendant nodes.",
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseMenuHierarchy"
          },
          {
            "type": "object",
            "required": [
              "rootNodes"
            ],
            "properties": {
              "rootNodes": {
                "description": "Root nodes of the hierarchy.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/CustomMenuHierarchyNode"
                }
              }
            }
          }
        ]
      },
      "CustomMenuHierarchyNode": {
        "description": "A node in a custom menu hierarchy. Can be linked to a CDF asset ID, and can have any number of child nodes.",
        "type": "object",
        "properties": {
          "displayName": {
            "description": "The name of the node, as it will be displayed in the menu. If both this field and assetInternalId are provided, this field will be displayed instead of the name from the asset associated with the asset ID.",
            "type": "string"
          },
          "assetInternalId": {
            "description": "CDF internal ID of asset associated with this hierarchy node. If displayName is not provided, the name of the asset in CDF will be displayed in the menu.",
            "type": "integer",
            "format": "int64"
          },
          "children": {
            "description": "Child hierarchy nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CustomMenuHierarchyNode"
            }
          }
        }
      },
      "Box": {
        "description": "This is a bounding box.",
        "allOf": [
          {
            "type": "object",
            "required": [
              "min",
              "max"
            ],
            "properties": {
              "min": {
                "$ref": "#/components/schemas/GeographicLocation"
              },
              "max": {
                "$ref": "#/components/schemas/GeographicLocation"
              }
            }
          }
        ]
      },
      "Camera": {
        "description": "Scene camera properties.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "initialCoordinates": {
                "$ref": "#/components/schemas/AbsoluteTransform"
              },
              "limits": {
                "$ref": "#/components/schemas/Box"
              },
              "groundReference": {
                "type": "number",
                "format": "float"
              }
            }
          }
        ]
      },
      "Scene": {
        "type": "object",
        "description": "Describes a 3D scene and all the objects in it.",
        "properties": {
          "geographicCoordinates": {
            "$ref": "#/components/schemas/GeographicCoordinateMapping"
          },
          "camera": {
            "$ref": "#/components/schemas/Camera"
          },
          "actors": {
            "description": "List of actors: objects that will be placed in the 3D scene.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Actor"
            }
          },
          "terrains": {
            "description": "List of objects that describe terrains in the scene.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Terrain"
            }
          },
          "heightRenderer": {
            "$ref": "#/components/schemas/HeightRenderer"
          },
          "basicMeshActors": {
            "description": "List of objects that describe basic meshes with materials positioned in the 3D scene.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BasicMeshActor"
            }
          },
          "waterPlane": {
            "$ref": "#/components/schemas/WaterPlane"
          },
          "environmentControl": {
            "$ref": "#/components/schemas/EnvironmentControl"
          },
          "visibilityLayers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VisibilityLayers"
            }
          }
        }
      },
      "Terrain": {
        "type": "object",
        "required": [
          "transform"
        ],
        "properties": {
          "transform": {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          "heightMap": {
            "description": "A reference to the image to use as the source of heightmap data.",
            "type": "string"
          },
          "normalMapMap": {
            "description": "A reference to the image to use as surface normal information.",
            "type": "string"
          },
          "baseColor": {
            "description": "A reference to the image to use to color the terrain surface.",
            "type": "string"
          },
          "terrainMinHeight": {
            "description": "The height of the lowest point of the terrain.",
            "type": "number",
            "format": "float"
          },
          "terrainMaxHeight": {
            "description": "The height of the highest point of the terrain.",
            "type": "number",
            "format": "float"
          },
          "heightMapMinValue": {
            "description": "The value of the lowest point of the terrain as encoded in the heightmap.",
            "type": "number",
            "format": "float"
          },
          "heightMapMaxValue": {
            "description": "The value of the highest point of the terrain as encoded in the heightmap.",
            "type": "number",
            "format": "float"
          },
          "lodScreenSizeFactor": {
            "description": "The LOD screen-size factor determines the distance at which refinement of the geometry of the terrain mesh occurs. This impacts the performance and fidelity of the terrain object.",
            "type": "number",
            "format": "float"
          },
          "tileSizeScale": {
            "description": "the tile size scale parameter scales the terrain tiles. It does not affect the scale of the terrain features (see metersPerpixel). This parameter impacts performance, as larger tiles cover more terrain area, so that fewer are needed to cover the same region.",
            "type": "number",
            "format": "float"
          },
          "metersPerPixel": {
            "description": "The meters-per-pixel parameter determines the scale of the terrain data. It specifies how far apart in the scene to space the pixel-centers of the heightmap and the other terrain surface textures. A value of 1 corresponds to 1 meter between each heightmap sample point. The parameter must correspond to the scale and resolution of the provided heightmap.",
            "type": "number",
            "format": "float"
          },
          "numTilesX": {
            "description": "The number of terrain tiles along the first axis.",
            "type": "integer",
            "format": "int32"
          },
          "numTilesY": {
            "description": "The number of terrain tiles along the second axis.",
            "type": "integer",
            "format": "int32"
          }
        },
        "description": "The terrain object uses heightmap data to produce a 3D terrain in the scene.<br> The terrain assumes that the heightmap data is linearly encoded.<br> transform: The position of the terrain."
      },
      "WidgetRotationMode": {
        "type": "string",
        "enum": [
          "noRotation",
          "faceCamera",
          "faceCamera_ZOnly",
          "faceCamera_HorizontalAlignment"
        ],
        "description": "Rotation type for widgets in the scene (relative to camera):\n  * `noRotation` - The rotation will be fixed to the direction given by the transform.\n  * `faceCamera` - The widget will rotate to always face towards the camera.\n  * `faceCamera_ZOnly` - The widget will rotate around its vertical axis to face towards the camera. (Typical use-case: rotated towards camera while staying perpendicular to the ground).\n  * `faceCamera_HorizontalAlignment` - The widget will always face towards the camera and be aligned to the screen. Equivalent to a 2D widget, but placed in 3D space.\n"
      },
      "WidgetType": {
        "type": "string",
        "enum": [
          "text",
          "bar",
          "discreteTimeSeries"
        ],
        "description": "Describes a type of a widget\n  * `text` - A widget displaying a single string of text.\n  * `bar` - A 3D grapical bar representing a value.\n  * `discreteTimeSeries` - A widget displaying discrete time series in the format of a heading, content based on user defined enums and a possible image.\n"
      },
      "BarFillType": {
        "type": "string",
        "enum": [
          "leftToRight",
          "rightToLeft",
          "fillFromCenter",
          "topToBottom",
          "bottomToTop"
        ],
        "description": "Gives the orientation of the progress bar fill mode.\n  * 'leftToRight' -    left to right fill mode\n  * 'rightToLeft' -    right to left fill mode\n  * 'fillFromCenter' - fill from center fill mode\n  * 'topToBottom' -    top to bottom fill mode\n  * 'bottomToTop' -    bottom to top fill mode\n"
      },
      "WidgetMaterialType": {
        "description": "Controls the translucency of a widget\n  * 'masked' - the widget will use a masked material, with sharp cutoff in opacity.\n  * 'translucent' - the widget uses a translucent material. Required if the widgets should fade out smoothly with distance.\n",
        "type": "string",
        "enum": [
          "translucent",
          "masked"
        ]
      },
      "WidgetBase": {
        "description": "Base class for widgets (texts, images, etc) that appear in a scene.",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "text": "#/components/schemas/WidgetText",
            "bar": "#/components/schemas/WidgetBar",
            "discreteTimeSeries": "#/components/schemas/WidgetDiscreteTimeSeries"
          }
        },
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/WidgetType"
          },
          "assetId": {
            "description": "Asset ID in CDF to which widget should be connected (useful for connecting widget to specific building on scene without explicitly specifying widget's location)",
            "type": "integer",
            "format": "int64"
          },
          "minScreenSize": {
            "description": "Minimal percentage of screen size along vertical axis for widget to occupy.",
            "type": "number",
            "format": "float"
          },
          "cutOffDistance": {
            "description": "Distance from camera above which the widget becomes invisible (If not specified, the widget will be visible from any distance).",
            "type": "number",
            "format": "float"
          },
          "fadeDistance": {
            "description": "Defines the size of the region where the visibility of the widget fades out. The widget will start fading out at a distance cutOffDistance - fadeDistance from the camera, and be completely invisible at a camera distance equal to cutOffDistance.",
            "type": "number",
            "format": "float"
          },
          "materialType": {
            "$ref": "#/components/schemas/WidgetMaterialType"
          },
          "transform": {
            "$ref": "#/components/schemas/RelativeTransform"
          },
          "rotationMode": {
            "$ref": "#/components/schemas/WidgetRotationMode"
          }
        }
      },
      "FontTypeface": {
        "description": "Font family",
        "type": "string",
        "enum": [
          "black",
          "blackItalic",
          "bold",
          "boldItalic",
          "extraBoldItalic",
          "extraLight",
          "extraLightItalic",
          "italic",
          "light",
          "lightItalic",
          "medium",
          "mediumItalic",
          "regular",
          "semiBold",
          "semiBoldItalic",
          "thin",
          "thinItalic"
        ]
      },
      "WidgetText": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WidgetBase"
          },
          {
            "type": "object",
            "description": "Widget for creating text labels in the 3D scene.",
            "required": [
              "content"
            ],
            "properties": {
              "content": {
                "description": "String content of the text widget. Supports inline time series, see example for syntax.",
                "example": "Temperature is {timeseriesId:012345} degrees.",
                "type": "string"
              },
              "color": {
                "$ref": "#/components/schemas/Color"
              },
              "size": {
                "description": "Font size for text",
                "type": "number",
                "format": "float"
              },
              "outlineSize": {
                "description": "Outline size for text",
                "type": "number",
                "format": "float"
              },
              "outlineColor": {
                "$ref": "#/components/schemas/Color"
              },
              "typeface": {
                "$ref": "#/components/schemas/FontTypeface"
              },
              "shadowColor": {
                "$ref": "#/components/schemas/Color"
              },
              "shadowOffsetX": {
                "description": "Offset of a shadow along horizontal axis",
                "type": "number",
                "format": "float"
              },
              "shadowOffsetY": {
                "description": "Offset of a shadow along vertical axis",
                "type": "number",
                "format": "float"
              },
              "backgroundColor": {
                "$ref": "#/components/schemas/Color"
              }
            }
          }
        ]
      },
      "WidgetBar": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WidgetBase"
          },
          {
            "type": "object",
            "description": "Widget for creating graphical bars in the 3D scene.",
            "required": [
              "minValue",
              "maxValue"
            ],
            "properties": {
              "heading": {
                "description": "Displayed heading for the bar widget. Will use timeseries name if not specified.",
                "type": "string"
              },
              "color": {
                "$ref": "#/components/schemas/Color"
              },
              "width": {
                "description": "The width of the bar widget",
                "type": "number",
                "format": "float"
              },
              "height": {
                "description": "The height of the bar widget",
                "type": "number",
                "format": "float"
              },
              "defaultValue": {
                "description": "Default value for bar widget",
                "type": "number",
                "format": "float"
              },
              "minValue": {
                "description": "Minimum value for bar widget",
                "type": "number",
                "format": "float"
              },
              "maxValue": {
                "description": "Maximum value for bar widget",
                "type": "number",
                "format": "float"
              },
              "timeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesId"
              },
              "currentValueMaxFractionalDigits": {
                "description": "The maximum number of fractional decimal digits to display for the current value",
                "type": "integer",
                "format": "int32"
              },
              "boundsValueMaxFractionalDigits": {
                "description": "The maximum number of fractional decimal digits to display for the min and max values",
                "type": "integer",
                "format": "int32"
              },
              "headingFontSize": {
                "description": "Font size for heading",
                "type": "number",
                "format": "float"
              },
              "valuesFontSize": {
                "description": "Font size for values",
                "type": "number",
                "format": "float"
              },
              "paddingSize": {
                "description": "Border padding override",
                "type": "number",
                "format": "float"
              },
              "barFill": {
                "$ref": "#/components/schemas/BarFillType"
              },
              "typeface": {
                "$ref": "#/components/schemas/FontTypeface"
              }
            }
          }
        ]
      },
      "DiscreteTimeSeriesEnums": {
        "description": "User defined content based on discrete time series enums.",
        "required": [
          "content"
        ],
        "properties": {
          "content": {
            "description": "user defined message to be displayed once the enum is triggered by discrete time series content from the CDF",
            "type": "string"
          },
          "image": {
            "description": "Image ID in CDF for load as an icon in the display of widgetDiscreteTimeSeries",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "WidgetDiscreteTimeSeries": {
        "allOf": [
          {
            "$ref": "#/components/schemas/WidgetBase"
          },
          {
            "type": "object",
            "description": "Widget for creating discrete time series labels in the 3D scene.",
            "required": [
              "heading",
              "timeSeries"
            ],
            "properties": {
              "heading": {
                "description": "String with the containing header for displaying the discrete time series content.",
                "example": "Machine status:",
                "type": "string"
              },
              "timeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesId"
              },
              "colorHeading": {
                "$ref": "#/components/schemas/Color"
              },
              "sizeHeading": {
                "description": "Font size for text",
                "type": "number",
                "format": "float"
              },
              "outlineSizeHeading": {
                "description": "Outline size for text",
                "type": "number",
                "format": "float"
              },
              "outlineColorHeading": {
                "$ref": "#/components/schemas/Color"
              },
              "typefaceHeading": {
                "$ref": "#/components/schemas/FontTypeface"
              },
              "colorContent": {
                "$ref": "#/components/schemas/Color"
              },
              "sizeContent": {
                "description": "Font size for text",
                "type": "number",
                "format": "float"
              },
              "outlineSizeContent": {
                "description": "Outline size for text",
                "type": "number",
                "format": "float"
              },
              "outlineColorContent": {
                "$ref": "#/components/schemas/Color"
              },
              "typefaceContent": {
                "$ref": "#/components/schemas/FontTypeface"
              },
              "shadowColor": {
                "$ref": "#/components/schemas/Color"
              },
              "shadowOffsetX": {
                "description": "Offset of a shadow along horizontal axis",
                "type": "number",
                "format": "float"
              },
              "shadowOffsetY": {
                "description": "Offset of a shadow along vertical axis",
                "type": "number",
                "format": "float"
              },
              "TextPadding": {
                "description": "Padding added in the text area",
                "type": "number",
                "format": "float"
              },
              "ImagePadding": {
                "description": "Padding added in the image area",
                "type": "number",
                "format": "float"
              },
              "ImageScaleX": {
                "description": "Image scale along horizontal axis",
                "type": "number",
                "format": "float"
              },
              "ImageScaleY": {
                "description": "Image scale along along vertical axis",
                "type": "number",
                "format": "float"
              },
              "backgroundColor": {
                "$ref": "#/components/schemas/Color"
              },
              "enums": {
                "description": "Map of discrete time series enums to user defined messages.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/DiscreteTimeSeriesEnums"
                }
              },
              "defaultContent": {
                "description": "default content in case of not having a proper enum set up",
                "type": "string"
              },
              "defaultImage": {
                "description": "default image in case of not having a proper enum set up",
                "type": "integer",
                "format": "int64"
              }
            }
          }
        ]
      },
      "TransformControllerType": {
        "type": "string",
        "enum": [
          "latLongSeparateTimeSeries",
          "northingEastingSeparateTimeSeries",
          "localToWorldUserDefinedSeparateTimeSeries",
          "localToWorldWithVelocityVectorsUserDefinedSeparateTimeSeries"
        ],
        "description": "Specifies the type of a transform controller\n  * `latLongSeparateTimeSeries` - Controls the position and rotation of an actor based on time series containing latitude and longitude information.\n  * `northingEastingSeparateTimeSeries` - Controls the position and rotation of an actor based on time series containing northing and easting information.\n  * `localToWorldUserDefinedSeparateTimeSeries` - Controls the position and rotation of an actor based on time series containing local coordinates that will be transformed linearly to world coordinates.\n  * `localToWorldWithVelocityVectorsUserDefinedSeparateTimeSeries` - Controls the position and rotation with absolute positions and velocity vectors to be able to properly interpolate.\n"
      },
      "TransformControllerBase": {
        "description": "Controls the transform (position, rotation, scale) of the actor it is attached to.<br>  Variants:\n  * `latLongSeparateController` - Controls the position and rotation of an actor based on time series containing latitude and longitude information.\n  * `northingEastingSeparateController` - Controls the position and rotation of an actor based on time series containing northing and easting information.\n  * `localToWorldUserDefinedSeparateController` - Controls the position and rotation of an actor based on time series containing local coordinates that will be transformed linearly to world coordinates.\n",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "latLongSeparateTimeSeries": "#/components/schemas/LatLongSeparateController",
            "northingEastingSeparateTimeSeries": "#/components/schemas/NorthingEastingSeparateController",
            "localToWorldUserDefinedSeparateTimeSeries": "#/components/schemas/LocalToWorldUserDefinedSeparateController",
            "localToWorldWithVelocityVectorsUserDefinedSeparateTimeSeries": "#/components/schemas/LocalToWorldUserWithVelocityVectorsDefinedSeparateController"
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TransformControllerType"
          }
        }
      },
      "HeightTrackingMode": {
        "type": "string",
        "enum": [
          "none",
          "constantValue",
          "heightmapData"
        ],
        "description": "Determines how the vertical position of an actor will be adjusted by a transform controller:\n  * `none` - The vertical position of the actor will not be affected by the controller.\n  * `constantValue` - The actor will be placed at a fixed height.\n  * `heightmapData` - The vertical position of the actor is determined by a height map.\n"
      },
      "LatLongSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series containing latitude and longitude information.<br> Additional field usage information:\n  * `latitudeTimeSeries` - The time series from which to read geographic latitude coordinate data.     \n  * `longitudeTimeSeries` - The time series from which to read geographic longitude coordinate data.             \n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "latitudeTimeSeries",
              "longitudeTimeSeries",
              "heightTrackingMode"
            ],
            "properties": {
              "latitudeTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "longitudeTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "heightTrackingMode": {
                "$ref": "#/components/schemas/HeightTrackingMode"
              },
              "defaultHeightPosition": {
                "description": "If heightTrackingMode is set to constantValue, then defaultHeightPosition is used to specify the constant height value to use.",
                "type": "number",
                "format": "float"
              },
              "simulateRotationFromPosition": {
                "description": "Uses consecutive positions to infer rotation. Assumes that the first axis (the X-axis in local object space) should be aligned with the tangent vector of the position.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "vec4TimeSeries": {
        "description": "Four dimensional time series.<br>\n  * `xTimeSeries` - The time series from which to read the x component.\n  * `yTimeSeries` - The time series from which to read the y component.\n  * `zTimeSeries` - The time series from which to read the z component.\n  * `wTimeSeries` - The time series from which to read the w component.\n",
        "allOf": [
          {
            "type": "object",
            "required": [
              "xTimeSeries",
              "yTimeSeries",
              "zTimeSeries",
              "wTimeSeries"
            ],
            "properties": {
              "xTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "yTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "zTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "wTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              }
            }
          }
        ]
      },
      "vec3TimeSeries": {
        "description": "Three dimensional time series.<br>\n  * `xTimeSeries` - The time series from which to read the x component.\n  * `yTimeSeries` - The time series from which to read the y component.\n  * `zTimeSeries` - The time series from which to read the z component.\n",
        "allOf": [
          {
            "type": "object",
            "required": [
              "xTimeSeries",
              "yTimeSeries",
              "zTimeSeries"
            ],
            "properties": {
              "xTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "yTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "zTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              }
            }
          }
        ]
      },
      "vec2TimeSeries": {
        "description": "Three dimensional time series.<br>\n  * `xTimeSeries` - The time series from which to read the x component.\n  * `yTimeSeries` - The time series from which to read the y component.\n",
        "allOf": [
          {
            "type": "object",
            "required": [
              "xTimeSeries",
              "yTimeSeries"
            ],
            "properties": {
              "xTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "yTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              }
            }
          }
        ]
      },
      "BasicMeshType": {
        "type": "string",
        "enum": [
          "plane"
        ],
        "description": "Specifies the type of the basic mesh to add to the scene\n   * `plane` - generates a plane of 1x1 m that will have applied the transform.\n"
      },
      "Material": {
        "type": "object",
        "properties": {
          "diffuse": {
            "description": "The file ID of the image in the file API.",
            "type": "integer",
            "format": "int64"
          },
          "normal": {
            "description": "The file ID of the image in the file API.",
            "type": "integer",
            "format": "int64"
          },
          "tiling": {
            "description": "The tiling for the textures attached to the material.",
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "offset": {
            "description": "The offset for the textures attached to the material.",
            "type": "array",
            "minItems": 2,
            "maxItems": 2,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "BasicMeshActor": {
        "description": "Controls the transform (position, rotation, scale) of the actor it is attached to.<br> \n",
        "allOf": [
          {
            "$ref": "#/components/schemas/ActorBase"
          },
          {
            "type": "object",
            "required": [
              "meshType"
            ],
            "properties": {
              "meshType": {
                "$ref": "#/components/schemas/BasicMeshType"
              },
              "material": {
                "$ref": "#/components/schemas/Material"
              }
            }
          }
        ]
      },
      "VisibilityController": {
        "description": "Controls the visibility of an actor based on a time series.<br> Additional field usage information:\n  * `timeSeries` - Time series used to control the visibility of the actor. \n",
        "allOf": [
          {
            "type": "object",
            "required": [
              "timeSeries",
              "minimumCondition",
              "maximumCondition"
            ],
            "properties": {
              "timeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "minimumCondition": {
                "description": "The minimum value of the time series for when the actor is visible.",
                "type": "number",
                "format": "float"
              },
              "maximumCondition": {
                "description": "The maximum value of the time series for when the actor is visible.",
                "type": "number",
                "format": "float"
              }
            }
          }
        ]
      },
      "NorthingEastingSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series containing northing and easting information.<br> Additional field usage information:\n  * `northingTimeSeries` - The time series from which to read geographic northing coordinate data.       \n  * `eastingTimeSeries` - The time series from which to read geographic easting coordinate data.     \n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "northingTimeSeries",
              "eastingTimeSeries",
              "heightTrackingMode",
              "zone",
              "isNorthernHemisphere"
            ],
            "properties": {
              "northingTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "eastingTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "heightTrackingMode": {
                "$ref": "#/components/schemas/HeightTrackingMode"
              },
              "zone": {
                "description": "Set the northing easting zone.",
                "type": "integer",
                "format": "int32"
              },
              "isNorthernHemisphere": {
                "description": "If the coordinates are in the northern hemisphere.",
                "type": "boolean"
              },
              "defaultHeightPosition": {
                "description": "If heightTrackingMode is set to constantValue, then defaultHeightPosition is used to specify the constant height value to use.",
                "type": "number",
                "format": "float"
              },
              "simulateRotationFromPosition": {
                "description": "Uses consecutive positions to infer rotation. Assumes that the first axis (the X-axis in local object space) should be aligned with the tangent vector of the position.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "RotationTimeSeriesType": {
        "type": "string",
        "enum": [
          "quaternionTimeSeries",
          "yawPitchRollTimeSeries",
          "singleAxisRotationTimeSeries"
        ],
        "description": "Specifies the type of a rotation time series\n   * `quaternion` - i j q and k time series defining the quaternion orientation.\n   * `yawPitchRoll` - yaw pitch and roll time series defining the orientation.\n   * `singleAxisRotation` - single dimension rotation based on an input axis.\n"
      },
      "RotationUnitsType": {
        "type": "string",
        "enum": [
          "degree",
          "radians"
        ],
        "description": "Specifies the unit of a rotation time series\n   * `degree` - yaw pitch and roll rotations will be considered as degrees, degrees/s in case of used as angular speed.\n   * `radians` - yaw pitch and roll rotations will be considered as radians, radians/s in case of used as angular speed.\n   \n"
      },
      "PositionTimeSeries": {
        "description": "Controls the position of the actor it is attached to with 3 time series that maps X, Y and Z.\n",
        "type": "object",
        "required": [
          "xyzTimeSeries"
        ],
        "properties": {
          "xyzTimeSeries": {
            "$ref": "#/components/schemas/vec3TimeSeries"
          }
        }
      },
      "VelocityTimeSeries": {
        "description": "Controls the velocity of the actor it is attached to with 3 time series that maps X, Y and Z.\n",
        "type": "object",
        "required": [
          "xyzTimeSeries"
        ],
        "properties": {
          "xyzTimeSeries": {
            "$ref": "#/components/schemas/vec3TimeSeries"
          }
        }
      },
      "AngularVelocityTimeSeriesBase": {
        "description": "Controls the rotation velocity of the actor it is attached to in rpm.\n",
        "type": "object",
        "required": [
          "rpmTimeSeries",
          "axisRotation"
        ],
        "properties": {
          "rpmTimeSeries": {
            "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
          },
          "axisRotation": {
            "description": "Vector defining the rotation axis. Doesn't need to be normalized.",
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "RotationTimeSeriesBase": {
        "description": "Controls the rotation of the actor it is attached to.<br>  Variants:\n  * `quaternionController` - Controls the position and rotation of an actor based on time series containing latitude and longitude information.\n  * `yawPitchRollController` - Controls the position and rotation of an actor based on time series containing northing and easting information.\n  * `singleAxisRotationController` - Controls the position and rotation of an actor based on time series containing local coordinates that will be transformed linearly to world coordinates.\n",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "quaternionTimeSeries": "#/components/schemas/QuaternionController",
            "yawPitchRollTimeSeries": "#/components/schemas/YawPitchRollController",
            "singleAxisRotationTimeSeries": "#/components/schemas/SingleAxisRotationController"
          }
        },
        "type": "object",
        "required": [
          "type",
          "unitsType"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/RotationTimeSeriesType"
          },
          "unitsType": {
            "$ref": "#/components/schemas/RotationUnitsType"
          }
        }
      },
      "QuaternionController": {
        "description": "Controls rotation of an actor based on time series containing quaternion data in a 4 dimensional time series defining i j k and q axis from a quaternion.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/RotationTimeSeriesBase"
          },
          {
            "type": "object",
            "required": [
              "quaternionTimeSeries"
            ],
            "properties": {
              "quaternionTimeSeries": {
                "$ref": "#/components/schemas/vec4TimeSeries"
              }
            }
          }
        ]
      },
      "ComponentType": {
        "type": "string",
        "enum": [
          "geometryComponent",
          "widgetComponent",
          "splineComponent",
          "decalComponent"
        ],
        "description": "Type of component\n   * geometryComponent - Uses a 3D model from CDF as its geometry.\n   * widgetComponent - 3D widget positioned in the 3D scene displaying various information.\n   * splineComponent - Class for describing pipelines in scene.\n   * decalComponent - Class describing an image overlay for geometry in the scene.\n"
      },
      "Component": {
        "description": "Base class for different types of components that can be attached to actors.",
        "type": "object",
        "required": [
          "componentType"
        ],
        "discriminator": {
          "propertyName": "componentType",
          "mapping": {
            "geometryComponent": "#/components/schemas/GeometryComponent",
            "widgetComponent": "#/components/schemas/WidgetComponent",
            "splineComponent": "#/components/schemas/SplineComponent",
            "decalComponent": "#/components/schemas/DecalComponent"
          }
        },
        "properties": {
          "componentType": {
            "$ref": "#/components/schemas/ComponentType"
          }
        }
      },
      "GeometryComponent": {
        "description": "Uses a 3D model from CDF as its geometry.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": [
              "geometryDataID"
            ],
            "properties": {
              "geometryDataID": {
                "description": "Name of geometry listed in 'assets' section that this actor should use",
                "type": "string"
              }
            }
          }
        ]
      },
      "WidgetComponent": {
        "description": "3D widget positioned in the 3D scene.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": [
              "widget"
            ],
            "properties": {
              "widget": {
                "$ref": "#/components/schemas/WidgetBase"
              }
            }
          }
        ]
      },
      "SplineComponent": {
        "description": "Class for describing pipelines in scene",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": [
              "splineDataID",
              "radius",
              "color"
            ],
            "properties": {
              "splineDataID": {
                "description": "Name of spline asset listed in 'assets' section that this actor should use",
                "type": "string"
              },
              "radius": {
                "description": "Radius of the pipeline",
                "type": "number",
                "format": "float"
              },
              "color": {
                "$ref": "#/components/schemas/Color"
              }
            }
          }
        ]
      },
      "DecalComponent": {
        "description": "Class for describing decals projected onto geometry in the scene. Additional field usage information:\n  * `imageId` - File ID for the image that will be used for the decal, or ID of a time series that will specify the image file ID.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/Component"
          },
          {
            "type": "object",
            "required": [
              "decalHeight",
              "imageId"
            ],
            "properties": {
              "decalHeight": {
                "description": "The height of the box volume which contains and restricts the projected texture. <br> It determines the height range across which the projected image is applied.",
                "type": "number",
                "format": "float"
              },
              "imageId": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrFileId"
              }
            }
          }
        ]
      },
      "Actor": {
        "description": "An object that will be placed in the 3D scene.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ActorBase"
          },
          {
            "type": "object",
            "required": [
              "components"
            ],
            "properties": {
              "components": {
                "description": "Array of all components attached to this actor.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Component"
                }
              }
            }
          }
        ]
      },
      "YawPitchRollController": {
        "description": "Controls rotation of an actor based on time series containing Euler angles represented as yaw, pitch and roll in a vector of 3 time series data.<br>\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/RotationTimeSeriesBase"
          },
          {
            "type": "object",
            "required": [
              "yawPitchRollTimeSeries"
            ],
            "properties": {
              "yawPitchRollTimeSeries": {
                "$ref": "#/components/schemas/vec3TimeSeries"
              }
            }
          }
        ]
      },
      "SingleAxisRotationController": {
        "description": "Controls rotation of an actor around a single axis, using time series for the rotation angle.<br> Additional field usage information:\n  * `rotationTimeSeries` - The time series from which to read the rotation angle.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/RotationTimeSeriesBase"
          },
          {
            "type": "object",
            "required": [
              "rotationTimeSeries",
              "axisRotation"
            ],
            "properties": {
              "rotationTimeSeries": {
                "$ref": "#/components/schemas/ExtendedTimeSeriesIdOrConstant"
              },
              "axisRotation": {
                "description": "Vector defining the rotation axis. Doesn't need to be normalized.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        ]
      },
      "LocalToWorldTransform": {
        "description": "A local to world space transform defined with translation, rotation and unit scale.",
        "allOf": [
          {
            "type": "object",
            "required": [
              "translation",
              "rotation",
              "unitScale"
            ],
            "properties": {
              "translation": {
                "description": "The translation of the target object to be converted to world space coordinates from unreal. Expects an array of three numbers describing the X, Y and Z translation.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "rotation": {
                "description": "The rotation of the target object in model space. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around the Y, X and Z axes of the scene respectively.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "unitScale": {
                "description": "Scales the target object uniformly. Expects a single value that will be used to scale the XYZ-axes. A value of 1.0 corresponds to the original scale. It can be used for change of units like 100 for m to cm.",
                "type": "number",
                "format": "float"
              }
            }
          }
        ]
      },
      "LocalToWorldUserDefinedSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series data. Positions and rotations are given in a local coordinate system. The transformation to world space is defined by matrixTransformToWorld.<br> Additional field usage information:\n  * `positionTimeSeries` - Group of 3 time series defining x, y and z positions.\n  * `rotationTimeSeries` - Different possible representations of rotation position in different number of time series.\n  * `matrixTransformToWorld` - The matrix to transform from time series transforms to world transforms based on the twin calibration.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "positionTimeSeries",
              "rotationTimeSeries",
              "matrixTransformToWorld"
            ],
            "properties": {
              "positionTimeSeries": {
                "$ref": "#/components/schemas/PositionTimeSeries"
              },
              "rotationTimeSeries": {
                "$ref": "#/components/schemas/RotationTimeSeriesBase"
              },
              "matrixTransformToWorld": {
                "$ref": "#/components/schemas/LocalToWorldTransform"
              }
            }
          }
        ]
      },
      "LocalToWorldUserWithVelocityVectorsDefinedSeparateController": {
        "description": "Controls the position and rotation of an actor based on time series data. Positions and rotations are given in a local coordinate system. The transformation to world space is defined by matrixTransformToWorld.<br> Additional field usage information:\n  * `positionTimeSeries` - Group of 3 time series defining x, y and z positions.\n  * `rotationTimeSeries` - Different possible representations of rotation position in different number of time series.\n  * `matrixTransformToWorld` - The matrix to transform from time series transforms to world transforms based on the twin calibration.\n  * `velocityTimeSeries` - Group of 3 time series defining x, y and z velocities.\n  * `angularVelocityTimeSeries` - Different possible representations of the angular velocity in different variation of time series.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          {
            "type": "object",
            "required": [
              "matrixTransformToWorld"
            ],
            "properties": {
              "matrixTransformToWorld": {
                "$ref": "#/components/schemas/LocalToWorldTransform"
              },
              "positionTimeSeries": {
                "$ref": "#/components/schemas/PositionTimeSeries"
              },
              "rotationTimeSeries": {
                "$ref": "#/components/schemas/RotationTimeSeriesBase"
              },
              "velocityTimeSeries": {
                "$ref": "#/components/schemas/VelocityTimeSeries"
              },
              "angularVelocityTimeSeries": {
                "$ref": "#/components/schemas/AngularVelocityTimeSeriesBase"
              }
            }
          }
        ]
      },
      "ActorType": {
        "type": "string",
        "enum": [
          "basicMeshActor",
          "actor"
        ]
      },
      "ActorBase": {
        "description": "Abstract base class for objects (actors) that can appear in scene.",
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "basicMeshActor": "#/components/schemas/BasicMeshActor",
            "actor": "#/components/schemas/Actor"
          }
        },
        "type": "object",
        "required": [
          "name",
          "transform",
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ActorType"
          },
          "name": {
            "description": "Unique name of the actor in scene.",
            "type": "string"
          },
          "transform": {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          "widgets": {
            "description": "Widgets that should be attached to this actor. (if actor will move, widgets will move along with it)",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WidgetBase"
            }
          },
          "transformController": {
            "$ref": "#/components/schemas/TransformControllerBase"
          },
          "visibilityController": {
            "$ref": "#/components/schemas/VisibilityController"
          },
          "hiddenByDefault": {
            "description": "if true, actor will be invisible when entering a scene",
            "type": "boolean"
          },
          "assetIdOverride": {
            "description": "AssetID to be associated with the actor. This will override the asset hierarchy mapping for geometries.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "HeightRenderer": {
        "type": "object",
        "required": [
          "location",
          "orthoWidth",
          "textureSize"
        ],
        "properties": {
          "location": {
            "description": "Determines where in the scene the heightmap is captured from.",
            "type": "array",
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "orthoWidth": {
            "description": "Determines the extent of the scene area captured by the height-renderer.",
            "type": "number",
            "format": "float"
          },
          "textureSize": {
            "description": "Determines the resolution of the height data.",
            "type": "integer",
            "format": "int32"
          }
        },
        "description": "An object in the scene responsible for capturing a heightmap. <br> The heightmap is used to determine the height-position of objects in the scene which do not have any other way of determining height position."
      },
      "WaterPlane": {
        "type": "object",
        "properties": {
          "followCamera": {
            "description": "Determines whether the water plane object moves with the player, creating an illusion of an endless expanse of water.",
            "type": "boolean"
          },
          "heightZoomFactor": {
            "description": "Adjusts the scale of the water surface as a function of camera height. This essentially moves the horizon of the water further away by scaling the water by the given factor, which helps maintain the same level of detail at all scales. The parameters should be left to a default of 1.0 in most cases.",
            "type": "number",
            "format": "float"
          },
          "minimumHeight": {
            "description": "The lowest height at which to scale the water surface. This is to prevent the water from disappearing when near zero height. Should be left at default, or a number slightly larger than zero.",
            "type": "number",
            "format": "float"
          },
          "transform": {
            "$ref": "#/components/schemas/AbsoluteTransform"
          }
        },
        "description": "An object in the scene responsible for rendering a water surface. Typically used for oceans."
      },
      "EnvironmentControl": {
        "description": "The environment controller is responsible for controlling environmental effects such as weather, underwater effects, and so on.<br> Additional field usage information:\n  * `fogInscatteringColor` - A property of the Unreal engine post-process volume, which is used here for the underwater fogginess effect.\n",
        "type": "object",
        "properties": {
          "underWaterDensity": {
            "description": "The density of the particles of the underwater scene. used to simulate the absorption of light as it passes through the water. Admissable range is within 0.0, to 0.05\n",
            "type": "number",
            "format": "float"
          },
          "underWaterVignetteIntensity": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurScale": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurFocalDistance": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurNearTransitionRegion": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underWaterBlurFarTransitionRegion": {
            "description": "",
            "type": "number",
            "format": "float"
          },
          "underwaterColor": {
            "$ref": "#/components/schemas/Color"
          },
          "useDynamicLighting": {
            "description": "Whether or not to use dynamic lighting in the scene. Currently only affects the sunlight.",
            "type": "boolean"
          },
          "renderSkySphere": {
            "description": "Whether or not to render the sky. Can be used to turn off sky rendering for indoor scenes.",
            "type": "boolean"
          },
          "hideSkySphereUnderWater": {
            "description": "Whether or not to render the sky when below the water surface. Requires 'renderSkySphere' to be true to have any effect.",
            "type": "boolean"
          },
          "useTimeOfDayUpdate": {
            "description": "Whether or not to update the sun and sky according to the time of day",
            "type": "boolean"
          },
          "directionalLightSettings": {
            "$ref": "#/components/schemas/DirLightSettings"
          }
        }
      },
      "VisibilityLayers": {
        "description": "A view mode determines the visibility of a set of objects in the scene.<br> If a view mode is toggled, then it toggles the visibility of all its referenced objects.",
        "type": "object",
        "required": [
          "name",
          "actorNames"
        ],
        "properties": {
          "name": {
            "description": "The name of the view mode as it appears in the user interface",
            "type": "string"
          },
          "actorNames": {
            "description": "A set of objects which is referenced by this view mode for visibility filtering.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AbsoluteTransformType": {
        "type": "string",
        "enum": [
          "unrealTransform",
          "universalTransform"
        ],
        "description": "Specification of the format or coordinate system of a (world space) transform:\n   * `unrealTransform` - Coordinates are given in the Unreal Engine 4 coordinate system.\n   * `universalTransform` - Coordinates are given in a geographic coordinate system described by a CRS.\n"
      },
      "DirLightSettings": {
        "type": "object",
        "description": "controls the settings of a directional light",
        "properties": {
          "intensity": {
            "type": "number",
            "format": "float"
          },
          "color": {
            "$ref": "#/components/schemas/Color"
          },
          "rotation": {
            "description": "Rotates the target light. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around its local Y, X and Z axes respectively. A value of [0.0, 0.0, 0.0] corresponds to no change.",
            "type": "array",
            "example": [
              -90,
              0,
              180
            ],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "TimeseriesFilterType": {
        "type": "string",
        "enum": [
          "nameRegex",
          "metadataExactMatch"
        ],
        "description": "Describes which predicate type to use in filtering the timeseries.\n  * `nameRegex` - The filter will only keep timeseries in which the name field is accepted by the specified regular expression string.\n  * `metadataExactMatch` - THe filter will only keep timeseries in which the metadata field contains a given key-value pair of strings.\n"
      },
      "AbsoluteTransform": {
        "description": "A world space transform - a transformation of position, rotation and scale in the coordinate system of the 3D scene.<br> Variants:\n  * `unrealTransform` - A world space transform represented in the Unreal Engine 4 coordinate system.\n  * `universalTransform` - A world space transform represented geographic coordinate system described by a CRS. For this to work correctly, the scene must be set up with proper geographic coordinates.\n",
        "type": "object",
        "required": [
          "type"
        ],
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "unrealTransform": "#/components/schemas/UnrealTransform",
            "universalTransform": "#/components/schemas/UniversalTransform"
          }
        },
        "properties": {
          "type": {
            "$ref": "#/components/schemas/AbsoluteTransformType"
          }
        }
      },
      "UnrealTransform": {
        "description": "A world space transform represented in the Unreal Engine 4 coordinate system.",
        "allOf": [
          {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          {
            "type": "object",
            "required": [
              "position",
              "rotation",
              "scale"
            ],
            "properties": {
              "position": {
                "description": "The position of the target object in the scene coordinate system. Expects an array of three numbers for position (in centimeters) along the XYZ-axes.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "rotation": {
                "description": "The orientation of the target object in the space of the 3D scene. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around the Y, X and Z axes of the scene respectively.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "scale": {
                "description": "Scales the target object along each axis in its local coordinate system. Expects an array of three numbers describing scale multipliers along the XYZ-axes. A value of [1.0, 1.0, 1.0] corresponds to the original scale. Note that not all objects support non-uniform scaling (different scale values along each axis).",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        ]
      },
      "UniversalTransform": {
        "description": "A world space transform represented geographic coordinate system described by a CRS. For this to work correctly, the scene must be set up with proper geographic coordinates.",
        "allOf": [
          {
            "$ref": "#/components/schemas/AbsoluteTransform"
          },
          {
            "type": "object",
            "required": [
              "location",
              "rotation",
              "scale"
            ],
            "properties": {
              "location": {
                "$ref": "#/components/schemas/GeographicLocation"
              },
              "rotation": {
                "description": "The orientation of the target object in the space of the 3D scene. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around the Y, X and Z axes of the scene respectively.",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              "scale": {
                "description": "Scales the target object along each axis in its local coordinate system. Expects an array of three numbers describing scale multipliers along the XYZ-axes. A value of [1.0, 1.0, 1.0] corresponds to the original scale. Note that not all objects support non-uniform scaling (different scale values along each axis).",
                "type": "array",
                "minItems": 3,
                "maxItems": 3,
                "items": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        ]
      },
      "RelativeTransform": {
        "description": "A transformation in an object's local coordinate system. This is primarily used for changing the origin, scale or default orientation of a 3D model.",
        "type": "object",
        "required": [
          "position",
          "rotation",
          "scale"
        ],
        "properties": {
          "position": {
            "description": "Offsets the position of the target object in its local coordinate system. This is equivalent to changing the origin of the object. Expects an array of three numbers, corresponding to offsets along the XYZ-axes. A value of [0.0, 0.0, 0.0] corresponds to no change.",
            "type": "array",
            "example": [
              100,
              0,
              -50
            ],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "rotation": {
            "description": "Rotates the target object in its local coordinate system. Expects an array of three numbers describing the Pitch, Yaw and Roll angles in degrees. This corresponds to rotation around its local Y, X and Z axes respectively. A value of [0.0, 0.0, 0.0] corresponds to no change.",
            "type": "array",
            "example": [
              -90,
              0,
              180
            ],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          },
          "scale": {
            "description": "Scales the target object along each axis in its local coordinate system. Expects an array of three numbers describing scale multipliers along the XYZ-axes. A value of [1.0, 1.0, 1.0] corresponds to the original scale. Note that not all objects support non-uniform scaling (different scale values along each axis).",
            "type": "array",
            "example": [
              0.5,
              0.5,
              0.5
            ],
            "minItems": 3,
            "maxItems": 3,
            "items": {
              "type": "number",
              "format": "float"
            }
          }
        }
      },
      "Color": {
        "type": "string",
        "description": "Color in hexadecimal format (HTML standard)",
        "example": "#05ff54"
      },
      "TimeseriesFilter": {
        "description": "The base class of all timeseries filter implementations.\n  * `type` The predicate type to use for filtering timeseries.\n",
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/TimeseriesFilterType"
          }
        },
        "discriminator": {
          "propertyName": "type",
          "mapping": {
            "nameRegex": "#/components/schemas/TimeseriesFilterNameRegex",
            "metadataExactMatch": "#/components/schemas/TimeseriesFilterMetadataExactMatch"
          }
        }
      },
      "TimeseriesFilterNameRegex": {
        "description": "A timeseries filter which keeps only the timeseries in which the name field is accepted by the specifiec regular expression string.\n  *  `regexString` - The regular expression to match against. The regular expression syntax is given by ICU and can be found at http://userguide.icu-project.org/strings/regexp\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TimeseriesFilter"
          },
          {
            "type": "object",
            "required": [
              "regexString"
            ],
            "properties": {
              "regexString": {
                "type": "string"
              }
            },
            "description": "The timeseries name regex to filter with\n"
          }
        ]
      },
      "TimeseriesFilterMetadataExactMatch": {
        "description": "A timeseries filter which keeps only the timeseries which contain the given key-value string pair. The strings must match exactly.\n  * `key` - The metadata key entry to match\n  * `value` - The metadata value entry to match\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/TimeseriesFilter"
          },
          {
            "type": "object",
            "required": [
              "key",
              "value"
            ],
            "properties": {
              "key": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "description": "The timeseries metadata entry to filter on\n"
          }
        ]
      },
      "FileId": {
        "type": "integer",
        "example": 1234,
        "description": "The file ID of a file in CDF.",
        "format": "int64"
      },
      "FileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The file external ID of a file in CDF."
      },
      "GaugeType": {
        "type": "string",
        "description": "Type of gauge in image. Either \"analog\", \"digital\" or \"level\".",
        "example": "analog"
      },
      "Unit": {
        "type": "string",
        "example": "bar",
        "description": "The unit of the gauge."
      },
      "DeadAngle": {
        "type": "number",
        "example": 1.57,
        "description": "The angle between the start and end point on the bottom part of an analog gauge, measured in radians."
      },
      "MinLevel": {
        "type": "number",
        "example": 0,
        "description": "The start value of the gauge."
      },
      "MaxLevel": {
        "type": "number",
        "example": 100,
        "description": "The end value of the gauge."
      },
      "MinNumDigits": {
        "type": "integer",
        "example": 2,
        "description": "Minimum number of digits on a digital gauge."
      },
      "MaxNumDigits": {
        "type": "integer",
        "example": 5,
        "description": "Maximum number of digits on a digital gauge."
      },
      "CommaPos": {
        "type": "integer",
        "example": 3,
        "description": "Number of digits after comma in a digital gauge."
      },
      "NeedlePoints": {
        "type": "object",
        "description": "Coordinates of needle ends in an analog gauge.",
        "example": {
          "startX": 0.1,
          "startY": 0.2,
          "tipX": 0.3,
          "tipY": 0.4
        },
        "required": [
          "startX",
          "startY",
          "tipX",
          "tipY"
        ],
        "properties": {
          "startX": {
            "type": "number"
          },
          "startY": {
            "type": "number"
          },
          "tipX": {
            "type": "number"
          },
          "tipY": {
            "type": "number"
          }
        }
      },
      "Entities": {
        "type": "array",
        "example": [
          "21PT1019",
          {
            "name": "21PT1017",
            "ignoredfield": "AA11"
          },
          {
            "name": [
              "21PT1017-A",
              "21PT1017-B"
            ]
          }
        ],
        "description": "A list of entities to look for in the P&ID. For example, all the assets under a root node. The entities can either be strings or objects. If objects, the searchField determines which string or strings that identify the entities. The value of an entity searchField could be a string or a list of strings, and if one of the strings is detected, the entity will be added to the detection result. ",
        "items": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "object"
            }
          ]
        }
      },
      "SearchField": {
        "type": "string",
        "example": "name",
        "default": "name",
        "description": "The field that determines the string or strings to search for and identify object entities. An object entity can have a string or a list of strings as value in its search field, and detecting any of the strings will identify the entity."
      },
      "NameMapping": {
        "type": "object",
        "example": {
          "21PT1019": "PT1019",
          "21PT1017": "PT1017"
        },
        "description": "Optional mapping between entity names and their synonyms in the P&ID. Use this if the P&ID contains names on a different form than the entity list. For example if the asset names have a prefix that is not in the P&ID. The response contain names as provided in the entity list."
      },
      "PartialMatch": {
        "type": "boolean",
        "description": "Allow partial (fuzzy) matching of entity names in the P&ID. Will only match when it is possible to do so unambiguously.",
        "default": false
      },
      "MinTokens": {
        "type": "integer",
        "description": "Each detected asset must match the matched entity on at least this number of tokens. That is, substrings of consecutive letters or consecutive digits.",
        "default": 2
      },
      "Patterns": {
        "type": "array",
        "example": [
          "([0-9]{2})-([A-Z]{2,3})-([0-9]{4,5})",
          "(TAG)_([0-9]{2,4})"
        ],
        "description": "Regular expression pattern to look for in the P&ID. The regular expressions must follow the rules described above.",
        "items": {
          "type": "string"
        }
      },
      "BoundingBox": {
        "type": "object",
        "description": "Bounding box in normalized coordinates with (0,0) corresponding to the upper left corner and (1,1) corresponding to the lower right corner of the image.",
        "example": {
          "xMax": 0.5895183277794608,
          "xMin": 0.573159648591336,
          "yMax": 0.3737254901960784,
          "yMin": 0.3611764705882352
        },
        "required": [
          "xMax",
          "xMin",
          "yMax",
          "yMin"
        ],
        "properties": {
          "xMax": {
            "type": "number"
          },
          "xMin": {
            "type": "number"
          },
          "yMax": {
            "type": "number"
          },
          "yMin": {
            "type": "number"
          }
        }
      },
      "Annotation": {
        "description": "Annotation representing a detected entity.",
        "type": "object",
        "required": [
          "text",
          "boundingBox",
          "confidence",
          "type"
        ],
        "properties": {
          "text": {
            "description": "The text extracted by the engine.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "entities": {
            "description": "The object corresponding to the extracted text.",
            "type": "object",
            "example": {
              "name": "21-PT-1019",
              "someField": "value"
            }
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox"
          },
          "confidence": {
            "type": "number",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "type": {
            "type": "string",
            "enum": [
              "word",
              "paragraph"
            ]
          }
        }
      },
      "Vertex": {
        "type": "object",
        "description": "A vertex represents a 2D point in the image. The vertex coordinates are normalized.",
        "example": {
          "x": 0.58,
          "y": 0.12
        },
        "required": [
          "x",
          "y"
        ],
        "properties": {
          "x": {
            "type": "number",
            "description": "Normalized x coordinate.",
            "minimum": 0,
            "maximum": 1
          },
          "y": {
            "type": "number",
            "description": "Normalized y coordinate.",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "Region": {
        "description": "Shape and coordinates of the detected entity in the image.",
        "type": "object",
        "required": [
          "shape",
          "vertices"
        ],
        "properties": {
          "shape": {
            "type": "string",
            "description": "The geometrical shape of the image region to which a detected entity belongs.",
            "enum": [
              "points",
              "rectangle",
              "polyline",
              "polygon"
            ]
          },
          "vertices": {
            "type": "array",
            "description": "List of vertices representing the image region to which a detected entity belongs.",
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/Vertex"
            }
          }
        }
      },
      "DiagramRegion": {
        "description": "Shape and coordinates of the detected entity in the image.",
        "type": "object",
        "required": [
          "shape",
          "vertices"
        ],
        "properties": {
          "shape": {
            "type": "string",
            "description": "The geometrical shape of the image region to which a detected entity belongs.",
            "enum": [
              "rectangle"
            ]
          },
          "vertices": {
            "type": "array",
            "description": "List of vertices representing the image region to which a detected entity belongs.",
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/Vertex"
            },
            "minItems": 4,
            "maxItems": 4
          }
        }
      },
      "JobId": {
        "description": "Contextualization job ID.",
        "type": "integer",
        "example": 123,
        "format": "int64"
      },
      "JobStatus": {
        "description": "The status of the job.",
        "type": "string",
        "enum": [
          "Queued",
          "Running",
          "Completed",
          "Failed"
        ]
      },
      "BatchJobStatus": {
        "description": "The status of the job.",
        "type": "string",
        "enum": [
          "Queued",
          "Distributing",
          "Running",
          "Collecting",
          "Completed",
          "Failed",
          "Timeout"
        ]
      },
      "ErrorMessage": {
        "description": "Error message returned by the model if it fails.",
        "type": "string",
        "example": "Found zero entities, expecting more."
      },
      "ModelName": {
        "type": "string",
        "description": "User defined name.",
        "example": "simple_model_1",
        "maxLength": 256
      },
      "ModelDescription": {
        "type": "string",
        "description": "User defined description.",
        "example": "Simple model 1",
        "maxLength": 500
      },
      "FeatureType": {
        "type": "string",
        "example": "simple",
        "enum": [
          "simple",
          "insensitive",
          "bigram",
          "frequencyweightedbigram",
          "bigramextratokenizers",
          "bigramcombo"
        ],
        "default": "simple",
        "description": "Each feature type defines one combination of features that will be created and used in the entity matcher model. All features are based on matching tokens. Tokens are defined at the top of the Entity matching section.\nThe options are:\n  * Simple: Calculates the cosine-distance similarity score for each of the pairs of fields defined in `matchFields`. This is the fastest option.\n  * Insensitive: Similar to Simple, but ignores lowercase/uppercase differences.\n  * Bigram: Similar to `simple`, but adds similarity score based on matching bigrams of the tokens.\n  * FrequencyWeightedBigram: Similar to `bigram`, but give higher weights to less commonly occurring tokens.\n  * BigramExtraTokenizers: Similar to `bigram`, but able to learn that leading zeros, spaces, and uppercase/lowercase differences should be ignored in matching.\n  * BigramCombo: Calculates all of the above options, relying on the model to determine the appropriate features to use.\n  Hence, this option is only appropriate if there are  labeled data/trueMatches. This is the slowest option.\n"
      },
      "Classifier": {
        "type": "string",
        "description": "The classifier used in the model. Only relevant if there are trueMatches/labeled data and a supervised model is fitted.",
        "example": "randomforest",
        "default": "randomforest",
        "enum": [
          "randomforest",
          "decisiontree",
          "logisticregression",
          "augmentedlogisticregression",
          "augmentedrandomforest"
        ]
      },
      "IgnoreMissingFields": {
        "type": "boolean",
        "default": false,
        "example": true,
        "description": "If True, replaces missing fields in `sources` or `targets` entities, for fields set in set in `matchFields`, with empty strings. Else, returns an error if there are missing data."
      },
      "MatchFields": {
        "type": "array",
        "example": [
          {
            "source": "name",
            "target": "name"
          },
          {
            "source": "field",
            "target": "somefield"
          }
        ],
        "description": "List of pairs of fields from the target and source items used to calculate features. All source and target items should have all the `source` and `target` fields specified here.",
        "items": {
          "type": "object",
          "required": [
            "source",
            "target"
          ],
          "properties": {
            "source": {
              "type": "string"
            },
            "target": {
              "type": "string"
            }
          }
        }
      },
      "PipelineName": {
        "type": "string",
        "description": "User defined name of the pipeline.",
        "example": "my_pipeline",
        "maxLength": 256
      },
      "PipelineDescription": {
        "type": "string",
        "description": "User defined description of the pipeline.",
        "example": "My pipeline",
        "maxLength": 500
      },
      "PipelineScoreThreshold": {
        "type": "number",
        "example": 0.7,
        "minimum": 0,
        "maximum": 1,
        "default": 0,
        "description": "Only return model matches with score above this threshold."
      },
      "PipelineReplacements": {
        "type": "array",
        "description": "Replace strings in entity fields. You can use this field to add input naming variations to the entity matching model to improve the suggested matches, for example, 'pmp' for 'pump' and 'bhp' for 'bottom hole pressure'. To avoid false positives, we recommend using the longer string as 'string' and the shorter as 'replacement'.",
        "items": {
          "type": "object",
          "required": [
            "field",
            "string",
            "replacement"
          ],
          "properties": {
            "field": {
              "type": "string",
              "description": "Which field to replace in. Can be '*' to affect all fields in both source and targets."
            },
            "string": {
              "type": "string",
              "description": "String to search for and replace in both sources and targets."
            },
            "replacement": {
              "type": "string",
              "description": "Replacement for the string."
            }
          }
        }
      },
      "PipelineUseExistingMatches": {
        "type": "boolean",
        "example": true,
        "default": false,
        "description": "Use existing (id/assetId) links on the CDF resources as traning data when the entity matching model is created."
      },
      "Sources": {
        "type": "array",
        "items": {
          "type": "object",
          "example": {
            "id": 10,
            "name": "a_name",
            "field": "value",
            "ignoredfield": {
              "key": "value"
            }
          }
        },
        "description": "List of custom source object to match from, for example, time series. String key -> value. Only string values are considered in the matching. Optional id and/or externalId fields."
      },
      "Targets": {
        "type": "array",
        "items": {
          "type": "object",
          "example": {
            "id": 6,
            "name": "some_name",
            "somefield": "value",
            "ignoredfield": {
              "key": "value"
            }
          }
        },
        "description": "List of custom target object to match to, for example, assets. String key -> value. Only string values are considered in the matching. Optional id and/or externalId fields."
      },
      "EitherId": {
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            {
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          ]
        }
      },
      "SourceId": {
        "description": "The id for the from-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "SourceExternalId": {
        "description": "The external id for the source-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        ]
      },
      "TargetId": {
        "description": "The id for the target-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "TargetExternalId": {
        "description": "The external id for the to-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        ]
      },
      "TrueMatches": {
        "type": "array",
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a match used to train the model. If omitted, an unsupervised model is used.",
        "items": {
          "type": "object",
          "example": [
            {
              "sourceId": 1,
              "targetId": 1
            },
            {
              "sourceExternalId": "2",
              "targetExternalId": "2"
            }
          ],
          "oneOf": [
            {
              "properties": {
                "sourceId": {
                  "$ref": "#/components/schemas/SourceId"
                },
                "targetId": {
                  "$ref": "#/components/schemas/TargetId"
                }
              }
            },
            {
              "properties": {
                "sourceId": {
                  "$ref": "#/components/schemas/SourceId"
                },
                "targetExternalId": {
                  "$ref": "#/components/schemas/TargetExternalId"
                }
              }
            },
            {
              "properties": {
                "sourceExternalId": {
                  "$ref": "#/components/schemas/SourceExternalId"
                },
                "targetId": {
                  "$ref": "#/components/schemas/TargetId"
                }
              }
            },
            {
              "properties": {
                "sourceExternalId": {
                  "$ref": "#/components/schemas/SourceExternalId"
                },
                "targetExternalId": {
                  "$ref": "#/components/schemas/TargetExternalId"
                }
              }
            }
          ]
        }
      },
      "ConfirmedMatches": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TrueMatches"
          }
        ],
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a confirmed match by the user. A source and target pair in this list will override results from a model or rules and will therefore always be returned as a match. The matches are also used as training data when the entity matcher model is created."
      },
      "RejectedMatches": {
        "allOf": [
          {
            "$ref": "#/components/schemas/TrueMatches"
          }
        ],
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a match rejected by the user. A source and target pair in this list will override results from a model or rules and will never be returned as a match."
      },
      "ModelParameters": {
        "type": "object",
        "example": {
          "featureType": "bigram"
        },
        "description": "The parameters used in the entity matching model.",
        "properties": {
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "classifier": {
            "$ref": "#/components/schemas/Classifier"
          },
          "matchFields": {
            "$ref": "#/components/schemas/MatchFields"
          }
        }
      },
      "ContextJobSchema": {
        "type": "object",
        "required": [
          "jobId",
          "status"
        ],
        "properties": {
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatus"
          }
        }
      },
      "ContextModelReferenceSchema": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "EntityMatchingFeatureSchema": {
        "type": "object",
        "properties": {
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "classifier": {
            "description": "Name of the classifier used in the model, \"Unsupervised\" if unsupervised model.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Classifier"
              }
            ]
          },
          "ignoreMissingFields": {
            "description": "If True, missing fields in `sources` or `targets` entities set in `matchFields`, are replaced with empty strings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/IgnoreMissingFields"
              }
            ]
          },
          "matchFields": {
            "$ref": "#/components/schemas/MatchFields"
          },
          "originalId": {
            "type": "integer",
            "description": "The ID of original model, only relevant when the model is a retrained model.",
            "example": 111
          },
          "name": {
            "$ref": "#/components/schemas/ModelName"
          },
          "description": {
            "$ref": "#/components/schemas/ModelDescription"
          }
        }
      },
      "EntityMatcherResponseSchema": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/ContextModelReferenceSchema"
          },
          {
            "$ref": "#/components/schemas/EntityMatchingFeatureSchema"
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          }
        ]
      },
      "EntityMatcherPipelinesSchema": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "$ref": "#/components/schemas/PipelineName"
          },
          "description": {
            "$ref": "#/components/schemas/PipelineDescription"
          },
          "sources": {
            "$ref": "#/components/schemas/PipelineSources"
          },
          "targets": {
            "$ref": "#/components/schemas/PipelineTargets"
          },
          "confirmedMatches": {
            "$ref": "#/components/schemas/ConfirmedMatches"
          },
          "rejectedMatches": {
            "$ref": "#/components/schemas/RejectedMatches"
          },
          "useExistingMatches": {
            "$ref": "#/components/schemas/PipelineUseExistingMatches"
          },
          "scoreThreshold": {
            "$ref": "#/components/schemas/PipelineScoreThreshold"
          },
          "replacements": {
            "$ref": "#/components/schemas/PipelineReplacements"
          },
          "modelParameters": {
            "$ref": "#/components/schemas/ModelParameters"
          },
          "rules": {
            "$ref": "#/components/schemas/MatchRule"
          }
        }
      },
      "StatusSchema": {
        "type": "object",
        "required": [
          "status",
          "createdTime",
          "startTime",
          "statusTime"
        ],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/JobStatus"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "startTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              {
                "nullable": true
              }
            ]
          },
          "statusTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "SinglePatchRequiredName": {
        "title": "Name",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelName"
          }
        },
        "description": "Set a new value for name.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredDescription": {
        "title": "Description",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelDescription"
          }
        },
        "description": "Set a new value for description.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredModelParameters": {
        "title": "ModelParameters",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelParameters"
          }
        },
        "description": "Set a new value for modelParameters.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredSources": {
        "title": "Sources",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/Sources"
          }
        },
        "description": "Set a new value for Sources.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredTargets": {
        "title": "Targets",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/Targets"
          }
        },
        "description": "Set a new value for Targets.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredRules": {
        "title": "Rules",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/MatchRule"
          }
        },
        "description": "Set a new value for Rules.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredConfirmedMatches": {
        "title": "TrueMatches",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ConfirmedMatches"
          }
        },
        "description": "Set a new value for confirmedMatches.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredRejectedMatches": {
        "title": "RejectedMatches",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/TrueMatches"
          }
        },
        "description": "Set a new value for rejectedMatches.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredScoreThreshold": {
        "title": "ScoreThreshold",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineScoreThreshold"
          }
        },
        "description": "Set a new value for scoreThreshold.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredUseExistingMatches": {
        "title": "UseExistingMatches",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineUseExistingMatches"
          }
        },
        "description": "Set a new value for useExistingMatches.",
        "required": [
          "set"
        ]
      },
      "PipelineChange": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/PipelineChangeById"
          },
          {
            "$ref": "#/components/schemas/PipelineChangeByExternalId"
          }
        ]
      },
      "PipelineChangeById": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PipelinePatch"
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "PipelineChangeByExternalId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PipelinePatch"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "PipelinePatch": {
        "type": "object",
        "description": "Changes applied to model",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/SinglePatchRequiredName"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchRequiredDescription"
              },
              "modelParameters": {
                "$ref": "#/components/schemas/SinglePatchRequiredModelParameters"
              },
              "sources": {
                "$ref": "#/components/schemas/SinglePatchRequiredSources"
              },
              "targets": {
                "$ref": "#/components/schemas/SinglePatchRequiredTargets"
              },
              "useExistingMatches": {
                "$ref": "#/components/schemas/SinglePatchRequiredUseExistingMatches"
              },
              "rules": {
                "$ref": "#/components/schemas/SinglePatchRequiredRules"
              },
              "scoreThreshold": {
                "$ref": "#/components/schemas/SinglePatchRequiredScoreThreshold"
              },
              "confirmedMatches": {
                "$ref": "#/components/schemas/SinglePatchRequiredConfirmedMatches"
              },
              "rejectedMatches": {
                "$ref": "#/components/schemas/SinglePatchRequiredRejectedMatches"
              }
            }
          }
        }
      },
      "PipelineSources": {
        "type": "object",
        "required": [
          "dataSetIds",
          "assetSubtreeIds",
          "entities"
        ],
        "oneOf": [
          {
            "properties": {
              "dataSetIds": {
                "type": "array",
                "description": "List of id or externalId for datasets to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "$ref": "#/components/schemas/PipelineResourceType"
              }
            }
          },
          {
            "properties": {
              "assetSubtreeIds": {
                "type": "array",
                "description": "List of id or externalId for asset subtrees to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "$ref": "#/components/schemas/PipelineResourceType"
              }
            }
          },
          {
            "properties": {
              "entities": {
                "type": "array",
                "items": {
                  "type": "object",
                  "example": {
                    "id": 10,
                    "name": "a_name",
                    "field": "value",
                    "ignoredfield": {
                      "key": "value"
                    }
                  }
                },
                "description": "List of custom source object to match from, for example, time series. String key -> value. Optional id and/or externalId fields."
              }
            }
          }
        ]
      },
      "PipelineTargets": {
        "type": "object",
        "required": [
          "dataSetIds",
          "assetSubtreeIds",
          "entities"
        ],
        "oneOf": [
          {
            "properties": {
              "dataSetIds": {
                "type": "array",
                "description": "List of id or externalId for datasets to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "default": "assets",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "properties": {
              "assetSubtreeIds": {
                "type": "array",
                "description": "List of id or externalId for asset subtrees to use.",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                }
              },
              "resource": {
                "default": "assets",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "properties": {
              "entities": {
                "type": "array",
                "items": {
                  "type": "object",
                  "example": {
                    "id": 10,
                    "name": "a_name",
                    "field": "value",
                    "ignoredfield": {
                      "key": "value"
                    }
                  }
                },
                "description": "List of custom target object to match to, for example, assets. String key -> value. Optional id and/or externalId fields."
              }
            }
          }
        ]
      },
      "PipelineResourceType": {
        "type": "string",
        "description": "Resource type.",
        "example": "assets",
        "enum": [
          "assets",
          "time_series",
          "events",
          "files",
          "sequences"
        ],
        "default": "time_series"
      },
      "AvgScore": {
        "type": "number",
        "format": "float",
        "example": 0.9,
        "minimum": 0,
        "maximum": 1,
        "description": "The average score of the rule."
      },
      "ApplyPriorityRulesRequest": {
        "type": "object",
        "required": [
          "sources",
          "targets",
          "rules"
        ],
        "properties": {
          "sources": {
            "type": "array",
            "example": [
              {
                "id": 1,
                "name": "Lady",
                "species": "dog"
              },
              {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              {
                "id": 6,
                "name": "Madame Mim",
                "species": "witch"
              }
            ],
            "items": {
              "type": "object"
            },
            "description": "List of source entities, for example time series, to match with target entities."
          },
          "targets": {
            "type": "array",
            "example": [
              {
                "id": 2,
                "name": "the tramp",
                "species": "dog"
              },
              {
                "id": 4,
                "name": "Donald",
                "species": "bird"
              },
              {
                "id": 5,
                "name": "Gander",
                "species": "bird"
              }
            ],
            "items": {
              "type": "object"
            },
            "description": "List of target entities, for example assets, to match with source entities."
          },
          "rules": {
            "description": "A list of rules with priorities. Each rule describes specific conditions for two entities to match. A single rule usually only applies to a limited set of entities and entities that do not match by one rule may well match by another. If separate rules match a source entity to different target entities, only the highest priority rules are applied to that source entity.",
            "type": "array",
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/MatchRule"
            }
          }
        }
      },
      "MatchRule": {
        "description": "An entity matching rule matches source entities with target entities based on a pattern defined by the rule. A rule has extractors that both require entities to follow a certain format, and produce lists of features. For a regex extractor, a specific field must match a pattern, and parts of the pattern become the features. The conditions of a rule express which extracted features must be equal for two entities to match. Since extractors restrict the scopes of rules to entities that conform with patterns, two rules will often not have entities in common that they apply to. But if they do, the more specific rule is given higher priority. If one rule is not a special case of the other, they may be inconsistent (conflict) or redundant (overlap).",
        "type": "object",
        "required": [
          "extractors",
          "conditions"
        ],
        "example": {
          "extractors": [
            {
              "entitySet": "sources",
              "extractorType": "regex",
              "field": "species",
              "pattern": "(.*)"
            },
            {
              "entitySet": "targets",
              "extractorType": "regex",
              "field": "species",
              "pattern": "(.*)"
            }
          ],
          "conditions": [
            {
              "conditionType": "equals",
              "arguments": [
                [
                  0,
                  0
                ],
                [
                  1,
                  0
                ]
              ]
            }
          ],
          "priority": 10
        },
        "properties": {
          "extractors": {
            "type": "array",
            "description": "An extractor produces a list of features based on a source entity or a target entity. In particular a regex extractor defines which entities (e.g. sources) it acts on, a field (e.g. name) and a regular expression. The extractor will only produce features if the field of an entity matches the pattern. The returned features are then substrings of the field as defined in the pattern. Entities in the relevant set that do not match the pattern will not be matched by the rule, but may be matched by other rules.",
            "items": {
              "$ref": "#/components/schemas/RegexExtractor"
            }
          },
          "conditions": {
            "type": "array",
            "description": "List of conditions that must be met for the rule to link two entities. The conditions refer to features extracted by the extractors. A condition of type \"equals\" that refers to features extracted from a source entity and a target entity requires these features to be equal for the entities to match.",
            "items": {
              "$ref": "#/components/schemas/MatchCondition"
            }
          },
          "priority": {
            "type": "number",
            "format": "int64",
            "minimum": 0,
            "default": 0,
            "description": "In case different rules provide matches for the same source entities, only the highest priority rules are applied to these entities."
          }
        }
      },
      "RegexExtractor": {
        "type": "object",
        "required": [
          "entitySet",
          "extractorType",
          "field",
          "pattern"
        ],
        "description": "An extractor that acts on entities from 'entitySet'. An entity must have a value of 'field' that matches the regular expression 'pattern' to get features. The features are the catching groups of the pattern, that is the parts that are in parenthesis. E.g. ([A-Z])-00([0-9]) applied to A-007 produces [A, 7] as features.",
        "properties": {
          "entitySet": {
            "type": "string",
            "description": "Which set of entities the extractor will extract features from.",
            "enum": [
              "sources",
              "targets"
            ]
          },
          "extractorType": {
            "type": "string",
            "description": "The type of extractor. Currently,  we only support \"regex\".",
            "enum": [
              "regex"
            ]
          },
          "field": {
            "type": "string",
            "description": "The entity field that the extractor will get features from."
          },
          "pattern": {
            "type": "string",
            "description": "A regular expression without nested catching groups."
          }
        }
      },
      "MatchCondition": {
        "type": "object",
        "required": [
          "conditionType",
          "arguments"
        ],
        "properties": {
          "conditionType": {
            "type": "string",
            "description": "The type of condition. Currently, we only support the 'equals' condition. It requires all features referenced by its arguments to be equal.",
            "enum": [
              "equals"
            ]
          },
          "arguments": {
            "type": "array",
            "description": "References to features. Each argument is a list with two zero indexed indices. E.g. [0, 1] refers to the 1th (second) feature produced by the 0th (first) extractor of the rule.",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "int64",
                "minimum": 0
              }
            }
          },
          "config": {
            "$ref": "#/components/schemas/MatchConditionConfig"
          }
        }
      },
      "MatchConditionConfig": {
        "type": "object",
        "description": "Configuration of the condition not captured in its arguments and type.",
        "properties": {
          "synonyms": {
            "type": "array",
            "description": "Entries describing tokens that are equivalent.",
            "items": {
              "$ref": "#/components/schemas/SynonymEntry"
            },
            "example": [
              {
                "sources": [
                  "odour"
                ],
                "targets": [
                  "odor"
                ]
              },
              {
                "sources": [
                  "petrol"
                ],
                "targets": [
                  "gas",
                  "gasoline"
                ]
              }
            ]
          }
        }
      },
      "SynonymEntry": {
        "type": "object",
        "description": "List of sources and targets words that all mean the same.",
        "properties": {
          "sources": {
            "type": "array",
            "description": "List of tokens that have the same meaning when appearing in a source entity.",
            "items": {
              "type": "string"
            }
          },
          "targets": {
            "type": "array",
            "description": "List of tokens that have the same meaning when appearing in a target entity.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "SuggestPriorityRulesRequest": {
        "type": "object",
        "required": [
          "sources",
          "targets",
          "matches"
        ],
        "properties": {
          "sources": {
            "example": [
              {
                "id": 1,
                "name": "Lady",
                "species": "dog"
              },
              {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              {
                "id": 6,
                "name": "Madame Mim",
                "species": "witch"
              }
            ],
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "List of source entities, for example time series, to match with target entities."
          },
          "targets": {
            "example": [
              {
                "id": 2,
                "name": "the tramp",
                "species": "dog"
              },
              {
                "id": 4,
                "name": "Donald",
                "species": "bird"
              },
              {
                "id": 5,
                "name": "Gander",
                "species": "bird"
              }
            ],
            "type": "array",
            "items": {
              "type": "object"
            },
            "description": "List of target entities, assets for instance, to match with source entities."
          },
          "matches": {
            "type": "array",
            "description": "List of objects with either sourceId or sourceExternalId and either targetId or targetExternalId. The provided ids must correspond to id or externalId of a source entity and a target entity respectively. The entries represent matches that the suggested rules try to reproduce.",
            "items": {
              "type": "object",
              "example": [
                {
                  "sourceId": 1,
                  "targetId": 2
                }
              ],
              "oneOf": [
                {
                  "properties": {
                    "sourceId": {
                      "$ref": "#/components/schemas/SourceId"
                    },
                    "targetId": {
                      "$ref": "#/components/schemas/TargetId"
                    }
                  }
                },
                {
                  "properties": {
                    "sourceId": {
                      "$ref": "#/components/schemas/SourceId"
                    },
                    "targetExternalId": {
                      "$ref": "#/components/schemas/TargetExternalId"
                    }
                  }
                },
                {
                  "properties": {
                    "sourceExternalId": {
                      "$ref": "#/components/schemas/SourceExternalId"
                    },
                    "targetId": {
                      "$ref": "#/components/schemas/TargetId"
                    }
                  }
                },
                {
                  "properties": {
                    "sourceExternalId": {
                      "$ref": "#/components/schemas/SourceExternalId"
                    },
                    "targetExternalId": {
                      "$ref": "#/components/schemas/TargetExternalId"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "AppliedRulesItem": {
        "type": "object",
        "properties": {
          "flags": {
            "type": "array",
            "description": "An array of flags resulting from applying this rule. If a rule has more matches than there are source entities, it will yield no matches and get the flag \"Too many matches\".",
            "items": {
              "type": "string",
              "enum": [
                "Too many matches"
              ]
            }
          },
          "numberOfMatches": {
            "type": "number",
            "format": "int64",
            "minimum": 0,
            "description": "The number of matches resulting form this rule that are not part of a conflict with another rule."
          },
          "conflicts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Conflict"
            },
            "description": "Objects referencing rules and the number of times this rule conflicts with those rules."
          },
          "overlaps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Overlap"
            },
            "description": "Objects referencing other rules and the number of times this rule overlaps with those rules."
          },
          "matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Match"
            },
            "description": "List of pairs of entities that match according to this rule. Source entities that are matched by rules with higher priority will not be seen among the matches."
          },
          "rule": {
            "$ref": "#/components/schemas/MatchRule"
          }
        },
        "example": {
          "flags": [],
          "numberOfMatches": 1,
          "conflicts": [
            {
              "ruleIndex": 0,
              "multiplicity": 2
            }
          ],
          "overlaps": [],
          "matches": [
            {
              "source": {
                "id": 1,
                "name": "Lady",
                "species": "dog"
              },
              "target": {
                "id": 2,
                "name": "the tramp",
                "species": "dog"
              }
            },
            {
              "source": {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              "target": {
                "id": 4,
                "name": "Donald",
                "species": "bird"
              }
            },
            {
              "source": {
                "id": 3,
                "name": "Daisy",
                "species": "bird"
              },
              "target": {
                "id": 5,
                "name": "Gladstone",
                "species": "bird"
              }
            }
          ],
          "rule": {
            "extractors": [
              {
                "entitySet": "sources",
                "extractorType": "regex",
                "field": "species",
                "pattern": "(.*)"
              },
              {
                "entitySet": "targets",
                "extractorType": "regex",
                "field": "species",
                "pattern": "(.*)"
              }
            ],
            "conditions": [
              {
                "conditionType": "equals",
                "arguments": [
                  [
                    0,
                    0
                  ],
                  [
                    1,
                    0
                  ]
                ]
              }
            ],
            "priority": 10
          }
        }
      },
      "Conflict": {
        "type": "object",
        "properties": {
          "ruleIndex": {
            "description": "Index reference of conflicting rule, could refer to the same rule if it has multiple matches for a source.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          },
          "multiplicity": {
            "description": "Number of matches this rule produces that conflicts with the referenced rule.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "Overlap": {
        "type": "object",
        "properties": {
          "ruleIndex": {
            "description": "Index of overlapping rule.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          },
          "multiplicity": {
            "description": "Number of identical matches between this rule and the referenced rule.",
            "type": "number",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "Match": {
        "type": "object",
        "description": "Two entities that match.",
        "properties": {
          "source": {
            "type": "object",
            "description": "A source entity."
          },
          "target": {
            "type": "object",
            "description": "A target entity."
          }
        }
      },
      "Properties": {
        "type": "object",
        "description": "Properties of the template",
        "additionalProperties": {
          "type": "object",
          "description": "property of the template",
          "required": [
            "items"
          ],
          "properties": {
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/TemplateCompletionReport"
              }
            }
          }
        }
      },
      "TemplateCompletionReport": {
        "type": "object",
        "description": "Properties of the template",
        "properties": {
          "assetId": {
            "type": "integer",
            "description": "the id of the asset"
          },
          "assetExternalId": {
            "type": "string",
            "description": "the external id of the asset",
            "example": "WELL 12"
          },
          "assetName": {
            "type": "string",
            "description": "the name of the asset",
            "example": "Well 12"
          },
          "cost": {
            "type": "number",
            "description": "the cost used to match the resource with the pattern",
            "example": 0.000018
          },
          "currentExternalId": {
            "type": "string",
            "description": "the external id of the current resource",
            "example": "ABC_PT_WELL_01234"
          },
          "currentId": {
            "type": "integer",
            "description": "the id of the current resource"
          },
          "currentName": {
            "type": "string",
            "description": "the name of the current resource",
            "example": "ABC_PT_WELL_01234"
          },
          "foundExternalId": {
            "type": "string",
            "description": "External id of the found resource",
            "example": "ABC_PT_WELL_01234"
          },
          "foundExternalIds": {
            "type": "array",
            "description": "External ids of found resources"
          },
          "foundId": {
            "type": "integer",
            "description": "Id of the found resource"
          },
          "foundIds": {
            "type": "array",
            "description": "Ids of found resources"
          },
          "foundName": {
            "type": "string",
            "description": "name of the found resource",
            "example": "ABC_PT_WELL_01234"
          },
          "matchType": {
            "type": "string",
            "description": "which pattern is used to find the found resource.",
            "example": "PATTERN_1_CONFIRMED"
          }
        }
      },
      "TemplateReference": {
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string",
            "example": "templateGroupExternalId",
            "description": "External ID of the template group."
          },
          "templateName": {
            "type": "string",
            "description": "Name of the template to be completed within the template group",
            "example": "templateNameWithinTheDomain"
          },
          "assetProperty": {
            "type": "string",
            "example": "templateProperty",
            "description": "Which field (with constant type) in the template defines the externalId of the parent asset in each entry. If ommitted, it is assumed the externalId of the template instances is the same as the parent asset's externalId."
          },
          "version": {
            "type": "integer",
            "description": "Version of the domain, default at version 1",
            "example": 1
          }
        }
      },
      "ContextFileId": {
        "type": "integer",
        "example": 1234,
        "description": "The ID of a file in CDF.",
        "format": "int64"
      },
      "ContextFileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The external ID of a file in CDF."
      },
      "OneOfFileId": {
        "type": "object",
        "required": [
          "fileId",
          "fileExternalId"
        ],
        "description": "An object containg file (external) id. The file can only have maximum 50 pages.",
        "oneOf": [
          {
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/ContextFileId"
              }
            }
          },
          {
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/ContextFileExternalId"
              }
            }
          }
        ]
      },
      "AllOfFileId": {
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/ContextFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/ContextFileExternalId"
          }
        }
      },
      "DiagramDetectEntities": {
        "type": "array",
        "example": [
          {
            "userDefinedField": "21PT1017",
            "ignoredField": "AA11"
          },
          {
            "userDefinedField": [
              "21PT1017-A",
              "21PT1017-B"
            ]
          }
        ],
        "description": "A list of entities to look for. For example, all the assets under a root node. The `searchField` determines the strings that identify the entities.",
        "items": {
          "type": "object",
          "maxProperties": 256
        },
        "minItems": 1,
        "maxItems": 500000
      },
      "DiagramSearchField": {
        "type": "string",
        "example": "userDefinedField",
        "default": "name",
        "description": "This field determines the string to search for and to identify object entities."
      },
      "DiagramPartialMatch": {
        "type": "boolean",
        "description": "Allow partial (fuzzy) matching of entities in the engineering diagrams. Creates a match only when it is possible to do so unambiguously.",
        "default": false
      },
      "DiagramMinTokens": {
        "type": "integer",
        "description": "Each detected item must match the detected entity on at least this number of tokens. A token is a substring of consecutive letters or digits.",
        "default": 2
      },
      "Page": {
        "type": "integer",
        "example": 1,
        "description": "The page of the file where the annotations in `annotations` were detected.",
        "maximum": 50,
        "minimum": 1
      },
      "DiagramDetectConfig": {
        "type": "object",
        "properties": {
          "searchField": {
            "$ref": "#/components/schemas/DiagramSearchField"
          },
          "partialMatch": {
            "$ref": "#/components/schemas/DiagramPartialMatch"
          },
          "minTokens": {
            "$ref": "#/components/schemas/DiagramMinTokens"
          }
        }
      },
      "DiagramConvertConfig": {
        "type": "object",
        "properties": {
          "grayscale": {
            "$ref": "#/components/schemas/Grayscale"
          }
        }
      },
      "Grayscale": {
        "type": "boolean",
        "example": true,
        "default": true,
        "description": "Return the SVG version in grayscale colors only (reduces the file size)."
      },
      "NewAnnotation": {
        "type": "object",
        "required": [
          "text",
          "region"
        ],
        "properties": {
          "text": {
            "description": "The text and entities detected by the service.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "required": [
              "shape",
              "vertices",
              "page"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/DiagramRegion"
              },
              {
                "properties": {
                  "page": {
                    "$ref": "#/components/schemas/Page"
                  }
                }
              }
            ]
          }
        }
      },
      "DiagramDetectedEntities": {
        "type": "array",
        "example": [
          {
            "userDefinedField": "21PT1017",
            "ignoredField": "AA11"
          },
          {
            "userDefinedField": [
              "21PT1017-A",
              "21PT1017-B"
            ]
          }
        ],
        "description": "A list of entities detected per annotation.",
        "items": {
          "type": "object"
        },
        "minItems": 1,
        "maxItems": 5
      },
      "DiagramAnnotation": {
        "description": "Annotation representing a detected entity.",
        "allOf": [
          {
            "$ref": "#/components/schemas/NewAnnotation"
          },
          {
            "type": "object",
            "properties": {
              "entities": {
                "$ref": "#/components/schemas/DiagramDetectedEntities"
              }
            }
          }
        ]
      },
      "DiagramDetectResultSchema": {
        "description": "An array of detected results, returned when the job finished or failed partially.",
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "annotations": {
                      "type": "array",
                      "description": "Annotations of entities detected by the service",
                      "items": {
                        "$ref": "#/components/schemas/DiagramAnnotation"
                      }
                    }
                  }
                }
              ],
              "required": [
                "annotations"
              ]
            },
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "errorMessage": {
                      "type": "string",
                      "description": "Error message for the file."
                    }
                  }
                }
              ],
              "required": [
                "errorMessage"
              ]
            }
          ]
        }
      },
      "DiagramSvgPngResultSchema": {
        "type": "object",
        "oneOf": [
          {
            "properties": {
              "page": {
                "$ref": "#/components/schemas/Page"
              },
              "svgUrl": {
                "type": "string",
                "example": "https://storage.googleapis.com/cluster/1234/PH-ME-P-0004-001.svg",
                "description": "A signed URL to an interactive SVG version of the engineering diagram (valid for 10 minutes)."
              },
              "pngUrl": {
                "type": "string",
                "example": "https://storage.googleapis.com/cluster/1234/PH-ME-P-0004-001.png",
                "description": "A signed URL to a PNG version of the engineering diagram (valid for 10 minutes)."
              }
            },
            "required": [
              "page",
              "svgUrl",
              "pngUrl"
            ]
          },
          {
            "properties": {
              "page": {
                "$ref": "#/components/schemas/Page"
              },
              "errorMessage": {
                "type": "string",
                "description": "The error message for the page and file."
              }
            },
            "required": [
              "page",
              "errorMessage"
            ]
          }
        ]
      },
      "DiagramConvertResultSchema": {
        "description": "An array of converted results, returned when the job finished or failed partially.",
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DiagramSvgPngResultSchema"
                      },
                      "maxItems": 50
                    }
                  }
                }
              ],
              "required": [
                "results"
              ]
            },
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "errorMessage": {
                      "type": "string",
                      "description": "The error message for a file."
                    }
                  }
                }
              ],
              "required": [
                "errorMessage"
              ]
            }
          ]
        }
      },
      "DiagramConvertRequestSchema": {
        "description": "An array of files and annotations to create interactive diagrams.",
        "type": "array",
        "maxItems": 50,
        "minItems": 1,
        "items": {
          "type": "object",
          "required": [
            "annotations"
          ],
          "allOf": [
            {
              "$ref": "#/components/schemas/OneOfFileId"
            },
            {
              "properties": {
                "annotations": {
                  "description": "Annotations to draw on the engineering diagrams",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DiagramAnnotation"
                  },
                  "maxItems": 1000
                }
              }
            }
          ]
        }
      },
      "FileReference": {
        "type": "object",
        "required": [
          "fileId",
          "fileExternalId"
        ],
        "description": "An object containing file (external) id.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "fileId"
            ],
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/ContextFileId"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "fileExternalId"
            ],
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/ContextFileExternalId"
              }
            }
          }
        ]
      },
      "FailedBatch": {
        "description": "List of the items and the corresponding error message(s) per failed batch.",
        "type": "object",
        "properties": {
          "errorMessage": {
            "type": "string",
            "description": "The error message(s) of the failed batch."
          },
          "items": {
            "type": "array",
            "description": "List of the items in the failed batch.",
            "items": {
              "$ref": "#/components/schemas/AllOfFileId"
            }
          }
        }
      },
      "VisionAnnotation": {
        "description": "Annotation representing a detected entity.",
        "type": "object",
        "required": [
          "text"
        ],
        "properties": {
          "text": {
            "description": "The entity (e.g. a valve, a pump or text) detected by a computer vision model.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "GaugeReadingAnnotation": {
        "description": "Annotation representing a detected valve.",
        "type": "object",
        "required": [
          "attributes",
          "region"
        ],
        "properties": {
          "attributes": {
            "required": [
              "description",
              "gaugeValue"
            ],
            "properties": {
              "description": {
                "description": "Type of gauge",
                "type": "string",
                "example": "analog"
              },
              "gaugeValue": {
                "description": "The predicted value of the gauge.",
                "type": "number",
                "example": 1.75
              }
            }
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "VisionTagDetectionAnnotation": {
        "description": "Annotation representing detected entities.",
        "type": "object",
        "required": [
          "text",
          "assetIds"
        ],
        "properties": {
          "text": {
            "description": "The matched string which corresponds to either the name or the external id of the matched assets.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "assetIds": {
            "description": "List of internal IDs for matched assets.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "example": [
              1234,
              8888
            ]
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "ValveReadingAnnotation": {
        "description": "Annotation representing a detected valve.",
        "type": "object",
        "required": [
          "description",
          "data",
          "region"
        ],
        "properties": {
          "description": {
            "description": "valve",
            "type": "string",
            "example": "valve"
          },
          "data": {
            "required": [
              "state"
            ],
            "properties": {
              "state": {
                "description": "The predicted state of the valve.",
                "type": "string",
                "example": "on",
                "enum": [
                  "on",
                  "off",
                  "undefined"
                ]
              }
            }
          },
          "region": {
            "$ref": "#/components/schemas/Region"
          }
        }
      },
      "ThresholdParameter": {
        "title": "Threshold",
        "description": "The confidence threshold returns predictions as positive if their confidence score is the selected value or higher. \nA higher confidence threshold increases precision but lowers recall, and vice versa.\n",
        "type": "number",
        "example": 0.8,
        "minimum": 0,
        "maximum": 1
      },
      "TextDetection": {
        "title": "TextDetection",
        "description": "Detect text in images.",
        "type": "string",
        "enum": [
          "TextDetection"
        ]
      },
      "AssetTagDetection": {
        "title": "AssetTagDetection",
        "description": "Detect external ID or name of assets (from your CDF projects) in images. Usage of this feature requires `[\"assetsAcl:READ\"]` capability.",
        "type": "string",
        "enum": [
          "AssetTagDetection"
        ]
      },
      "PeopleDetection": {
        "title": "PeopleDetection",
        "description": "Detect people in images.",
        "type": "string",
        "enum": [
          "PeopleDetection"
        ]
      },
      "IndustrialObjectDetection": {
        "title": "IndustrialObjectDetection",
        "description": "Detect industrial objects such as gauges and valves in images.",
        "type": "string",
        "enum": [
          "IndustrialObjectDetection"
        ]
      },
      "PersonalProtectiveEquipmentDetection": {
        "title": "PersonalProtectiveEquipmentDetection",
        "description": "Detect personal protective equipment, such as helmet, protective eyewear, and mask in images.",
        "type": "string",
        "enum": [
          "PersonalProtectiveEquipmentDetection"
        ]
      },
      "VisionExtractFeature": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/TextDetection"
          },
          {
            "$ref": "#/components/schemas/AssetTagDetection"
          },
          {
            "$ref": "#/components/schemas/PeopleDetection"
          },
          {
            "$ref": "#/components/schemas/IndustrialObjectDetection"
          },
          {
            "$ref": "#/components/schemas/PersonalProtectiveEquipmentDetection"
          }
        ]
      },
      "TextDetectionParameters": {
        "description": "Parameters for text detection",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "AssetTagDetectionParameters": {
        "description": "Parameters for asset tag detection.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          },
          "partialMatch": {
            "description": "Allow partial (fuzzy) matching of detected external IDs in the file. \nWill only match when it is possible to do so unambiguously.\n",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "assetSubtreeIds": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Search for external ID or name of assets that are in a subtree rooted at one of \nthe assetSubtreeIds (including the roots given).\n",
            "example": [
              1,
              2
            ]
          }
        }
      },
      "PeopleDetectionParameters": {
        "description": "Parameters for people detection.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "IndustrialObjectDetectionParameters": {
        "description": "Parameters for industrial object detection.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "PersonalProtectiveEquipmentDetectionParameters": {
        "description": "Parameters for industrial personal protective equipment detection.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "FeatureParameters": {
        "description": "Feature-specific parameters. New feature extractor parameters may appear.",
        "type": "object",
        "properties": {
          "textDetectionParameters": {
            "$ref": "#/components/schemas/TextDetectionParameters"
          },
          "assetTagDetectionParameters": {
            "$ref": "#/components/schemas/AssetTagDetectionParameters"
          },
          "peopleDetectionParameters": {
            "$ref": "#/components/schemas/PeopleDetectionParameters"
          },
          "industrialObjectDetectionParameters": {
            "$ref": "#/components/schemas/IndustrialObjectDetectionParameters"
          },
          "personalProtectiveEquipmentDetectionParameters": {
            "$ref": "#/components/schemas/PersonalProtectiveEquipmentDetectionParameters"
          }
        }
      },
      "VisionExtractPredictions": {
        "title": "Predictions",
        "description": "Detected features in images. New fields may appear in case new feature extractors are add.",
        "type": "object",
        "properties": {
          "textPredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.TextRegion"
            }
          },
          "assetTagPredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.cognite__annotation_types__images__AssetLink"
            }
          },
          "industrialObjectPredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          },
          "peoplePredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          },
          "personalProtectiveEquipmentPredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          }
        }
      },
      "VisionExtractItem": {
        "type": "object",
        "required": [
          "fileId",
          "predictions"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/ContextFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/ContextFileExternalId"
          },
          "predictions": {
            "$ref": "#/components/schemas/VisionExtractPredictions"
          }
        }
      },
      "ConfidenceThresholdMetricSchema": {
        "type": "object",
        "properties": {
          "confidenceThreshold": {
            "type": "number",
            "description": "The confidence threshold returns predictions as positive if their confidence score is the selected value or higher. A higher confidence threshold increases precision but lowers recall, and vice versa.",
            "example": 0.1,
            "minimum": 0,
            "maximum": 1
          },
          "precision": {
            "type": "number",
            "description": "The percentage of predictions that were correct (positive).",
            "example": 0.6,
            "minimum": 0,
            "maximum": 1
          },
          "recall": {
            "type": "number",
            "description": "The percentage of all ground truth items that were successfully predicted by the model.",
            "example": 0.4,
            "minimum": 0,
            "maximum": 1
          },
          "f1score": {
            "type": "number",
            "description": "Calculated F1 score. See [this Wikipedia article](https://en.wikipedia.org/wiki/F-score) for its definition and possible usages.",
            "example": 0.666,
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "ModelEvaluationSchema": {
        "type": "object",
        "required": [
          "meanAveragePrecision",
          "metrics"
        ],
        "properties": {
          "iouThreshold": {
            "type": "number",
            "description": "The intersection over union (IOU) threshold used to generate the confidence metrics. Only returned for object detection models.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "meanAveragePrecision": {
            "type": "number",
            "description": "A measure of how well your model performs across all confidence thresholds by calculating the area under the precision-recall tradeoff curve.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "metrics": {
            "type": "array",
            "description": "The model metrics for different values of confidence thresholds. Ordered ascendingly by the confidence threshold.",
            "items": {
              "$ref": "#/components/schemas/ConfidenceThresholdMetricSchema"
            }
          }
        }
      },
      "Annotations.Point": {
        "title": "primitives.geometry2d.Point",
        "description": "Point in a 2D-Cartesian coordinate system with origin at the top-left corner of the page",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "x": {
            "description": "The abscissa of the point in a coordinate system with origin at the top-left corner of the page. Normalized in (0,1).",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "y": {
            "description": "The ordinate of the point in a coordinate system with origin at the top-left corner of the page. Normalized in (0,1).",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": [
          "x",
          "y"
        ],
        "additionalProperties": false
      },
      "Annotations.Boolean": {
        "title": "primitives.attributes.Boolean",
        "description": "The boolean value of something",
        "type": "object",
        "properties": {
          "description": {
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "type": {
            "enum": [
              "boolean"
            ],
            "type": "string"
          },
          "value": {
            "description": "The boolean value",
            "type": "boolean"
          }
        },
        "required": [
          "type",
          "value"
        ],
        "additionalProperties": false
      },
      "Annotations.Numerical": {
        "title": "primitives.attributes.Numerical",
        "description": "The numerical value of something",
        "type": "object",
        "properties": {
          "description": {
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "type": {
            "enum": [
              "numerical"
            ],
            "type": "string"
          },
          "value": {
            "description": "The numerical value",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ]
          }
        },
        "required": [
          "type",
          "value"
        ],
        "additionalProperties": false
      },
      "Annotations.Keypoint": {
        "title": "primitives.geometry2d.Keypoint",
        "description": "A point attached with additional information such as a confidence value and\nvarious attribute(s).",
        "type": "object",
        "properties": {
          "attributes": {
            "description": "Additional attributes data for a compound.",
            "type": "object",
            "additionalProperties": {
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "boolean": "#/components/schemas/Boolean",
                  "numerical": "#/components/schemas/Numerical"
                }
              },
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            }
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "point": {
            "description": "The position of the keypoint",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.Point"
              }
            ]
          }
        },
        "required": [
          "point"
        ],
        "additionalProperties": false
      },
      "Annotations.BoundingBox": {
        "title": "primitives.geometry2d.BoundingBox",
        "description": "A plain rectangle",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "xMin": {
            "description": "Minimum abscissa of the bounding box (left edge). Must be strictly less than x_max.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "xMax": {
            "description": "Maximum abscissa of the bounding box (right edge). Must be strictly more than x_min.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "yMin": {
            "description": "Minimum ordinate of the bounding box (bottom edge). Must be strictly less than y_max.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "yMax": {
            "description": "Maximum ordinate of the bounding box (top edge). Must be strictly more than y_min.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": [
          "xMin",
          "xMax",
          "yMin",
          "yMax"
        ],
        "additionalProperties": false
      },
      "Annotations.Polygon": {
        "title": "primitives.geometry2d.Polygon",
        "description": "A _closed_ polygon represented by _n_ vertices. In other words, we assume\nthat the first and last vertex are connected.",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "vertices": {
            "minItems": 3,
            "maxItems": 1000,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.Point"
            }
          }
        },
        "required": [
          "vertices"
        ],
        "additionalProperties": false
      },
      "Annotations.PolyLine": {
        "title": "primitives.geometry2d.PolyLine",
        "description": "A polygonal chain consisting of _n_ vertices",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "vertices": {
            "minItems": 2,
            "maxItems": 1000,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.Point"
            }
          }
        },
        "required": [
          "vertices"
        ],
        "additionalProperties": false
      },
      "Annotations.Box": {
        "title": "primitives.geometry3d.Box",
        "description": "A box in 3D space, defined by a 4x4 row-major homogeneous transformation matrix that rotates and\ntranslates a unit box centered at the origin to it's location and orientation in 3D space.",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "matrix": {
            "description": "The homogeneous transformation matrix",
            "minItems": 16,
            "maxItems": 16,
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "matrix"
        ],
        "additionalProperties": false
      },
      "Annotations.Cylinder": {
        "title": "primitives.geometry3d.Cylinder",
        "description": "A cylinder in 3D space, defined by the centers of two sides and the radius.",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "centerA": {
            "description": "The center of the first cap.",
            "minItems": 3,
            "maxItems": 3,
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "centerB": {
            "description": "The center of the second cap.",
            "minItems": 3,
            "maxItems": 3,
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "radius": {
            "description": "The radius of the cylinder.",
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "centerA",
          "centerB",
          "radius"
        ],
        "additionalProperties": false
      },
      "Annotations.Geometry": {
        "title": "primitives.geometry3d.Geometry",
        "description": "A 3D geometry model represented by exactly *one of* `cylinder` and `box`.",
        "type": "object",
        "properties": {
          "cylinder": {
            "$ref": "#/components/schemas/Annotations.Cylinder"
          },
          "box": {
            "$ref": "#/components/schemas/Annotations.Box"
          }
        },
        "additionalProperties": false
      },
      "Annotations.AssetRef": {
        "title": "primitives.references.AssetRef",
        "description": "A reference to an asset. Either the internal ID or the external ID must be provided (exactly one).",
        "type": "object",
        "properties": {
          "id": {
            "description": "The internal ID of the referenced resource",
            "type": "integer"
          },
          "externalId": {
            "description": "The external ID of the referenced resource",
            "maxLength": 256,
            "type": "string"
          }
        },
        "additionalProperties": false,
        "oneOf": [
          {
            "required": [
              "id"
            ]
          },
          {
            "required": [
              "externalId"
            ]
          }
        ]
      },
      "Annotations.FileRef": {
        "title": "primitives.references.FileRef",
        "description": "A reference to a file. Either the internal ID or the external ID must be provided (exactly one).",
        "type": "object",
        "properties": {
          "id": {
            "description": "The internal ID of the referenced resource",
            "type": "integer"
          },
          "externalId": {
            "description": "The external ID of the referenced resource",
            "maxLength": 256,
            "type": "string"
          }
        },
        "additionalProperties": false,
        "oneOf": [
          {
            "required": [
              "id"
            ]
          },
          {
            "required": [
              "externalId"
            ]
          }
        ]
      },
      "Annotations.ObjectDetection": {
        "title": "images.ObjectDetection",
        "description": "Models an image object detection represented by a label, a geometry, and\noptionally a confidence value.",
        "type": "object",
        "properties": {
          "boundingBox": {
            "$ref": "#/components/schemas/Annotations.BoundingBox"
          },
          "polygon": {
            "$ref": "#/components/schemas/Annotations.Polygon"
          },
          "polyline": {
            "$ref": "#/components/schemas/Annotations.PolyLine"
          },
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": [
          "label"
        ],
        "additionalProperties": false
      },
      "Annotations.Classification": {
        "title": "images.Classification",
        "description": "Models an image classification represented by a label, and optionally a\nconfidence value.",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          }
        },
        "required": [
          "label"
        ],
        "additionalProperties": false
      },
      "Annotations.KeypointCollection": {
        "title": "images.KeypointCollection",
        "description": "Models a collection of keypoints represented by a label, a dictionary of\nkeypoints (mapping from a (unique) label name to a keypoint), and\noptionally a confidence value and an attributes dictionary.",
        "type": "object",
        "properties": {
          "attributes": {
            "description": "Additional attributes data for a compound.",
            "type": "object",
            "additionalProperties": {
              "discriminator": {
                "propertyName": "type",
                "mapping": {
                  "boolean": "primitives.yml#/components/schemas/Boolean",
                  "numerical": "primitives.yml#/components/schemas/Numerical"
                }
              },
              "anyOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            }
          },
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "keypoints": {
            "description": "The detected keypoints",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Annotations.Keypoint"
            }
          }
        },
        "required": [
          "label",
          "keypoints"
        ],
        "additionalProperties": false
      },
      "Annotations.cognite__annotation_types__images__AssetLink": {
        "title": "images.AssetLink",
        "description": "Models a link to a CDF Asset referenced in an image",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "assetRef": {
            "description": "The asset this annotation is pointing to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.AssetRef"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "description": "The location of the text mentioning the asset",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          }
        },
        "required": [
          "assetRef",
          "text",
          "textRegion"
        ],
        "additionalProperties": false
      },
      "Annotations.TextRegion": {
        "title": "images.TextRegion",
        "description": "Models an extracted text region in an image",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "description": "The location of the extracted text",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          }
        },
        "required": [
          "text",
          "textRegion"
        ],
        "additionalProperties": false
      },
      "Annotations.cognite__annotation_types__diagrams__AssetLink": {
        "title": "diagrams.AssetLink",
        "description": "Models a link to a CDF Asset referenced in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "assetRef": {
            "description": "The asset this annotation is pointing to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.AssetRef"
              }
            ]
          },
          "symbolRegion": {
            "description": "The location of the symbol representing the asset",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "textRegion": {
            "description": "The location of the text mentioning the asset",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "The symbol representing the asset",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "assetRef",
          "textRegion"
        ],
        "additionalProperties": false
      },
      "Annotations.FileLink": {
        "title": "diagrams.FileLink",
        "description": "Models a link to a CDF File referenced in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "fileRef": {
            "description": "The file this annotation is pointing to",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.FileRef"
              }
            ]
          },
          "symbolRegion": {
            "description": "The location of the symbol representing the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "textRegion": {
            "description": "The location of the text mentioning the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "fileRef",
          "textRegion"
        ],
        "additionalProperties": false
      },
      "Annotations.UnhandledTextObject": {
        "title": "diagrams.UnhandledTextObject",
        "description": "Models an extracted text region in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "textRegion": {
            "description": "The location of the text",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "textRegion",
          "text"
        ],
        "additionalProperties": false
      },
      "Annotations.UnhandledSymbolObject": {
        "title": "diagrams.UnhandledSymbolObject",
        "description": "Models an extracted symbol region in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "symbolRegion": {
            "description": "The location of the symbol",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "symbol": {
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "symbolRegion",
          "symbol"
        ],
        "additionalProperties": false
      },
      "Annotations.ExtractedText": {
        "title": "documents.ExtractedText",
        "description": "Represents text extracted from a document. Annotations of this type are low-level and not specific to any domain.",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "textRegion": {
            "description": "The location of the extracted text",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "extractedText": {
            "description": "The extracted text",
            "maxLength": 1024,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "textRegion",
          "extractedText"
        ],
        "additionalProperties": false
      },
      "Annotations.Line": {
        "title": "diagrams.Line",
        "description": "Models a line in an engineering diagram",
        "type": "object",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "polyline": {
            "description": "The polyline representing the line",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.PolyLine"
              }
            ]
          }
        },
        "required": [
          "label",
          "polyline"
        ],
        "additionalProperties": false
      },
      "Annotations.Junction": {
        "title": "diagrams.Junction",
        "description": "Models a junction between lines in an engineering diagram",
        "type": "object",
        "properties": {
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "position": {
            "description": "The point representing the junction",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.Point"
              }
            ]
          }
        },
        "required": [
          "position"
        ],
        "additionalProperties": false
      },
      "Annotations.Detection": {
        "title": "forms.Detection",
        "description": "Represents a detection of a field value in a form.\nA field is identified by a field_name, optionally component_name and component_type if the field belongs to a subcomponent.\nThe bounding_box indicates the position of the detection. The content of the field is given by the value, and optionally\nan unnormalized_value and the unit.",
        "type": "object",
        "properties": {
          "confidence": {
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "minimum": 0,
            "maximum": 1,
            "type": "number"
          },
          "pageNumber": {
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "default": 1,
            "minimum": 1,
            "maximum": 2048,
            "type": "integer"
          },
          "boundingBox": {
            "description": "Bounding box of the detection area",
            "allOf": [
              {
                "$ref": "#/components/schemas/Annotations.BoundingBox"
              }
            ]
          },
          "componentType": {
            "description": "Type of subcomponent that the detection belongs to",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "componentName": {
            "description": "Name of subcomponent that the detection belongs to",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "fieldName": {
            "description": "Name of field that has been detected",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "value": {
            "description": "The value that has been detected",
            "maxLength": 128,
            "type": "string"
          },
          "valueUnnormalized": {
            "description": "The value that has been detected, before normalization. Optional.",
            "maxLength": 128,
            "type": "string"
          },
          "unit": {
            "description": "The unit of the value field. Optional.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "boundingBox",
          "fieldName",
          "value"
        ],
        "additionalProperties": false
      },
      "DocumentsSearchRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsFilterOption"
          },
          {
            "$ref": "#/components/schemas/DocumentsSearch"
          },
          {
            "$ref": "#/components/schemas/DocumentsAggregates"
          },
          {
            "$ref": "#/components/schemas/DocumentsSort"
          },
          {
            "$ref": "#/components/schemas/DocumentsSearchLimit"
          }
        ]
      },
      "DocumentsFilterRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsFilterOption"
          },
          {
            "$ref": "#/components/schemas/DocumentsLimit"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "DocumentContentRequestItems": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/DocumentContentItem"
            }
          }
        }
      },
      "DocumentContentItem": {
        "oneOf": [
          {
            "type": "object",
            "title": "Select by Id",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/DocumentId"
              }
            }
          },
          {
            "type": "object",
            "title": "Select by ExternalId",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "DocumentContentRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentContentRequestItems"
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DocumentsClassifierListByIdsRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsClassifierListByIdsItems"
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DocumentsClassifierDeleteRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentsClassifierDeleteItems"
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DocumentsLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DocumentsSearchLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items.",
            "type": "integer",
            "format": "int32",
            "minimum": 0,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DocumentsSort": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "array",
            "description": "List of fields to sort by, currently only supports 1 field.\nSyntax: `[\"<fieldname>:asc|desc\"]`. Default sort order is `asc` with short syntax `[\"<fieldname>\"]`.\n",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "string"
            },
            "example": [
              "externalId:desc"
            ]
          }
        }
      },
      "DocumentsFilterOption": {
        "description": "Filter with exact match",
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/DocumentsFilter"
          }
        }
      },
      "DocumentsFilter": {
        "description": "Filter with exact match",
        "type": "object",
        "properties": {
          "id": {
            "description": "Id of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/IntPredicate"
              }
            ]
          },
          "externalIdPrefix": {
            "description": "External Id provided by client",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "title": {
            "description": "Derived title of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "author": {
            "description": "Derived author of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "createdTime": {
            "description": "Derived creation date of the file",
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "mimeType": {
            "description": "Derived MIME type of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "extension": {
            "description": "Extension of the file (case-insensitive)",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ],
            "example": "pdf"
          },
          "pageCount": {
            "description": "Number of pages for multi-page documents.",
            "type": "object",
            "properties": {
              "max": {
                "description": "The maximum page count for any document.",
                "type": "integer",
                "minimum": 0,
                "format": "int32"
              },
              "min": {
                "description": "The minimum page count for any document.",
                "type": "integer",
                "minimum": 0,
                "format": "int32"
              }
            }
          },
          "type": {
            "description": "Derived document type of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "language": {
            "description": "Derived langugage of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "assetIds": {
            "$ref": "#/components/schemas/AssetIdsFilter"
          },
          "assetExternalIds": {
            "$ref": "#/components/schemas/AssetExternalIdsFilter"
          },
          "assetSubtreeIds": {
            "$ref": "#/components/schemas/AssetSubtreeIdsFilter"
          },
          "sourceSystem": {
            "description": "The system the source file lives in",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "labels": {
            "$ref": "#/components/schemas/DocumentsLabelFilter"
          },
          "geoLocation": {
            "description": "Geometric shape and geoJson relation. The filtering here is done on the `geoLocation` of the file.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentGeoLocationFilter"
              }
            ]
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentsSourceFileFilter"
          }
        }
      },
      "DocumentsSourceFileFilter": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "directoryPrefix": {
            "description": "The name of the directory holding the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "source": {
            "description": "The source of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "mimeType": {
            "description": "MIME type of the file, e.g. `text/plain`, `application/pdf`",
            "allOf": [
              {
                "$ref": "#/components/schemas/StringPredicate"
              }
            ]
          },
          "size": {
            "description": "Range between two integers.",
            "type": "object",
            "properties": {
              "max": {
                "description": "The maximum size of the source file in bytes.",
                "type": "integer",
                "minimum": 0,
                "format": "int64"
              },
              "min": {
                "description": "The minimum size of the source file in bytes.",
                "type": "integer",
                "minimum": 0,
                "format": "int64"
              }
            }
          },
          "assetIds": {
            "$ref": "#/components/schemas/AssetIdsFilter"
          },
          "assetExternalIds": {
            "$ref": "#/components/schemas/AssetExternalIdsFilter"
          },
          "assetSubtreeIds": {
            "$ref": "#/components/schemas/AssetSubtreeIdsFilter"
          },
          "uploadedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "sourceCreatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "sourceModifiedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "labels": {
            "$ref": "#/components/schemas/DocumentsLabelFilter"
          },
          "geoLocation": {
            "description": "Geometric shape and geoJson relation. The filtering here is done on the `geoLocation` of the file.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentGeoLocationFilter"
              }
            ]
          },
          "datasetId": {
            "description": "Data set id of the file",
            "allOf": [
              {
                "$ref": "#/components/schemas/IntPredicate"
              }
            ]
          },
          "metadata": {
            "type": "object",
            "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "DocumentsSearch": {
        "type": "object",
        "properties": {
          "search": {
            "type": "object",
            "properties": {
              "query": {
                "type": "string",
                "description": "The free text search query as described in detail above.",
                "maxLength": 1000
              },
              "highlight": {
                "type": "boolean",
                "description": "Whether or not matches in search results should be highlighted.",
                "default": false
              }
            }
          }
        }
      },
      "DocumentsAggregates": {
        "type": "object",
        "properties": {
          "aggregates": {
            "type": "array",
            "items": {
              "type": "object",
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DocumentsCountAggregate"
                },
                {
                  "$ref": "#/components/schemas/DocumentsDateHistogramAggregate"
                }
              ],
              "minItems": 1,
              "maxItems": 5
            }
          }
        }
      },
      "DocumentsCountAggregate": {
        "type": "object",
        "required": [
          "name",
          "aggregate"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined name for this aggregate"
          },
          "aggregate": {
            "type": "string",
            "description": "count",
            "example": "count"
          },
          "groupBy": {
            "type": "array",
            "description": "List of fields to group the count by. It is currently only possible to group by 1 field or 0 fields. If grouping by 0 fields, the aggregate value is the total count of all documents.",
            "items": {
              "type": "string",
              "minItems": 1,
              "maxItems": 1
            }
          }
        }
      },
      "DocumentsDateHistogramAggregate": {
        "type": "object",
        "required": [
          "name",
          "aggregate",
          "field",
          "interval"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined name for this aggregate"
          },
          "aggregate": {
            "type": "string",
            "description": "dateHistogram",
            "example": "dateHistogram"
          },
          "field": {
            "type": "string",
            "description": "Which field to create the date histogram on.",
            "example": true
          },
          "interval": {
            "type": "string",
            "description": "Date interval to use to create histogram, 'day', 'week', 'month', or 'year'."
          }
        }
      },
      "DocumentContent": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DocumentId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "content": {
            "type": "string",
            "description": "The textual content of the document, truncated to the first 1MB of text",
            "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
          }
        }
      },
      "Document": {
        "type": "object",
        "required": [
          "id",
          "sourceFile"
        ],
        "description": "A document",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/DocumentId",
            "example": 1
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId",
            "example": "haml001"
          },
          "title": {
            "description": "The title of the document",
            "type": "string",
            "example": "Hamlet"
          },
          "author": {
            "description": "The author of the document",
            "type": "string",
            "example": "William Shakespeare"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp",
            "description": "When the document was created, measured in milliseconds since 00:00:00 Thursday, 1 January 1970",
            "example": -11676052800000
          },
          "lastIndexedTime": {
            "$ref": "#/components/schemas/EpochTimestamp",
            "description": "When the document was indexed, measured in milliseconds since 00:00:00 Thursday, 1 January 1970",
            "example": -11676052800000
          },
          "mimeType": {
            "description": "Detected mime type for the document",
            "type": "string",
            "example": "text/plain"
          },
          "extension": {
            "type": "string",
            "description": "Extension of the file (always in lowercase)",
            "example": "pdf"
          },
          "pageCount": {
            "description": "Number of pages for multi-page documents",
            "type": "integer",
            "format": "int32",
            "example": 2
          },
          "type": {
            "description": "Detected mime type for the document",
            "type": "string",
            "example": "text/plain"
          },
          "language": {
            "description": "The detected language used in the document",
            "type": "string",
            "example": "en"
          },
          "truncatedContent": {
            "description": "The textual content of the document. Currently truncated to 155 characters",
            "type": "string",
            "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
          },
          "assetIds": {
            "description": "The ids of any assets referred to in the document",
            "type": "array",
            "example": [
              42,
              101
            ],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "labels": {
            "description": "A list of labels derived by this pipeline's document classifier.",
            "type": "array",
            "example": [
              {
                "externalId": "play"
              },
              {
                "externalId": "tragedy"
              }
            ],
            "$ref": "#/components/schemas/LabelList",
            "items": {
              "type": "object",
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          },
          "sourceSystem": {
            "type": "string",
            "example": "CDF"
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentSourceFile"
          },
          "geoLocation": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentGeoLocation"
              },
              {
                "description": "Geolocation derived for this document. Represented using a GeoJSON Geometry.\n\nThe derived geolocation also includes geolocation information from a matched\nasset (see assetIds property). For matched assets without geolocation information\nthe parent chain is followed until it finds an asset with geolocation information.\n"
              }
            ]
          }
        }
      },
      "DocumentSourceFile": {
        "type": "object",
        "description": "The source file that this document is derived from.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the file",
            "example": "hamlet.txt"
          },
          "directory": {
            "type": "string",
            "description": "The directory the file can be found in",
            "example": "plays/shakespeare"
          },
          "source": {
            "type": "string",
            "description": "The source of the file",
            "example": "SubsurfaceConnectors"
          },
          "mimeType": {
            "type": "string",
            "description": "The mime type of the file",
            "example": "application/octet-stream"
          },
          "size": {
            "type": "number",
            "format": "int64",
            "description": "The size of the source file in bytes",
            "example": 1000
          },
          "assetIds": {
            "type": "array",
            "description": "The ids of the assets related to this file",
            "example": [],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "createdTime": {
            "type": "number",
            "format": "int64",
            "description": "The time the file was created"
          },
          "lastIndexedTime": {
            "type": "number",
            "format": "int64",
            "description": "The time the file was indexed"
          },
          "lastUpdatedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "uploadedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "sourceCreatedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "sourceModifiedTime": {
            "type": "number",
            "format": "int64",
            "description": "The last time the file was updated"
          },
          "labels": {
            "description": "A list of labels associated with this document's source file in CDF.",
            "example": [
              {
                "externalId": "play"
              },
              {
                "externalId": "tragedy"
              }
            ],
            "$ref": "#/components/schemas/LabelList"
          },
          "geoLocation": {
            "$ref": "#/components/schemas/DocumentGeoLocation"
          },
          "datasetId": {
            "$ref": "#/components/schemas/CogniteInternalId",
            "description": "The id if the dataset this file belongs to, if any"
          },
          "securityCategories": {
            "type": "array",
            "description": "The security category IDs required to access this file",
            "example": [],
            "items": {
              "type": "number",
              "format": "int64"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "Highlight": {
        "type": "object",
        "description": "Highlighted snippets from content, name and externalId fields which show where the query matches are.",
        "properties": {
          "name": {
            "type": "array",
            "description": "Matches in name.",
            "items": {
              "type": "string"
            }
          },
          "content": {
            "type": "array",
            "description": "Matches in content.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AssetIds": {
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "uniqueItems": true,
        "description": "IDs of assets related to the file.",
        "example": [
          363848954441724,
          793045462540095,
          1261042166839739
        ],
        "items": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "AssetIdsFilter": {
        "description": "Only include files that reference these specific asset IDs.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContainsAllIds"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyId"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "AssetExternalIdsFilter": {
        "description": "Only include files that reference these specific asset externalIds.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContainsAllExternalIds"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyExternalIds"
          }
        ]
      },
      "AssetSubtreeIdsFilter": {
        "description": "Only include documents with a related asset in a subtree rooted at any of these asset IDs, including the roots given. Returns an error if the total size of the given subtrees exceeds 10,000 assets. Usage of this field requires `[\"assetsAcl:READ\"]` capability.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContainsAnyId"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "DocumentsLabelFilter": {
        "description": "Return only the resource matching the specified label constraints.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelContainsAllFilter"
          },
          {
            "$ref": "#/components/schemas/LabelContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "ShapeType": {
        "description": "Type of the shape. Currently we support \"polygon\", \"linestring\" and \"point\".",
        "type": "string"
      },
      "ShapeCoordinates": {
        "description": "Coordinates of the shape.",
        "type": "array"
      },
      "GeometryCollection": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ShapeType"
          },
          "coordinates": {
            "$ref": "#/components/schemas/ShapeCoordinates"
          }
        }
      },
      "DocumentGeoLocation": {
        "description": "GeoJson representation of a geometry.",
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ShapeType"
          },
          "coordinates": {
            "$ref": "#/components/schemas/ShapeCoordinates"
          },
          "geometries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeometryCollection"
            }
          }
        }
      },
      "Relation": {
        "description": "Spatial relation which will be used at search time. Currently we support `intersects`, `disjoint`, and `within`. For guidance regarding relations, see [this Wikipedia article](https://en.wikipedia.org/wiki/Spatial_relation#Topological_relations).",
        "type": "string",
        "default": "intersects"
      },
      "DocumentGeoLocationFilter": {
        "description": "Filter on files which have the specified spatial relation with the specified geometry shape.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ValueMissing"
          },
          {
            "type": "object",
            "title": "shape",
            "properties": {
              "shape": {
                "$ref": "#/components/schemas/DocumentGeoLocation"
              },
              "relation": {
                "$ref": "#/components/schemas/Relation"
              }
            },
            "required": [
              "shape"
            ]
          }
        ]
      },
      "IntIn": {
        "type": "object",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "Int value must be a value in this array",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "StringIn": {
        "type": "object",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "String value must be a value in this array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "StringEquals": {
        "type": "object",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "type": "string",
            "description": "String value must match this value"
          }
        }
      },
      "ValueMissing": {
        "type": "object",
        "required": [
          "missing"
        ],
        "properties": {
          "missing": {
            "type": "boolean",
            "description": "Value for the field is missing"
          }
        }
      },
      "IntEquals": {
        "type": "object",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "type": "integer",
            "description": "Int value must match this value"
          }
        }
      },
      "ContainsAllStrings": {
        "type": "object",
        "properties": {
          "containsAll": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "Values for this field must match all values in this array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ContainsAnyString": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "description": "Values for this field must match with at least one of the values in this array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ContainsAllIds": {
        "type": "object",
        "properties": {
          "containsAll": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match all values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "ContainsAnyId": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match with at least one of the values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "ContainsAllExternalIds": {
        "type": "object",
        "properties": {
          "containsAll": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match all values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        }
      },
      "ContainsAnyExternalIds": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Values for this field must match with at least one of the values in this array",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        }
      },
      "IntPredicate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/IntIn"
          },
          {
            "$ref": "#/components/schemas/IntEquals"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "StringPredicate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/StringIn"
          },
          {
            "$ref": "#/components/schemas/StringEquals"
          },
          {
            "$ref": "#/components/schemas/ValueMissing"
          }
        ]
      },
      "DocumentsPipelineArrayOf1To10Strings": {
        "type": "array",
        "maxItems": 10,
        "minItems": 1,
        "items": {
          "type": "string"
        }
      },
      "DocumentsPipelineArrayOf1To10ExternalIds": {
        "type": "array",
        "maxItems": 10,
        "minItems": 1,
        "items": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "DocumentsPipelineArrayOf1To10StringsUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
              }
            }
          },
          {
            "title": "add and/or remove",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
              },
              "remove": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
              }
            }
          }
        ]
      },
      "DocumentsPipelineArrayOf1To10ExternalIdsUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
              }
            }
          },
          {
            "title": "add and/or remove",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
              },
              "remove": {
                "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
              }
            }
          }
        ]
      },
      "DocumentsPipelineSourceFile": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "directory": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "content": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
            }
          }
        }
      },
      "DocumentsPipelineFieldMappings": {
        "type": "object",
        "properties": {
          "title": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "author": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "mimeType": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "type": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10Strings"
          },
          "labelsExternalIds": {
            "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIds"
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentsPipelineSourceFile"
          }
        },
        "example": {
          "title": [
            "TERMS"
          ],
          "author": [
            "TERMS"
          ],
          "type": [
            "TERMS",
            "TYPES"
          ],
          "sourceFile": {
            "name": [
              "TERMS"
            ],
            "content": [
              "TERMS",
              "TYPES"
            ],
            "directory": [
              "DIRECTORIES"
            ]
          }
        }
      },
      "DocumentsPipelineSensitivityMatcher": {
        "type": "object",
        "properties": {
          "matchLists": {
            "type": "object",
            "description": "Dictionary object. Name of match lists as keys, lists of matching words as values.",
            "example": {
              "DIRECTORIES": [
                "secret"
              ],
              "TYPES": [
                "contracts",
                "emails"
              ],
              "TERMS": [
                "secret",
                "confidential",
                "sensitive"
              ]
            },
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "fieldMappings": {
            "$ref": "#/components/schemas/DocumentsPipelineFieldMappings"
          },
          "filterPasswords": {
            "type": "boolean",
            "description": "Whether or not a file is marked sensitive if it contains text that looks like a password.",
            "default": true
          },
          "sensitiveSecurityCategory": {
            "type": "integer",
            "description": "The security category id to attach to sensitive documents.",
            "format": "int64",
            "example": 345341343656745
          },
          "restrictToSources": {
            "type": "array",
            "description": "Only documents from these sources will be evaluated if they are sensitive. If the field is empty, all documents will be evaluated.",
            "items": {
              "type": "string",
              "example": "my source"
            }
          }
        }
      },
      "DocumentsPipelineClassifier": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "A descriptive name of the classifier."
          },
          "trainingLabels": {
            "$ref": "#/components/schemas/LabelList"
          },
          "activeClassifierId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "lastTrainedAt": {
            "type": "number",
            "format": "int64",
            "description": "Timestamp when the classifier was last trained"
          }
        }
      },
      "DocumentsPipeline": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "sensitivityMatcher": {
            "$ref": "#/components/schemas/DocumentsPipelineSensitivityMatcher"
          },
          "classifier": {
            "$ref": "#/components/schemas/DocumentsPipelineClassifier"
          }
        }
      },
      "DocumentsPipelineItems": {
        "description": "A list of pipeline configuration objects.",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsPipeline"
            }
          }
        }
      },
      "LabelListUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/LabelList"
              }
            }
          },
          {
            "title": "add and/or remove",
            "type": "object",
            "properties": {
              "add": {
                "$ref": "#/components/schemas/LabelList"
              },
              "remove": {
                "$ref": "#/components/schemas/LabelList"
              }
            }
          }
        ]
      },
      "DocumentsPipelineSourceFileUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineSourceFile"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": [
              "modify"
            ],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "directory": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "content": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "metadata": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": [
                          "set"
                        ],
                        "description": "Replaces all metadata values",
                        "properties": {
                          "set": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      {
                        "title": "add and/or remove",
                        "type": "object",
                        "properties": {
                          "add": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "remove": {
                            "type": "array",
                            "description": "list of keys to remove",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "SensitivityMatcherFieldMappingsUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineFieldMappings"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": [
              "modify"
            ],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "title": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "author": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "mimeType": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "type": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10StringsUpdate"
                  },
                  "labelsExternalIds": {
                    "$ref": "#/components/schemas/DocumentsPipelineArrayOf1To10ExternalIdsUpdate"
                  },
                  "sourceFile": {
                    "$ref": "#/components/schemas/DocumentsPipelineSourceFileUpdate"
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsPipelineSensitivityMatcherUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineSensitivityMatcher"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": [
              "modify"
            ],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "fieldMappings": {
                    "$ref": "#/components/schemas/SensitivityMatcherFieldMappingsUpdate"
                  },
                  "matchLists": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": [
                          "set"
                        ],
                        "properties": {
                          "set": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          }
                        }
                      },
                      {
                        "title": "add and/or remove",
                        "type": "object",
                        "properties": {
                          "add": {
                            "type": "object",
                            "additionalProperties": {
                              "type": "array",
                              "items": {
                                "type": "string"
                              }
                            }
                          },
                          "remove": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    ]
                  },
                  "filterPasswords": {
                    "type": "object",
                    "required": [
                      "set"
                    ],
                    "properties": {
                      "set": {
                        "type": "boolean"
                      }
                    }
                  },
                  "sensitiveSecurityCategory": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": [
                          "set"
                        ],
                        "properties": {
                          "set": {
                            "type": "integer",
                            "format": "int64",
                            "example": 345341343656745
                          }
                        }
                      },
                      {
                        "title": "nullSetter",
                        "type": "object",
                        "required": [
                          "setNull"
                        ],
                        "properties": {
                          "setNull": {
                            "type": "boolean",
                            "default": false
                          }
                        }
                      }
                    ]
                  },
                  "restrictToSources": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": [
                          "set"
                        ],
                        "properties": {
                          "set": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      },
                      {
                        "title": "add and/or remove",
                        "type": "object",
                        "properties": {
                          "add": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "remove": {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsPipelineClassifierUpdate": {
        "oneOf": [
          {
            "title": "setter",
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/DocumentsPipelineClassifier"
              }
            }
          },
          {
            "title": "modifier",
            "type": "object",
            "required": [
              "modify"
            ],
            "properties": {
              "modify": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "object",
                    "required": [
                      "set"
                    ],
                    "properties": {
                      "set": {
                        "type": "string",
                        "description": "A new name for the classifier."
                      }
                    }
                  },
                  "trainingLabels": {
                    "$ref": "#components/schemas/LabelListUpdate"
                  },
                  "activeClassifierId": {
                    "oneOf": [
                      {
                        "title": "setter",
                        "type": "object",
                        "required": [
                          "set"
                        ],
                        "properties": {
                          "set": {
                            "$ref": "#/components/schemas/CogniteInternalId"
                          }
                        }
                      },
                      {
                        "title": "nullSetter",
                        "type": "object",
                        "required": [
                          "setNull"
                        ],
                        "properties": {
                          "setNull": {
                            "type": "boolean"
                          }
                        }
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsPipelineUpdate": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "type": "object",
            "properties": {
              "sensitivityMatcher": {
                "$ref": "#/components/schemas/DocumentsPipelineSensitivityMatcherUpdate"
              },
              "classifier": {
                "$ref": "#/components/schemas/DocumentsPipelineClassifierUpdate"
              }
            }
          }
        }
      },
      "DocumentsPipelineItemsUpdate": {
        "description": "A list of update pipeline configuration objects.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsPipelineUpdate"
            }
          }
        }
      },
      "DocumentsClassifier": {
        "type": "object",
        "required": [
          "id",
          "projectId",
          "name",
          "createdAt",
          "status",
          "active"
        ],
        "properties": {
          "projectId": {
            "$ref": "#/components/schemas/CogniteInternalId",
            "description": "Project id"
          },
          "name": {
            "type": "string",
            "description": "Name of the classifier"
          },
          "createdAt": {
            "type": "number",
            "format": "int64",
            "description": "Timestamp when the classifier is created"
          },
          "status": {
            "type": "string",
            "description": "Status of the creating classifier job. Can be one of `QUEUING`, `TRAINING`, `FINISHED`, `FAILED`"
          },
          "active": {
            "type": "boolean",
            "description": "Whether the classifier is currently used for predicting labels"
          },
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId",
            "description": "Classifier id"
          },
          "metrics": {
            "$ref": "#/components/schemas/DocumentsClassifierMetrics"
          },
          "trainingSetSize": {
            "type": "number",
            "format": "int64",
            "description": "The number of documents used for training the classifier"
          }
        }
      },
      "DocumentsClassifierMetrics": {
        "type": "object",
        "properties": {
          "precision": {
            "type": "number",
            "format": "float"
          },
          "recall": {
            "type": "number",
            "format": "float"
          },
          "f1Score": {
            "type": "number",
            "format": "float"
          },
          "confusionMatrix": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "float"
              }
            }
          },
          "labels": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "DocumentsClassifierItems": {
        "description": "A list of classifiers.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifier"
            }
          }
        }
      },
      "DocumentsClassifierCreate": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string"
          }
        }
      },
      "DocumentsClassifierCreateItems": {
        "description": "A list of classifiers.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifierCreate"
            }
          }
        }
      },
      "DocumentsClassifierListByIds": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DocumentsClassifierListByIdsItems": {
        "description": "A list of classifier ids.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifierListByIds"
            }
          }
        }
      },
      "DocumentsClassifierDelete": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DocumentsClassifierDeleteItems": {
        "description": "A list of classifier ids.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentsClassifierDelete"
            }
          }
        }
      },
      "FeedbackLabel": {
        "type": "object",
        "description": "Label to add to, or remove from a file",
        "allOf": [
          {
            "$ref": "#/components/schemas/LabelDefinitionExternalId"
          }
        ]
      },
      "DocumentId": {
        "$ref": "#/components/schemas/CogniteInternalId",
        "description": "Internal ID of the CDF file/document",
        "example": 1066
      },
      "FeedbackId": {
        "$ref": "#/components/schemas/CogniteInternalId",
        "description": "Server-generated identifier for the feedback object",
        "example": 42
      },
      "FeedbackAction": {
        "type": "string",
        "description": "What to do with the label on the file",
        "enum": [
          "ATTACH",
          "DETACH"
        ]
      },
      "FeedbackStatus": {
        "type": "string",
        "enum": [
          "CREATED",
          "ACCEPTED",
          "REJECTED",
          "STALE"
        ],
        "example": "ACCEPTED",
        "description": "Status of the feedback, complying with the lifecycle described below.\n\n## Feedback lifecycle\n- It is initially `CREATED`.\n- If the administrator accepts the feedback, it moves to `ACCEPTED`.\n  Once in this state, it cannot move to another state.\n- If the administrator rejects the feedback, it moves to `REJECTED`.\n  Once in this state, it cannot move to another state.\n- If the feedback object has become _invalid_, it moves to `STALE`.\n  Once in this state, it cannot move to another state.\n\n## Definition of feedback _invalidity_\n- If the action was `ATTACH`, and the label to attach does not exist anymore.\n- If the action was `ATTACH`, and the label is already attached to the file.\n- If the action was `DETACH`, and the label is not attached to the file anymore."
      },
      "ReporterInfo": {
        "type": "string",
        "nullable": true,
        "description": "**Optional** information about the reporter. This could be a name\nor an email. Please note that this field is free text – it is not\nchecked for integrity at any time.",
        "example": "Jane Doe"
      },
      "DocumentFeedbackCreateRequest": {
        "description": "A list of feedback objects, not yet written to the API",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentFeedbackCreateItem"
            }
          }
        }
      },
      "DocumentFeedbackCreateItem": {
        "description": "A new feedback object, not yet written to the API",
        "type": "object",
        "required": [
          "documentId",
          "label",
          "action"
        ],
        "properties": {
          "documentId": {
            "$ref": "#/components/schemas/DocumentId"
          },
          "label": {
            "$ref": "#/components/schemas/FeedbackLabel"
          },
          "action": {
            "$ref": "#/components/schemas/FeedbackAction"
          },
          "reporterInfo": {
            "$ref": "#/components/schemas/ReporterInfo"
          }
        }
      },
      "DocumentFeedback": {
        "description": "A feedback object",
        "type": "object",
        "required": [
          "documentId",
          "label",
          "action",
          "feedbackId",
          "createdAt",
          "status"
        ],
        "properties": {
          "documentId": {
            "$ref": "#/components/schemas/DocumentId"
          },
          "label": {
            "$ref": "#/components/schemas/FeedbackLabel"
          },
          "action": {
            "$ref": "#/components/schemas/FeedbackAction"
          },
          "feedbackId": {
            "$ref": "#/components/schemas/FeedbackId"
          },
          "reporterInfo": {
            "$ref": "#/components/schemas/ReporterInfo"
          },
          "createdAt": {
            "description": "When this feedback object was created by the end-user.\n\nA UTC-based [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp string.",
            "type": "string",
            "example": "2021-02-04T16:24:23.284407"
          },
          "reviewedAt": {
            "description": "When this feedback object moved from `CREATED` to another state.\nThis field is only present if the status is not `CREATED`.\n\nA UTC-based [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp string.",
            "type": "string",
            "nullable": true,
            "example": "2021-02-05T14:28:27"
          },
          "status": {
            "$ref": "#/components/schemas/FeedbackStatus"
          }
        }
      },
      "AggregateField": {
        "type": "string",
        "description": "A feedback field to aggregate on.\n\nYou can find extensive description of the available fields in the\n[List Feedback](#operation/documentsListFeedback) endpoint response.",
        "enum": [
          "action",
          "status"
        ],
        "example": "action"
      },
      "DocumentFeedbackAggregateRequest": {
        "description": "A query object for the aggregation endpoint",
        "type": "object",
        "required": [
          "field"
        ],
        "properties": {
          "field": {
            "$ref": "#/components/schemas/AggregateField"
          }
        }
      },
      "AggregateGroup": {
        "description": "A value/count aggregation object",
        "type": "object",
        "required": [
          "value",
          "count"
        ],
        "properties": {
          "value": {
            "type": "string",
            "description": "A value of the `field`"
          },
          "count": {
            "type": "integer",
            "description": "The count of records with the `value` for the `field`"
          }
        }
      },
      "DocumentFeedbackAcceptRejectRequest": {
        "description": "A query object for the accept/reject endpoints",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentFeedbackAcceptRejectItem"
            }
          }
        }
      },
      "DocumentFeedbackAcceptRejectItem": {
        "description": "An id of the accepted / rejected feedback",
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/FeedbackId"
          }
        }
      },
      "RevokeSessionRequestList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RevokeSessionRequest"
            }
          }
        }
      },
      "RevokeSessionRequest": {
        "description": "",
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          }
        }
      },
      "SessionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Session"
            }
          }
        }
      },
      "Session": {
        "type": "object",
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          },
          "type": {
            "type": "string",
            "description": "Values reserved for future use",
            "anyOf": [
              {
                "enum": [
                  "CLIENT_CREDENTIALS",
                  "TOKEN_EXCHANGE"
                ]
              }
            ]
          },
          "status": {
            "description": "Current status of the session",
            "type": "string",
            "enum": [
              "READY",
              "ACTIVE",
              "CANCELLED",
              "EXPIRED",
              "REVOKED",
              "ACCESS_LOST"
            ]
          },
          "creationTime": {
            "description": "Session creation time, in milliseconds since 1970",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "expirationTime": {
            "description": "Session expiry time, in milliseconds since 1970. This value is updated on refreshing a token",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "clientId": {
            "description": "Client ID in identity provider. Returned only if the session was created using client credentials",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "RawTable": {
        "required": [
          "dbName",
          "tableName"
        ],
        "type": "object",
        "properties": {
          "dbName": {
            "minLength": 1,
            "type": "string",
            "description": "Database name"
          },
          "tableName": {
            "minLength": 1,
            "type": "string",
            "description": "Table name"
          }
        }
      },
      "Contact": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Contact name",
            "nullable": true
          },
          "email": {
            "maxLength": 254,
            "minLength": 1,
            "type": "string",
            "description": "Contact email",
            "format": "email",
            "nullable": true
          },
          "role": {
            "type": "string",
            "description": "Contact role",
            "nullable": true
          },
          "sendNotification": {
            "type": "boolean",
            "description": "True, if contact receives email notifications",
            "nullable": true
          }
        }
      },
      "CreateExtPipe": {
        "required": [
          "dataSetId",
          "externalId",
          "name"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          },
          "name": {
            "maxLength": 140,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Name of Extraction Pipeline"
          },
          "description": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline",
            "nullable": true
          },
          "dataSetId": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "required": [
              "true"
            ],
            "type": "integer",
            "description": "DataSet ID",
            "format": "int64"
          },
          "rawTables": {
            "type": "array",
            "description": "Raw tables",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "schedule": {
            "pattern": "^(On trigger|Continuous)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|µs|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: “On trigger”, “Continuous” or cron expression. If empty then null",
            "nullable": true
          },
          "contacts": {
            "type": "array",
            "description": "Contacts list.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "source": {
            "maxLength": 255,
            "type": "string",
            "description": "Source for Extraction Pipeline",
            "nullable": true
          },
          "documentation": {
            "maxLength": 10000,
            "type": "string",
            "description": "Documentation text field",
            "nullable": true
          }
        }
      },
      "ExtPipe": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateExtPipe"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "maximum": 9007199254740991,
                "minimum": 0,
                "type": "integer",
                "description": "A server-generated ID for the object.",
                "format": "int64"
              },
              "lastSuccess": {
                "type": "integer",
                "description": "Time of last successful run. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "lastFailure": {
                "type": "integer",
                "description": "Time of last failure run. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "lastMessage": {
                "type": "string",
                "description": "Last failure message."
              },
              "lastSeen": {
                "type": "integer",
                "description": "Last seen time. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "createdBy": {
                "type": "string",
                "description": "Extraction Pipeline creator. Usually user email is expected here"
              }
            }
          }
        ]
      },
      "ExtPipes": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipe"
            }
          }
        },
        "description": "List of extraction pipelines"
      },
      "DefaultError": {
        "type": "object",
        "properties": {
          "code": {
            "required": [
              "true"
            ],
            "type": "integer",
            "description": "HTTP status code",
            "format": "int32"
          },
          "message": {
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Error message"
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object"
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object"
            }
          }
        },
        "description": "Cognite API error"
      },
      "ItemsRequest_CreateExtPipe_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateExtPipe"
            }
          }
        }
      },
      "ItemsRequest_ExtPipeId_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeId"
            }
          }
        }
      },
      "ExtPipeInternalId": {
        "required": [
          "id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          }
        }
      },
      "ExtPipeExternalId": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          }
        }
      },
      "ExtPipeId": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ExtPipeInternalId"
          },
          {
            "$ref": "#/components/schemas/ExtPipeExternalId"
          }
        ]
      },
      "ItemsRequest_ExtPipeUpdate_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeUpdate"
            }
          }
        }
      },
      "ExternalIdUpdateField": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          }
        },
        "description": "Set a new value for the externalId. Must be unique for the resource type."
      },
      "NameUpdateField": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 140,
            "minLength": 1,
            "type": "string",
            "description": "Name of Extraction Pipeline"
          }
        },
        "description": "Set a new value for name."
      },
      "DescriptionUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline",
            "nullable": true
          }
        },
        "description": "Set a new value for description."
      },
      "DataSetIdUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "required": [
              "true"
            ],
            "type": "integer",
            "description": "DataSet ID",
            "format": "int64"
          }
        },
        "description": "Set a new value for dataSetId."
      },
      "ScheduleUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "pattern": "^(On trigger|Continuous)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|µs|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: “On trigger”, “Continuous” or cron expression. If empty then null",
            "nullable": true
          }
        },
        "description": "Set a new value for schedule."
      },
      "RawTablesUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          }
        }
      },
      "RawTablesUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "remove": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          }
        }
      },
      "RawTablesUpdate": {
        "type": "object",
        "description": "Updates the resource's assigned rawTables. RawTables can be added, removed or replaced (set). ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawTablesUpdateSet"
          },
          {
            "$ref": "#/components/schemas/RawTablesUpdateAddRemove"
          }
        ]
      },
      "ContactsUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "New contacts list",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          }
        }
      },
      "ContactsUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "Contacts to add",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "remove": {
            "type": "array",
            "description": "Contacts to remove",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          }
        }
      },
      "ContactsUpdate": {
        "type": "object",
        "description": "Updates the resource's assigned contacts. Contacts can be added, removed or replaced (set). ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContactsUpdateSet"
          },
          {
            "$ref": "#/components/schemas/ContactsUpdateAddRemove"
          }
        ]
      },
      "MapUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "nullable": true,
            "example": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "MapUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "nullable": true,
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "remove": {
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "MapUpdate": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated extraction pipeline: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/MapUpdateSet"
          },
          {
            "$ref": "#/components/schemas/MapUpdateAddRemove"
          }
        ]
      },
      "SourceUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 255,
            "type": "string",
            "description": "Source for Extraction Pipeline",
            "nullable": true
          }
        },
        "description": "Set a new value for source."
      },
      "DocumentationUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 10000,
            "type": "string",
            "description": "Documentation text field",
            "nullable": true
          }
        },
        "description": "Set a new value for documentation."
      },
      "ExtPipeUpdateData": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/ExternalIdUpdateField"
          },
          "name": {
            "$ref": "#/components/schemas/NameUpdateField"
          },
          "description": {
            "$ref": "#/components/schemas/DescriptionUpdateField"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetIdUpdateField"
          },
          "schedule": {
            "$ref": "#/components/schemas/ScheduleUpdateField"
          },
          "rawTables": {
            "$ref": "#/components/schemas/RawTablesUpdate"
          },
          "contacts": {
            "$ref": "#/components/schemas/ContactsUpdate"
          },
          "metadata": {
            "$ref": "#/components/schemas/MapUpdate"
          },
          "source": {
            "$ref": "#/components/schemas/SourceUpdateField"
          },
          "documentation": {
            "$ref": "#/components/schemas/DocumentationUpdateField"
          }
        },
        "description": "List of updates for Extraction Pipeline"
      },
      "ExtPipeUpdateById": {
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          },
          "update": {
            "$ref": "#/components/schemas/ExtPipeUpdateData"
          }
        }
      },
      "ExtPipeUpdateByExternalId": {
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project.",
            "nullable": true
          },
          "update": {
            "$ref": "#/components/schemas/ExtPipeUpdateData"
          }
        }
      },
      "ExtPipeUpdate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ExtPipeUpdateById"
          },
          {
            "$ref": "#/components/schemas/ExtPipeUpdateByExternalId"
          }
        ]
      },
      "ExtendedItemsRequest_ExtPipeId_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeId"
            }
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore IDs and external IDs that are not found",
            "default": false
          }
        }
      },
      "ExtPipesFilterRequest": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/ExtPipesFilter"
          },
          "limit": {
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "description": "Limits the number of results to return.",
            "format": "int32",
            "default": 100
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "ExtPipesFilter": {
        "type": "object"
      },
      "CreateExtPipeRunResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExtPipeRunResponse"
          },
          {
            "type": "object",
            "properties": {
              "externalId": {
                "type": "string",
                "description": "Extraction Pipeline external Id."
              }
            },
            "description": "Create Extraction Pipeline Runs response."
          }
        ]
      },
      "ItemsResponse_CreateExtPipeRunResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateExtPipeRunResponse"
            }
          }
        },
        "description": "Response with a list of elements."
      },
      "ItemsRequest_ExtPipeRunRequest_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunRequest"
            }
          }
        }
      },
      "ExtPipeRunStatus": {
        "type": "string",
        "enum": [
          "success",
          "failure",
          "seen"
        ]
      },
      "ExtPipeRunRequest": {
        "required": [
          "externalId",
          "status"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Extraction pipeline external Id provided by client. Should be unique within the project."
          },
          "status": {
            "$ref": "#/components/schemas/ExtPipeRunStatus"
          },
          "message": {
            "maxLength": 1000,
            "type": "string",
            "description": "Error message.",
            "nullable": true
          },
          "createdTime": {
            "type": "integer",
            "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64",
            "nullable": true
          }
        },
        "description": "Status of the extraction pipeline."
      },
      "RunsFilterRequest": {
        "required": [
          "filter"
        ],
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/RunsFilter"
          },
          "limit": {
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "description": "Limits the number of results to return.",
            "format": "int32",
            "default": 100
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "RunsFilter": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Extraction pipeline external Id provided by client."
          },
          "statuses": {
            "type": "array",
            "description": "Extraction pipeline statuses list. Expected values: success, failure, seen.",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunStatus"
            }
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "message": {
            "$ref": "#/components/schemas/StringFilter"
          }
        }
      },
      "StringFilter": {
        "type": "object",
        "properties": {
          "substring": {
            "type": "string",
            "description": "Substring to find strings, that contains it ignoring case."
          }
        }
      },
      "ExtPipeRunResponse": {
        "required": [
          "status"
        ],
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 1,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          },
          "status": {
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Extraction Pipeline status."
          },
          "message": {
            "type": "string",
            "description": "Error message."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "description": "Extraction Pipeline Run. Contains extraction pipeline status and message for a moment of time"
      },
      "ItemsResponse_ExtPipeRunResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunResponse"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "Response with a list of elements."
      },
      "ProjectConfigurationProperties": {
        "type": "object",
        "properties": {
          "isOidcEnabled": {
            "type": "boolean",
            "description": "Whether oidc is enabled"
          },
          "isLegacyLoginFlowAndApiKeysEnabled": {
            "type": "boolean",
            "description": "Whether legacy authentication flows are enabled"
          }
        }
      }
    },
    "parameters": {
      "callId": {
        "schema": {
          "type": "integer"
        },
        "name": "callId",
        "in": "path",
        "required": true,
        "description": "The function call id."
      },
      "functionId": {
        "schema": {
          "type": "integer"
        },
        "name": "functionId",
        "in": "path",
        "required": true,
        "description": "The function id."
      },
      "scheduleId": {
        "schema": {
          "type": "integer"
        },
        "name": "scheduleId",
        "in": "path",
        "required": true,
        "description": "The function schedule id."
      },
      "LimitQuery": {
        "name": "limit",
        "description": "Limits the number of results to be returned.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1
        }
      },
      "Limit": {
        "name": "limit",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 1000
        }
      },
      "Cursor": {
        "name": "cursor",
        "in": "query",
        "schema": {
          "type": "string",
          "example": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo"
        }
      },
      "ModelId": {
        "name": "modelId",
        "in": "path",
        "description": "Model ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "RevisionId": {
        "name": "revisionId",
        "in": "path",
        "description": "Revision ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "project": {
        "in": "path",
        "name": "project",
        "required": true,
        "description": "The project name.",
        "schema": {
          "type": "string",
          "example": "publicdata"
        }
      },
      "partition": {
        "in": "query",
        "name": "partition",
        "required": false,
        "description": "Splits the data set into N partitions.\nYou need to follow the cursors within each partition in order to receive all the data.\nExample: 1/10\n",
        "schema": {
          "type": "string",
          "example": "1/10"
        }
      },
      "CogniteInternalId": {
        "in": "path",
        "name": "id",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "IncludeMetadata": {
        "name": "includeMetadata",
        "in": "query",
        "description": "Whether the metadata field should be returned, or not.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "Offset": {
        "name": "offset",
        "description": "Offset from the first result. Sum of limit and offset must not exceed 1000.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 0,
          "minimum": 0,
          "maximum": 1000
        }
      },
      "jobId": {
        "in": "path",
        "name": "jobId",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/JobId"
        }
      },
      "feedbackStatus": {
        "name": "status",
        "in": "query",
        "required": false,
        "schema": {
          "$ref": "#/components/schemas/FeedbackStatus"
        }
      },
      "seismicId": {
        "in": "path",
        "name": "seismic_id",
        "required": true,
        "description": "The identifier of a seismic",
        "schema": {
          "type": "integer"
        }
      }
    },
    "responses": {
      "FunctionScheduleDataResponse": {
        "description": "Input data to the associated function.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "id",
                "data"
              ],
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                },
                "data": {
                  "$ref": "#/components/schemas/data"
                }
              }
            }
          }
        }
      },
      "FunctionCallResponse": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "response",
                "functionId",
                "callId"
              ],
              "description": "The function response.",
              "properties": {
                "response": {
                  "type": "object"
                },
                "functionId": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                },
                "callId": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            "examples": {
              "Function response example": {
                "value": {
                  "response": {
                    "numAssets": 1234,
                    "someCalculation": 3.14
                  }
                }
              }
            }
          }
        }
      },
      "FunctionScheduleCreated": {
        "description": "Created",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionSchedule"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionScheduleList": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionSchedule"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionCalled": {
        "description": "Created",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          }
        }
      },
      "FunctionCallLog": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionCallLogEntry"
                  }
                }
              }
            },
            "examples": {
              "Example response": {
                "value": {
                  "items": [
                    {
                      "timestamp": 1585350274000,
                      "message": "Did do fancy thing"
                    },
                    {
                      "timestamp": 1585350276000,
                      "message": "Did do another fancy thing"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "FunctionCallList": {
        "description": "List of function calls.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCalls"
            }
          }
        }
      },
      "FunctionCallListWithCursor": {
        "description": "Paged response with list of function calls.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCallsWithCursor"
            }
          }
        }
      },
      "FunctionList": {
        "description": "List of functions.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Function"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionsLimits": {
        "description": "Limits",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "timeoutMinutes",
                "cpuCores",
                "memoryGb",
                "runtimes",
                "responseSizeMb"
              ],
              "properties": {
                "timeoutMinutes": {
                  "type": "integer",
                  "description": "Timeout of each function call.",
                  "example": 15
                },
                "cpuCores": {
                  "type": "object",
                  "$ref": "#/components/schemas/CPURange"
                },
                "memoryGb": {
                  "type": "object",
                  "$ref": "#/components/schemas/MemoryRange"
                },
                "runtimes": {
                  "type": "array",
                  "description": "Available runtimes. For example, runtime \"py38\" translates to the latest version of the Python 3.8 series.",
                  "items": {
                    "type": "string",
                    "example": [
                      "py37",
                      "py38",
                      "py39"
                    ]
                  }
                },
                "responseSizeMb": {
                  "type": "integer",
                  "description": "Maximum response size of function calls.",
                  "example": 1
                }
              }
            }
          }
        }
      },
      "FunctionsActivation": {
        "description": "Functions activation status",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "status"
              ],
              "properties": {
                "status": {
                  "type": "string",
                  "description": "Signifies whether Cognite Functions have been requested or activated for the project. Set to inactive by default.",
                  "enum": [
                    "inactive",
                    "requested",
                    "activated"
                  ]
                }
              }
            }
          }
        }
      },
      "CountResponse": {
        "description": "Number of items",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Some required fields are missing.",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "description": "Number of items",
                  "format": "int64",
                  "example": 100000
                }
              }
            }
          }
        }
      },
      "AggregateResponse": {
        "description": "Response with list of aggregation results.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AggregateResult"
            }
          }
        }
      },
      "MissingField": {
        "description": "Missing required fields.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Some required fields are missing.",
              "required": [
                "code",
                "message",
                "missingFields"
              ],
              "properties": {
                "code": {
                  "type": "integer",
                  "description": "HTTP status code.",
                  "format": "int32",
                  "example": 400
                },
                "message": {
                  "type": "string",
                  "description": "Error message."
                },
                "missingFields": {
                  "uniqueItems": true,
                  "type": "array",
                  "description": "Fields that are missing.",
                  "items": {
                    "type": "object",
                    "description": "Fields that are missing."
                  }
                }
              }
            }
          }
        }
      },
      "EmptyResponse": {
        "description": "Empty response.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "ErrorResponse": {
        "description": "The response for a failed request.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "AuthErrorResponse": {
        "description": "Authorization error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "UnprocessableEntityErrorResponse": {
        "description": "Processing error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "BadRequestErrorResponse": {
        "description": "Bad request error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "IllegalAcceptHeaderErrorResponse": {
        "description": "Illegal \"Accept\" header",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "VisionExtractPostResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "features"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "description": "List of files to be analyzed by the feature extractors.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/AllOfFileId"
                      }
                    },
                    "features": {
                      "type": "array",
                      "description": "The type of detections to perform. New feature extractors may appear.",
                      "uniqueItems": true,
                      "items": {
                        "$ref": "#/components/schemas/VisionExtractFeature"
                      },
                      "example": [
                        "TextDetection",
                        "AssetTagDetection",
                        "IndustrialObjectDetection",
                        "PeopleDetection",
                        "PersonalProtectiveEquipmentDetection"
                      ]
                    },
                    "parameters": {
                      "$ref": "#/components/schemas/FeatureParameters"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "VisionExtractGetResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of file IDs and their corresponding predictions.",
                      "items": {
                        "type": "object",
                        "$ref": "#/components/schemas/VisionExtractItem"
                      }
                    },
                    "failedItems": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/FailedBatch"
                      }
                    },
                    "parameters": {
                      "$ref": "#/components/schemas/FeatureParameters"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "DocumentsClassifiersResponse": {
        "description": "The response for a successful classifier create/list/update operation.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentsClassifierItems"
            }
          }
        }
      },
      "DocumentsTemporaryPreviewLinkResponse": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "description": "A temporary link to download a preview of the document.",
              "type": "object",
              "properties": {
                "temporaryLink": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "DocumentsPipelinesResponse": {
        "description": "The response for a successful pipline create/get/update operation.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DocumentsPipelineItems"
            }
          }
        }
      },
      "DocumentFeedbackCreateResponse": {
        "description": "The response for a successful feedback 'create' operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "documentId",
                      "label",
                      "action",
                      "feedbackId",
                      "createdAt",
                      "status"
                    ],
                    "properties": {
                      "documentId": {
                        "$ref": "#/components/schemas/DocumentId"
                      },
                      "label": {
                        "$ref": "#/components/schemas/FeedbackLabel"
                      },
                      "action": {
                        "$ref": "#/components/schemas/FeedbackAction"
                      },
                      "feedbackId": {
                        "$ref": "#/components/schemas/FeedbackId"
                      },
                      "reporterInfo": {
                        "$ref": "#/components/schemas/ReporterInfo"
                      },
                      "createdAt": {
                        "description": "When this feedback object was created by the end-user.\n\nA UTC-based [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp string.",
                        "type": "string",
                        "example": "2021-02-04T16:24:23.284407"
                      },
                      "status": {
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/FeedbackStatus"
                          },
                          {
                            "example": "CREATED"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "DocumentFeedbackListResponse": {
        "description": "The response for a successful feedback list operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of feedback objects",
                  "items": {
                    "$ref": "#/components/schemas/DocumentFeedback"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentFeedbackAggregateResponse": {
        "description": "The response for a successful aggregated list operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "field",
                "groups",
                "total"
              ],
              "properties": {
                "field": {
                  "$ref": "#/components/schemas/AggregateField"
                },
                "groups": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AggregateGroup"
                  }
                },
                "total": {
                  "type": "integer",
                  "description": "The sum of all groups"
                }
              }
            },
            "example": {
              "field": "action",
              "groups": [
                {
                  "value": "ATTACH",
                  "count": 3
                },
                {
                  "value": "DETACH",
                  "count": 2
                }
              ],
              "total": 5
            }
          }
        }
      },
      "DocumentsFilterResponse": {
        "description": "The results of a list.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Document"
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available)."
                }
              }
            }
          }
        }
      },
      "DocumentContentResponse": {
        "description": "Textual content for the requested documents.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentContent"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentsSearchResponse": {
        "description": "The results of a search.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "item"
                    ],
                    "properties": {
                      "highlight": {
                        "$ref": "#/components/schemas/Highlight"
                      },
                      "item": {
                        "$ref": "#/components/schemas/Document"
                      }
                    }
                  }
                },
                "aggregates": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "name",
                      "groups",
                      "total"
                    ],
                    "properties": {
                      "name": {
                        "type": "string",
                        "description": "User defined name for this aggregate"
                      },
                      "groups": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "group": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "oneOf": [
                                  {
                                    "type": "object"
                                  },
                                  {
                                    "$ref": "#/components/schemas/LabelDefinitionExternalId"
                                  }
                                ]
                              }
                            },
                            "value": {
                              "type": "integer",
                              "format": "int32"
                            }
                          }
                        }
                      },
                      "total": {
                        "type": "integer",
                        "format": "int32",
                        "description": "Total number of results for this aggregate"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "DownloadSeismicResponse": {
        "description": "The generated SEG-Y file",
        "content": {
          "application/octet-stream": {}
        }
      }
    },
    "requestBodies": {
      "VisionExtractPostRequestSchema": {
        "description": "A request for running an extract job.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items",
                "features"
              ],
              "properties": {
                "items": {
                  "description": "List of image files to be analyzed by the feature extractors.",
                  "type": "array",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/FileReference"
                  }
                },
                "features": {
                  "type": "array",
                  "description": "The type of detections to perform. New feature extractors may appear.",
                  "uniqueItems": true,
                  "items": {
                    "$ref": "#/components/schemas/VisionExtractFeature"
                  },
                  "example": [
                    "TextDetection",
                    "AssetTagDetection",
                    "IndustrialObjectDetection",
                    "PeopleDetection",
                    "PersonalProtectiveEquipmentDetection"
                  ]
                },
                "parameters": {
                  "$ref": "#/components/schemas/FeatureParameters"
                }
              }
            }
          }
        }
      }
    }
  },
  "security": [
    {
      "api-key": []
    },
    {
      "oidc-token": []
    }
  ],
  "x-tagGroups": [
    {
      "name": "Core Resources",
      "tags": [
        "Assets",
        "Events",
        "Files",
        "3D",
        "3D V2",
        "Types",
        "Labels",
        "Relationships",
        "Sequences",
        "Synthetic Time Series",
        "Data sets",
        "Seismic"
      ]
    },
    {
      "name": "Identity and Access Management",
      "tags": [
        "Sessions",
        "Projects"
      ]
    },
    {
      "name": "Contextualization",
      "tags": [
        "Contextualization",
        "Entity matching",
        "Engineering diagrams",
        "P&IDs and files",
        "Template completion"
      ]
    },
    {
      "name": "Vision",
      "tags": [
        "Vision",
        "Vision AutoML"
      ]
    },
    {
      "name": "Digital Twin",
      "tags": [
        "Digital Twin"
      ]
    },
    {
      "name": "Documents",
      "tags": [
        "Documents",
        "Document pipelines",
        "Document preview",
        "Document feedback"
      ]
    },
    {
      "name": "Extraction Pipelines",
      "tags": [
        "Extraction Pipelines",
        "Extraction Pipelines Runs"
      ]
    },
    {
      "name": "Functions",
      "tags": [
        "Functions",
        "Function calls",
        "Function schedules"
      ]
    }
  ],
  "tags": [
    {
      "name": "Functions",
      "description": "Functions enables Python code to be hosted and executed in the cloud, on demand or by using a schedule. Execution, status and logs are available through the API. A function is uploaded to the Files API as a zip file with at least a Python file called `handler.py` (unless specified otherwise through the `functionPath`-argument) that must contain a function named `handle` with any of the following arguments: `data`, `client`, `secrets`, or 'function_call_info', which are passed into the function. \nThe latest version of Cognite SDK's are available, and additional python packages and version specifications can be defined in a `requirements.txt` in the root of the zip."
    },
    {
      "name": "Function calls",
      "description": "Function calls let you execute functions asynchronously with a timeout of 15 minutes."
    },
    {
      "name": "Function schedules",
      "description": "Function schedules allow you to run functions with a specific input at intervals defined by a cron expression. These function calls will be asynchronous and show up in the function call list. Visit http://www.cronmaker.com to generate a cron expression with a UI."
    },
    {
      "name": "3D",
      "description": "We organize 3D data into models and revisions. A model is just a placeholder for a set of revisions. Revisions contains the actual 3D data. For example you can have a model named Compressor and you can upload a revision under that model. When you create a revision you need to attach a 3D file. For every new version of the 3D model you upload a new revision under the placeholder model. You can then easily track the history of a model by browsing the different revisions.\n\nWhen you upload a new revision Cognite need to process the 3D data to optimize it for rendering. This can take some time and we therefore give you a status string back in the revision object. You can then follow the process while you wait.\n\nA 3D model is typically built up by a hierarchical structure. This looks very similar to how we organize our internal asset hierarchy. We support endpoints to extract the 3D node hierarchy and endpoints to make mappings from the 3D nodes to nodes in Cognite's asset hierarchy. We assign a random ID, nodeId, to each node in the 3D hierarchy. This is the ID representing the object in the viewer. When a user click on a object in the viewer it returns the ID for the object that was clicked. You can then use that ID to look up which node in the hierarchy the user clicked on.\n\nWe also deliver a [web based 3D viewer](https://www.npmjs.com/package/@cognite/3d-viewer) to embed the 3D model in your own web page."
    },
    {
      "name": "3D V2"
    },
    {
      "name": "Digital Twin",
      "description": ""
    },
    {
      "name": "Contextualization",
      "description": "The contextualization endpoints lets you match, enrich and compare data in CDF.  For example, you can match time series to assets (or other resource types) using entity matching or create interactive engineering diagrams."
    },
    {
      "name": "Entity matching",
      "description": "The entity matching contextualization endpoints lets you match CDF resources. Note: The majority of the entity matching API has moved to our stable API, please see https://docs.cognite.com/api/v1/#tag/Entity-matching"
    },
    {
      "name": "Engineering diagrams",
      "description": "The engineering diagram contextualization endpoints let you find CDF resources from engineering diagrams and create SVGs of the diagrams. The POST endpoints start jobs and the associated GET endpoints to retrieve the job statuses and the results."
    },
    {
      "name": "Vision",
      "description": "The Vision contextualization endpoints enable extraction of information from imagery data based on their visual content. For example, you can detect external ID or name of assets, detect and read value of gauges or identify common industrial objects in images. \n\nVision contextualization endpoints have support for batch processing which enables processing of multiple files via an asynchronous prediction request. A new contextualization job is triggered by sending a POST request to one of the Vision endpoints. The response of the POST request contains a job ID, which can then be used to make subsequent calls to check the status and retrieve the results of the job once it is completed. "
    },
    {
      "name": "Vision AutoML",
      "description": "**Note: The Vision AutoML service is currently in closed-alpha. You can request access to this service via [Vision Early Adopter Program](https://hub.cognite.com/groups/vision-early-adopter-205) at [Cognite Hub](https://hub.cognite.com/).**\n\nThe Vision Automated Machine Learning (AutoML) service enables you to train and deploy specialized computer vision models (in you CDF project) tailored for a particular use case. You can train classification models (what is contained in an image) or object detection models (what is contained in an image and where is it in the image) by providing a set of annotated images stored in Cognite Data Fusion. Images can be annotated using the UI at [https://fusion.cognite.com](https://fusion.cognite.com) (for more details and guides visit [Vision Early Adopter Program](https://hub.cognite.com/groups/vision-early-adopter-205)). \n\nOnce the training is completed, the model will be deployed in your project and made available for you to analyze new data (read more [here](#operation/visionAutoMLPredict)). Alternatively, you can download the model as e.g. a Tensorflow Lite file (`.tflite`) for offline usage (read more [here](#operation/visionAutoMLDownload))."
    },
    {
      "name": "Documents",
      "description": "Note! We are in the process of deprecating playground support. Endpoints marked deprecated are superseded by endpoints found in v1.\n\nA document is a file that has been indexed by a document processing pipeline.\nThese pipelines are able to extract content from a variety of document types,\nand perform classification, contextualization and other operations on the file.\nThe result is a document.\n\nThe document structure consists of a selection of derived fields, such as the\ntitle, author and language of the document, plus some of the original fields\nfrom the raw file. The fields from the raw file can be found in the\n`sourceFile` structure.\n\n### File type support\nDocuments can be created from the following types of files:\n- PDF files\n- Plain text files\n- Spreadsheets, documents, and presentations from the Microsoft, Open Office and macOS office suites\n- Images"
    },
    {
      "name": "Document pipelines",
      "description": "The document processing pipelines ensure that all files uploaded to CDF are\nparsed and processed automatically.\n\nNote that it is currently only possible to define a single pipeline per project. Support for multiple pipelines may be added in the future.\nIf no pipelines have been created, files will be indexed with the default configuration settings.\nThe default settings are listed for each configuration category below.\n\nCurrently, the pipeline configuration objects lets you configure the settings for the sensitivity matcher, and specify training data for the classifier.\nMore configuration categories will be added in the future.\n\n### The sensitivity matcher\nThe sensitivity matcher lets you provide one or more matchlists and specify fields to match.\nCDF also provides default matchlists which you can use.\nIf a match is found in any of the configured fields, the document can be marked as sensitive.\nFor instance, if you want to match the terms \"top secret\", \"classified\" and \"sensitive\" in\nthe documents, you first create a matchlist containing these terms:\n\n```\n  \"matchLists\": {\n    \"my-terms\": [\n      \"top secret\",\n      \"classified\",\n      \"sensitive\"\n    ]\n  }\n```\n\nNow that we have a matchlist containing our terms, we need to specify which fields to search for the terms in.\nFor instance, if we want to search in the title and in the content of the documents, we can do:\n\n```\n  \"fieldMappings\": {\n    \"title\": [\"my-terms\"],\n    \"sourceFile\": {\n      \"content\": [\"my-terms\"]\n    }\n  }\n```\n\n### Classifiers\nThe classifier field lets you provide a list of labels to be used to train the document classifier.\nThe labels must have been created using the Labels API in order for this operation to succeed.\n\n```\n  \"classifier\": {\n    \"name\": \"Document Type\"\n    \"trainingLabels\": [{\"externalId\": \"label1\"}, {\"externalId\": \"label2\"}]\n  }\n```\n\n### Defaults\nIf no sensitivity matcher configuration is provided, the sensitivity matcher will be disabled,\nand no documents will be automatically marked as sensitive.\n\nIf no classifier is provided, no classifier will be trained for this pipeline."
    },
    {
      "name": "Document preview",
      "x-displayName": "Preview",
      "description": "The preview service is a utility API that can convert most document types into PDF or PNG. This can\nbe very helpful if you want to display a preview of a file in a frontend, or for other tasks that\nrequire conversion of documents into one of these formats.\n\nFor conversion into PDF, the whole document is converted. For PNG, one file is created per page."
    },
    {
      "name": "Document feedback",
      "x-displayName": "Feedback",
      "description": "The document feedback mechanism lets you continuously improve the correctness of the document labels."
    },
    {
      "name": "Sessions",
      "description": "Sessions are used to maintain access to CDF resources for an extended period of time beyond the initial access granted to an internal service. The methods available to extend a sessions lifetime are client credentials and token exchange."
    },
    {
      "name": "Extraction Pipelines",
      "description": "Extraction Pipeline objects represent the applications and software that are deployed to ingest operational data into CDF.  An extraction pipeline can consist of a number of different software components between the source system and CDF. The extraction pipeline object represents the software component that actually sends the data to CDF. Two examples are Cognite extractors and third party ETL tools such as Microsoft Azure or Informatica PowerCenter"
    },
    {
      "name": "Extraction Pipelines Runs",
      "description": "Extraction Pipelines Runs are CDF objects to store statuses related to an extraction pipeline. The supported statuses are: success, failure and seen. The statuses are related to two different types of operation of the extraction pipeline. Success and failure indicate the status for a particular EP run where the EP attempts to send data to CDF. If the data is successfully posted to CDF the status of the run is ‘success’; if the run has been unsuccessful and the data is not posted to CDF, the status of the run is ‘failure’. Message can be stored to explain run status. Seen is a heartbeat status that indicates that the extraction pipeline is alive. This message is sent periodically on a schedule and indicates that the extraction pipeline is working even though data may not have been sent to CDF by the extraction pipeline."
    },
    {
      "name": "Projects",
      "description": "Projects are used to isolate data in CDF from each other. All objects in CDF belong to a single project, and objects in different projects are isolated from each other.\n"
    },
    {
      "name": "Seismic",
      "description": "Seismic is a no-copy view into seismic stores. Once it has been defined, either via a polygon to \"cut out\" from the origin seismic store or via an explicit trace-by-trace mapping, you cannot modify it. Seismics can be assigned to partitions, and you can restrict user access to particular partitions. Thus, they serve as the most granular unit of access control. Each seismic has one corresponding partition, and if a user is restricted to a particular partition, they will only be able to view the seismics that have been assigned to the partition."
    }
  ]
}