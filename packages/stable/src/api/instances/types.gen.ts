// Do not modify this file!
// It was generated by the command "yarn codegen".
// Instead update the code generation logic or the OpenAPI document.

export interface AggregatedHistogramValue {
    aggregate: "histogram";
    /** List (array) of buckets to use for histogram aggregates. */
    buckets: {
        start: number;
        count: number;
    }[];
    /** @example 50 */
    interval: number;
    /** @example duration */
    property: string;
}
export interface AggregatedNumberValue {
    /** @example avg */
    aggregate: "avg" | "min" | "max" | "count" | "sum";
    /**
     * The property the aggregate was calculated from
     * @example duration
     */
    property?: string;
    /**
     * Value returned by the aggregate function
     * @example 0.2
     */
    value?: number;
}
export interface AggregatedResultItem {
    aggregates: AggregatedValueItem[];
    /** @example {"name":"PumpName1","tag":"tag01"} */
    group?: Record<string, string | number | boolean>;
    /** The type of instance */
    instanceType: InstanceType;
}
export interface AggregatedResultItemCollection {
    items: AggregatedResultItem[];
}
export type AggregatedValueItem = AggregatedNumberValue | AggregatedHistogramValue;
/**
 * An aggregate.  It consists of a name, an aggregator function, and the field to use for the function.
 */
export type AggregationDefinition = AvgAggregateFunctionV3 | CountAggregateFunctionV3 | MinAggregateFunctionV3 | MaxAggregateFunctionV3 | SumAggregateFunctionV3 | HistogramAggregateFunctionV3;
export type AggregationRequest = CommonAggregationRequest & {
    instanceType?: InstanceType;
    view: ViewReference;
    targetUnits?: TargetUnits;
    includeTyping?: IncludeTyping;
};
export type AggregationResponse = AggregatedResultItemCollection & {
    typing?: TypeInformationOuter;
};
/**
 * Calculates the average from the data stored by the specified property. This aggregation uses an average mean  calculation, and not an integral mean.
 */
export interface AvgAggregateFunctionV3 {
    avg: {
        property: string;
    };
}
export interface ByIdsResponse {
    /** List of nodes and edges */
    items: NodeOrEdge[];
    /** Spaces for the requested view and containers */
    typing?: TypeInformationOuter;
}
/**
* An external-id reference to an existing CDF resource type item, such as a time series.

An example could be that for an existing time series stored in the CDF time series resource type with the
external-id 21PT0293, then the value would be set to "21PT029", and the type would be set to "timeseries". There
are no referential integrity guarantees for this, and the client should handle if the time series has been removed
or the client may not have access to it.

Currently, time series, sequence and file references are supported.
*/
export interface CDFExternalIdReference {
    /**
     * Specifies that the data type is a list of values. The ordering of values is preserved.
     *
     */
    list?: boolean;
    type: "timeseries" | "file" | "sequence";
}
/**
 * Defines an aggregation request. This will let you group, and aggregate supported data types. The request    supports filters, and allows optional search matching.
 */
export interface CommonAggregationRequest {
    aggregates?: AggregationDefinition[];
    /** A filter Domain Specific Language (DSL) used to create advanced filter queries. */
    filter?: FilterDefinition;
    /**
     * The selection of fields to group the results by when doing aggregations. You can specify up to 5 items
     * to group by.
     *
     * When you do not specify any aggregates, the fields listed in the `groupBy` clause will return the unique
     * values stored for each field.
     */
    groupBy?: string[];
    /**
     * Limit the number of results returned. The default limit is currently at 100 items.
     * @min 1
     * @max 1000
     */
    limit?: number;
    /** Optional list (array) of properties you want to apply the query above to. If you do not list any properties, you search through text fields by default. */
    properties?: string[];
    /** Optional query string.  The API will parse the query string, and use it to match the text properties on elements to use for the aggregate(s). */
    query?: string;
}
/**
 * Reference to an existing container
 */
export interface ContainerReference {
    /** External-id of the container */
    externalId: DMSExternalId;
    /** Id of the space hosting (containing) the container */
    space: SpaceSpecification;
    type: "container";
}
export interface ContainsAllFilterV3 {
    /** Matches items where the property contains all the given values. Only apply this filter to multivalued properties. */
    containsAll: {
        property: DMSFilterProperty;
        values: FilterValueList;
    };
}
export interface ContainsAnyFilterV3 {
    /** Matches items where the property contains one or more of the given values. Only apply this filter to multivalued properties. */
    containsAny: {
        property: DMSFilterProperty;
        values: FilterValueList;
    };
}
export interface CorePropertyDefinition {
    /** When set to ```true```, the API will increment the property based on its highest current value  (max value).  You can only use this functionality to increment properties of type `int32` or `int64`.  If the property has a different data type, the API will return an error. */
    autoIncrement?: boolean;
    /**
     * Default value to use when you do not specify a value for the property.  The default value must be of the same type as what you defined for the property itself.
     *
     * We do not currently support using default values for array/list types.
     */
    defaultValue?: string | number | boolean | object;
    /** Description of the content and suggested use for this property. */
    description?: string;
    /** Should updates to this property be rejected after the initial population? */
    immutable?: boolean;
    /** Readable property name. */
    name?: string;
    /** Does this property need to be set to a value, or not? */
    nullable?: boolean;
}
/**
 * Counts the number of items.  When you specify a property, it returns the number of non-null values for that  property.
 */
export interface CountAggregateFunctionV3 {
    count: {
        property?: string;
    };
}
/**
 * Cursor for paging through results.
 */
export interface Cursor {
    /** @example 4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo */
    cursor?: string;
}
/**
* Build a new query by combining other queries, using boolean operators. We support the `and`, `or`, and
`not` boolean operators.
*/
export type DataModelsBoolFilter = {
    and: FilterDefinition[];
} | {
    or: FilterDefinition[];
} | {
    not: FilterDefinition;
};
/**
 * Leaf filter
 */
export type DataModelsLeafFilter = EqualsFilterV3 | InFilterV3 | RangeFilterV3 | PrefixFilterV3 | DMSExistsFilter | ContainsAnyFilterV3 | ContainsAllFilterV3 | MatchAllFilter | DataModelsNestedFilter | OverlapsFilterV3 | HasExistingDataFilterV3;
export interface DataModelsNestedFilter {
    /**
     * Use `nested` to apply the properties of the direct relation as the filter.  `scope` specifies the direct
     * relation property you want use as the filtering property.
     *
     * Example:
     * ```
     *   {
     *     "nested": {
     *       "scope": ["some", "direct_relation", "property"],
     *       "filter": {
     *         "equals": {
     *           "property": ["node", "name"],
     *           "value": "ACME"
     *         }
     *       }
     *     }
     *   }
     */
    nested: {
        scope: string[];
        filter: FilterDefinition;
    };
}
/**
 * Direct node relation
 */
export interface DirectNodeRelation {
    /** The (optional) required type for the node the direct relation points to. If specified, the node must exist before the direct relation is referenced and of the specified type. If no container specification is used, the node will be auto created with the built-in ```node``` container type, and it does not explicitly have to be created before the node that references it. */
    container?: ContainerReference;
    /**
     * Specifies that the data type is a list of values. The ordering of values is preserved.
     *
     */
    list?: boolean;
    type: "direct";
}
/**
 * Reference to the node pointed to by the direct relation. The reference consists of a space and an external-id.
 */
export interface DirectRelationReference {
    externalId: NodeOrEdgeExternalId;
    space: SpaceSpecification;
}
export interface DMSExistsFilter {
    /**
     * Will match items that have a value in the specified property.
     *
     */
    exists: {
        property: DMSFilterProperty;
    };
}
/**
 * @pattern ^[a-zA-Z]([a-zA-Z0-9_]{0,253}[a-zA-Z0-9])?$
 */
export type DMSExternalId = string;
/**
* Property you want to filter. Use a list of strings to specify nested properties.

<u>Example:</u>

You have the object
```
{
  "room": {
    "id": "b53"
  },
  "roomId": "a23"
}
```

Use `["room", "id"]` to return the value in the nested `id` property, which is a part of the `room` object.

You can also read the value(s) in the standalone property `roomId` with `["roomId"]`.
*/
export type DMSFilterProperty = string[];
/**
 * @pattern ^[a-zA-Z0-9]([.a-zA-Z0-9_-]{0,41}[a-zA-Z0-9])?$
 */
export type DMSVersion = string;
/**
 * Edge
 */
export interface EdgeDefinition {
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    createdTime: EpochTimestamp;
    /** Timestamp when the edge was soft deleted. Note that deleted edges are filtered out of query results, but  present in sync results. This means that this value will only be present in sync results. */
    deletedTime?: EpochTimestamp;
    /** Reference to the node pointed to by the direct relation. The reference consists of a space and an external-id. */
    endNode: DirectRelationReference;
    /** Unique identifier for the edge. Can also be a null character. */
    externalId: NodeOrEdgeExternalId;
    instanceType: "edge";
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    lastUpdatedTime: EpochTimestamp;
    /** Spaces for the requested view and its containers */
    properties?: Record<string, ViewOrContainer>;
    /** Id of the space the edge belongs to */
    space: SpaceSpecification;
    /** Reference to the node pointed to by the direct relation. The reference consists of a space and an external-id. */
    startNode: DirectRelationReference;
    /** Edge type */
    type: DirectRelationReference;
    /** Current version of the edge */
    version: number;
}
/**
 * Property values for the identified/specified view or container
 */
export interface EdgeOrNodeData {
    /** Group of property values indexed by a local unique identifier. The identifier has to have a length of between 1 and 255 characters.  It must also match the pattern ```^[a-zA-Z0-9][a-zA-Z0-9_-]{0,253}[a-zA-Z0-9]?$``` , and it cannot be any of the following reserved identifiers: ```space```, ```externalId```, ```createdTime```, ```lastUpdatedTime```, ```deletedTime```, and ```extensions```. The maximum number of properties depends on your subscription, and is by default 100. */
    properties?: PropertyValueGroupV3;
    /** Reference to a view, or a container */
    source: SourceReference;
}
/**
 * Edge to create or update
 */
export interface EdgeWrite {
    /** Reference to the node pointed to by the direct relation. The reference consists of a space and an external-id. */
    endNode: DirectRelationReference;
    /** Fail the ingestion request if the edge's version is greater than this value. If no  existingVersion is specified, the ingestion will always overwrite any existing data for the edge (for the  specified container or view). If existingVersion is set to 0, the upsert will behave as an insert, so it  will fail the bulk if the item already exists. If skipOnVersionConflict is set on the ingestion request,  then the item will be skipped instead of failing the ingestion request. */
    existingVersion?: number;
    /** Unique alphanumeric identifier for the edge */
    externalId: NodeOrEdgeExternalId;
    instanceType: "edge";
    /** Properties to write to in a view or container, for the edge. */
    sources?: EdgeOrNodeData[];
    /** Id of the space that the edge belongs to. This id cannot be updated. */
    space: SpaceSpecification;
    /** Reference to the node pointed to by the direct relation. The reference consists of a space and an external-id. */
    startNode: DirectRelationReference;
    /** Edge type (direct relation) */
    type: DirectRelationReference;
}
/**
 * The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.
 * @format int64
 * @min 0
 */
export type EpochTimestamp = number;
export interface EqualsFilterV3 {
    /** Matches items that contain the exact value in the provided property. */
    equals: {
        property: DMSFilterProperty;
        value: FilterValue;
    };
}
/**
 * A filter Domain Specific Language (DSL) used to create advanced filter queries.
 * @example {"and":[{"in":{"property":["tag"],"values":[10011,10011]}},{"range":{"property":["weight"],"gte":0}}]}
 */
export type FilterDefinition = DataModelsBoolFilter | DataModelsLeafFilter;
export type FilterValue = RawPropertyValueV3 | ReferencedPropertyValueV3;
export type FilterValueList = RawPropertyValueListV3 | ReferencedPropertyValueV3;
export type FilterValueRange = RangeValue | ReferencedPropertyValueV3;
export interface HasExistingDataFilterV3 {
    /** Matches items where data is present in the referenced views, or containers. */
    hasData: SourceReference[];
}
/**
 * A histogram aggregator function.  This function will generate a histogram from the values of the specified  property.  It uses the specified interval as defined in your `interval` argument.
 */
export interface HistogramAggregateFunctionV3 {
    histogram: {
        property: string;
        interval: number;
    };
}
/**
 * Should we return property type information as part of the result?
 */
export type IncludeTyping = boolean;
export interface InFilterV3 {
    /** Matches items where the property **exactly** matches one of the given values. You can only apply this  filter to properties containing a single value. */
    in: {
        property: DMSFilterProperty;
        values: FilterValueList;
    };
}
export interface InstanceInspectRequest {
    inspectionOperations: {
        involvedViews?: {
            allVersions?: boolean;
        };
        involvedContainers?: {
            allVersions?: boolean;
        };
    };
    items: {
        instanceType: InstanceType;
        externalId: NodeOrEdgeExternalId;
        space: SpaceSpecification;
    }[];
}
export interface InstanceInspectResponse {
    /** List of instance inspection results */
    items: InstanceInspectResultItem[];
}
export interface InstanceInspectResultItem {
    /** External ids for the requested items */
    externalId: NodeOrEdgeExternalId;
    inspectionResults: {
        involvedViews?: ViewReference[];
        involvedContainers?: ContainerReference[];
    };
    /** The type of instance being returned, an edge or a node. */
    instanceType: InstanceType;
    space: SpaceSpecification;
}
/**
 * The type of instance
 */
export type InstanceType = "node" | "edge";
export interface LimitWithDefault1000 {
    /**
     * Limits the number of results to return.
     * @min 1
     * @max 1000
     */
    limit?: number;
}
export interface ListOfSpaceExternalIdsRequestWithTyping {
    /** Should we return property type information as part of the result? */
    includeTyping?: IncludeTyping;
    items: {
        instanceType: InstanceType;
        externalId: NodeOrEdgeExternalId;
        space: SpaceSpecification;
    }[];
    /** The node/edge must have data in all the sources defined in the list */
    sources?: SourceSelectorWithoutPropertiesV3;
}
export interface MatchAllFilter {
    /** All the listed items must match the clause. */
    matchAll: object;
}
/**
 * The function will calculate, and return, the highest - max - value for the property.
 */
export interface MaxAggregateFunctionV3 {
    max: {
        property: string;
    };
}
/**
 * The function will calculate, and return, the lowest - min - value for a property.
 */
export interface MinAggregateFunctionV3 {
    min: {
        property: string;
    };
}
/**
 * The cursor value used to return (paginate to) the next page of results, when more data is available.
 */
export type NextCursorV3 = string;
export interface NodeAndEdgeCollectionResponseWithCursorV3Response {
    /** List of nodes and edges */
    items: NodeOrEdge[];
    /** The cursor value used to return (paginate to) the next page of results, when more data is available. */
    nextCursor?: NextCursorV3;
    /** Spaces for the requested view and containers */
    typing?: TypeInformationOuter;
}
export interface NodeAndEdgeCreateCollection {
    /** Should we create missing target nodes of direct relations? If the target-container constraint has been specified for a direct relation, the target node cannot be auto-created. If you want to point direct relations to a space where you have only read access, this option must be set to false. */
    autoCreateDirectRelations?: boolean;
    /** Should we create missing end nodes for edges when ingesting?  By default, the end node of an edge must  exist before we can ingest the edge. */
    autoCreateEndNodes?: boolean;
    /** Should we create missing start nodes for edges when ingesting?  By default, the start node of an edge  must exist before we can ingest the edge. */
    autoCreateStartNodes?: boolean;
    /** List of nodes and edges to create/update */
    items: NodeOrEdgeCreate[];
    /** How do we behave when a property value exists? Do we replace all matching and existing values with  the supplied values (`true`)?  Or should we merge in new values for properties together with the  existing values (`false`)?  Note: This setting applies for all nodes or edges specified in the ingestion  call. */
    replace?: boolean;
    /** If existingVersion is specified on any of the nodes/edges in the input, the default behaviour is that the  entire ingestion will fail when version conflicts occur. If skipOnVersionConflict is set to true, items  with version conflicts will be skipped instead. If no version is specified for nodes/edges, it will do  the write directly. */
    skipOnVersionConflict?: boolean;
}
/**
 * Node
 */
export interface NodeDefinition {
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    createdTime: EpochTimestamp;
    /** Timestamp when the node was soft deleted. Note that deleted nodes are filtered out of query results, but  present in sync results. This means that this value will only be present in sync results. */
    deletedTime?: EpochTimestamp;
    /** Unique identifier for the node */
    externalId: NodeOrEdgeExternalId;
    instanceType: "node";
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    lastUpdatedTime: EpochTimestamp;
    /** Spaces for the requested view and its containers */
    properties?: Record<string, ViewOrContainer>;
    /** Id of the space that the node belongs to */
    space: SpaceSpecification;
    /** Node type */
    type?: DirectRelationReference;
    /** Current version of the node */
    version: number;
}
export type NodeOrEdge = NodeDefinition | EdgeDefinition;
export type NodeOrEdgeCreate = NodeWrite | EdgeWrite;
export interface NodeOrEdgeDeleteRequest {
    items: {
        instanceType: "node" | "edge";
        externalId: NodeOrEdgeExternalId;
        space: SpaceSpecification;
    }[];
}
export interface NodeOrEdgeDeleteResponse {
    items: {
        instanceType: "node" | "edge";
        externalId: NodeOrEdgeExternalId;
        space: SpaceSpecification;
    }[];
}
/**
 * @pattern ^[^\\x00]{1,256}$
 */
export type NodeOrEdgeExternalId = string;
export type NodeOrEdgeListRequestV3 = {
    includeTyping?: IncludeTyping;
    sources?: SourceSelectorWithoutPropertiesV3;
    instanceType?: InstanceType;
} & Cursor & LimitWithDefault1000 & SortV3 & {
    filter?: FilterDefinition;
};
/**
 * Searching nodes or edges using properties from a view
 */
export type NodeOrEdgeSearchRequest = SearchRequestV3;
/**
 * The view or container property to use when we traverse direct relations. Has to reference a direct relation property. Only applicable when `from` is specified.
 */
export type NodeTableExpressionThrough = ViewPropertyReference | ThroughReference;
/**
 * Node to create or update
 */
export interface NodeWrite {
    /** Fail the ingestion request if the node's version is greater than this value. If no  existingVersion is specified, the ingestion will always overwrite any existing data for the edge (for the  specified container or view). If existingVersion is set to 0, the upsert will behave as an insert, so it  will fail the bulk if the item already exists. If skipOnVersionConflict is set on the ingestion request,  then the item will be skipped instead of failing the ingestion request. */
    existingVersion?: number;
    /** Unique identifier for the node */
    externalId: NodeOrEdgeExternalId;
    instanceType: "node";
    /** List of source properties to write. The properties are from the view and/or the container(s) making up this node. */
    sources?: EdgeOrNodeData[];
    /** Id of the space that the node belongs to. This space-id cannot be updated. */
    space: SpaceSpecification;
    /** Node type (direct relation) */
    type?: DirectRelationReference;
}
export interface OverlapsFilterV3 {
    /** Matches items where the range made up of the two properties overlap with the provided range. */
    overlaps: {
        startProperty: DMSFilterProperty;
        endProperty: DMSFilterProperty;
        gte?: FilterValueRange;
        gt?: FilterValueRange;
        lte?: FilterValueRange;
        lt?: FilterValueRange;
    };
}
/**
 * A parameterized value
 */
export interface ParameterizedPropertyValueV3 {
    parameter: string;
}
export interface PrefixFilterV3 {
    /** Matches items that have the prefix in the identified property. This filter is only supported for single value text properties. */
    prefix: {
        property: DMSFilterProperty;
        value: string | ParameterizedPropertyValueV3;
    };
}
/**
* Primitive types for the property.

We expect dates to be in the ISO-8601 format, while timestamps are expected to be an epoch value with
millisecond precision. JSON values have to be valid JSON fragments. The maximum allowed size for a JSON
object is 40960 bytes. For list of json values, the size of the entire list must be within this limit.
The maximum allowed length of a key is 128, while the maximum allowed size of a value is 10240 bytes
and you can have up to 256 key-value pairs.
*/
export interface PrimitiveProperty {
    /**
     * Specifies that the data type is a list of values. The ordering of values is preserved.
     *
     */
    list?: boolean;
    type: "boolean" | "float32" | "float64" | "int32" | "int64" | "timestamp" | "date" | "json";
    /**
     * The unit of the data stored in this property, can only be assign to type float32 or float64.
     * ExternalId needs to match with a unit in the Cognite unit catalog.
     *
     * @example externalId: temperature:deg_c, sourceUnit: Celsius
     */
    unit?: {
        externalId: NodeOrEdgeExternalId;
        sourceUnit?: string;
    };
}
/**
 * @pattern ^[a-zA-Z]([a-zA-Z0-9_]{0,253}[a-zA-Z0-9])?$
 */
export type PropertyIdentifierV3 = string;
export interface PropertySortV3 {
    direction?: "ascending" | "descending";
    nullsFirst?: boolean;
    /**
     * Property you want to filter. Use a list of strings to specify nested properties.
     *
     * <u>Example:</u>
     * You have the object
     * ```
     * {
     *   "room": {
     *     "id": "b53"
     *   },
     *   "roomId": "a23"
     * }
     * Use `["room", "id"]` to return the value in the nested `id` property, which is a part of the `room` object.
     * You can also read the value(s) in the standalone property `roomId` with `["roomId"]`.
     */
    property: DMSFilterProperty;
}
/**
 * Group of property values indexed by a local unique identifier. The identifier has to have a length of between 1 and 255 characters.  It must also match the pattern ```^[a-zA-Z0-9][a-zA-Z0-9_-]{0,253}[a-zA-Z0-9]?$``` , and it cannot be any of the following reserved identifiers: ```space```, ```externalId```, ```createdTime```, ```lastUpdatedTime```, ```deletedTime```, and ```extensions```. The maximum number of properties depends on your subscription, and is by default 100.
 * @example {"someStringProperty":"someStringValue","someDirectRelation":{"space":"mySpace","externalId":"someNode"},"someIntArrayProperty":[1,2,3,4]}
 */
export type PropertyValueGroupV3 = Record<string, RawPropertyValueV3>;
export interface QueryEdgeTableExpressionV3 {
    edges: {
        from?: string;
        chainTo?: TableExpressionChainToDefinition;
        maxDistance?: number;
        direction?: "outwards" | "inwards";
        filter?: TableExpressionFilterDefinition;
        nodeFilter?: TableExpressionFilterDefinition;
        terminationFilter?: TableExpressionFilterDefinition;
        limitEach?: number;
    };
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionQueryLimit;
    postSort?: PropertySortV3[];
    sort?: PropertySortV3[];
}
/**
 * Find the common elements in the returned result set. Excludes the elements from the optional `except`  result set.
 */
export interface QueryIntersectionTableExpressionV3 {
    except?: string[];
    intersection: (QuerySetOperationTableExpressionV3 | string)[];
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionQueryLimit;
}
export interface QueryNodeTableExpressionV3 {
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionQueryLimit;
    nodes: {
        from?: string;
        chainTo?: TableExpressionChainToDefinition;
        through?: NodeTableExpressionThrough;
        direction?: "outwards" | "inwards";
        filter?: TableExpressionFilterDefinition;
    };
    sort?: PropertySortV3[];
}
export interface QueryRequest {
    /** Cursors returned from the previous query request. These cursors match the result set expressions you  specified in the ```with``` clause for the query. */
    cursors?: Record<string, NextCursorV3>;
    /** Should we return property type information as part of the result? */
    includeTyping?: IncludeTyping;
    /** Values in filters can be parameterised. Parameters are provided as part of the query  object, and referenced in the filter itself. */
    parameters?: Record<string, RawPropertyValueV3>;
    select: Record<string, QuerySelectV3>;
    with: Record<string, QueryTableExpressionV3>;
}
export interface QueryResponse {
    items: Record<string, NodeOrEdge[]>;
    nextCursor: Record<string, any>;
    /** Property type information for selected result expressions. */
    typing?: Record<string, TypeInformationOuter>;
}
/**
 * Define which view to return properties for, and the properties to return. Up to 10 views can be specified per query.
 */
export interface QuerySelectV3 {
    limit?: number;
    sort?: PropertySortV3[];
    sources?: SourceSelectorV3;
}
export type QuerySetOperationTableExpressionV3 = QueryUnionAllTableExpressionV3 | QueryUnionTableExpressionV3 | QueryIntersectionTableExpressionV3;
export type QueryTableExpressionV3 = QueryNodeTableExpressionV3 | QueryEdgeTableExpressionV3 | QuerySetOperationTableExpressionV3;
/**
* Return the union of the specified result sets.  We will remove the results that match the optional exception
result sets.  Note: The operation may return duplicate results since we do not perform deduplication.
*/
export interface QueryUnionAllTableExpressionV3 {
    except?: string[];
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionQueryLimit;
    unionAll: (QuerySetOperationTableExpressionV3 | string)[];
}
/**
* Return the union of the specified result sets. We will remove the results that match the optional
exception result sets.  But this operation does not result in duplicate results as it performs
deduplication.

Note: You should use the `unionAll` operation whenever possible. Using it enables a built-in optimization.
I.e. `A unionAll B` with `limit: n` will execute set operation B, if and only if, A returns less than
n records.
*/
export interface QueryUnionTableExpressionV3 {
    except?: string[];
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionQueryLimit;
    union: (QuerySetOperationTableExpressionV3 | string)[];
}
export interface RangeFilterV3 {
    /**
     * Matches items that contain terms within the provided range.
     *
     * The range must include both an upper and a lower bound. It is not permitted to specify both inclusive
     * and exclusive bounds together.  E.g. `gte` and `gt`.
     *   `gte`: Greater than or equal to.
     *   `gt`: Greater than.
     *   `lte`: Less than or equal to.
     *   `lt`: Less than.
     */
    range: {
        property: DMSFilterProperty;
        gte?: FilterValueRange;
        gt?: FilterValueRange;
        lte?: FilterValueRange;
        lt?: FilterValueRange;
    };
}
/**
 * Value you wish to find in the provided property using a range clause.
 */
export type RangeValue = string | number | number;
/**
 * A list of values
 */
export type RawPropertyValueListV3 = (string | number | boolean | object)[];
/**
 * A value matching the data type of the defined property
 */
export type RawPropertyValueV3 = string | number | boolean | object | string[] | boolean[] | number[] | object[];
/**
 * A property reference value
 */
export interface ReferencedPropertyValueV3 {
    property: string[];
}
export type SearchRequestV3 = {
    view: ViewReference;
    query?: string;
    instanceType?: InstanceType;
    properties?: string[];
    targetUnits?: TargetUnits;
    filter?: FilterDefinition;
    includeTyping?: IncludeTyping;
    sort?: SearchSort[];
} & LimitWithDefault1000;
export interface SearchResponse {
    /** List of nodes and edges */
    items: NodeOrEdge[];
    /** Spaces for the requested view and containers */
    typing?: TypeInformationOuter;
}
export interface SearchSort {
    direction?: "ascending" | "descending";
    /**
     * Property you want to filter. Use a list of strings to specify nested properties.
     *
     * <u>Example:</u>
     * You have the object
     * ```
     * {
     *   "room": {
     *     "id": "b53"
     *   },
     *   "roomId": "a23"
     * }
     * Use `["room", "id"]` to return the value in the nested `id` property, which is a part of the `room` object.
     * You can also read the value(s) in the standalone property `roomId` with `["roomId"]`.
     */
    property: DMSFilterProperty;
}
/**
 * Edge
 */
export interface SlimEdgeDefinition {
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    createdTime: EpochTimestamp;
    /** Unique alphanumeric identifier for the edge */
    externalId: NodeOrEdgeExternalId;
    instanceType: "edge";
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    lastUpdatedTime: EpochTimestamp;
    /** Id of the space that the edge belongs to */
    space: SpaceSpecification;
    /** Current version of the edge */
    version: number;
    /** Whether or not the edge was modified by this ingestion. We only update the edges if the input differs from the existing state. */
    wasModified: boolean;
}
export interface SlimNodeAndEdgeCollectionResponse {
    /** List of nodes and edges that were created or updated */
    items: SlimNodeOrEdge[];
}
/**
 * Node
 */
export interface SlimNodeDefinition {
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    createdTime: EpochTimestamp;
    /** Unique identifier for the node */
    externalId: NodeOrEdgeExternalId;
    instanceType: "node";
    /** The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. */
    lastUpdatedTime: EpochTimestamp;
    /** Id of the space that the node belongs to */
    space: SpaceSpecification;
    /** Current version of the node */
    version: number;
    /** Whether or not the node was modified by this ingestion. We only update the nodes if the input differs from the existing state. */
    wasModified: boolean;
}
export type SlimNodeOrEdge = SlimNodeDefinition | SlimEdgeDefinition;
export interface SortV3 {
    sort?: PropertySortV3[];
}
/**
 * Reference to a view, or a container
 */
export type SourceReference = ViewReference | ContainerReference;
export type SourceSelectorV3 = {
    source: ViewReference;
    properties: string[];
    targetUnits?: TargetUnits;
}[];
/**
 * Retrieve properties from the listed - by reference - views. The node/edge must have data in all the sources defined in the list.
 */
export type SourceSelectorWithoutPropertiesV3 = {
    source: ViewReference;
    targetUnits?: TargetUnits;
}[];
/**
 * @pattern ^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$
 */
export type SpaceSpecification = string;
/**
 * Calculates the sum from the values of the specified property.
 */
export interface SumAggregateFunctionV3 {
    sum: {
        property: string;
    };
}
/**
 * The synchronization query to use when we listen for changes to edges.  The edges must also match the  specified filter.
 */
export interface SyncEdgeTableExpressionV3 {
    edges: {
        from?: string;
        chainTo?: TableExpressionChainToDefinition;
        maxDistance?: number;
        direction?: "outwards" | "inwards";
        filter?: TableExpressionFilterDefinition;
        nodeFilter?: TableExpressionFilterDefinition;
        terminationFilter?: TableExpressionFilterDefinition;
    };
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionSyncLimit;
}
/**
 * The synchronization query to use when we listen for changes to nodes.  The nodes must also match the  specified filter.
 */
export interface SyncNodeTableExpressionV3 {
    /** Limits the number of instances in the result set generated by this table expression. */
    limit?: TableExpressionSyncLimit;
    nodes: {
        from?: string;
        chainTo?: TableExpressionChainToDefinition;
        through?: NodeTableExpressionThrough;
        direction?: "outwards" | "inwards";
        filter?: TableExpressionFilterDefinition;
    };
}
export interface SyncRequest {
    /** Cursors returned from the previous sync request. These cursors match the result set expressions you  specified in the ```with``` clause for the sync. */
    cursors?: Record<string, NextCursorV3>;
    /** Should we return property type information as part of the result? */
    includeTyping?: IncludeTyping;
    /** Parameters to return */
    parameters?: Record<string, RawPropertyValueV3>;
    select: Record<string, SyncSelectV3>;
    with: Record<string, SyncTableExpressionV3>;
}
/**
 * Specify the container or view to return properties for. Also specify the properties for those  containers/views to return. Up to 10 views can be specified.
 */
export interface SyncSelectV3 {
    sources?: SourceSelectorV3;
}
export type SyncTableExpressionV3 = SyncNodeTableExpressionV3 | SyncEdgeTableExpressionV3;
/**
* Control which side of the edge to chain to. This option is only applicable if the view referenced in the `from` field consists of edges.
- `source` will chain to `start` if you're following edges outwards i.e `direction=outwards`. If you're following edges inwards i.e `direction=inwards`, it will chain to `end`.
- `destination (default)` will chain to `end` if you're following edges outwards i.e `direction=outwards`. If you're following edges inwards i.e `direction=inwards`, it will chain to `start`.
*/
export type TableExpressionChainToDefinition = "source" | "destination";
export interface TableExpressionContainsAllFilterV3 {
    /** Matches items where the property contains all the given values. Only apply this filter to multivalued properties. */
    containsAll: {
        property: DMSFilterProperty;
        values: TableExpressionFilterValueList;
    };
}
export interface TableExpressionContainsAnyFilterV3 {
    /** Matches items where the property contains one or more of the given values. Only apply this filter to multivalued properties. */
    containsAny: {
        property: DMSFilterProperty;
        values: TableExpressionFilterValueList;
    };
}
/**
* Build a new query by combining other queries, using boolean operators. We support the `and`, `or`, and
`not` boolean operators.
*/
export type TableExpressionDataModelsBoolFilter = {
    and: TableExpressionFilterDefinition[];
} | {
    or: TableExpressionFilterDefinition[];
} | {
    not: TableExpressionFilterDefinition;
};
export interface TableExpressionEqualsFilterV3 {
    /** Matches items that contain the exact value in the provided property. */
    equals: {
        property: DMSFilterProperty;
        value: TableExpressionFilterValue;
    };
}
/**
 * A filter Domain Specific Language (DSL) used to create advanced filter queries.
 * @example {"and":[{"in":{"property":["tag"],"values":[10011,10011]}},{"range":{"property":["weight"],"gte":0}}]}
 */
export type TableExpressionFilterDefinition = TableExpressionDataModelsBoolFilter | TableExpressionLeafFilter;
export type TableExpressionFilterValue = RawPropertyValueV3 | ParameterizedPropertyValueV3 | ReferencedPropertyValueV3;
export type TableExpressionFilterValueList = RawPropertyValueListV3 | ParameterizedPropertyValueV3 | ReferencedPropertyValueV3;
export type TableExpressionFilterValueRange = RangeValue | ParameterizedPropertyValueV3 | ReferencedPropertyValueV3;
export interface TableExpressionInFilterV3 {
    /** Matches items where the property **exactly** matches one of the given values. You can only apply this filter to properties containing a single value. */
    in: {
        property: DMSFilterProperty;
        values: TableExpressionFilterValueList;
    };
}
/**
 * Leaf filter
 */
export type TableExpressionLeafFilter = TableExpressionEqualsFilterV3 | TableExpressionInFilterV3 | TableExpressionRangeFilterV3 | TableExpressionPrefixFilterV3 | DMSExistsFilter | TableExpressionContainsAnyFilterV3 | TableExpressionContainsAllFilterV3 | MatchAllFilter | DataModelsNestedFilter | TableExpressionOverlapsFilterV3 | HasExistingDataFilterV3;
export interface TableExpressionOverlapsFilterV3 {
    /** Matches items where the range made up of the two properties overlap with the provided range. */
    overlaps: {
        startProperty: DMSFilterProperty;
        endProperty: DMSFilterProperty;
        gte?: TableExpressionFilterValueRange;
        gt?: TableExpressionFilterValueRange;
        lte?: TableExpressionFilterValueRange;
        lt?: TableExpressionFilterValueRange;
    };
}
export interface TableExpressionPrefixFilterV3 {
    /** Matches items that have the prefix in the identified property. */
    prefix: {
        property: DMSFilterProperty;
        value: TableExpressionFilterValue;
    };
}
/**
 * Limits the number of instances in the result set generated by this table expression.
 * @min 1
 * @max 10000
 */
export type TableExpressionQueryLimit = number;
export interface TableExpressionRangeFilterV3 {
    /**
     * Matches items that contain terms within the provided range.
     *
     * The range must include both an upper and a lower bound. It is not permitted to specify both inclusive
     * and exclusive bounds together.  E.g. `gte` and `gt`.
     *   `gte`: Greater than or equal to.
     *   `gt`: Greater than.
     *   `lte`: Less than or equal to.
     *   `lt`: Less than.
     */
    range: {
        property: DMSFilterProperty;
        gte?: TableExpressionFilterValueRange;
        gt?: TableExpressionFilterValueRange;
        lte?: TableExpressionFilterValueRange;
        lt?: TableExpressionFilterValueRange;
    };
}
/**
 * Limits the number of instances in the result set generated by this table expression.
 * @min 100
 * @max 2000
 */
export type TableExpressionSyncLimit = number;
/**
 * Describes a target unit for a property.
 */
export interface TargetUnit {
    property: string;
    /** The external id of the target unit or unit system to convert to. */
    unit: UnitReference | UnitSystemReference;
}
/**
 * Properties to convert to another unit. The API can only convert to another unit, if a unit has been defined as part of the type on the underlying container being queried.
 */
export type TargetUnits = TargetUnit[];
/**
 * Text type
 */
export interface TextProperty {
    /** Collation - the set of language specific rules - used when sorting text fields */
    collation?: "ucs_basic" | "und" | "af" | "af-NA" | "af-ZA" | "agq" | "agq-CM" | "ak" | "ak-GH" | "am" | "am-ET" | "ar" | "ar-001" | "ar-AE" | "ar-BH" | "ar-DJ" | "ar-DZ" | "ar-EG" | "ar-EH" | "ar-ER" | "ar-IL" | "ar-IQ" | "ar-JO" | "ar-KM" | "ar-KW" | "ar-LB" | "ar-LY" | "ar-MA" | "ar-MR" | "ar-OM" | "ar-PS" | "ar-QA" | "ar-SA" | "ar-SD" | "ar-SO" | "ar-SS" | "ar-SY" | "ar-TD" | "ar-TN" | "ar-YE" | "as" | "as-IN" | "asa" | "asa-TZ" | "ast" | "ast-ES" | "az" | "az-Cyrl" | "az-Cyrl-AZ" | "az-Latn" | "az-Latn-AZ" | "bas" | "bas-CM" | "be" | "be-BY" | "bem" | "bem-ZM" | "bez" | "bez-TZ" | "bg" | "bg-BG" | "bm" | "bm-ML" | "bn" | "bn-BD" | "bn-IN" | "bo" | "bo-CN" | "bo-IN" | "br" | "br-FR" | "brx" | "brx-IN" | "bs" | "bs-Cyrl" | "bs-Cyrl-BA" | "bs-Latn" | "bs-Latn-BA" | "ca" | "ca-AD" | "ca-ES" | "ca-FR" | "ca-IT" | "ccp" | "ccp-BD" | "ccp-IN" | "ce" | "ce-RU" | "ceb" | "ceb-PH" | "cgg" | "cgg-UG" | "chr" | "chr-US" | "ckb" | "ckb-IQ" | "ckb-IR" | "cs" | "cs-CZ" | "cy" | "cy-GB" | "da" | "da-DK" | "da-GL" | "dav" | "dav-KE" | "de" | "de-AT" | "de-BE" | "de-CH" | "de-DE" | "de-IT" | "de-LI" | "de-LU" | "dje" | "dje-NE" | "dsb" | "dsb-DE" | "dua" | "dua-CM" | "dyo" | "dyo-SN" | "dz" | "dz-BT" | "ebu" | "ebu-KE" | "ee" | "ee-GH" | "ee-TG" | "el" | "el-CY" | "el-GR" | "en" | "en-001" | "en-150" | "en-AE" | "en-AG" | "en-AI" | "en-AS" | "en-AT" | "en-AU" | "en-BB" | "en-BE" | "en-BI" | "en-BM" | "en-BS" | "en-BW" | "en-BZ" | "en-CA" | "en-CC" | "en-CH" | "en-CK" | "en-CM" | "en-CX" | "en-CY" | "en-DE" | "en-DG" | "en-DK" | "en-DM" | "en-ER" | "en-FI" | "en-FJ" | "en-FK" | "en-FM" | "en-GB" | "en-GD" | "en-GG" | "en-GH" | "en-GI" | "en-GM" | "en-GU" | "en-GY" | "en-HK" | "en-IE" | "en-IL" | "en-IM" | "en-IN" | "en-IO" | "en-JE" | "en-JM" | "en-KE" | "en-KI" | "en-KN" | "en-KY" | "en-LC" | "en-LR" | "en-LS" | "en-MG" | "en-MH" | "en-MO" | "en-MP" | "en-MS" | "en-MT" | "en-MU" | "en-MW" | "en-MY" | "en-NA" | "en-NF" | "en-NG" | "en-NL" | "en-NR" | "en-NU" | "en-NZ" | "en-PG" | "en-PH" | "en-PK" | "en-PN" | "en-PR" | "en-PW" | "en-RW" | "en-SB" | "en-SC" | "en-SD" | "en-SE" | "en-SG" | "en-SH" | "en-SI" | "en-SL" | "en-SS" | "en-SX" | "en-SZ" | "en-TC" | "en-TK" | "en-TO" | "en-TT" | "en-TV" | "en-TZ" | "en-UG" | "en-UM" | "en-US" | "en-US-u-va-posix" | "en-VC" | "en-VG" | "en-VI" | "en-VU" | "en-WS" | "en-ZA" | "en-ZM" | "en-ZW" | "eo" | "eo-001" | "es" | "es-419" | "es-AR" | "es-BO" | "es-BR" | "es-BZ" | "es-CL" | "es-CO" | "es-CR" | "es-CU" | "es-DO" | "es-EA" | "es-EC" | "es-ES" | "es-GQ" | "es-GT" | "es-HN" | "es-IC" | "es-MX" | "es-NI" | "es-PA" | "es-PE" | "es-PH" | "es-PR" | "es-PY" | "es-SV" | "es-US" | "es-UY" | "es-VE" | "et" | "et-EE" | "eu" | "eu-ES" | "ewo" | "ewo-CM" | "fa" | "fa-AF" | "fa-IR" | "ff" | "ff-Adlm" | "ff-Adlm-BF" | "ff-Adlm-CM" | "ff-Adlm-GH" | "ff-Adlm-GM" | "ff-Adlm-GN" | "ff-Adlm-GW" | "ff-Adlm-LR" | "ff-Adlm-MR" | "ff-Adlm-NE" | "ff-Adlm-NG" | "ff-Adlm-SL" | "ff-Adlm-SN" | "ff-Latn" | "ff-Latn-BF" | "ff-Latn-CM" | "ff-Latn-GH" | "ff-Latn-GM" | "ff-Latn-GN" | "ff-Latn-GW" | "ff-Latn-LR" | "ff-Latn-MR" | "ff-Latn-NE" | "ff-Latn-NG" | "ff-Latn-SL" | "ff-Latn-SN" | "fi" | "fi-FI" | "fil" | "fil-PH" | "fo" | "fo-DK" | "fo-FO" | "fr" | "fr-BE" | "fr-BF" | "fr-BI" | "fr-BJ" | "fr-BL" | "fr-CA" | "fr-CD" | "fr-CF" | "fr-CG" | "fr-CH" | "fr-CI" | "fr-CM" | "fr-DJ" | "fr-DZ" | "fr-FR" | "fr-GA" | "fr-GF" | "fr-GN" | "fr-GP" | "fr-GQ" | "fr-HT" | "fr-KM" | "fr-LU" | "fr-MA" | "fr-MC" | "fr-MF" | "fr-MG" | "fr-ML" | "fr-MQ" | "fr-MR" | "fr-MU" | "fr-NC" | "fr-NE" | "fr-PF" | "fr-PM" | "fr-RE" | "fr-RW" | "fr-SC" | "fr-SN" | "fr-SY" | "fr-TD" | "fr-TG" | "fr-TN" | "fr-VU" | "fr-WF" | "fr-YT" | "fur" | "fur-IT" | "fy" | "fy-NL" | "ga" | "ga-GB" | "ga-IE" | "gd" | "gd-GB" | "gl" | "gl-ES" | "gsw" | "gsw-CH" | "gsw-FR" | "gsw-LI" | "gu" | "gu-IN" | "guz" | "guz-KE" | "gv" | "gv-IM" | "ha" | "ha-GH" | "ha-NE" | "ha-NG" | "haw" | "haw-US" | "he" | "he-IL" | "hi" | "hi-IN" | "hr" | "hr-BA" | "hr-HR" | "hsb" | "hsb-DE" | "hu" | "hu-HU" | "hy" | "hy-AM" | "ia" | "ia-001" | "id" | "id-ID" | "ig" | "ig-NG" | "ii" | "ii-CN" | "is" | "is-IS" | "it" | "it-CH" | "it-IT" | "it-SM" | "it-VA" | "ja" | "ja-JP" | "jgo" | "jgo-CM" | "jmc" | "jmc-TZ" | "jv" | "jv-ID" | "ka" | "ka-GE" | "kab" | "kab-DZ" | "kam" | "kam-KE" | "kde" | "kde-TZ" | "kea" | "kea-CV" | "khq" | "khq-ML" | "ki" | "ki-KE" | "kk" | "kk-KZ" | "kkj" | "kkj-CM" | "kl" | "kl-GL" | "kln" | "kln-KE" | "km" | "km-KH" | "kn" | "kn-IN" | "ko" | "ko-KP" | "ko-KR" | "kok" | "kok-IN" | "ks" | "ks-Arab" | "ks-Arab-IN" | "ksb" | "ksb-TZ" | "ksf" | "ksf-CM" | "ksh" | "ksh-DE" | "ku" | "ku-TR" | "kw" | "kw-GB" | "ky" | "ky-KG" | "lag" | "lag-TZ" | "lb" | "lb-LU" | "lg" | "lg-UG" | "lkt" | "lkt-US" | "ln" | "ln-AO" | "ln-CD" | "ln-CF" | "ln-CG" | "lo" | "lo-LA" | "lrc" | "lrc-IQ" | "lrc-IR" | "lt" | "lt-LT" | "lu" | "lu-CD" | "luo" | "luo-KE" | "luy" | "luy-KE" | "lv" | "lv-LV" | "mai" | "mai-IN" | "mas" | "mas-KE" | "mas-TZ" | "mer" | "mer-KE" | "mfe" | "mfe-MU" | "mg" | "mg-MG" | "mgh" | "mgh-MZ" | "mgo" | "mgo-CM" | "mi" | "mi-NZ" | "mk" | "mk-MK" | "ml" | "ml-IN" | "mn" | "mn-MN" | "mni" | "mni-Beng" | "mni-Beng-IN" | "mr" | "mr-IN" | "ms" | "ms-BN" | "ms-ID" | "ms-MY" | "ms-SG" | "mt" | "mt-MT" | "mua" | "mua-CM" | "my" | "my-MM" | "mzn" | "mzn-IR" | "naq" | "naq-NA" | "nb" | "nb-NO" | "nb-SJ" | "nd" | "nd-ZW" | "nds" | "nds-DE" | "nds-NL" | "ne" | "ne-IN" | "ne-NP" | "nl" | "nl-AW" | "nl-BE" | "nl-BQ" | "nl-CW" | "nl-NL" | "nl-SR" | "nl-SX" | "nmg" | "nmg-CM" | "nn" | "nn-NO" | "nnh" | "nnh-CM" | "nus" | "nus-SS" | "nyn" | "nyn-UG" | "om" | "om-ET" | "om-KE" | "or" | "or-IN" | "os" | "os-GE" | "os-RU" | "pa" | "pa-Arab" | "pa-Arab-PK" | "pa-Guru" | "pa-Guru-IN" | "pcm" | "pcm-NG" | "pl" | "pl-PL" | "ps" | "ps-AF" | "ps-PK" | "pt" | "pt-AO" | "pt-BR" | "pt-CH" | "pt-CV" | "pt-GQ" | "pt-GW" | "pt-LU" | "pt-MO" | "pt-MZ" | "pt-PT" | "pt-ST" | "pt-TL" | "qu" | "qu-BO" | "qu-EC" | "qu-PE" | "rm" | "rm-CH" | "rn" | "rn-BI" | "ro" | "ro-MD" | "ro-RO" | "rof" | "rof-TZ" | "ru" | "ru-BY" | "ru-KG" | "ru-KZ" | "ru-MD" | "ru-RU" | "ru-UA" | "rw" | "rw-RW" | "rwk" | "rwk-TZ" | "sah" | "sah-RU" | "saq" | "saq-KE" | "sat" | "sat-Olck" | "sat-Olck-IN" | "sbp" | "sbp-TZ" | "sd" | "sd-Arab" | "sd-Arab-PK" | "sd-Deva" | "sd-Deva-IN" | "se" | "se-FI" | "se-NO" | "se-SE" | "seh" | "seh-MZ" | "ses" | "ses-ML" | "sg" | "sg-CF" | "shi" | "shi-Latn" | "shi-Latn-MA" | "shi-Tfng" | "shi-Tfng-MA" | "si" | "si-LK" | "sk" | "sk-SK" | "sl" | "sl-SI" | "smn" | "smn-FI" | "sn" | "sn-ZW" | "so" | "so-DJ" | "so-ET" | "so-KE" | "so-SO" | "sq" | "sq-AL" | "sq-MK" | "sq-XK" | "sr" | "sr-Cyrl" | "sr-Cyrl-BA" | "sr-Cyrl-ME" | "sr-Cyrl-RS" | "sr-Cyrl-XK" | "sr-Latn" | "sr-Latn-BA" | "sr-Latn-ME" | "sr-Latn-RS" | "sr-Latn-XK" | "su" | "su-Latn" | "su-Latn-ID" | "sv" | "sv-AX" | "sv-FI" | "sv-SE" | "sw" | "sw-CD" | "sw-KE" | "sw-TZ" | "sw-UG" | "ta" | "ta-IN" | "ta-LK" | "ta-MY" | "ta-SG" | "te" | "te-IN" | "teo" | "teo-KE" | "teo-UG" | "tg" | "tg-TJ" | "th" | "th-TH" | "ti" | "ti-ER" | "ti-ET" | "tk" | "tk-TM" | "to" | "to-TO" | "tr" | "tr-CY" | "tr-TR" | "tt" | "tt-RU" | "twq" | "twq-NE" | "tzm" | "tzm-MA" | "ug" | "ug-CN" | "uk" | "uk-UA" | "ur" | "ur-IN" | "ur-PK" | "uz" | "uz-Arab" | "uz-Arab-AF" | "uz-Cyrl" | "uz-Cyrl-UZ" | "uz-Latn" | "uz-Latn-UZ" | "vai" | "vai-Latn" | "vai-Latn-LR" | "vai-Vaii" | "vai-Vaii-LR" | "vi" | "vi-VN" | "vun" | "vun-TZ" | "wae" | "wae-CH" | "wo" | "wo-SN" | "xh" | "xh-ZA" | "xog" | "xog-UG" | "yav" | "yav-CM" | "yi" | "yi-001" | "yo" | "yo-BJ" | "yo-NG" | "yue" | "yue-Hans" | "yue-Hans-CN" | "yue-Hant" | "yue-Hant-HK" | "zgh" | "zgh-MA" | "zh" | "zh-Hans" | "zh-Hans-CN" | "zh-Hans-HK" | "zh-Hans-MO" | "zh-Hans-SG" | "zh-Hant" | "zh-Hant-HK" | "zh-Hant-MO" | "zh-Hant-TW" | "zu" | "zu-ZA";
    /**
     * Specifies that the data type is a list of values. The ordering of values is preserved.
     *
     */
    list?: boolean;
    type: "text";
}
export interface ThroughReference {
    identifier: PropertyIdentifierV3;
    /** Reference to a view, or a container */
    source: SourceReference;
}
/**
 * Type information for the returned properties (if requested)
 */
export type TypeInformation = Record<string, TypePropertyDefinition>;
/**
 * Spaces for the requested view and containers
 */
export type TypeInformationOuter = Record<string, TypingViewOrContainer>;
/**
 * Describes the type and configuration of a property included in the result.
 */
export type TypePropertyDefinition = ViewCorePropertyDefinition;
/**
 * View or container holding properties
 */
export type TypingViewOrContainer = Record<string, TypeInformation>;
/**
 * Target unit reference.
 */
export interface UnitReference {
    externalId: NodeOrEdgeExternalId;
}
/**
* Target system to convert data to. Can be used instead of targetUnit to identify the unit to convert to.
* @example Default, SI, Imperial

*/
export interface UnitSystemReference {
    unitSystemName: string;
}
export interface UpsertConflict {
    /** Details about the error caused by the upsert/update. */
    error: {
        code: number;
        message: string;
    };
}
export type ViewCorePropertyDefinition = CorePropertyDefinition & {
    type: TextProperty | PrimitiveProperty | CDFExternalIdReference | ViewDirectNodeRelation;
};
/**
 * Direct node relation. Can include a hint to specify the view that this direct relation points to. This hint is optional.
 */
export type ViewDirectNodeRelation = DirectNodeRelation & {
    source?: ViewReference;
};
/**
 * View or container holding properties
 */
export type ViewOrContainer = Record<string, PropertyValueGroupV3>;
export interface ViewPropertyReference {
    /** The unique identifier, from the view, for the property */
    identifier: PropertyIdentifierV3;
    /** Reference to a view - this is deprecated, use `source` with ViewReference instead */
    view: ViewReference;
}
/**
 * Reference to a view
 */
export interface ViewReference {
    /** External-id of the view */
    externalId: DMSExternalId;
    /** Id of the space that the view belongs to */
    space: SpaceSpecification;
    type: "view";
    /** Version of the view */
    version: DMSVersion;
}
