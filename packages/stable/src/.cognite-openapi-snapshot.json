{
  "openapi": "3.1.0",
  "info": {
    "title": "Cognite API",
    "description": "# Introduction\nThis is the reference documentation for the Cognite API with\nan overview of all the available methods.\n\n# Postman\nSelect the **Download** button to download our OpenAPI specification to get started.\n\nTo import your data into Postman, select **Import**, and the Import modal opens.\nYou can import items by dragging or dropping files or folders. You can choose how to import your API and manage the import settings in **View Import Settings**.\n\nIn the Import Settings, set the **Folder organization** to **Tags**, select\n**Enable optional parameters** to turn off the settings, and select **Always inherit authentication** to turn on the settings. Select **Import**.\n\nSet the Authorization to **Oauth2.0**. By default, the settings are for Open Industrial Data. Navigate to [Cognite Hub](https://hub.cognite.com/open-industrial-data-211) to understand how to get the credentials for use in Postman.\n\nFor more information, see [Getting Started with Postman](https://developer.cognite.com/dev/guides/postman/).\n\n# Pagination\nMost resource types can be paginated, indicated by the field `nextCursor` in the response.\nBy passing the value of `nextCursor` as the cursor you will get the next page of `limit` results.\nNote that all parameters except `cursor` has to stay the same.\n\n# Parallel retrieval\nAs general guidance, Parallel Retrieval is a technique that should be used when due to query complexity, retrieval of data in a single request is significantly slower than it would otherwise be for a simple request.  Parallel retrieval does not act as a speed multiplier on optimally running queries.  By parallelizing such requests, data retrieval performance can be tuned to meet the client application needs. \n\nCDF supports parallel retrieval through the `partition` parameter, which has the format `m/n` where `n` is the amount of partitions you would like to split the entire data set into.\nIf you want to download the entire data set by splitting it into 10 partitions, do the following in parallel with `m` running from 1 to 10:\n  - Make a request to `/events` with `partition=m/10`.\n  - Paginate through the response by following the cursor as explained above. Note that the `partition` parameter needs to be passed to all subqueries.\n\nProcessing of parallel retrieval requests is subject to concurrency quota availability. The request returns the `429` response upon exceeding concurrency limits. See the Request throttling chapter below.\n\nTo prevent unexpected problems and to maximize read throughput, you should at most use 10 partitions. \nSome CDF resources will automatically enforce a maximum of 10 partitions.\nFor more specific and detailed information, please read the ```partition``` attribute documentation for the CDF resource you're using.  \n\n# Requests throttling\nCognite Data Fusion (CDF) returns the HTTP `429` (too many requests) response status code when project capacity exceeds the limit.\n\nThe throttling can happen:\n  - If a user or a project sends too many (more than allocated) concurrent requests.\n  - If a user or a project sends a too high (more than allocated) rate of requests in a given amount of time.\n\nCognite recommends using a retry strategy based on truncated exponential backoff to handle sessions with HTTP response codes 429.\n\nCognite recommends using a reasonable number (up to 10) of  `Parallel retrieval` partitions.\n\nFollowing these strategies lets you slow down the request frequency to maximize productivity without having to re-submit/retry failing requests.\n\nSee more [here](https://developer.cognite.com/dev/concepts/request_throttling/).\n\n# API versions\n## Version headers\nThis API uses calendar versioning, and version names follow the `YYYYMMDD` format.\nYou can find the versions currently available by using the version selector at the top of this page.\n\nTo use a specific API version, you can pass the `cdf-version: $version` header along with your requests to the API.\n\n## Beta versions\nThe beta versions provide a preview of what the stable version will look like in the future.\nBeta versions contain functionality that is reasonably mature, and highly likely to become a part of the stable API.\n\nBeta versions are indicated by a `-beta` suffix after the version name. For example, the beta version header for the\n2023-01-01 version is then `cdf-version: 20230101-beta`.\n\n## Alpha versions\nAlpha versions contain functionality that is new and experimental, and not guaranteed to ever become a part of the stable API.\nThis functionality presents no guarantee of service, so its use is subject to caution.\n\nAlpha versions are indicated by an `-alpha` suffix after the version name. For example, the alpha version header for\nthe 2023-01-01 version is then `cdf-version: 20230101-alpha`.",
    "version": "v1",
    "contact": {
      "name": "Cognite Support",
      "url": "https://support.cognite.com",
      "email": "support@cognite.com"
    }
  },
  "servers": [
    {
      "url": "https://{cluster}.cognitedata.com/api/v1/projects/{project}",
      "description": "The URL for the CDF cluster to connect to",
      "variables": {
        "cluster": {
          "enum": [
            "api",
            "az-tyo-gp-001",
            "az-eastus-1",
            "az-power-no-northeurope",
            "westeurope-1",
            "asia-northeast1-1",
            "gc-dsm-gp-001"
          ],
          "default": "api",
          "description": "The CDF cluster to connect to"
        },
        "project": {
          "default": "publicdata",
          "description": "The CDF project name."
        }
      }
    }
  ],
  "paths": {
    "/token/inspect": {
      "get": {
        "servers": [
          {
            "url": "https://{cluster}.cognitedata.com/api/v1",
            "description": "The URL for the CDF cluster to connect to",
            "variables": {
              "cluster": {
                "description": "The CDF cluster to connect to",
                "default": "api",
                "enum": [
                  "api",
                  "az-tyo-gp-001",
                  "az-eastus-1",
                  "az-power-no-northeurope",
                  "westeurope-1",
                  "asia-northeast1-1",
                  "gc-dsm-gp-001"
                ]
              }
            }
          }
        ],
        "x-capability": [
          "projectsAcl:LIST",
          "groupsAcl:LIST"
        ],
        "tags": [
          "Token"
        ],
        "summary": "Inspect",
        "description": "Inspect CDF access granted to an IdP issued token",
        "operationId": "inspectToken",
        "responses": {
          "200": {
            "description": "Ok response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenInspectionResponse"
                }
              }
            }
          },
          "401": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "403": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/assets": {
      "get": {
        "tags": [
          "Assets"
        ],
        "summary": "List assets",
        "description": "List all assets, or only the assets matching the specified query.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "getAssets",
        "parameters": [
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/IncludeMetadata"
          },
          {
            "in": "query",
            "name": "name",
            "schema": {
              "$ref": "#/components/schemas/AssetName"
            }
          },
          {
            "in": "query",
            "name": "parentIds",
            "description": "List only assets that have one of the parentIds as a parent. The parentId for root assets is null.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "parentExternalIds",
            "description": "List only assets that have one of the parentExternalIds as a parent. The parentId for root assets is null.",
            "example": "[externalId_1, externalId_2, externalId_3]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayString"
            }
          },
          {
            "in": "query",
            "name": "rootIds",
            "description": "This parameter is deprecated. Use assetSubtreeIds instead. List only assets that have one of the rootIds as a root asset. A root asset is its own root asset.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "deprecated": true,
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "assetSubtreeIds",
            "description": "List only assets that are in a subtree rooted at any of these assetIds (including the roots given).  If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "assetSubtreeExternalIds",
            "description": "List only assets that are in a subtree rooted at any of these assetExternalIds. If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": "[externalId_1, externalId_2, externalId_3]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayString"
            }
          },
          {
            "in": "query",
            "name": "source",
            "schema": {
              "maxLength": 128,
              "type": "string",
              "description": "The source of the asset, for example which database it's from."
            }
          },
          {
            "in": "query",
            "name": "root",
            "schema": {
              "type": "boolean",
              "default": false,
              "description": "Whether the filtered assets are root assets, or not. Set to True to only list root assets."
            }
          },
          {
            "in": "query",
            "name": "minCreatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxCreatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minLastUpdatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxLastUpdatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "externalIdPrefix",
            "schema": {
              "$ref": "#/components/schemas/CogniteExternalIdPrefix"
            }
          },
          {
            "$ref": "#/components/parameters/partitionLimited10"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/AssetDataWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = await client.assets.list({ filter: { name: '21PT1019' } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.assets.filter(filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.assets import AssetProperty, SortableAssetProperty\nin_timezone = filters.Prefix(AssetProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.assets.filter(\n    filter=in_timezone,\n    sort=(SortableAssetProperty.external_id, \"asc\"))\nasset_list = client.assets.list(limit=5)\n\nfor asset in client.assets:\n    asset # do something with the asset\n\nfor asset_list in client.assets(chunk_size=2500):\n    asset_list # do something with the assets\n\nfrom cognite.client.data_classes import LabelFilter\nmy_label_filter = LabelFilter(contains_all=[\"PUMP\", \"VERIFIED\"])\nasset_list = client.assets.list(labels=my_label_filter)\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.assets.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.assets import AssetProperty, SortableAssetProperty\nin_timezone = filters.Prefix(AssetProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.assets.list(\n    advanced_filter=in_timezone,\n    sort=(SortableAssetProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.assets.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Create assets",
        "description": "Create multiple asset objects in the same project.\nIt is possible to create a maximum of 1000 assets per request.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "createAssets",
        "requestBody": {
          "description": "List of the assets to create. You can create a maximum of 1000 assets per request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataExternalAsset"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/AssetDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = [\n  { name: 'First asset' },\n  { name: 'Second asset', description: 'Another asset', externalId: 'anotherAsset' },\n  { name: 'Child asset', parentExternalId: 'anotherAsset'},\n];\nconst createdAssets = await client.assets.create(assets);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import AssetWrite\nassets = [AssetWrite(name=\"asset1\"), AssetWrite(name=\"asset2\")]\nres = client.assets.create(assets)\n\nfrom cognite.client.data_classes import AssetWrite, Label\nasset = AssetWrite(name=\"my_pump\", labels=[Label(external_id=\"PUMP\")])\nres = client.assets.create(asset)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Asset> upsertAssetsList = List.of(Asset.newBuilder()\n    .setExternalId(\"10\")\n    .setName(\"generated_asset_\")\n    .setDescription(\"generated_asset_description_\")\n    .setSource(\"sdk-data-generator\")\n    .putMetadata(\"type\", \"sdk-data-generator\")\n    .build()); \nList<Asset> upsertedAssets = client.assets().upsert(upsertAssetsList);  \n\n"
          }
        ]
      }
    },
    "/assets/{id}": {
      "get": {
        "tags": [
          "Assets"
        ],
        "summary": "Retrieve an asset by its ID",
        "description": "Retrieve an asset by its internal ID. If you want to retrieve assets by externalIds, use Retrieve assets instead.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "getAsset",
        "parameters": [
          {
            "$ref": "#/components/parameters/CogniteInternalId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/AssetResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = await client.assets.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.assets.retrieve(id=1)\n\nres = client.assets.retrieve(external_id=\"1\")\n"
          }
        ]
      }
    },
    "/assets/list": {
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Filter assets",
        "description": "Retrieve a list of assets in the same project. This operation supports pagination by cursor.\nApply Filtering and Advanced filtering criteria to select a subset of assets.\n\n### Advanced filtering\nAdvanced filter lets you create complex filtering expressions that combine simple operations,\nsuch as `equals`, `prefix`, `exists`, etc., using boolean operators `and`, `or`, and `not`.\nIt applies to basic fields as well as metadata.\n\nSee the `advancedFilter` attribute in the example.\n\nSee more information about filtering DSL [here](https://docs.cognite.com/dev/concepts/resource_filtering_dsl/ \"filtering DSL\").\n\n#### Supported leaf filters\n\n| Leaf filter    | Supported fields                   | Description  |\n|----------------|------------------------------------|--------------|\n| `containsAll`  | Array type fields                  | Only includes results which contain all of the specified values. <br /> `{\"containsAll\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}` |\n| `containsAny`  | Array type fields                  | Only includes results which contain at least one of the specified values. <br /> `{\"containsAny\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}` |\n| `equals`       | Non-array type fields              | Only includes results that are equal to the specified value. <br /> `{\"equals\": {\"property\": [\"property\"], \"value\": \"example\"}}` |\n| `exists`       | All fields                         | Only includes results where the specified property exists (has value). <br /> `{\"exists\": {\"property\": [\"property\"]}}` |\n| `in`           | Non-array type fields              | Only includes results that are equal to one of the specified values. <br /> `{\"in\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}` |\n| `prefix`       | String type fields                 | Only includes results which start with the specified value. <br /> `{\"prefix\": {\"property\": [\"property\"], \"value\": \"example\"}}` |\n| `range`        | Non-array type fields              | Only includes results that fall within the specified range. <br /> `{\"range\": {\"property\": [\"property\"], \"gt\": 1, \"lte\": 5}}` <br /> Supported operators: `gt`, `lt`, `gte`, `lte` |\n| `search`       | `[\"name\"]`, `[\"description\"]`      | Introduced to provide functional parity with /assets/search endpoint. <br /> `{\"search\": {\"property\": [\"property\"], \"value\": \"example\"}}` |\n\n##### Search\nThe `search` leaf filter provides functional parity with the `/assets/search` endpoint.\nIt's available only for the `[\"description\"]` and `[\"name\"]` properties. When specifying only this filter with no explicit ordering,\nbehavior is the same as of the `/assets/search/` endpoint without specifying filters.\nExplicit sorting overrides the default ordering by relevance.\nIt's possible to use the `search` leaf filter as any other leaf filter for creating complex queries.\n\nSee the `search` filter in the `advancedFilter` attribute in the example.\n\n#### advancedFilter attribute limits\n- filter query max depth: 10\n- filter query max number of clauses: 100\n- `and` and `or` clauses must have at least one element\n- `property` array of each leaf filter has the following limitations:\n  - number of elements in the array is in the range [1, 2]\n  - elements must not be blank\n  - each element max length is 128 symbols\n  - property array must match one of the existing properties (static or dynamic metadata).\n- `containsAll`, `containsAny`, and `in` filter `values` array size must be in the range [1, 100]\n- `containsAll`, `containsAny`, and `in` filter `values` array must contain elements of a primitive type (number, string)\n- `range` filter must have at least one of `gt`, `gte`, `lt`, `lte` attributes.\n  But `gt` is mutually exclusive to `gte`, while `lt` is mutually exclusive to `lte`.\n  At least one of the bounds must be specified.\n- `gt`, `gte`, `lt`, `lte` in the `range` filter must be a primitive value\n- `search` filter `value` must not be blank and the length must be in the range [1, 128]\n- filter query may have maximum 2 search leaf filters\n- maximum leaf filter string value length is different depending on the property the filter is using:\n  - `externalId` - 255\n  - `name` - 128 for the `search` filter and 255 for other filters\n  - `description` - 128 for the `search` filter and 255 for other filters\n  - `labels` item - 255\n  - `source` - 128\n  - any `metadata` key - 128\n\n### Sorting\nBy default, assets are sorted by `id` in the ascending order.\nUse the `search` leaf filter to sort the results by relevance.\nSorting by other fields can be explicitly requested. The `order` field is optional\nand defaults to `desc` for `_score_` and `asc` for all other fields.\nThe `nulls` field is optional and defaults to `auto`. `auto` is translated to\n`last` for the `asc` order and to `first` for the `desc` order by the service.\nPartitions are done independently of sorting; there's no guarantee of the sort order between elements from different partitions.\n\nSee the `sort` attribute in the example.\n\n#### Null values\nIn case the `nulls` attribute has the `auto` value or the attribute isn't specified,\nnull (missing) values are considered to be bigger than any other values.\nThey are placed last when sorting in the `asc` order and first when sorting in `desc`.\nOtherwise, missing values are placed according to the `nulls` attribute (last or first), and their placement doesn't depend on the `order` value.\nValues, such as empty strings, aren't considered as nulls.\n\n#### Sorting by score\nUse a special sort property `_score_` when sorting by relevance.\nThe more filters a particular asset matches, the higher its score is. This can be useful,\nfor example, when building UIs. Let's assume we want exact matches to be be displayed above matches by\nprefix as in the request below. An asset named `pump` will match both `equals` and `prefix`\nfilters and, therefore, have higher score than assets with names like `pump valve` that match only `prefix` filter.\n\n```\n\"advancedFilter\" : {\n  \"or\" : [\n    {\n      \"equals\": {\n        \"property\": [\"name\"],\n        \"value\": \"pump\"\n      }\n    },\n    {\n      \"prefix\": {\n        \"property\": [\"name\"],\n        \"value\": \"pump\"\n      }\n    }\n  ]\n},\n\"sort\": [\n  {\n    \"property\" : [\"_score_\"]\n  }\n]\n```\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "listAssets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetListScope"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AssetDataWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = await client.assets.list({ filter: { name: '21PT1019' } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.assets.filter(filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.assets import AssetProperty, SortableAssetProperty\nin_timezone = filters.Prefix(AssetProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.assets.filter(\n    filter=in_timezone,\n    sort=(SortableAssetProperty.external_id, \"asc\"))\nasset_list = client.assets.list(limit=5)\n\nfor asset in client.assets:\n    asset # do something with the asset\n\nfor asset_list in client.assets(chunk_size=2500):\n    asset_list # do something with the assets\n\nfrom cognite.client.data_classes import LabelFilter\nmy_label_filter = LabelFilter(contains_all=[\"PUMP\", \"VERIFIED\"])\nasset_list = client.assets.list(labels=my_label_filter)\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.assets.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.assets import AssetProperty, SortableAssetProperty\nin_timezone = filters.Prefix(AssetProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.assets.list(\n    advanced_filter=in_timezone,\n    sort=(SortableAssetProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.assets.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Asset> listAssetsResults = new ArrayList<>(); \nclient.assets() \n .list() \n .forEachRemaining(listAssetsResults::addAll); \n\n \nclient.assets() \n .list(Request.create() \n .withFilterParameter(\"source\", \"source\")) \n .forEachRemaining(listAssetsResults::addAll); \n\n"
          }
        ]
      }
    },
    "/assets/aggregate": {
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Aggregate assets",
        "description": "The aggregation API lets you compute aggregated results on assets,\nsuch as getting the count of all assets in a project, checking\ndifferent names and descriptions of assets in your project, etc.\n\n#### Aggregate filtering\n##### Filter (filter & advancedFilter) data for aggregates\nFilters behave the same way as for the `Filter assets` endpoint.\nIn text properties, the values are aggregated in a case-insensitive manner.\n\n##### aggregateFilter to filter aggregate results\n`aggregateFilter` works similarly to `advancedFilter` but always applies to aggregate properties.\nFor instance, in case of an aggregation for the `source` property, only the values (aka buckets) of the `source` property can be filtered out.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\\\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "aggregateAssets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetAggregateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregates = await client.assets.aggregate({ filter: { root: true } });\nconsole.log('Number of root assets: ', aggregates[0].count)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "aggregate_by_prefix = client.assets.aggregate(filter={\"external_id_prefix\": \"prefix\"})\nfrom cognite.client.data_classes.assets import AssetProperty\nkey_count = client.assets.aggregate_cardinality_properties(AssetProperty.metadata)\nfrom cognite.client.data_classes.assets import AssetProperty\nlabel_count = client.assets.aggregate_cardinality_values(AssetProperty.labels)\n\nfrom cognite.client.data_classes.filters import Search\nfrom cognite.client.data_classes.assets import AssetProperty\nis_critical = Search(AssetProperty.description, \"critical\")\ncritical_assets = client.assets.aggregate_cardinality_values(\n    AssetProperty.metadata_key(\"timezone\"),\n    advanced_filter=is_critical)\ncount = client.assets.aggregate_count()\n\nfrom cognite.client.data_classes.filters import ContainsAny\nfrom cognite.client.data_classes.assets import AssetProperty\nhas_timezone = ContainsAny(AssetProperty.metadata, \"timezone\")\nasset_count = client.assets.aggregate_count(advanced_filter=has_timezone)\nfrom cognite.client.data_classes.assets import AssetProperty\nresult = client.assets.aggregate_unique_properties(AssetProperty.metadata)\nfrom cognite.client.data_classes.assets import AssetProperty\nresult = client.assets.aggregate_unique_values(AssetProperty.metadata_key(\"timezone\"))\nprint(result.unique)\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.assets import AssetProperty\nfrom cognite.client.utils import timestamp_to_ms\nfrom datetime import datetime\ncreated_after_2020 = filters.Range(AssetProperty.created_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.assets.aggregate_unique_values(AssetProperty.labels, advanced_filter=created_after_2020)\nprint(result.unique)\n\nfrom cognite.client.data_classes.assets import AssetProperty\nfrom cognite.client.data_classes import aggregations\nfrom cognite.client.data_classes import filters\nnot_test = aggregations.Not(aggregations.Prefix(\"test\"))\ncreated_after_2020 = filters.Range(AssetProperty.last_updated_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.assets.aggregate_unique_values(AssetProperty.labels, advanced_filter=created_after_2020, aggregate_filter=not_test)\nprint(result.unique)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Aggregate aggregateResult = client.assets() \n      .aggregate(Request.create().withFilterParameter(\"source\", \"\")); \n\n"
          }
        ]
      }
    },
    "/assets/byids": {
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Retrieve assets",
        "operationId": "byIdsAssets",
        "description": "Retrieve assets by IDs or external IDs.\nIf you specify to get aggregates, then be aware that the aggregates are eventually consistent.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "requestBody": {
          "description": "All provided IDs and external IDs must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetDataIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AssetDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = await client.assets.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.assets.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.assets.retrieve_multiple(external_ids=[\"abc\", \"def\"], ignore_unknown_ids=True)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<Asset> retrievedAssets = client.assets().retrieve(byExternalIds);// by list of items \nList<Asset> retrievedAssets = client.assets().retrieve(\"10\", \"20\");// by varargs of String \n\nList<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<Asset> retrievedAssets = client.assets().retrieve(byInternalIds);// by list of items \nList<Asset> retrievedAssets = client.assets().retrieve(10, 20);// by varargs of Long \n\n"
          }
        ]
      }
    },
    "/assets/update": {
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Update assets",
        "description": "Update the attributes of assets.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "updateAssets",
        "requestBody": {
          "description": "All provided IDs and external IDs must be unique. Fields that aren't included in the request aren't changed.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataAssetChange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AssetDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = await client.assets.update([{id: 123, update: {name: {set: 'New name'}}}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import AssetUpdate\nmy_update = AssetUpdate(id=1).description.set(\"New description\").metadata.add({\"key\": \"value\"})\nres1 = client.assets.update(my_update)\nanother_update = AssetUpdate(id=1).description.set(None)\nres2 = client.assets.update(another_update)\n\nfrom cognite.client.data_classes import AssetUpdate\nmy_update = AssetUpdate(id=1).metadata.add({\"key\": \"value\"})\nres1 = client.assets.update(my_update)\nanother_update = AssetUpdate(id=1).metadata.set(None)\nanother_update2 = AssetUpdate(id=1).metadata.set({})\nres2 = client.assets.update(another_update)\n\nfrom cognite.client.data_classes import AssetUpdate\nmy_update = AssetUpdate(id=1).labels.add([\"PUMP\", \"VERIFIED\"])\nres = client.assets.update(my_update)\n\nfrom cognite.client.data_classes import AssetUpdate\nmy_update = AssetUpdate(id=1).labels.remove(\"PUMP\")\nres = client.assets.update(my_update)\n\nfrom cognite.client.data_classes import AssetUpdate\nmy_update = AssetUpdate(id=1).labels.set(\"PUMP\")\nres = client.assets.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Asset> upsertedAssets = client.assets().upsert(upsertAssetsList); \n\n"
          }
        ]
      }
    },
    "/assets/search": {
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Search assets",
        "description": "Fulltext search for assets based on result relevance. Primarily meant\nfor human-centric use-cases, not for programs, since matching and\nordering may change over time. Additional filters can also be\nspecified. This operation doesn't support pagination.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "searchAssets",
        "requestBody": {
          "description": "Search query",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetSearchFilter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AssetDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assets = await client.assets.search({\n  filter: {\n    parentIds: [1, 2]\n  },\n  search: {\n    query: '21PT1019'\n  }\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.assets.search(name=\"some name\")\n\nres = client.assets.search(filter={\"name\": \"some name\"})\n\nres = client.assets.search(query=\"TAG 30 XV\")\n\nres = client.assets.search(name=\"xyz\",filter={\"parent_ids\": [123,456],\"source\": \"some source\"})\n\nmy_label_filter = LabelFilter(contains_all=[\"PUMP\"])\nres = client.assets.search(name=\"xyz\",filter=AssetFilter(labels=my_label_filter))\n"
          }
        ]
      }
    },
    "/assets/delete": {
      "post": {
        "tags": [
          "Assets"
        ],
        "summary": "Delete assets",
        "description": "Delete assets. By default, `recursive=false` and the request would fail if attempting to delete assets that are referenced as parent by other assets.\nTo delete such assets and all its descendants, set recursive to true.\nThe limit of the request does not include the number of descendants that are deleted.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Assets resource description](../../) for more information.",
        "operationId": "deleteAssets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.assets.delete([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.assets.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<Item> deletedAssets = client.assets().delete(byInternalIds); \n\nList<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<Item> deletedAssets = client.assets().delete(byExternalIds); \n\n"
          }
        ]
      }
    },
    "/models/spaces": {
      "post": {
        "tags": [
          "Spaces"
        ],
        "summary": "Create or update spaces",
        "description": "Add or update (upsert) spaces. For unchanged space specifications, the operation completes without making any changes.  We will not update the ```lastUpdatedTime``` value for spaces that remain unchanged.",
        "operationId": "ApplySpaces",
        "requestBody": {
          "description": "Spaces to add or update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SpaceCreateCollection"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SpaceCollectionResponseV3"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "409": {
            "description": "Space conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpsertConflict"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import SpaceApply\nspaces = [SpaceApply(space=\"mySpace\", description=\"My first space\", name=\"My Space\"),\nSpaceApply(space=\"myOtherSpace\", description=\"My second space\", name=\"My Other Space\")]\nres = client.data_modeling.spaces.apply(spaces)\n"
          }
        ]
      },
      "get": {
        "tags": [
          "Spaces"
        ],
        "summary": "List spaces defined in the project",
        "description": "List spaces defined in the current project.",
        "operationId": "listSpacesV3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ReducedLimit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/IncludeGlobal"
          }
        ],
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SpaceCollectionResponseWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "space_list = client.data_modeling.spaces.list(limit=5)\n\nfor space in client.data_modeling.spaces:\n    space # do something with the space\n\nfor space_list in client.data_modeling.spaces(chunk_size=2500):\n    space_list # do something with the spaces\n"
          }
        ]
      }
    },
    "/models/spaces/byids": {
      "post": {
        "tags": [
          "Spaces"
        ],
        "summary": "Retrieve spaces by their space-ids",
        "description": "Retrieve up to 100 spaces by specifying their space-ids.",
        "operationId": "bySpaceIdsSpaces",
        "requestBody": {
          "description": "List of space-ids for the spaces to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfSpaceIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SpaceCollectionResponseV3"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.data_modeling.spaces.retrieve(spaces='mySpace')\n\nres = client.data_modeling.spaces.retrieve(spaces=[\"MySpace\", \"MyAwesomeSpace\", \"MyOtherSpace\"])\n"
          }
        ]
      }
    },
    "/models/spaces/delete": {
      "post": {
        "tags": [
          "Spaces"
        ],
        "summary": "Delete spaces",
        "description": "Delete one or more spaces. Currently limited to 100 spaces at a time.\n\n\nIf an existing data model references a space, you cannot delete that space. Nodes, edges and other data types that are part of a space will no longer be available. ",
        "operationId": "deleteSpacesV3",
        "requestBody": {
          "description": "List of space-ids for spaces to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfSpaceIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListOfSpaceIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.spaces.delete(spaces=[\"mySpace\", \"myOtherSpace\"])\n"
          }
        ]
      }
    },
    "/models/datamodels": {
      "post": {
        "tags": [
          "Data models"
        ],
        "summary": "Create or update data models",
        "description": "Add or update (upsert) data models. For unchanged data model specifications, the operation completes without making any changes.  We will not update the ```lastUpdatedTime``` value for models that remain unchanged.",
        "operationId": "createDataModels",
        "requestBody": {
          "description": "List of data models to add",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataModelCreateCollection"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataModelCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "409": {
            "description": "Data model conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpsertConflict"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import DataModelApply\ndata_models = [\n    DataModelApply(space=\"mySpace\",external_id=\"myDataModel\",version=\"v1\"),\n    DataModelApply(space=\"mySpace\",external_id=\"myOtherDataModel\",version=\"v1\")]\nres = client.data_modeling.data_models.apply(data_models)\n"
          }
        ]
      },
      "get": {
        "tags": [
          "Data models"
        ],
        "summary": "List data models defined in the project",
        "description": "List data models defined in the project. You can filter the returned models by the specified space.",
        "operationId": "listDataModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/ReducedLimit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/InlineViews"
          },
          {
            "$ref": "#/components/parameters/Space"
          },
          {
            "$ref": "#/components/parameters/AllVersions"
          },
          {
            "$ref": "#/components/parameters/IncludeGlobal"
          }
        ],
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataModelCollectionResponseWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "data_model_list = client.data_modeling.data_models.list(limit=5)\n\nfor data_model in client.data_modeling.data_models:\n    data_model # do something with the data_model\n\nfor data_model_list in client.data_modeling.data_models(chunk_size=10):\n    data_model_list # do something with the data model\n"
          }
        ]
      }
    },
    "/models/datamodels/byids": {
      "post": {
        "tags": [
          "Data models"
        ],
        "summary": "Retrieve data models by their external ids",
        "description": "Retrieve up to 100 data models by their external ids. Views can be auto-expanded when the ```InlineViews``` query parameter is set.",
        "operationId": "byExternalIdsDataModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/InlineViews"
          }
        ],
        "requestBody": {
          "description": "List of external-ids of data models to retrieve.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ListOfVersionReferences"
                  },
                  {
                    "$ref": "#/components/schemas/ListOfAllVersionsReferences"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataModelCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.data_modeling.data_models.retrieve((\"mySpace\", \"myDataModel\", \"v1\"))\n"
          }
        ]
      }
    },
    "/models/datamodels/delete": {
      "post": {
        "tags": [
          "Data models"
        ],
        "summary": "Delete data models",
        "description": "Delete one or more data models.  Currently limited to 100 models at a time.  This does not delete the views, nor the containers they reference.",
        "operationId": "deleteDataModels",
        "requestBody": {
          "description": "List of references to data models you wish to delete",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfVersionReferences"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/VersionReferencesCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.data_models.delete((\"mySpace\", \"myDataModel\", \"v1\"))\n"
          }
        ]
      }
    },
    "/models/views": {
      "post": {
        "tags": [
          "Views"
        ],
        "summary": "Create or update views",
        "description": "Add or update (upsert) views. For unchanged view specifications, the operation completes without making any changes.  We will not update the ```lastUpdatedTime``` value for views that remain unchanged.",
        "operationId": "ApplyViews",
        "requestBody": {
          "description": "Views to add or update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ViewCreateCollection"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ViewCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "409": {
            "description": "View conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpsertConflict"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import ViewApply, MappedPropertyApply, ContainerId\nviews = [\n    ViewApply(\n        space=\"mySpace\",\n        external_id=\"myView\",\n        version=\"v1\",\n        properties={\n            \"someAlias\": MappedPropertyApply(\n                container=ContainerId(\"mySpace\", \"myContainer\"),\n                container_property_identifier=\"someProperty\",\n            ),\n        }\n   )\n]\nres = client.data_modeling.views.apply(views)\n\nfrom cognite.client.data_classes.data_modeling import (\n    ContainerId,\n    DirectRelationReference,\n    MappedPropertyApply,\n    MultiEdgeConnectionApply,\n    ViewApply,\n    ViewId\n)\nacts_in_edge_type = DirectRelationReference(space=\"imdb\", external_id=\"acts-in\")\nmovie_view = ViewApply(\n    space=\"imdb\",\n    external_id=\"Movie\",\n    version=\"1\",\n    name=\"Movie\",\n    properties={\n        \"title\": MappedPropertyApply(\n            container=ContainerId(space=\"imdb\", external_id=\"Movie\"),\n            container_property_identifier=\"title\",\n        ),\n        \"actors\": MultiEdgeConnectionApply(\n            type=acts_in_edge_type,\n            direction=\"inwards\",\n            source=ViewId(\"imdb\", \"Actor\", \"1\"),\n            name=\"actors\",\n        ),\n    }\n)\nactor_view = ViewApply(\n    space=\"imdb\",\n    external_id=\"Actor\",\n    version=\"1\",\n    name=\"Actor\",\n    properties={\n        \"name\": MappedPropertyApply(\n            container=ContainerId(\"imdb\", \"Actor\"),\n            name=\"name\",\n            container_property_identifier=\"name\",\n        ),\n        \"movies\": MultiEdgeConnectionApply(\n            type=acts_in_edge_type,\n            direction=\"outwards\",\n            source=ViewId(\"imdb\", \"Movie\", \"1\"),\n            name=\"movies\",\n        ),\n    }\n)\nres = client.data_modeling.views.apply([movie_view, actor_view])\n"
          }
        ]
      },
      "get": {
        "tags": [
          "Views"
        ],
        "summary": "List views defined in the project",
        "description": "List of views defined in the current project. You can filter the list by specifying a space.",
        "operationId": "listViews",
        "parameters": [
          {
            "$ref": "#/components/parameters/ReducedLimit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Space"
          },
          {
            "$ref": "#/components/parameters/IncludeInheritedProperties"
          },
          {
            "$ref": "#/components/parameters/AllVersions"
          },
          {
            "$ref": "#/components/parameters/IncludeGlobal"
          }
        ],
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ViewCollectionResponseWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "view_list = client.data_modeling.views.list(limit=5)\n\nfor view in client.data_modeling.views:\n    view # do something with the view\n\nfor view_list in client.data_modeling.views(chunk_size=10):\n    view_list # do something with the views\n"
          }
        ]
      }
    },
    "/models/views/byids": {
      "post": {
        "tags": [
          "Views"
        ],
        "summary": "Retrieve views by their external ids",
        "description": "Retrieve up to 100 views by their external ids.",
        "operationId": "byExternalIdsViews",
        "parameters": [
          {
            "$ref": "#/components/parameters/IncludeInheritedProperties"
          }
        ],
        "requestBody": {
          "description": "List of external-ids of views to retrieve.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/ListOfVersionReferences"
                  },
                  {
                    "$ref": "#/components/schemas/ListOfAllVersionsReferences"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ViewCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.data_modeling.views.retrieve(('mySpace', 'myView', 'v1'))\n"
          }
        ]
      }
    },
    "/models/views/delete": {
      "post": {
        "tags": [
          "Views"
        ],
        "summary": "Delete views",
        "description": "Delete one or more views.  Currently limited to 100 views at a time.",
        "operationId": "deleteViews",
        "requestBody": {
          "description": "List of references to views you want to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfVersionReferences"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/VersionReferencesCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.views.delete(('mySpace', 'myView', 'v1'))\n"
          }
        ]
      }
    },
    "/models/containers": {
      "post": {
        "tags": [
          "Containers"
        ],
        "summary": "Create or update containers",
        "description": "Add or update (upsert) containers. For unchanged container specifications, the operation completes without making any changes.  We will not update the ```lastUpdatedTime``` value for containers that remain unchanged.",
        "operationId": "ApplyContainers",
        "requestBody": {
          "description": "Containers to add or update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContainerCreateCollection"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ContainerCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "409": {
            "description": "View conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpsertConflict"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import ContainerApply, ContainerProperty, Text\ncontainer = [ContainerApply(space=\"mySpace\", external_id=\"myContainer\",\n    properties={\"name\": ContainerProperty(type=Text, name=\"name\")})]\nres = client.data_modeling.containers.apply(container)\n\nfrom cognite.client.data_classes.data_modeling import Float64\nfrom cognite.client.data_classes.data_modeling.data_types import UnitReference\ncontainer = ContainerApply(\n    space=\"mySpace\",\n    external_id=\"myContainer\",\n    properties={\n        \"maxPressure\": ContainerProperty(\n            nullable=True,\n            description=\"Maximum Pump Pressure\",\n            name=\"maxPressure\",\n            type=Float64(\n                unit=UnitReference(\n                    external_id=\"pressure:bar\",\n                    source_unit=\"BAR\"\n                )\n            )\n        ),\n        \"rotationConfigurations\": ContainerProperty(\n            nullable=True,\n            description=\"Rotation Configurations\",\n            name=\"rotationConfigurations\",\n            type=Float64(\n                is_list=True,\n                unit=UnitReference(\n                    external_id=\"angular_velocity:rev-per-min\"\n                )\n            )\n        )\n    }\n)\nres = client.data_modeling.containers.apply(container)\n\nfrom cognite.client.data_classes.data_modeling.data_types import UnitReference, EnumValue\nfrom cognite.client.data_classes.data_modeling.data_types import (\n    Boolean, Date, DirectRelation, Enum, FileReference, Float32, Float64,\n    Int32, Int64, Json, SequenceReference, Text, TimeSeriesReference, Timestamp\n)\ncontainer_properties = {\n    \"prop01\": ContainerProperty(Boolean),\n    \"prop02\": ContainerProperty(Boolean(is_list=True)),\n    \"prop03\": ContainerProperty(Date),\n    \"prop04\": ContainerProperty(Date(is_list=True)),\n    \"prop05\": ContainerProperty(Timestamp),\n    \"prop06\": ContainerProperty(Timestamp(is_list=True)),\n    \"prop07\": ContainerProperty(Text),\n    \"prop08\": ContainerProperty(Text(is_list=True)),\n    # Note: DirectRelation(list) support `container`: The (optional) required type for the node\n    #       the direct relation points to.\n    \"prop09\": ContainerProperty(DirectRelation),\n    \"prop10\": ContainerProperty(DirectRelation(is_list=True)),\n    # Note: Enum also support `unknown_value`: The value to use when the enum value is unknown.\n    \"prop11\": ContainerProperty(\n        Enum({\"Closed\": EnumValue(\"Valve is closed\"),\n              \"Opened\": EnumValue(\"Valve is opened\")})),\n    # Note: Floats support unit references, e.g. `unit=UnitReference(\"pressure:bar\")`:\n    \"prop12\": ContainerProperty(Float32),\n    \"prop13\": ContainerProperty(Float32(is_list=True)),\n    \"prop14\": ContainerProperty(Float64),\n    \"prop15\": ContainerProperty(Float64(is_list=True)),\n    \"prop16\": ContainerProperty(Int32),\n    \"prop17\": ContainerProperty(Int32(is_list=True)),\n    \"prop18\": ContainerProperty(Int64),\n    \"prop19\": ContainerProperty(Int64(is_list=True)),\n    \"prop20\": ContainerProperty(Json),\n    \"prop21\": ContainerProperty(Json(is_list=True)),\n    \"prop22\": ContainerProperty(SequenceReference),\n    \"prop23\": ContainerProperty(SequenceReference(is_list=True)),\n    # Note: It is adviced to represent files and time series directly as nodes\n    #       instead of referencing existing:\n    \"prop24\": ContainerProperty(FileReference),\n    \"prop25\": ContainerProperty(FileReference(is_list=True)),\n    \"prop26\": ContainerProperty(TimeSeriesReference),\n    \"prop27\": ContainerProperty(TimeSeriesReference(is_list=True)),\n}\ncontainer = ContainerApply(\n    space=\"my-space\",\n    external_id=\"my-everything-container\",\n    properties=container_properties,\n)\n"
          }
        ]
      },
      "get": {
        "tags": [
          "Containers"
        ],
        "summary": "List containers defined in the project",
        "description": "List of containers defined in the current project. You can filter the list by specifying a space.",
        "operationId": "listContainers",
        "parameters": [
          {
            "$ref": "#/components/parameters/ReducedLimit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Space"
          },
          {
            "$ref": "#/components/parameters/IncludeGlobal"
          }
        ],
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ContainerCollectionResponseWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "container_list = client.data_modeling.containers.list(limit=5)\n\nfor container in client.data_modeling.containers:\n    container # do something with the container\n\nfor container_list in client.data_modeling.containers(chunk_size=10):\n    container_list # do something with the containers\n"
          }
        ]
      }
    },
    "/models/containers/byids": {
      "post": {
        "tags": [
          "Containers"
        ],
        "summary": "Retrieve containers by their external ids",
        "description": "Retrieve up to 100 containers by their specified external ids.",
        "operationId": "byExternalIdsContainers",
        "requestBody": {
          "description": "List of external-ids of containers to retrieve.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfSpaceExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ContainerCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.data_modeling.containers.retrieve(('mySpace', 'myContainer'))\n\nfrom cognite.client.data_classes.data_modeling import ContainerId\nres = client.data_modeling.containers.retrieve(ContainerId(space='mySpace', external_id='myContainer'))\n"
          }
        ]
      }
    },
    "/models/containers/delete": {
      "post": {
        "tags": [
          "Containers"
        ],
        "summary": "Delete containers",
        "description": "Delete one or more containers. Currently limited to 100 containers at a time.",
        "operationId": "deleteContainers",
        "requestBody": {
          "description": "List of the spaces and external-ids for the containers you want to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfSpaceExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListOfSpaceExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.containers.delete((\"mySpace\", \"myContainer\"))\n"
          }
        ]
      }
    },
    "/models/containers/indexes/delete": {
      "post": {
        "tags": [
          "Containers"
        ],
        "summary": "Delete indexes from containers",
        "description": "Delete one or more container indexes. Currently limited to 10 indexes at a time.",
        "operationId": "deleteContainerIndexes",
        "requestBody": {
          "description": "List of the references to indexes you want to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfContainerSubObjectIdentifierRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListOfContainerSubObjectIdentifierResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.containers.delete_indexes(\n    [(ContainerId(\"mySpace\", \"myContainer\"), \"myIndex\")]\n)\n"
          }
        ]
      }
    },
    "/models/containers/constraints/delete": {
      "post": {
        "tags": [
          "Containers"
        ],
        "summary": "Delete constraints from containers",
        "description": "Delete one or more container constraints. Currently limited to 10 constraints at a time.",
        "operationId": "deleteContainerConstraints",
        "requestBody": {
          "description": "List of the references to constraints you want to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfContainerSubObjectIdentifierRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ListOfContainerSubObjectIdentifierResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.containers.delete_constraints(\n    [(ContainerId(\"mySpace\", \"myContainer\"), \"myConstraint\")]\n)\n"
          }
        ]
      }
    },
    "/models/containers/inspect": {
      "post": {
        "tags": [
          "Containers"
        ],
        "summary": "Inspect containers",
        "operationId": "containerInspect",
        "requestBody": {
          "description": "Which containers to inspect and the inspection operations to run.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ContainerInspectRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ContainerInspectResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/models/instances": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Create or update nodes/edges",
        "description": "Create or update nodes and edges in a transaction. The ```items``` field of the payload is an array of objects\nwhere each object describes a node or an edge to create, patch or replace. The ```instanceType``` field of\neach object must be ```node``` or ```edge``` and determines how the rest of the object is interpreted.\n\nThis operation is currently limited to 1000 nodes and/or edges at a time.\n\nIndividual nodes and edges are uniquely identified by their externalId and space.\n\nFor more details on ingesting instances into a graph, see [Ingesting instances]\n(https://docs.cognite.com/cdf/dm/dm_concepts/dm_ingestion).\n\n### Creating new instances\n\nWhen there is no node or edge with the given externalId in the given space, a node will be created and the\nproperties provided for each of the containers or views in the ```sources``` array will be populated for the\nnode/edge. Nodes can also be created implicitly when an edge between them is created (if\n```autoCreateStartNodes``` and/or ``` autoCreateEndNodes``` is set), or when a direct relation\nproperty is set, the target node does not exist and ```autoCreateDirectRelations``` is set.\n\nTo add a node or edge, the user must have capabilities to access (write to) both the view(s) referenced in\n```sources``` and the container(s) underlying these views, as well as any directly referenced containers.\n\n### Updating (patching) or replacing instances\n\nWhen a node or edge (instance) with the given externalId already exists in a space, the\nproperties named in the ```sources``` field will be written to the instance. Other properties will remain\nunchanged. To replace the whole set of properties for an instance (a node or an edge) rather than patch the\ninstance, set the ```replace``` parameter to ```true```.\n\nNote: When using ```replace``` as ```true``` it will replace any omitted property to either it's default\nvalue as defined on the container(s) or null if no default value is set. All properties on the related\ncontainer(s) referenced in the provided ```sources``` view(s) will be replaced, so even when the provided\nview(s) only contains a subset of properties from a container all the properties in that container for that\ninstance will be replaced. If the underlying container(s) have any required properties that are not provided,\nthe operation will fail.\n\nIf you use a writable view to update properties (that is, the source you are referring to in ```sources```\nis a view), you must have write access to the view as well as all of its backing containers.\n\n### No-change patch operations\nWhen a node/edge item has no changes compared to the existing instance - that is, when the supplied property\nvalues are equal to the corresponding values in the existing node/edge, the node/edge will stay unchanged.\nIn this case, the ```lastUpdatedTime``` values for the nodes/edges in question will not change.\n",
        "operationId": "applyNodeAndEdges",
        "requestBody": {
          "description": "Nodes/edges to add or update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NodeAndEdgeCreateCollection"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SlimNodeAndEdgeCollectionResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "409": {
            "description": "Ingestion conflict",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpsertConflict"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import EdgeApply, NodeOrEdgeData, NodeApply\nnode = NodeApply(\"mySpace\", \"myNodeId\")\nres = client.data_modeling.instances.apply(node)\n\nfrom cognite.client.data_classes.data_modeling import EdgeApply, NodeOrEdgeData, NodeApply, ViewId\nactor = NodeApply(\n    space=\"actors\",\n    external_id=\"arnold_schwarzenegger\",\n    sources=[\n        NodeOrEdgeData(\n            ViewId(\"mySpace\", \"PersonView\", \"v1\"),\n            {\"name\": \"Arnold Schwarzenegger\", \"birthYear\": 1947}\n        ),\n        NodeOrEdgeData(\n            ViewId(\"mySpace\", \"ActorView\", \"v1\"),\n            {\"wonOscar\": False}\n        )\n    ]\n)\nmovie = NodeApply(\n    space=\"movies\",\n    external_id=\"Terminator\",\n    sources=[\n        NodeOrEdgeData(\n            ViewId(\"mySpace\", \"MovieView\", \"v1\"),\n            {\"title\": \"Terminator\", \"releaseYear\": 1984}\n        )\n    ]\n)\n# This is one-to-many edge, in this case from a person to a movie\nactor_to_movie = EdgeApply(\n    space=\"actors\",\n    external_id=\"relation:arnold_schwarzenegger:terminator\",\n    type=(\"types\", \"acts-in\"),\n    start_node=(\"actors\", \"arnold_schwarzenegger\"),\n    end_node=(\"movies\", \"Terminator\"),\n)\nres = client.data_modeling.instances.apply([actor, movie], [actor_to_movie])\n\nfrom cognite.client.data_classes.data_modeling import EdgeApply\nactor_to_movie = EdgeApply(\n    space=\"actors\",\n    external_id=\"relation:arnold_schwarzenegger:terminator\",\n    type=(\"types\", \"acts-in\"),\n    start_node=(\"actors\", \"arnold_schwarzenegger\"),\n    end_node=(\"movies\", \"Terminator\"),\n)\nres = client.data_modeling.instances.apply(\n    edges=actor_to_movie,\n    auto_create_start_nodes=True,\n    auto_create_end_nodes=True\n)\n\nfrom cognite.client.utils import datetime_to_ms_iso_timestamp\nfrom datetime import datetime, timezone\nmy_date = datetime(2020, 3, 14, 15, 9, 26, 535000, tzinfo=timezone.utc)\ndata_model_timestamp = datetime_to_ms_iso_timestamp(my_date)  # \"2020-03-14T15:09:26.535+00:00\"\n\nfrom cognite.client.data_classes.data_modeling import TypedNodeApply, PropertyOptions\nclass PersonApply(TypedNodeApply):\n    birth_year = PropertyOptions(identifier=\"birthYear\")\n\n    def __init__(self, space: str, external_id, name: str, birth_year: int):\n        super().__init__(space, external_id, type=(\"sp_model_space\", \"Person\"))\n        self.name = name\n        self.birth_year = birth_year\n    def get_source(self):\n        return ViewId(\"sp_model_space\", \"Person\", \"v1\")\nperson = PersonApply(\"sp_date_space\", \"my_person\", \"John Doe\", 1980)\nres = client.data_modeling.instances.apply(nodes=person)\n"
          }
        ]
      }
    },
    "/models/instances/list": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Filter nodes/edges",
        "description": "Filter the instances - nodes and edges - in a project.",
        "operationId": "advancedListInstance",
        "requestBody": {
          "description": "Filter based on the instance type, the name, the external-ids, and on properties. The filter supports sorting and pagination. The instances must have data in all the views referenced by the sources field. Properties for up to 10 views can be retrieved in one query.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NodeOrEdgeListRequestV3"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/NodeAndEdgeCollectionResponseWithCursorV3"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "instance_list = client.data_modeling.instances.list(limit=5)\n\ninstance_list = client.data_modeling.instances.list(space=\"my-space\")\n\nfrom cognite.client.data_classes.data_modeling import InstanceSort\nproperty_sort = InstanceSort(\n    property=('space', 'view_xid/view_version', 'some_property'),\n    direction=\"descending\",\n    nulls_first=True)\ninstance_list = client.data_modeling.instances.list(sort=property_sort)\n\nfor instance in client.data_modeling.instances:\n    instance # do something with the instance\n\nfor instance_list in client.data_modeling.instances(chunk_size=100):\n    instance_list # do something with the instances\n"
          }
        ]
      }
    },
    "/models/instances/byids": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Retrieve nodes/edges by their external ids",
        "description": "Retrieve up to 1000 nodes or edges by their external ids.",
        "operationId": "byExternalIdsInstances",
        "requestBody": {
          "description": "List of external-ids for nodes or edges to retrieve. Properties for **up to 10 unique views** (in total across the external ids requested) can be retrieved in one query.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListOfSpaceExternalIdsRequestWithTyping"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ByIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.data_modeling.instances.retrieve(\n    nodes=(\"mySpace\", \"myNodeExternalId\"),\n    edges=(\"mySpace\", \"myEdgeExternalId\"),\n    sources=(\"mySpace\", \"myViewExternalId\", \"myViewVersion\"))\n\nfrom cognite.client.data_classes.data_modeling import NodeId, EdgeId, ViewId\nres = client.data_modeling.instances.retrieve(\n    NodeId(\"mySpace\", \"myNode\"),\n    EdgeId(\"mySpace\", \"myEdge\"),\n    ViewId(\"mySpace\", \"myViewExternalId\", \"myViewVersion\"))\n\nfrom cognite.client.data_classes.data_modeling import NodeId, EdgeId\nres = client.data_modeling.instances.retrieve(\n    NodeId(\"mySpace\", \"myNode\"),\n    EdgeId(\"mySpace\", \"myEdge\"),\n    sources=(\"myspace\", \"myView\"))\nfrom cognite.client.data_classes.data_modeling import EdgeId, TypedEdge, PropertyOptions, DirectRelationReference, ViewId\nclass Flow(TypedEdge):\n   flow_rate = PropertyOptions(identifier=\"flowRate\")\n\n   def __init__(\n       self,\n       space: str,\n       external_id: str,\n       version: int,\n       type: DirectRelationReference,\n       last_updated_time: int,\n       created_time: int,\n       flow_rate: float,\n       start_node: DirectRelationReference,\n       end_node: DirectRelationReference,\n       deleted_time: int | None = None,\n   ) -> None:\n       super().__init__(\n           space, external_id, version, type, last_updated_time, created_time, start_node, end_node, deleted_time\n       )\n       self.flow_rate = flow_rate\n\n   @classmethod\n   def get_source(cls) -> ViewId:\n       return ViewId(\"sp_model_space\", \"flow\", \"1\")\nres = client.data_modeling.instances.retrieve_edges(\n    EdgeId(\"mySpace\", \"theFlow\"), edge_cls=Flow\n)\nisinstance(res, Flow)\nfrom cognite.client.data_classes.data_modeling import NodeId, TypedNode, PropertyOptions, DirectRelationReference, ViewId\nclass Person(TypedNode):\n   birth_year = PropertyOptions(identifier=\"birthYear\")\n\n   def __init__(\n       self,\n       space: str,\n       external_id: str,\n       version: int,\n       last_updated_time: int,\n       created_time: int,\n       name: str,\n       birth_year: int | None = None,\n       type: DirectRelationReference | None = None,\n       deleted_time: int | None = None,\n   ):\n       super().__init__(\n           space=space,\n           external_id=external_id,\n           version=version,\n           last_updated_time=last_updated_time,\n           created_time=created_time,\n           type=type,\n           deleted_time=deleted_time\n       )\n       self.name = name\n       self.birth_year = birth_year\n\n   @classmethod\n   def get_source(cls) -> ViewId:\n       return ViewId(\"myModelSpace\", \"Person\", \"1\")\nres = client.data_modeling.instances.retrieve_nodes(\n    NodeId(\"myDataSpace\", \"myPerson\"), node_cls=Person\n)\nisinstance(res, Person)\n"
          }
        ]
      }
    },
    "/models/instances/search": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Search for nodes/edges",
        "description": "Search text fields in views for nodes or edge(s). The service will return up to 1000 results. This operation orders the results by relevance, across the specified spaces.",
        "operationId": "searchInstances",
        "requestBody": {
          "description": "The search specification.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NodeOrEdgeSearchRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModels:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SearchResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import ViewId\nres = client.data_modeling.instances.search(\n    ViewId(\"mySpace\", \"PersonView\", \"v1\"),\n    query=\"Arnold\",\n    properties=[\"name\"])\n\nfrom cognite.client.data_classes.data_modeling import ViewId\nfrom cognite.client.data_classes import filters\nborn_after_1970 = filters.Range([\"mySpace\", \"PersonView/v1\", \"birthYear\"], gt=1970)\nres = client.data_modeling.instances.search(\n    ViewId(\"mySpace\", \"PersonView\", \"v1\"),\n    query=\"Quentin\",\n    properties=[\"name\"],\n    filter=born_after_1970)\n"
          }
        ]
      }
    },
    "/models/instances/aggregate": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Aggregate data across nodes/edges",
        "description": "Aggregate data for nodes or edges in a project. You can use an optional query or filter specification to limit the result.",
        "operationId": "aggregateInstances",
        "requestBody": {
          "description": "Aggregation specification.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AggregationRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/AggregationResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import ViewId, aggregations as aggs\navg_run_time = aggs.Avg(\"runTimeMinutes\")\nview_id = ViewId(\"mySpace\", \"PersonView\", \"v1\")\nres = client.data_modeling.instances.aggregate(view_id, avg_run_time, group_by=\"releaseYear\")\nfrom cognite.client.data_classes.data_modeling import aggregations as aggs, ViewId\nbirth_by_decade = aggs.Histogram(\"birthYear\", interval=10.0)\nview_id = ViewId(\"mySpace\", \"PersonView\", \"v1\")\nres = client.data_modeling.instances.histogram(view_id, birth_by_decade)\n"
          }
        ]
      }
    },
    "/models/instances/delete": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Delete nodes/edges",
        "description": "Delete nodes and edges in a transaction. Limited to 1000 nodes/edges at a time.\n\n\nWhen a node is selected for deletion, all connected incoming and outgoing edges that point to or from it are also deleted. However, please note that the operation might fail if the node has a high number of edge connections. If this is the case, consider deleting the edges connected to the node before deleting the node itself. ",
        "operationId": "deleteBulk",
        "requestBody": {
          "description": "List of types, spaces, and external-ids for nodes and edges to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NodeOrEdgeDeleteRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/NodeOrEdgeDeleteResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.data_modeling.instances.delete(nodes=(\"mySpace\", \"myNode\"))\n\nfrom cognite.client.data_classes.data_modeling import NodeId, EdgeId\nclient.data_modeling.instances.delete(NodeId('mySpace', 'myNode'), EdgeId('mySpace', 'myEdge'))\n\nfrom cognite.client.data_classes.data_modeling import NodeId, EdgeId\nmy_view = client.data_modeling.views.retrieve(('mySpace', 'myView'))\nmy_nodes = client.data_modeling.instances.list(instance_type='node', sources=my_view, limit=None)\nclient.data_modeling.instances.delete(nodes=my_nodes.as_ids())\n"
          }
        ]
      }
    },
    "/models/instances/query": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Query nodes/edges",
        "description": "Specification of query endpoint. For more information, see [Query language](https://docs.cognite.com/cdf/dm/dm_concepts/dm_querying).",
        "operationId": "queryContent",
        "requestBody": {
          "description": "Query specification.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/QueryResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling.query import Query, Select, NodeResultSetExpression, EdgeResultSetExpression, SourceSelector\nfrom cognite.client.data_classes.filters import Range, Equals\nfrom cognite.client.data_classes.data_modeling.ids import ViewId\nmovie_id = ViewId(\"mySpace\", \"MovieView\", \"v1\")\nactor_id = ViewId(\"mySpace\", \"ActorView\", \"v1\")\nquery = Query(\n    with_ = {\n        \"movies\": NodeResultSetExpression(filter=Range(movie_id.as_property_ref(\"releaseYear\"), lt=2000)),\n        \"actors_in_movie\": EdgeResultSetExpression(from_=\"movies\", filter=Equals([\"edge\", \"type\"], {\"space\": movie_id.space, \"externalId\": \"Movie.actors\"})),\n        \"actors\": NodeResultSetExpression(from_=\"actors_in_movie\"),\n    },\n    select = {\n        \"actors\": Select(\n            [SourceSelector(actor_id, [\"name\"])], sort=[InstanceSort(actor_id.as_property_ref(\"name\"))]),\n    },\n)\nres = client.data_modeling.instances.query(query)\n\nfrom cognite.client.data_classes.data_modeling.data_types import UnitReference, UnitSystemReference\nselected_source = SourceSelector(\n    source=ViewId(\"my-space\", \"my-xid\", \"v1\"),\n    properties=[\"f32_prop1\", \"f32_prop2\", \"f64_prop1\", \"f64_prop2\"],\n    target_units=[\n        TargetUnit(\"f32_prop1\", UnitReference(\"pressure:kilopa\")),\n        TargetUnit(\"f32_prop2\", UnitReference(\"pressure:barg\")),\n        TargetUnit(\"f64_prop1\", UnitSystemReference(\"SI\")),\n        TargetUnit(\"f64_prop2\", UnitSystemReference(\"Imperial\")),\n    ],\n)\n\nSourceSelector(source=ViewId(\"my-space\", \"my-xid\", \"v1\"), properties=[\"*\"])\n"
          }
        ]
      }
    },
    "/models/instances/sync": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Sync nodes/edges",
        "description": "Subscribe to changes for nodes and edges in a project, matching a supplied filter.  This endpoint will always return a ```NextCursor```.  The sync specification mirrors the query interface, but sorting is not currently supported. For more information, see [Query language](https://docs.cognite.com/cdf/dm/dm_concepts/dm_querying).",
        "operationId": "syncContent",
        "requestBody": {
          "description": "Change filter specification",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyncRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/QueryResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling.instances import InstanceSort\nfrom cognite.client.data_classes.data_modeling.query import Query, Select, NodeResultSetExpression, EdgeResultSetExpression, SourceSelector\nfrom cognite.client.data_classes.filters import Range, Equals\nfrom cognite.client.data_classes.data_modeling.ids import ViewId\nmovie_id = ViewId(\"mySpace\", \"MovieView\", \"v1\")\nactor_id = ViewId(\"mySpace\", \"ActorView\", \"v1\")\nquery = Query(\n    with_ = {\n        \"movies\": NodeResultSetExpression(filter=Range(movie_id.as_property_ref(\"releaseYear\"), lt=2000)),\n        \"actors_in_movie\": EdgeResultSetExpression(from_=\"movies\", filter=Equals([\"edge\", \"type\"], {\"space\": movie_id.space, \"externalId\": \"Movie.actors\"})),\n        \"actors\": NodeResultSetExpression(from_=\"actors_in_movie\"),\n    },\n    select = {\n        \"actors\": Select(\n            [SourceSelector(actor_id, [\"name\"])], sort=[InstanceSort(actor_id.as_property_ref(\"name\"))]),\n    },\n)\nres = client.data_modeling.instances.sync(query)\nquery.cursors = res.cursors\nres_new = client.data_modeling.instances.sync(query)\n"
          }
        ]
      }
    },
    "/models/instances/inspect": {
      "post": {
        "tags": [
          "Instances"
        ],
        "summary": "Inspect instances",
        "operationId": "instanceInspect",
        "requestBody": {
          "description": "Change filter specification",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstanceInspectRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DataModelsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/InstanceInspectResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import NodeId, EdgeId\nres = client.data_modeling.instances.inspect(\n    nodes=NodeId(\"my-space\", \"foo1\"),\n    edges=EdgeId(\"my-space\", \"bar2\"),\n)\n"
          }
        ]
      }
    },
    "/streams/{streamId}": {
      "get": {
        "tags": [
          "Streams"
        ],
        "summary": "Retrieve stream",
        "description": "Retrieve a stream by its identifier.\n",
        "operationId": "getStream",
        "parameters": [
          {
            "$ref": "#/components/parameters/StreamId"
          }
        ],
        "x-capability": [
          "StreamsAcl:READ"
        ],
        "responses": {
          "200": {
            "description": "Stream retrieved.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StreamResponseItem"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "delete": {
        "tags": [
          "Streams"
        ],
        "summary": "Delete stream",
        "description": "Delete a stream by its identifier, along with all records stored in the stream.\n",
        "operationId": "deleteStream",
        "parameters": [
          {
            "$ref": "#/components/parameters/StreamId"
          }
        ],
        "x-capability": [
          "StreamsAcl:DELETE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/events": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Create events",
        "description": "Creates multiple event objects in the same project.\nIt is possible to post a maximum of 1000 events per request.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "createEvents",
        "requestBody": {
          "description": "List of events to be posted. It is possible to post a maximum of 1000 events per request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataExternalEvent"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/EventDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = [\n  { description: 'Workorder pump abc', startTime: new Date('22 jan 2019') },\n  { description: 'Broken rule', externalId: 'rule123', startTime: 1557346524667000 },\n];\nconst createdEvents = await client.events.create(events);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import EventWrite\nevents = [EventWrite(start_time=0, end_time=1), EventWrite(start_time=2, end_time=3)]\nres = client.events.create(events)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Event> upsertEventsList = List.of(Event.newBuilder() \n          .setExternalId(\"10\") \n          .setStartTime(1552566113) \n          .setEndTime(1553566113) \n          .setDescription(\"generated_event_\") \n          .setType(\"generated_event\") \n          .setSubtype(\"event_sub_type\") \n          .setSource(\"sdk-data-generator\") \n          .putMetadata(\"type\", \"sdk-data-generator\") \n     .build()); \nclient.events().upsert(upsertEventsList); \n\n "
          }
        ]
      },
      "get": {
        "tags": [
          "Events"
        ],
        "summary": "List events",
        "description": "List events optionally filtered on query parameters\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "listEvents",
        "parameters": [
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "in": "query",
            "name": "minStartTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxStartTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minEndTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxEndTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minActiveAtTime",
            "schema": {
              "description": "Event is considered active from its startTime to endTime inclusive. If startTime is null, event is never active. If endTime is null, event is active from startTime onwards. activeAtTime filter will match all events that are active at some point from min to max, from min, or to max, depending on which of min and max parameters are specified.",
              "allOf": [
                {
                  "$ref": "#/components/schemas/EpochTimestamp"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "maxActiveAtTime",
            "schema": {
              "description": "Event is considered active from its startTime to endTime inclusive. If startTime is null, event is never active. If endTime is null, event is active from startTime onwards. activeAtTime filter will match all events that are active at some point from min to max, from min, or to max, depending on which of min and max parameters are specified.",
              "allOf": [
                {
                  "$ref": "#/components/schemas/EpochTimestamp"
                }
              ]
            }
          },
          {
            "in": "query",
            "name": "assetIds",
            "description": "Asset IDs of equipment that this event relates to. Format is list of IDs serialized as JSON array(int64). Takes [ 1 .. 100 ] of unique items.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "assetExternalIds",
            "description": "Asset external IDs of equipment that this event relates to. Takes 1..100 unique items.",
            "example": "[\"externalId1\", \"externalId2\", \"externalId3\"]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayString"
            }
          },
          {
            "in": "query",
            "name": "assetSubtreeIds",
            "description": "Only include events that have a related asset in a subtree rooted at any of these assetIds (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "assetSubtreeExternalIds",
            "description": "Only include events that have a related asset in a subtree rooted at any of these assetExternalIds (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": "[\"externalId1\", \"externalId2\", \"externalId3\"]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayString"
            }
          },
          {
            "in": "query",
            "name": "source",
            "schema": {
              "maxLength": 128,
              "type": "string",
              "description": "The source of this event."
            }
          },
          {
            "in": "query",
            "name": "type",
            "schema": {
              "$ref": "#/components/schemas/EventType"
            }
          },
          {
            "in": "query",
            "name": "subtype",
            "schema": {
              "$ref": "#/components/schemas/EventSubType"
            }
          },
          {
            "in": "query",
            "name": "minCreatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxCreatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minLastUpdatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxLastUpdatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "externalIdPrefix",
            "schema": {
              "$ref": "#/components/schemas/CogniteExternalIdPrefix"
            },
            "style": "form",
            "explode": false
          },
          {
            "$ref": "#/components/parameters/partitionLimited10"
          },
          {
            "$ref": "#/components/parameters/IncludeMetadata"
          },
          {
            "in": "query",
            "name": "sort",
            "description": "Sort by an array of the selected fields. Syntax: `[\"<fieldname>:asc|desc\"]`. Default sort order is `asc` with short syntax: `[\"<fieldname>\"]`.\nFilter accepts the following field names:\n  `dataSetId`,\n  `externalId`,\n  `type`,\n  `subtype`,\n  `startTime`,\n  `endTime`,\n  `createdTime`,\n  `lastUpdatedTime`,\n  `source`,\n  `description`,\n  `metadata`.\nPartitions are done independently of sorting, there's no guarantee on sort order between elements from different partitions.\n",
            "example": [
              "endTime:desc"
            ],
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EventDataWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = await client.events.list({ filter: { startTime: { min: new Date('1 jan 2018') }, endTime: { max: new Date('1 jan 2019') } } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nis_workorder = filters.Prefix(\"external_id\", \"workorder\")\nhas_failure = filters.Search(\"description\", \"failure\")\nres = client.events.filter(\n    filter=filters.And(is_workorder, has_failure), sort=(\"start_time\", \"desc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty, SortableEventProperty\nis_workorder = filters.Prefix(EventProperty.external_id, \"workorder\")\nhas_failure = filters.Search(EventProperty.description, \"failure\")\nres = client.events.filter(\n    filter=filters.And(is_workorder, has_failure),\n    sort=(SortableEventProperty.start_time, \"desc\"))\nevent_list = client.events.list(limit=5, start_time={\"max\": 1500000000})\n\nfor event in client.events:\n    event # do something with the event\n\nfor event_list in client.events(chunk_size=2500):\n    event_list # do something with the events\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.events.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty, SortableEventProperty\nin_timezone = filters.Prefix(EventProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.events.list(\n    advanced_filter=in_timezone,\n    sort=(SortableEventProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.events.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          }
        ]
      }
    },
    "/events/{id}": {
      "get": {
        "tags": [
          "Events"
        ],
        "summary": "Receive an event by its ID",
        "description": "Retrieves an event by its internal (service-generated) ID.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "getEventByInternalId",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EventResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = await client.events.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.events.retrieve(id=1)\n\nres = client.events.retrieve(external_id=\"1\")\n"
          }
        ]
      }
    },
    "/events/list": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Filter events",
        "description": "Retrieve a list of events in the same project. This operation supports pagination by cursor.\nApply Filtering and Advanced filtering criteria to select a subset of events.\n\n### Advanced filtering\nAdvanced filter lets you create complex filtering expressions that combine simple operations,\nsuch as `equals`, `prefix`, `exists`, etc., using boolean operators `and`, `or`, and `not`.\nIt applies to basic fields as well as metadata.\n\nSee the `advancedFilter` attribute in the example.\n\nSee more information about filtering DSL [here](https://docs.cognite.com/dev/concepts/resource_filtering_dsl/ \"filtering DSL\").\n\n#### Supported leaf filters\n| Leaf filter    | Supported fields       | Description  |\n|----------------|------------------------|--------------|\n| `containsAll`  | Array type fields      | Only includes results which contain all of the specified values. <br /> `{\"containsAll\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}` |\n| `containsAny`  | Array type fields      | Only includes results which contain at least one of the specified values. <br /> `{\"containsAny\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}` |\n| `equals`       | Non-array type fields  | Only includes results that are equal to the specified value. <br /> `{\"equals\": {\"property\": [\"property\"], \"value\": \"example\"}}` |\n| `exists`       | All fields             | Only includes results where the specified property exists (has value). <br /> `{\"exists\": {\"property\": [\"property\"]}}` |\n| `in`           | Non-array type fields  | Only includes results that are equal to one of the specified values. <br /> `{\"in\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}` |\n| `prefix`       | String type fields     | Only includes results which start with the specified value. <br /> `{\"prefix\": {\"property\": [\"property\"], \"value\": \"example\"}}` |\n| `range`        | Non-array type fields  | Only includes results that fall within the specified range. <br /> `{\"range\": {\"property\": [\"property\"], \"gt\": 1, \"lte\": 5}}` <br /> Supported operators: `gt`, `lt`, `gte`, `lte` |\n| `search`       | `[\"description\"]`      | Introduced to provide functional parity with /events/search endpoint. <br /> `{\"search\": {\"property\": [\"property\"], \"value\": \"example\"}}` |\n\n##### Search\nThe `search` leaf filter provides functional parity with the `/events/search` endpoint.\nIt's available only for the `[\"description\"]` field. When specifying only this filter with no explicit ordering,\nbehavior is the same as of the `/events/search/` endpoint without specifying filters.\nExplicit sorting overrides the default ordering by relevance.\nIt's possible to use the `search` leaf filter as any other leaf filter for creating complex queries.\n\nSee the `search` filter in the `advancedFilter` attribute in the example.\n\n#### advancedFilter attribute limits\n- filter query max depth: 10\n- filter query max number of clauses: 100\n- filter by metadata is case-insensitive, and it supports filtering on keys and values up to 256 characters\n- `and` and `or` clauses must have at least one element\n- `property` array of each leaf filter has the following limitations:\n  - number of elements in the array is in the range [1, 2]\n  - elements must not be blank\n  - each element max length is 128 symbols\n  - property array must match one of the existing properties (static or dynamic metadata)\n- `containsAll`, `containsAny`, and `in` filter `values` array size must be in the range [1, 100]\n- `containsAll`, `containsAny`, and `in` filter `values` array must contain elements of a primitive type (number, string)\n- `range` filter must have at least one of `gt`, `gte`, `lt`, `lte` attributes.\n  But `gt` is mutually exclusive to `gte`, while `lt` is mutually exclusive to `lte`.\n  For metadata, both upper and lower bounds must be specified.\n- `gt`, `gte`, `lt`, `lte` in the `range` filter must be a primitive value\n- `search` filter `value` must not be blank and the length must be in the range [1, 128]\n- filter query may have maximum 2 search leaf filters\n- maximum leaf filter string value length is different depending on the property the filter is using:\n  - `externalId` - 255\n  - `description` - 128 for the `search` filter and 255 for other filters\n  - `type` - 64\n  - `subtype` - 64\n  - `source` - 128\n  - any `metadata` key - 128\n\n### Sorting\nBy default, events are sorted by their creation time in the ascending order.\nUse the `search` leaf filter to sort the results by relevance.\nSorting by other fields can be explicitly requested. The `order` field is optional and defaults\nto `desc` for `_score_` and `asc` for all other fields.\nThe `nulls` field is optional and defaults to `auto`. `auto` is translated to `last`\nfor the `asc` order and to `first` for the `desc` order by the service.\nPartitions are done independently of sorting: there's no guarantee of the sort order between elements from different partitions.\n\nSee the `sort` attribute in the example.\n\n#### Null values\nIn case the `nulls` attribute has the `auto` value or the attribute isn't specified,\nnull (missing) values are considered to be bigger than any other values.\nThey are placed last when sorting in the `asc` order and first when sorting in `desc`.\nOtherwise, missing values are placed according to the `nulls` attribute (last or first), and their placement doesn't depend on the `order` value.\nValues, such as empty strings, aren't considered as nulls.\n\n#### Sorting by score\nUse a special sort property `_score_` when sorting by relevance.\nThe more filters a particular event matches, the higher its score is. This can be useful,\nfor example, when building UIs. Let's assume we want exact matches to be be displayed above matches by\nprefix as in the request below. An event with the type `fire` will match both `equals` and `prefix`\nfilters and, therefore, have higher score than events with names like `fire training` that match only the `prefix` filter.\n\n```\n\"advancedFilter\" : {\n  \"or\" : [\n    {\n      \"equals\": {\n        \"property\": [\"type\"],\n        \"value\": \"fire\"\n      }\n    },\n    {\n      \"prefix\": {\n        \"property\": [\"type\"],\n        \"value\": \"fire\"\n      }\n    }\n  ]\n},\n\"sort\": [\n  {\n    \"property\" : [\"_score_\"]\n  }\n]\n```\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "advancedListEvents",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventFilterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EventDataWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = await client.events.list({ filter: { startTime: { min: new Date('1 jan 2018') }, endTime: { max: new Date('1 jan 2019') } } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nis_workorder = filters.Prefix(\"external_id\", \"workorder\")\nhas_failure = filters.Search(\"description\", \"failure\")\nres = client.events.filter(\n    filter=filters.And(is_workorder, has_failure), sort=(\"start_time\", \"desc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty, SortableEventProperty\nis_workorder = filters.Prefix(EventProperty.external_id, \"workorder\")\nhas_failure = filters.Search(EventProperty.description, \"failure\")\nres = client.events.filter(\n    filter=filters.And(is_workorder, has_failure),\n    sort=(SortableEventProperty.start_time, \"desc\"))\nevent_list = client.events.list(limit=5, start_time={\"max\": 1500000000})\n\nfor event in client.events:\n    event # do something with the event\n\nfor event_list in client.events(chunk_size=2500):\n    event_list # do something with the events\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.events.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty, SortableEventProperty\nin_timezone = filters.Prefix(EventProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.events.list(\n    advanced_filter=in_timezone,\n    sort=(SortableEventProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.events.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Event> listEventsResults = new ArrayList<>(); \nclient.events() \n          .list() \n          .forEachRemaining(events -> listEventsResults.addAll(events)); \n\nclient.events() \n          .list(Request.create() \n               .withFilterParameter(\"source\", \"source\")) \n          .forEachRemaining(events -> listEventsResults.addAll(events)); \n\n"
          }
        ]
      }
    },
    "/events/aggregate": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Aggregate events",
        "description": "The aggregation API lets you compute aggregated results on events,\nsuch as getting the count of all Events in a project, checking\ndifferent descriptions of events in your project, etc.\n\n#### Aggregate filtering\n##### Filter (filter & advancedFilter) data for aggregates\nFilters behave the same way as for the `Filter events` endpoint.\nIn text properties, the values are aggregated in a case-insensitive manner.\n\n##### aggregateFilter to filter aggregate results\n`aggregateFilter` works similarly to `advancedFilter` but always applies to aggregate properties.\nFor instance, in an aggregation for the `source` property, only the values (aka buckets) of the `source` property can be filtered out.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\\\nThe Aggregates endpoint, as with all endpoints in the Events API,  is subject to a request budget that applies\nlimits to both request rate and concurrency.\nPlease check [Events resource description](../../) for more information.",
        "operationId": "aggregateEvents",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventAggregateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregates = await client.events.aggregate.count({ filter: { assetIds: [1, 2, 3] } });\nconsole.log('Number of events: ', aggregates[0].count)\n\nconst uniqueValues = await client.events.aggregate.uniqueValues({ filter: { assetIds: [1, 2, 3] }, fields: ['subtype'] });\nconsole.log('Unique values: ', uniqueValues)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "aggregate_type = client.events.aggregate(filter={\"type\": \"failure\"})\nfrom cognite.client.data_classes.events import EventProperty\ntype_count = client.events.aggregate_cardinality_properties(EventProperty.metadata)\nfrom cognite.client.data_classes.events import EventProperty\ntype_count = client.events.aggregate_cardinality_values(EventProperty.type)\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty\nis_asset = filters.ContainsAny(EventProperty.asset_ids, 123)\nplain_text_author_count = client.events.aggregate_cardinality_values(EventProperty.type, advanced_filter=is_asset)\ncount = client.events.aggregate_count()\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty\nis_workorder = filters.Equals(EventProperty.type, \"workorder\")\nworkorder_count = client.events.aggregate_count(advanced_filter=is_workorder)\nfrom cognite.client.data_classes.events import EventProperty\nresult = client.events.aggregate_unique_properties(EventProperty.metadata)\nprint(result.unique)\nfrom cognite.client.data_classes.events import EventProperty\nresult = client.events.aggregate_unique_values(property=EventProperty.type)\nprint(result.unique)\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.events import EventProperty\nfrom cognite.client.utils import timestamp_to_ms\nfrom datetime import datetime\nis_after_2020 = filters.Range(EventProperty.start_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.events.aggregate_unique_values(EventProperty.type, advanced_filter=is_after_2020)\nprint(result.unique)\n\nfrom cognite.client.data_classes.events import EventProperty\nfrom cognite.client.data_classes import aggregations\nagg = aggregations\nnot_planned = agg.Not(agg.Prefix(\"planned\"))\nis_after_2020 = filters.Range(EventProperty.start_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.events.aggregate_unique_values(EventProperty.type, advanced_filter=is_after_2020, aggregate_filter=not_planned)\nprint(result.unique)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Aggregate aggregateResult = \n          client.events().aggregate(Request.create().withFilterParameter(\"source\", \"source\")); \n\n"
          }
        ]
      }
    },
    "/events/byids": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Retrieve events",
        "description": "Retrieves information about events in the same project. Events\nare returned in the same order as the ids listed in the query.\n\nA maximum of 1000 event IDs may be listed per request and all of them\nmust be unique.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "byIdsEvents",
        "requestBody": {
          "description": "List of IDs of events to retrieve. Must be up to a maximum of 1000 IDs, and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventDataIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EventDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = await client.events.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.events.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.events.retrieve_multiple(external_ids=[\"abc\", \"def\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\").build()); \nList<Event> resultByExternalIds = \n          client.events().retrieve(byExternalIds);//by list of items \nList<Event> resultByExternalIds = \n           client.events().retrieve(\"10\", \"20\");//by varargs of String \n\n List<Item> byInternalIds = List.of(Item.newBuilder() \n          .setId(10).build()); \nList<Event> resultByInternalIds = \n          client.events().retrieve(byInternalIds);//by list of items \nList<Event> resultByInternalIds = \n          client.events().retrieve(10, 20);//by varargs of Long \n\n"
          }
        ]
      }
    },
    "/events/update": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Update events",
        "description": "Updates events in the same project. This operation supports\npartial updates; Fields omitted from queries will remain unchanged on\nobjects.\n\nFor primitive fields (String, Long, Int), use 'set': 'value' to update\nvalue; use 'setNull': true to set that field to null.\n\nFor the Json Array field (e.g. assetIds), use 'set': [value1, value2] to\nupdate value; use 'add': [v1, v2] to add values to current list of\nvalues; use 'remove': [v1, v2] to remove these values from current list\nof values if exists.\n\nA maximum of 1000 events can be updated per request, and all of the\nevent IDs must be unique.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "updateEvents",
        "requestBody": {
          "description": "List of changes. A maximum of 1000 events can be updated per request, and all of the event IDs must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataEventChange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EventDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = await client.events.update([{id: 123, update: {description: {set: 'New description'}}}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "event = client.events.retrieve(id=1)\nevent.description = \"New description\"\nres = client.events.update(event)\n\nfrom cognite.client.data_classes import EventUpdate\nmy_update = EventUpdate(id=1).description.set(\"New description\").metadata.add({\"key\": \"value\"})\nres = client.events.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "\nclient.events().upsert(upsertEventsList); \n\n"
          }
        ]
      }
    },
    "/events/search": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Search events",
        "description": "Fulltext search for events based on result relevance. Primarily meant\nfor human-centric use-cases, not for programs, since matching and\nordering may change over time. Additional filters can also be\nspecified. This operation doesn't support pagination.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "searchEvents",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventSearchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EventDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const events = await client.events.search({\n  filter: {\n    assetIds: [1, 2]\n  },\n  search: {\n    description: 'Pump'\n  }\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.events.search(description=\"some description\")\n"
          }
        ]
      }
    },
    "/events/delete": {
      "post": {
        "tags": [
          "Events"
        ],
        "summary": "Delete events",
        "description": "Deletes events with the given ids.\nA maximum of 1000 events can be deleted per request.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Events resource description](../../) for more information.",
        "operationId": "deleteEvents",
        "requestBody": {
          "description": "List of IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EventDataIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "429": {
            "$ref": "#/components/responses/429ErrorResponse"
          }
        },
        "x-capability": [
          "eventsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.events.delete([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.events.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\").build()); \nList<Item> resultByExternalIds = \n          client.events().delete(byExternalIds); \n\nList<Item> byInternalIds = List.of(Item.newBuilder() \n           .setId(10).build()); \nList<Item> resultByInternalIds = \n          client.events().delete(byInternalIds); \n\n"
          }
        ]
      }
    },
    "/files": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Upload file",
        "description": "Create metadata information and get an uploadUrl for a file.\n\nTo upload the file, send an HTTP PUT request to the uploadUrl from the response, with the relevant 'Content-Type' and 'Content-Length' headers.\n\nIf the uploadUrl contains the string '/v1/files/gcs_proxy/', you can make a Google Cloud Storage (GCS) resumable upload request\nas documented in https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload.\n\nThe uploadUrl expires after one week.\nAny file info entry that does not have the actual file uploaded within one week will be automatically deleted.\n\nNote: The uploadUrl from initFileUpload supports files smaller than 5 GiB.\n\nThe initMultiPartUpload and completeMultiPartUpload endpoints provides an alternative way to upload files, both small and large, up to 1 TiB in size.\nThese endpoints exposes a uniform multipart upload API for all cloud vendor environments for CDF. Optionally parallel part uploads can be used, for faster uploads.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "initFileUpload",
        "parameters": [
          {
            "in": "header",
            "name": "Origin",
            "description": "The 'Origin' header parameter is required if there is a Cross Origin issue.",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "overwrite",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "description": "If 'overwrite' is set to true, and the POST body content specifies a 'externalId' field, fields for the file found for externalId can be overwritten. The default setting is false.\n\nIf metadata is included in the request body, all of the original metadata will be overwritten.\nThe actual file will be overwritten after a successful upload with the uploadUrl from the response.\nIf there is no successful upload, the current file contents will be kept.\n\nFile-Asset mappings only change if explicitly stated in the assetIds field of the POST json body.\nDo not set assetIds in request body if you want to keep the current file-asset mappings."
          }
        ],
        "requestBody": {
          "description": "Fields to be set for the file.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalFilesMetadata"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/UploadFileMetadataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const fileContent = 'file data here'; // can also be of type ArrayBuffer, Buffer, Blob, File or any\n// automatic upload:\nconst file = await client.files.upload({name: 'examplefile.jpg', mimeType: 'image/jpeg'}, fileContent);\n\n// manual with uploadUrl:\nconst file2 = await client.files.upload({name: 'examplefile.jpg', mimeType: 'image/jpeg'});\n// then upload using the file.uploadUrl"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.files.upload(\"/path/to/file\", name=\"my_file\")\n\nres = client.files.upload(\"/path/to/file\")\n\nres = client.files.upload(\"/path/to/my/directory\")\n\nfrom cognite.client.data_classes import Label\nres = client.files.upload(\"/path/to/file\", name=\"my_file\", labels=[Label(external_id=\"WELL LOG\")])\n\nfrom cognite.client.data_classes import GeoLocation, Geometry\ngeometry = Geometry(type=\"LineString\", coordinates=[[30, 10], [10, 30], [40, 40]])\nres = client.files.upload(\"/path/to/file\", geo_location=GeoLocation(type=\"Feature\", geometry=geometry))\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Path fileAOriginal = Paths.get(\"./src/test/resources/csv-data.txt\"); \nList<FileContainer> fileContainerInput = new ArrayList<>(); \nFileMetadata fileMetadata = FileMetadata.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"test_file_.test\") \n          .setSource(\"sdk-data-generator\") \n          .putMetadata(\"type\", \"sdk-data-generator\") \n     .build(); \n\n FileContainer fileContainer = FileContainer.newBuilder() \n          .setFileMetadata(fileMetadata) \n          .setFileBinary(FileBinary.newBuilder() \n               .setBinaryUri(fileAOriginal.toUri().toString())) \n          .build(); \n fileContainerInput.add(fileContainer); \n\n List<FileMetadata> uploadFileResult = \n          client.files().upload(fileContainerInput); \n\n"
          }
        ]
      },
      "get": {
        "tags": [
          "Files"
        ],
        "summary": "List files",
        "description": "The GET /files operation can be used to return information for all files in a project.\n\nOptionally you can add one or more of the following query parameters.\nThe filter query parameters will filter the results to only include files that match all filter parameters.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "listFiles",
        "parameters": [
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Name"
          },
          {
            "in": "query",
            "name": "mimeType",
            "schema": {
              "$ref": "#/components/schemas/MimeType"
            }
          },
          {
            "in": "query",
            "name": "source",
            "schema": {
              "$ref": "#/components/schemas/FileSource"
            }
          },
          {
            "in": "query",
            "name": "assetIds",
            "schema": {
              "$ref": "#/components/schemas/AssetIds"
            }
          },
          {
            "in": "query",
            "name": "assetExternalIds",
            "description": "Asset external IDs of related equipment that this file relates to. Takes 1..100 unique items.",
            "example": "[\"externalId1\", \"externalId2\", \"externalId3\"]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayString"
            }
          },
          {
            "in": "query",
            "name": "dataSetIds",
            "schema": {
              "$ref": "#/components/schemas/DataSetIdEithers"
            }
          },
          {
            "in": "query",
            "name": "rootAssetIds",
            "description": "Only include files that have a related asset in a tree rooted at any of these root assetIds.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "assetSubtreeIds",
            "description": "Only include files that have a related asset in a subtree rooted at any of these assetIds (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "assetSubtreeExternalIds",
            "description": "Only include files that have a related asset in a subtree rooted at any of these assetExternalIds (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": "[\"externalId1\", \"externalId2\", \"externalId3\"]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayString"
            }
          },
          {
            "in": "query",
            "name": "minCreatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxCreatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minLastUpdatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxLastUpdatedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minUploadedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxUploadedTime",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minSourceCreatedTime",
            "description": "Include files that have sourceCreatedTime set and with minimum this value.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxSourceCreatedTime",
            "description": "Include files that have sourceCreatedTime set and with maximum this value.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "minSourceModifiedTime",
            "description": "Include files that have sourceModifiedTime set and with minimum this value.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "maxSourceModifiedTime",
            "description": "Include files that have sourceModifiedTime set and with maximum this value.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "in": "query",
            "name": "externalIdPrefix",
            "schema": {
              "$ref": "#/components/schemas/CogniteExternalIdPrefix"
            },
            "style": "form",
            "explode": false
          },
          {
            "in": "query",
            "name": "uploaded",
            "description": "Whether or not the actual file is uploaded. This field is returned only by the API, it has no effect in a post body.",
            "schema": {
              "type": "boolean"
            },
            "example": true
          },
          {
            "$ref": "#/components/parameters/partitionLimited10"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FileMetadataWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const files = await client.files.list({filter: {mimeType: 'image/png'}});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "file_list = client.files.list(limit=5, external_id_prefix=\"prefix\")\n\nfor file_metadata in client.files:\n    file_metadata # do something with the file metadata\n\nfor file_list in client.files(chunk_size=2500):\n    file_list # do something with the files\n\nfrom cognite.client.data_classes import LabelFilter\nmy_label_filter = LabelFilter(contains_all=[\"WELL LOG\", \"VERIFIED\"])\nfile_list = client.files.list(labels=my_label_filter)\n\nfrom cognite.client.data_classes import GeoLocationFilter, GeometryFilter\nmy_geo_location_filter = GeoLocationFilter(relation=\"intersects\", shape=GeometryFilter(type=\"Point\", coordinates=[35,10]))\nfile_list = client.files.list(geo_location=my_geo_location_filter)\n"
          }
        ]
      }
    },
    "/files/initmultipartupload": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Upload multipart file",
        "description": "Multipart file upload enables upload of files larger than 5 GiB, using a uniform API on all cloud environments for CDF.\n\nEach file part must be larger than 5 MiB, and smaller than 4000 MiB. The file part for the last uploadURL can be smaller than 5 MiB. Maximum 250 upload URLs can be requested.\nThe supported maximum size for each file uploaded with the multi-part upload API is therefore 1000 GiB (1.073 TB / 0.976 TiB).\nThe client should calculate the ideal number of parts depending on predetermined or estimated file size, between 1 and the maximum.\nSpecify the number of parts in the `parts` URL query parameter. The `parts` parameter is required.\n\nThe request creates metadata information for a new file, and returns in addition to the file `id`, also a `uploadId`, and a list of `uploadUrls` for uploading the file contents.\nTo upload a file, send an HTTP PUT request to each of the uploadUrls, with the corresponding part of the file in the request body.\nYou may use a 'Content-Length' header in the PUT request for each part, but this is not required.\nA failed part PUT upload can be retried.\n\nThe client must ensure that the parts of the source file are stored in the correct order, using the order of the `uploadUrls` as specified in the response.\nThis to avoid ending up with a corrupt final file.\n\nThe parts can optionally be uploaded in parallel, preferably on a subset of parts at a time, for example maximum 3 concurrent PUT operations.\n\nOnce all file parts have been uploaded, the client should call the 'files/completemultipartupload' endpoint,\nwith the required file ID (as `id` or `externalId`) and `uploadId` fields in the request body. This will assemble the parts into one file.\nThe file's `uploaded` flag will then eventually be set to `true`.\n\nA standard sequence of calls to upload a large file with multipart upload would be for example as follows:\n1. POST files/initmultipartupload?parts=8, to start a multipart upload session with 8 parts. Expect a 201 CREATED response code, and a response body with information to be used in the part uploads and completemultipartupload requests.\n2. PUT `uploadUrl`, for each of the `uploadUrls` in the response from files/initmultipartupload. Expect a 200 OK or 201 CREATED response for each PUT request.\n3. POST files/completemultipartupload, with request body '{ \"id\":123456789, \"uploadId\":\"ABCD4321EFGH\" }'. This will assemble the file. Expect a 200 OK response.\n\nConsider verifying that the file is eventually marked as uploaded with a call to the getFileByInternalId endpoint.\n\nNOTE: The uploadUrls expires after one week.\nA file that does not have the file content parts uploaded and completed within one week will be automatically deleted.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "initMultiPartUpload",
        "parameters": [
          {
            "in": "query",
            "name": "overwrite",
            "schema": {
              "type": "boolean",
              "default": false
            },
            "description": "If 'overwrite' is set to true, and the POST body content specifies a 'externalId' field, fields for the file found for externalId can be overwritten. The default setting is false.\n\nIf metadata is included in the request body, all of the original metadata will be overwritten.\nThe actual file will be overwritten after a successful upload with the uploadUrls from the response.\nIf there is no successful upload, the current file contents will be kept.\n\nFile-Asset mappings only change if explicitly stated in the assetIds field of the POST json body.\nDo not set assetIds in request body if you want to keep the current file-asset mappings."
          },
          {
            "in": "query",
            "name": "parts",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 250
            },
            "description": "The 'parts' parameter specifies how many uploadURLs should be returned, for uploading the file contents in parts. See main endpoint description for more details."
          }
        ],
        "requestBody": {
          "description": "Fields to be set for the file.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalFilesMetadata"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/MultiPartUploadFileMetadataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:WRITE"
        ]
      }
    },
    "/files/uploadlink": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Get upload file link",
        "description": "Get an uploadUrl for a file.\n\nTo upload the file, send an HTTP PUT request to the uploadUrl from the response, with the relevant 'Content-Type' and 'Content-Length' headers.\n\nIf the uploadUrl contains the string '/v1/files/gcs_proxy/', you can make a Google Cloud Storage (GCS) resumable upload request\nas documented in https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload.\n\nThe uploadUrl expires after one week.\nAny file info entry that does not have the actual file uploaded within one week will be automatically deleted.\n\nNote: The uploadUrl from getUploadLink supports files smaller than 5 GiB.\n\nThe getMultiPartUploadLink and completeMultiPartUpload endpoints provides an alternative way to upload files, both small and large, up to 1 TiB in size.\nThese endpoints exposes a uniform multipart upload API for all cloud vendor environments for CDF. Optionally parallel part uploads can be used, for faster uploads.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "getUploadLink",
        "parameters": [
          {
            "in": "header",
            "name": "Origin",
            "description": "The 'Origin' header parameter is required if there is a Cross Origin issue.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Fields to be set for the file.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileDataUploadIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/UploadFileMetadataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/files/multiuploadlink": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Get multipart file upload link",
        "description": "Multipart file upload enables upload of files larger than 5 GiB, using a uniform API on all cloud environments for CDF.\n\nEach file part must be larger than 5 MiB, and smaller than 4000 MiB. The file part for the last uploadURL can be smaller than 5 MiB. Maximum 250 upload URLs can be requested.\nThe supported maximum size for each file uploaded with the multi-part upload API is therefore 1000 GiB (1.073 TB / 0.976 TiB).\nThe client should calculate the ideal number of parts depending on predetermined or estimated file size, between 1 and the maximum.\nSpecify the number of parts in the `parts` URL query parameter. The `parts` parameter is required.\n\nThe request returns in addition to the file `id`, also a `uploadId`, and a list of `uploadUrls` for uploading the file contents.\nTo upload a file, send an HTTP PUT request to each of the uploadUrls, with the corresponding part of the file in the request body.\nYou may use a 'Content-Length' header in the PUT request for each part, but this is not required.\nA failed part PUT upload can be retried.\n\nThe client must ensure that the parts of the source file are stored in the correct order, using the order of the `uploadUrls` as specified in the response.\nThis to avoid ending up with a corrupt final file.\n\nThe parts can optionally be uploaded in parallel, preferably on a subset of parts at a time, for example maximum 3 concurrent PUT operations.\n\nOnce all file parts have been uploaded, the client should call the 'files/completemultipartupload' endpoint,\nwith the required file ID (as `id` or `externalId`) and `uploadId` fields in the request body. This will assemble the parts into one file.\nThe file's `uploaded` flag will then eventually be set to `true`.\n\nA standard sequence of calls to upload a large file with multipart upload would be for example as follows:\n1. POST files/initmultipartupload?parts=8, to start a multipart upload session with 8 parts. Expect a 201 CREATED response code, and a response body with information to be used in the part uploads and completemultipartupload requests.\n2. PUT `uploadUrl`, for each of the `uploadUrls` in the response from files/initmultipartupload. Expect a 200 OK or 201 CREATED response for each PUT request.\n3. POST files/completemultipartupload, with request body '{ \"id\":123456789, \"uploadId\":\"ABCD4321EFGH\" }'. This will assemble the file. Expect a 200 OK response.\n\nConsider verifying that the file is eventually marked as uploaded with a call to the getFileByInternalId endpoint.\n\nNOTE: The uploadUrls expires after one week.\nA file that does not have the file content parts uploaded and completed within one week will be automatically deleted.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "getMultiPartUploadLink",
        "parameters": [
          {
            "in": "query",
            "name": "parts",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 250
            },
            "description": "The 'parts' parameter specifies how many uploadURLs should be returned, for uploading the file contents in parts. See main endpoint description for more details."
          }
        ],
        "requestBody": {
          "description": "Fields to be set for the file.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileDataUploadIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/MultiPartUploadFileMetadataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/files/{id}": {
      "get": {
        "tags": [
          "Files"
        ],
        "summary": "Retrieve a file by its ID",
        "description": "Returns file info for the file ID\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "getFileByInternalId",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FileMetadataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const files = await client.files.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.files.retrieve(id=1)\n\nres = client.files.retrieve(external_id=\"1\")\n"
          }
        ]
      }
    },
    "/files/list": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Filter files",
        "description": "Retrieves a list of all files in a project. Criteria can be supplied to\nselect a subset of files. This operation supports pagination with cursors.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "advancedListFiles",
        "requestBody": {
          "description": "The project name",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileFilterRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FileMetadataWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const files = await client.files.list({filter: {mimeType: 'image/png'}});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "file_list = client.files.list(limit=5, external_id_prefix=\"prefix\")\n\nfor file_metadata in client.files:\n    file_metadata # do something with the file metadata\n\nfor file_list in client.files(chunk_size=2500):\n    file_list # do something with the files\n\nfrom cognite.client.data_classes import LabelFilter\nmy_label_filter = LabelFilter(contains_all=[\"WELL LOG\", \"VERIFIED\"])\nfile_list = client.files.list(labels=my_label_filter)\n\nfrom cognite.client.data_classes import GeoLocationFilter, GeometryFilter\nmy_geo_location_filter = GeoLocationFilter(relation=\"intersects\", shape=GeometryFilter(type=\"Point\", coordinates=[35,10]))\nfile_list = client.files.list(geo_location=my_geo_location_filter)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<FileMetadata> listFilesResults = new ArrayList<>(); \nclient.files() \n          .list() \n          .forEachRemaining(files -> listFilesResults.addAll(files)); \n\nclient.files() \n          .list(Request.create() \n                .withFilterParameter(\"source\", \"sourceValue\")) \n          .forEachRemaining(files -> listFilesResults.addAll(files)); \n\n"
          }
        ]
      }
    },
    "/files/byids": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Retrieve files",
        "description": "Retrieves metadata information about multiple specific files in the same project.\nResults are returned in the same order as in the request. This operation does not return the file contents.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "byIdsFiles",
        "requestBody": {
          "description": "List of IDs of files to retrieve. Must be up to a maximum of 1000 IDs, and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileDataIdsWithIgnoreUnknownIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FileResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const files = await client.files.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.files.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.files.retrieve_multiple(external_ids=[\"abc\", \"def\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<FileMetadata> retrievedFilesByExternalIds = client.files().retrieve(\"10\");//by varargs of String \nList<Item> itemsExternalId = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<FileMetadata> resultsExternal = client.files().retrieve(itemsExternalId);//by list of items \n\nList<FileMetadata> retrievedFilesByInternalIds = client.files().retrieve(10, 20);//by varargs of Long \nList<Item> itemsInternalId = List.of(Item.newBuilder().setId(10).build()); \nList<FileMetadata> resultsInternal = client.files().retrieve(itemsInternalId);//by list of items \n\n"
          }
        ]
      }
    },
    "/files/search": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Search files",
        "description": "Search for files based on relevance.\nYou can also supply a strict match filter as in Filter files, and search in the results from the filter.\nReturns first 1000 results based on relevance. This operation does not support pagination.\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "searchFiles",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilesSearchFilter"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FileResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const files = await client.files.search({\n  filter: {\n    mimeType: 'image/jpeg',\n  },\n  search: {\n    name: 'Pump'\n  }\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.files.search(name=\"some name\")\n\nmy_label_filter = LabelFilter(contains_all=[\"WELL LOG\"])\nres = client.assets.search(name=\"xyz\",filter=FileMetadataFilter(labels=my_label_filter))\n"
          }
        ]
      }
    },
    "/files/delete": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Delete files",
        "description": "Deletes the files with the given ids.\n\nA maximum of 1000 files can be deleted per request.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "deleteFiles",
        "requestBody": {
          "description": "List of IDs of files to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileDeleteByIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.files.delete([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.files.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\").build()); \nList<Item> deleteItemsResults = client.files().delete(deleteByExternalIds); \n\nList<Item> deleteByInternalIds = List.of(Item.newBuilder() \n          .setId(10).build()); \nList<Item> deleteItemsResults = client.files().delete(deleteByInternalIds); \n\n"
          }
        ]
      }
    },
    "/files/downloadlink": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Download files",
        "description": "Retrieves a list of download URLs for the specified list of file IDs.\nAfter getting the download links, the client has to issue a GET request to the returned URLs,\nwhich will respond with the contents of the file. The links will by default expire after 30 seconds.\nIf providing the query parameter extendedExpiration the links will expire after 1 hour.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "downloadLinks",
        "parameters": [
          {
            "in": "query",
            "name": "extendedExpiration",
            "schema": {
              "type": "boolean",
              "default": false,
              "description": "if set to true, will extend the expiration period of the link to 1 hour."
            }
          }
        ],
        "requestBody": {
          "description": "List of file IDs to retrieve the download URL for.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileLinkIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataWithLinks"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.files.getDownloadUrls([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.files.download(directory=\"my_directory\", id=[1,2,3], external_id=[\"abc\", \"def\"])\n\nclient.files.download(directory=\".\", id=[1,2,3])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> downloadByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\").build()); \nList<FileContainer> downloadFilesResults = \n          client.files().downloadToPath(downloadByExternalIds, Paths.get(\"\")); \n\nList<Item> downloadByInternallIds = List.of(Item.newBuilder() \n          .setId(10).build()); \nList<FileContainer> downloadFilesResults = \n          client.files().downloadToPath(downloadByInternallIds, Paths.get(\"\")); \n\n"
          }
        ]
      }
    },
    "/files/icon": {
      "get": {
        "tags": [
          "Files"
        ],
        "summary": "Get icon",
        "description": "The GET /files/icon operation can be used to get an image representation of a file.\n\nEither id or externalId must be provided as a query parameter (but not both).\nSupported file formats:\n- Normal jpeg and png files are currently fully supported.\n- Other image file formats might work, but continued support for these are not guaranteed.\n- Currently only supporting thumbnails for image files.\nAttempts to get icon for unsupported files will result in status 400.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "getIcon",
        "parameters": [
          {
            "in": "query",
            "name": "id",
            "schema": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          {
            "in": "query",
            "name": "externalId",
            "schema": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          },
          {
            "in": "query",
            "name": "space",
            "schema": {
              "$ref": "#/components/schemas/InstanceSpace"
            }
          },
          {
            "in": "query",
            "name": "instanceExternalId",
            "schema": {
              "$ref": "#/components/schemas/InstanceExternalId"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Thumbnail image (JPEG)",
            "content": {
              "image/jpeg": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/files/update": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Update files",
        "description": "Updates the information for the files specified in the request body.\n\nIf you want to update the file content, uploaded using the uploadUrl, please\nuse the initFileUpload request with the query parameter 'overwrite=true'.\nAlternatively, delete and recreate the file.\n\nFor primitive fields (String, Long, Int), use 'set': 'value' to update\nvalue; use 'setNull': true to set that field to null.\n\nFor the Json Array field (e.g. assetIds and securityCategories): Use either only 'set', or a combination of 'add' and/or 'remove'.\n\n__AssetIds update examples__:\n\nExample request body to overwrite assetIds with a new set, asset ID 1 and 2.\n\n```\n{\n  \"items\": [\n    {\n      \"id\": 1,\n      \"update\": {\n        \"assetIds\" : {\n          \"set\" : [ 1, 2 ]\n        }\n      }\n    }\n  ]\n}\n```\n\nExample request body to add one asset Id, and remove another asset ID.\n\n```\n{\n  \"items\": [\n    {\n      \"id\": 1,\n      \"update\": {\n        \"assetIds\" : {\n          \"add\" : [ 3 ],\n          \"remove\": [ 2 ]\n        }\n      }\n    }\n  ]\n}\n```\n\n__Metadata update examples__:\n\nExample request body to overwrite metadata with a new set.\n```\n{\n  \"items\": [\n    {\n      \"id\": 1,\n      \"update\": {\n        \"metadata\": {\n          \"set\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n          }\n        }\n      }\n    }\n  ]\n}\n```\n\nExample request body to add two key-value pairs and remove two other key-value pairs by key for\nthe metadata field.\n```\n{\n  \"items\": [\n    {\n      \"id\": 1,\n      \"update\": {\n        \"metadata\": {\n          \"add\": {\n            \"key3\": \"value3\",\n            \"key4\": \"value4\"\n          },\n          \"remove\": [\n            \"key1\",\n            \"key2\"\n          ]\n        }\n      }\n    }\n  ]\n}\n```\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "updateFiles",
        "requestBody": {
          "description": "The JSON request body which specifies which files and fields to update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataFileChange"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FileResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const files = await client.files.update([{\n  id: 123,\n  update: {\n    source: { set: 'new source' }\n  }\n}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "file_metadata = client.files.retrieve(id=1)\nfile_metadata.description = \"New description\"\nres = client.files.update(file_metadata)\n\nfrom cognite.client.data_classes import FileMetadataUpdate\nmy_update = FileMetadataUpdate(id=1).source.set(\"new source\").metadata.add({\"key\": \"value\"})\nres = client.files.update(my_update)\n\nfrom cognite.client.data_classes import FileMetadataUpdate\nmy_update = FileMetadataUpdate(id=1).labels.add([\"PUMP\", \"VERIFIED\"])\nres = client.files.update(my_update)\n\nfrom cognite.client.data_classes import FileMetadataUpdate\nmy_update = FileMetadataUpdate(id=1).labels.remove(\"PUMP\")\nres = client.files.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<FileMetadata> editFilesInput = listFilesResults.stream() \n .map(fileMetadata -> fileMetadata.toBuilder() \n .putMetadata(\"addedField\", \"new field value\") \n .build()) \n .collect(Collectors.toList()); \n\n List<FileMetadata> editFilesResult = \n          client.files().upsert(editFilesInput); \n\n"
          }
        ]
      }
    },
    "/files/aggregate": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Aggregate files",
        "description": "Calculate aggregates for files, based on optional filter specification.\nReturns the following aggregates: `count`\n\n### Request throttling\nThis endpoint is meant for data analytics/exploration usage and is not suitable for high load data retrieval usage.\nIt is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "aggregateFiles",
        "requestBody": {
          "description": "Files aggregate request body",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileFilter"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FilesAggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregates = await client.files.aggregate({ filter: { uploaded: true } });\nconsole.log('Number of uploaded files: ', aggregates[0].count)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "aggregate_uploaded = client.files.aggregate(filter={\"uploaded\": True})\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Aggregate fileAggregate = \n          client.files().aggregate(Request.create() \n          .withFilterParameter(\"source\", \"source\")); \n\n"
          }
        ]
      }
    },
    "/files/completemultipartupload": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Complete multipart upload",
        "description": "Completes a multipart file upload.\nThis endpoint must be called by the client when an 'initMultiPartUpload' operation (POST /files/initmultipartupload) was called,\nand all file content parts have been successfully uploaded using PUT for all upload URLs.\nEither `id` or `externalId` must be specified in the request body, but not both. The `uploadId` is also required.\nThe values for these properties can be retrieved from the response of the initMultiPartUpload operation.\n\n### Request throttling\nThis endpoint is a subject of the new throttling schema (limited request rate and concurrency).\nPlease check [Files resource description](../../) for more information.",
        "operationId": "completeMultiPartUpload",
        "requestBody": {
          "required": true,
          "description": "The JSON request body which specifies which file id/externalId and uploadId to complete the multipart upload for.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompleteMultiPartUpload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:WRITE"
        ]
      }
    },
    "/functions": {
      "get": {
        "tags": [
          "Functions"
        ],
        "summary": "List functions",
        "operationId": "getFunctions",
        "parameters": [
          {
            "$ref": "#/components/parameters/LimitQuery"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "List functions.",
        "x-capability": [
          "functionsAcl:READ"
        ]
      },
      "post": {
        "summary": "Create functions",
        "operationId": "postFunctions",
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "You can only create one function per request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "description": "Array of functions to create.",
                    "maxItems": 1,
                    "minItems": 1,
                    "items": {
                      "$ref": "#/components/schemas/Function"
                    }
                  }
                },
                "required": [
                  "items"
                ]
              },
              "examples": {
                "Minimal function": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343
                      }
                    ]
                  }
                },
                "With secrets": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "fileId": 5467347282343,
                        "secrets": {
                          "key1": "secret1",
                          "key2": "secret2"
                        }
                      }
                    ]
                  }
                },
                "Full example": {
                  "value": {
                    "items": [
                      {
                        "name": "My awesome function",
                        "description": "This function does some things",
                        "owner": "user@cognite.com",
                        "fileId": 5467347282343,
                        "externalId": "my-function",
                        "metadata": {
                          "key1": "value1",
                          "key2": "value2"
                        },
                        "secrets": {
                          "key1": "secret1",
                          "key2": "secret2"
                        },
                        "functionPath": "myfunction/handler.py",
                        "envVars": {
                          "ENV_VAR": "value"
                        },
                        "cpu": 0.2,
                        "memory": 0.4,
                        "runtime": "py38",
                        "indexUrl": "https://pypi.org",
                        "extraIndexUrls": [
                          "https://user:password@some.index.org"
                        ]
                      }
                    ]
                  }
                }
              }
            }
          },
          "description": ""
        },
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "function = client.functions.create(\n    name=\"myfunction\",\n    folder=\"path/to/code\",\n    function_path=\"path/to/function.py\")\n\nfunction = client.functions.create(\n    name=\"myfunction\", file_id=123, function_path=\"path/to/function.py\")\n\nfunction = client.functions.create(name=\"myfunction\", function_handle=handle)\n\ndef handle(client, data):\n    \"\"\"\n    [requirements]\n    numpy\n    [/requirements]\n    \"\"\"\n    pass\nfunction = client.functions.create(name=\"myfunction\", function_handle=handle)\n"
          }
        ]
      }
    },
    "/functions/limits": {
      "get": {
        "tags": [
          "Functions"
        ],
        "summary": "Functions limits",
        "description": "Service limits for the associated project.",
        "operationId": "functionsLimits",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionsLimits"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "limits = client.functions.limits()\n"
          }
        ]
      }
    },
    "/functions/list": {
      "post": {
        "summary": "Filter functions",
        "operationId": "listFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find functions.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionListScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "status": "Queued",
                      "createdTime": {
                        "min": 10,
                        "max": 199
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Functions"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "functions_list = client.functions.list()\n"
          }
        ]
      }
    },
    "/functions/delete": {
      "post": {
        "summary": "Delete functions",
        "operationId": "deleteFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Delete functions. You can delete a maximum of 10 functions per request. Function source files stored in the Files API must be deleted separately.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionDeleteRequest"
              }
            }
          }
        },
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.functions.delete(id=[1,2,3], external_id=\"function3\")\n"
          }
        ]
      }
    },
    "/functions/{functionId}/call": {
      "parameters": [
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "summary": "Call a function asynchronously",
        "operationId": "postFunctionsCall",
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionCalled"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Perform a function call. To provide input data to the function, add the data in an object called `data` in the request body. It will be available as the `data` argument into the function. Info about the function call at runtime can be obtained through the `function_call_info` argument if added in the function handle. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionCallRequest"
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "call = client.functions.call(id=1)\n\nfunc = client.functions.retrieve(id=1)\ncall = func.call()\n"
          }
        ]
      }
    },
    "/functions/{functionId}/calls": {
      "parameters": [
        {
          "$ref": "#/components/parameters/functionId"
        },
        {
          "$ref": "#/components/parameters/LimitQuery"
        },
        {
          "$ref": "#/components/parameters/Cursor"
        }
      ],
      "get": {
        "summary": "List function calls",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallListWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionCalls",
        "description": "List function calls.",
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "logs = client.functions.calls.get_logs(call_id=2, function_id=1)\n\ncall = client.functions.calls.retrieve(call_id=2, function_id=1)\nlogs = call.get_logs()\n"
          }
        ]
      }
    },
    "/functions/{functionId}/calls/byids": {
      "parameters": [
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "summary": "Retrieve calls",
        "requestBody": {
          "description": "List of IDs of calls to retrieve. Must be up to a maximum of 10000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FunctionCallIds"
                  },
                  {
                    "$ref": "#/components/schemas/IgnoreUnknownIdsField"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "byIdsFunctionCalls",
        "description": "Retrieve function calls by call ids.",
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "call = client.functions.calls.retrieve(call_id=2, function_id=1)\n\nfunc = client.functions.retrieve(id=1)\ncall = func.retrieve_call(id=2)\n"
          }
        ]
      }
    },
    "/functions/{functionId}/calls/{callId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "operationId": "getFunctionCall",
        "description": "Retrieve function calls.",
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve a function call by its id",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionCall"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/functions/{functionId}/calls/{callId}/logs": {
      "parameters": [
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "tags": [
          "Function calls"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve logs for function call",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallLog"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionCallLogs",
        "description": "Get logs from a function call."
      }
    },
    "/functions/{functionId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "operationId": "getFunction",
        "description": "Retrieve a function by its id. If you want to retrieve functions by names, use Retrieve functions instead.",
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve a function by its id",
        "tags": [
          "Functions"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Function"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/functions/byids": {
      "post": {
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "description": "Retrieve functions by ids.",
        "summary": "Retrieve functions",
        "operationId": "byIdsFunctions",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionIdEitherList"
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.functions.retrieve(id=1)\n\nres = client.functions.retrieve(external_id=\"abc\")\nres = client.functions.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.functions.retrieve_multiple(external_ids=[\"func1\", \"func2\"])\n"
          }
        ]
      }
    },
    "/functions/status": {
      "post": {
        "summary": "Activate Functions",
        "responses": {
          "202": {
            "$ref": "#/components/responses/FunctionsActivation"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "postFunctionsStatus",
        "description": "Activate Cognite Functions. This will create the necessary backend infrastructure for Cognite Functions.",
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "status = client.functions.activate()\n"
          }
        ]
      },
      "get": {
        "summary": "Get activation status",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionsActivation"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionsStatus",
        "description": "Get activation status",
        "tags": [
          "Functions"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "status = client.functions.status()\n"
          }
        ]
      }
    },
    "/functions/schedules": {
      "get": {
        "parameters": [
          {
            "$ref": "#/components/parameters/LimitQuery"
          }
        ],
        "operationId": "getFunctionSchedules",
        "description": "List function schedules in project.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "List schedules",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "description": "Create function schedules. Function schedules trigger asynchronous calls with specific input data, based on a cron expression that determines when these triggers should be fired. Use e.g. http://www.cronmaker.com to be guided on how to generate a cron expression. One of `FunctionId` or `FunctionExternalId` (deprecated) must be set (but not both). When creating a schedule with a session, i.e. with a `nonce`, `FunctionId` must be used. The `nonce` will be used to bind the session before function execution, and the session will be kept alive for the lifetime of the schedule. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "summary": "Create schedules",
        "operationId": "postFunctionSchedules",
        "responses": {
          "201": {
            "$ref": "#/components/responses/FunctionScheduleCreated"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1,
                    "minItems": 1,
                    "items": {
                      "$ref": "#/components/schemas/FunctionSchedule"
                    }
                  }
                }
              }
            }
          },
          "description": ""
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "import os\nfrom cognite.client.data_classes import ClientCredentials\nschedule = client.functions.schedules.create(\n    name=\"My schedule\",\n    function_id=123,\n    cron_expression=\"*/5 * * * *\",\n    client_credentials=ClientCredentials(\"my-client-id\", os.environ[\"MY_CLIENT_SECRET\"]),\n    description=\"This schedule does magic stuff.\",\n    data={\"magic\": \"stuff\"},\n)\n\nschedule = client.functions.schedules.create(\n    name=\"My schedule\",\n    function_id=456,\n    cron_expression=\"*/5 * * * *\",\n    description=\"A schedule just used for some temporary testing.\",\n)\n"
          }
        ]
      }
    },
    "/functions/schedules/list": {
      "post": {
        "summary": "Filter function schedules",
        "operationId": "listFunctionSchedules",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find function schedules.  At most one of `FunctionId` or `FunctionExternalId` can be specified.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionScheduleScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "name": "MySchedule",
                      "cronExpression": "5 4 * * *"
                    }
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Function schedules"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "schedules = client.functions.schedules.list()\n\nfunc = client.functions.retrieve(id=1)\nschedules = func.list_schedules(limit=None)\n"
          }
        ]
      }
    },
    "/functions/schedules/{scheduleId}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/scheduleId"
        }
      ],
      "get": {
        "operationId": "getFunctionSchedule",
        "description": "Retrieve a function schedule by its id.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "summary": "Retrieve a function schedule by its id",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FunctionSchedule"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/functions/schedules/byids": {
      "post": {
        "summary": "Retrieve schedules",
        "requestBody": {
          "description": "List of IDs of schedules to retrieve. Must be up to a maximum of 10000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FunctionScheduleIds"
                  },
                  {
                    "$ref": "#/components/schemas/IgnoreUnknownIdsField"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleList"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "byIdsFunctionSchedules",
        "description": "Retrieve function schedules by schedule ids.",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.functions.schedules.retrieve(id=1)\n"
          }
        ]
      }
    },
    "/functions/schedules/delete": {
      "post": {
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:WRITE"
        ],
        "summary": "Delete schedules",
        "operationId": "deleteFunctionSchedules",
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Delete function schedules.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionScheduleIdArray"
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.functions.schedules.delete(id = 123)\n"
          }
        ]
      }
    },
    "/functions/schedules/{scheduleId}/input_data": {
      "parameters": [
        {
          "$ref": "#/components/parameters/scheduleId"
        }
      ],
      "get": {
        "operationId": "getFunctionScheduleInputData",
        "description": "Retrieve the input data to the associated function.",
        "summary": "Retrieve function input data",
        "tags": [
          "Function schedules"
        ],
        "x-capability": [
          "functionsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionScheduleDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.functions.schedules.get_input_data(id=123)\n"
          }
        ]
      }
    },
    "/functions/{functionId}/calls/{callId}/response": {
      "parameters": [
        {
          "$ref": "#/components/parameters/callId"
        },
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "get": {
        "summary": "Retrieve response for function call",
        "tags": [
          "Function calls"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "operationId": "getFunctionCallResponse",
        "parameters": [],
        "description": "Retrieve response from a function call.",
        "x-capability": [
          "functionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "response = client.functions.calls.get_response(call_id=2, function_id=1)\n\ncall = client.functions.calls.retrieve(call_id=2, function_id=1)\nresponse = call.get_response()\n"
          }
        ]
      }
    },
    "/functions/{functionId}/calls/list": {
      "parameters": [
        {
          "$ref": "#/components/parameters/functionId"
        }
      ],
      "post": {
        "summary": "Filter function calls",
        "operationId": "listFunctionCalls",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FunctionCallListWithCursor"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "description": "Use advanced filtering options to find function calls.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FunctionCallListScope"
              },
              "examples": {
                "Filter by status": {
                  "value": {
                    "filter": {
                      "status": "Running",
                      "scheduleId": 123,
                      "startTime": {
                        "min": 1234,
                        "max": 5678
                      }
                    },
                    "limit": 10
                  }
                }
              }
            }
          }
        },
        "tags": [
          "Function calls"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "calls = client.functions.calls.list(function_id=1)\n\nfunc = client.functions.retrieve(id=1)\ncalls = func.list_calls()\n"
          }
        ]
      }
    },
    "/3d/files/{threedFileId}": {
      "get": {
        "tags": [
          "3D Files"
        ],
        "summary": "Retrieve a single 3D file",
        "description": "Retrieve the contents of a 3D file. This applies to the output types 'ciff-processed', 'ciff-partially-processed' and 'node-property-metadata-json'.\n\nThis endpoint supports tag-based caching.\n\nThis endpoint is only compatible with 3D file IDs from the 3D API, and not compatible with\nfile IDs from the Files API.",
        "operationId": "get3DFile",
        "parameters": [
          {
            "name": "threedFileId",
            "in": "path",
            "description": "The ID of the 3D file to retrieve.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string",
                  "description": "The raw contents of the file.",
                  "format": "binary"
                }
              }
            },
            "headers": {
              "Content-Type": {
                "schema": {
                  "type": "string"
                },
                "description": "The media type of the file."
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.files3D.retrieve(3744350296805509);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.files.retrieve(1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "client.threeD().files().downloadToPath(1L, Paths.get(\"\")); \n\n"
          }
        ]
      }
    },
    "/3d/files/{threedFileId}/{subPath}": {
      "get": {
        "tags": [
          "3D Files"
        ],
        "summary": "Retrieve a 3D directory file",
        "description": "Retrieve the contents of a 3D file, for a blobId which is of a directory type.\nThis applies to the output types 'gltf-directory', 'reveal-directory', 'ept-pointcloud', 'tiles-directory', 'model-from-points'.\n\nThe 'subPath' elements, i.e. directory and/or file names, within each directory output type is subject to change and depends on each output type.\n- The 'gltf-directory' output is used by Reveal v3+ for visualizing CAD files and contains a 'scene.json' file, which describes what other files are available within the blobId.\n- The 'reveal-directory' output is used by Reveal v1-2 for visualizing CAD files and contains a 'scene.json' file, which describes what other files are available within the blobId.\n- The 'ept-pointcloud' output is used by Reveal for visualizing point clouds, and contains a 'ept.json' file. The 'ept.json' file contains general information for the point cloud data. The file named 'ept-hierarchy/0-0-0-0.json' for the same blobId lists all the output point files which can be retrieved from a 'ept-data' folder for the same blobId, e.g. 'ept-data/0-0-0-0.bin'. The '.bin' files are in a custom point cloud format following the schema in the 'ept.json' file. Additionally, a 'filterOptions.json' file contains a description of which options were used when processing the point cloud.\n\nExperimental outputs, normally not enabled:\nThe 'tiles-directory' output contains files for classification of the point cloud data. Retrieve the 'tiles.json' file from this output for a overview of the files within this output.\nThe 'model-from-points' output is used for storing a mesh based output file of some parts of the point cloud. This is stored as a 'model.ciff' file, in the Cognite internal file format.\n\nThis endpoint supports tag-based caching.\n\nThis endpoint is only compatible with 3D file IDs from the 3D API, and not compatible with\nfile IDs from the Files API.",
        "operationId": "get3DDirectoryFile",
        "parameters": [
          {
            "name": "threedFileId",
            "in": "path",
            "description": "The blob ID of the 3D output directory.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "subPath",
            "in": "path",
            "description": "The filename for the 3D file to retrieve.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "*/*": {
                "schema": {
                  "type": "string",
                  "description": "The raw contents of the file.",
                  "format": "binary"
                }
              }
            },
            "headers": {
              "Content-Type": {
                "schema": {
                  "type": "string"
                },
                "description": "The media type of the file."
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/3d/models": {
      "get": {
        "tags": [
          "3D Models"
        ],
        "summary": "List 3D models",
        "description": "Retrieves a list of all models in a project. This operation supports pagination. You can filter out all models without a published revision.",
        "operationId": "get3DModels",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "name": "published",
            "in": "query",
            "description": "Filter based on whether or not it has published revisions.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of models.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const models3D = await client.models3D.list({ published: true });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "three_d_model_list = client.three_d.models.list()\n\nfor three_d_model in client.three_d.models:\n    three_d_model # do something with the 3d model\n\nfor three_d_model in client.three_d.models(chunk_size=50):\n    three_d_model # do something with the 3d model\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDModel> listResults = new ArrayList<>(); \n client.threeD().models() \n          .list() \n          .forEachRemaining(model -> listResults.addAll(model)); \n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "3D Models"
        ],
        "summary": "Create 3D models",
        "operationId": "create3DModels",
        "requestBody": {
          "description": "The models to create.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateModel3DClassicBody"
                  },
                  {
                    "$ref": "#/components/schemas/CreateModel3DDmsOnlyBody"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of the created models.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:CREATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const modelsToCreate = [\n  { name: 'Model 0' },\n  { name: 'Model 2' },\n];\nconst models3D = await client.models3D.create(modelsToCreate);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.models.create(name=\"My Model\", data_set_id=1, metadata={\"key1\": \"value1\", \"key2\": \"value2\"})\n\nfrom cognite.client.data_classes import ThreeDModelWrite\nmy_model = ThreeDModelWrite(name=\"My Model\", data_set_id=1, metadata={\"key1\": \"value1\", \"key2\": \"value2\"})\nmy_other_model = ThreeDModelWrite(name=\"My Other Model\", data_set_id=1, metadata={\"key1\": \"value1\", \"key2\": \"value2\"})\nres = client.three_d.models.create([my_model, my_other_model])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDModel> upsertThreeDModelsList = List.of( \n          ThreeDModel.newBuilder() \n          .setName(\"generated-\") \n          .setDataSetId(dataSetId) \n          .setCreatedTime(1552566113).build()); \nList<ThreeDModel> listUpsert = \n          client.threeD() \n          .models() \n          .upsert(upsertThreeDModelsList); \n\n"
          }
        ]
      }
    },
    "/3d/models/update": {
      "post": {
        "tags": [
          "3D Models"
        ],
        "summary": "Update 3D models",
        "operationId": "update3DModels",
        "requestBody": {
          "description": "List of changes.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateModel3DClassicBody"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateModel3DDmsOnlyBody"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Corresponding models after applying the updates.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:UPDATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const modelsToUpdate = [\n  { id: 3744350296805509, update: { name: { set: 'Model 0 updated' }}},\n  { id: 8163365893677939, update: { name: { set: 'Model 2 updated' }}},\n];\nconst models3D = await client.models3D.update(modelsToUpdate);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "three_d_model = client.three_d.models.retrieve(id=1)\nthree_d_model.name = \"New Name\"\nres = client.three_d.models.update(three_d_model)\n\nfrom cognite.client.data_classes import ThreeDModelUpdate\nmy_update = ThreeDModelUpdate(id=1).name.set(\"New Name\")\nres = client.three_d.models.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "ThreeDModel update = upsertThreeDModelsList.get(0).toBuilder() \n          .setName(\"Update Test\").build(); \nList<ThreeDModel> listUpsert = \n          client.threeD() \n          .models() \n          .upsert(List.of(update)); \n\n"
          }
        ]
      }
    },
    "/3d/models/delete": {
      "post": {
        "tags": [
          "3D Models"
        ],
        "summary": "Delete 3D models",
        "operationId": "delete3DModels",
        "requestBody": {
          "description": "List of models to delete.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/DataIdentifiers"
                  },
                  {
                    "$ref": "#/components/schemas/DataDmsIdentifiers"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:DELETE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.models3D.delete([{ id: 3744350296805509 }, { id: 8163365893677939 }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.models.delete(id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteItemsResultsByExternalIds = \n          client.threeD() \n          .models() \n          .delete(List.of(Item.newBuilder().setExternalId(\"10\").build())); \n\nList<Item> deleteItemsResultsByInternalIds = \n          client.threeD() \n          .models() \n          .delete(List.of(Item.newBuilder().setId(10).build())); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}": {
      "get": {
        "tags": [
          "3D Models"
        ],
        "summary": "Retrieve a 3D model",
        "operationId": "get3DModel",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          }
        ],
        "responses": {
          "200": {
            "description": "A model object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3D"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.models3D.retrieve(3744350296805509);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.models.retrieve(id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDModel> retrievedByInternalIds = \n          client.threeD() \n          .models() \n          .retrieve(List.of(Item.newBuilder().setId(10).build())); \n\nList<ThreeDModel> retrievedByExternalIds = \n          client.threeD() \n          .models() \n          .retrieve(List.of(Item.newBuilder().setExternalId(\"10\").build())); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions": {
      "get": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "List 3D revisions",
        "description": "Retrieves a list of all revisions of a model. This operation supports pagination. You can also filter revisions if they are marked as published or not by using the query param published.",
        "operationId": "get3DRevisions",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "name": "published",
            "in": "query",
            "description": "Filter based on published status.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of revisions of the model.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Revision3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const revisions3D = await client.revisions3D.list(324566546546346);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.list(model_id=1, published=True, limit=100)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDModelRevision> listResults = new ArrayList<>(); \nclient.threeD() \n          .models() \n          .revisions()\n          .list(1L) \n          .forEachRemaining(model -> listResults.addAll(model)); \n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Create 3D revisions",
        "operationId": "create3DRevisions",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          }
        ],
        "requestBody": {
          "description": "The revisions to create.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateRevision3DClassicBody"
                  },
                  {
                    "$ref": "#/components/schemas/CreateRevision3DDmsOnlyBody"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "A list of created revisions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Revision3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:CREATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const revisions = await client.revisions3D.create(4234325345643654, [{ fileId: 8252999965991682 }, { fileId: 6305529564379596 }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import ThreeDModelRevisionWrite\nmy_revision = ThreeDModelRevisionWrite(file_id=1)\nres = client.three_d.revisions.create(model_id=1, revision=my_revision)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Path fileAOriginal = Paths.get(\"./src/test/resources/csv-data.txt\"); \nList<FileContainer> fileContainerInput = new ArrayList<>(); \nFileMetadata fileMetadata = FileMetadata.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"test_file_.test\") \n          .setSource(\"sdk-data-generator\") \n          .putMetadata(\"type\", \"sdk-data-generator\") \n     .build(); \n\n FileContainer fileContainer = FileContainer.newBuilder() \n          .setFileMetadata(fileMetadata) \n          .setFileBinary(FileBinary.newBuilder() \n               .setBinaryUri(fileAOriginal.toUri().toString())) \n          .build(); \n fileContainerInput.add(fileContainer); \n\n List<FileMetadata> uploadFileResult = \n          client.files().upload(fileContainerInput); \n\nThreeDModelRevision.Camera camera = ThreeDModelRevision.Camera.newBuilder() \n .addPosition(2.707411050796509).addPosition(-4.514726638793945).addPosition(1.5695604085922241) \n .addTarget(0.0).addTarget(-0.002374999923631549).addTarget(1.5695604085922241) \n.build(); \nThreeDModelRevision revision = ThreeDModelRevision.newBuilder() \n .setFileId(uploadFileResult.get(0).getId()).setCamera(camera).addRotation(new Random().nextInt(100) / 100.0) \n.build(); \nList<ThreeDModelRevision> listUpsert = \n          client.threeD() \n          .models() \n          .revisions() \n          .upsert(10L, List.of(revision)); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/update": {
      "post": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Update 3D revisions",
        "operationId": "update3DRevisions",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          }
        ],
        "requestBody": {
          "description": "List of changes.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/UpdateRevision3DClassicBody"
                  },
                  {
                    "$ref": "#/components/schemas/UpdateRevision3DDmsOnlyBody"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Corresponding revisions after applying the updates.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Revision3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:UPDATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const revisionsToUpdate = [{\n id: 6305529564379596,\n update: {\n   rotation: {\n     set: [1, 2, 3]\n   },\n   translation: {\n     set: [4, 5, 6]\n   },\n   scale: {\n     set: [0.5, 0.3, 0.2]\n   }\n }\n}];\nconst updated = await client.revisions3D.update(8252999965991682, revisionsToUpdate);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "revision = client.three_d.revisions.retrieve(model_id=1, id=1)\nrevision.status = \"New Status\"\nres = client.three_d.revisions.update(model_id=1, item=revision)\n\nfrom cognite.client.data_classes import ThreeDModelRevisionUpdate\nmy_update = ThreeDModelRevisionUpdate(id=1).published.set(False).metadata.add({\"key\": \"value\"})\nres = client.three_d.revisions.update(model_id=1, item=my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "ThreeDModelRevision th = ThreeDModelRevision.newBuilder().setId(10).setRotation(1,10).build(); \nList<ThreeDModelRevision> tdUpdateResults = \nclient.threeD() \n          .models() \n          .revisions() \n          .upsert(10L, List.of(th)); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/delete": {
      "post": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Delete 3D revisions",
        "operationId": "delete3DRevisions",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          }
        ],
        "requestBody": {
          "description": "List of revisions ids to delete.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/DataIdentifiers"
                  },
                  {
                    "$ref": "#/components/schemas/DataDmsIdentifiers"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:DELETE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.revisions3D.delete(8252999965991682, [{ id: 4190022127342195 }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.delete(model_id=1, id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<Item> deleteItemsResults = client.threeD().models().revisions().delete(20L, byInternalIds); \n\nList<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<Item> deleteItemsResults = client.threeD().models().revisions().delete(20L, byExternalIds); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}": {
      "get": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Retrieve a 3D revision",
        "operationId": "get3DRevision",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "responses": {
          "200": {
            "description": "A revision object",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Revision3D"
                }
              }
            }
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const revisions3D = await client.revisions3D.retrieve(8252999965991682, 4190022127342195)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.retrieve(model_id=1, id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<ThreeDModelRevision> resultsByInternalIds = client.threeD().models().revisions().retrieve(10L, byInternalIds); \n\nList<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<ThreeDModelRevision> resultsByExternalIds = client.threeD().models().revisions().retrieve(10L, byExternalIds); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/logs": {
      "get": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "List 3D revision logs",
        "description": "List log entries for the revision",
        "operationId": "get3DLogs",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          },
          {
            "name": "severity",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int64",
              "description": "Minimum severity to retrieve (3 = INFO, 5 = WARN, 7 = ERROR).",
              "default": 5
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of log entries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RevisionLog3DResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/thumbnail": {
      "post": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Update 3D revision thumbnail",
        "operationId": "updateThumbnail",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "requestBody": {
          "description": "The request body containing the file ID of the thumbnail image (from Files API).",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateRevision3DThumbnail"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:UPDATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.revisions3D.updateThumbnail(8252999965991682, 4190022127342195, 3243334242324);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.update_thumbnail(model_id=1, revision_id=1, file_id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "FileMetadata fileMetadata = FileMetadata.newBuilder() \n .setExternalId(\"10\") \n .setName(\"CAMARO_THUMBNAIL_TEST_SDK_JAVA.png\") \n .setSource(\"sdk-data-generator\") \n .setUploaded(true) \n .setMimeType(\"image/png\") \n .putMetadata(\"type\", \"sdk-data-generator\") \n .putMetadata(\"sdk-data-generator\", \"sdk-data-generator\") \n .build(); \n byte[] fileByteA = bytes of file; \n List<FileContainer> list = List.of(FileContainer.newBuilder().setFileMetadata(fileMetadata).setFileBinary(FileBinary.newBuilder() \n          .setBinary(ByteString.copyFrom(fileByteA))).build()); \nList<FileMetadata> uploadFileResult = client.files().upload(list); \n\nBoolean updated = client \n          .threeD() \n          .models() \n          .revisions() \n          .updateThumbnail(model.getId(), revision.getId(), uploadFileResult.get(0).getId()); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/outputs": {
      "get": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "List available outputs",
        "description": "Retrieve a list of available outputs for a processed 3D model. An output can be a format that can be consumed by a viewer (e.g. Reveal) or import in external tools. Each of the outputs will have an associated version which is used to identify the version of output format (not the revision of the processed output). Note that the structure of the outputs will vary and is not covered here.",
        "operationId": "list3dModelOutputs",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          },
          {
            "name": "format",
            "in": "query",
            "description": "Format identifier, e.g. 'ept-pointcloud' (point cloud). Well known formats are:\n'ept-pointcloud' (point cloud data) or 'reveal-directory' (output supported by Reveal).\n'all-outputs' can be used to retrieve all outputs for a 3D revision. Note that some of\nthe outputs are internal, where the format and availability might change without warning.\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a list of outputs and available versions per output for the given revision.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Model3DOutputResponseList"
                }
              }
            }
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/nodes": {
      "get": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "List 3D nodes",
        "description": "Retrieves a list of nodes from the hierarchy in the 3D model. You can also request a specific subtree with the 'nodeId' query parameter and limit the depth of the resulting subtree with the 'depth' query parameter. By default, nodes are returned in order of ascending treeIndex. We suggest trying to set the query parameter `sortByNodeId` to `true` to check whether it makes your use case faster. The `partition` parameter can only be used if `sortByNodeId` is set to `true`. This operation supports pagination. If the model revision is still being processed, you will get a HTTP status 400 when accessing nodes too early. Wait until the retrieve revision response returns \"status\":\"Done\" before calling nodes endpoints.",
        "operationId": "get3DNodes",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          },
          {
            "$ref": "#/components/parameters/partition"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "name": "depth",
            "in": "query",
            "description": "Get sub nodes up to this many levels below the specified node. Depth 0 is the root node.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nodeId",
            "in": "query",
            "description": "ID of a node that are the root of the subtree you request (default is the root node).",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "sortByNodeId",
            "in": "query",
            "description": "Enable sorting by nodeId. When this parameter is `true`, nodes will be listed in order of ascending nodeId. Enabling this option will likely result in faster response for many requests.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "properties",
            "in": "query",
            "description": "Example: `{\"category1\":{\"property1\":\"value1\"}}`\n\nFilter for node properties. Only nodes that match all the given properties exactly will be listed.\nThe filter must be a JSON object with the same format as the `properties` field.\n",
            "schema": {
              "type": "string",
              "format": "jsonObject(jsonObject(string))"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of nodes of a revision.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Node3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const nodes3d = await client.revisions3D.list3DNodes(8252999965991682, 4190022127342195);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.list_nodes(model_id=1, revision_id=1, limit=10)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDModelRevision> listResults = new ArrayList<>(); \nclient.threeD() \n          .models() \n          .revisions() \n          .nodes() \n          .list(model.getId(), revision.getId()) \n          .forEachRemaining(val -> listResults.addAll(val)); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/nodes/list": {
      "post": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Filter 3D nodes",
        "description": "List nodes in a project, filtered by node names or node property values specified by supplied filters. This operation supports pagination and partitions. If the model revision is still being processed, you will get a HTTP status 400 when accessing nodes too early. Wait until the retrieve revision response returns \"status\":\"Done\" before calling nodes endpoints.",
        "operationId": "filter3DNodes",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/Node3DPropertyFilterBody"
                  },
                  {
                    "$ref": "#/components/schemas/Node3DNameFilterBody"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of nodes satisfying the supplied node property filters.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Node3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const query = {\n filter: {\n   properties: {\n     Items: {\n       Type: [\"Cylinder\"]\n     }\n   }\n },\n partition: \"1/10\"\n};\nconst nodes3d = await client.revisions3D.filter3DNodes(8252999965991682, 4190022127342195, query);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.filter_nodes(model_id=1, revision_id=1, properties={ \"PDMS\": { \"Area\": [\"AB76\", \"AB77\", \"AB78\"], \"Type\": [\"PIPE\", \"BEND\", \"PIPESUP\"] } }, limit=10)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "//without parameters \nIterator<List<ThreeDNode>> itFilter = client.threeD() \n          .models() \n          .revisions() \n          .nodes() \n          .filter(model.getId(), revision.getId()); \n List<ThreeDNode> listResults = itFilter.next(); \n\n//with parameters \nRequest request = Request.create() \n          .withFilterParameter(\"properties\", createFilterPropertiesWithCategories()); \n\nList<ThreeDNode> listResults = new ArrayList<>(); \nclient.threeD() \n          .models() \n          .revisions() \n          .nodes() \n          .filter(model.getId(), revision.getId(), request) \n          .forEachRemaining(val -> listResults.addAll(val)); \n\nprivate ThreeDNode.PropertiesFilter createFilterPropertiesWithCategories() { \n     ThreeDNode.PropertiesFilter.Categories.CategoriesValues.Builder catValBuilder = \n          ThreeDNode.PropertiesFilter.Categories.CategoriesValues.newBuilder(); \n     catValBuilder.addValuesString(\"Box\"); \n     ThreeDNode.PropertiesFilter.Categories.Builder catBuilder = \n          ThreeDNode.PropertiesFilter.Categories.newBuilder(); \n     catBuilder.setName(\"Item\"); \n     catBuilder.putValues(\"Type\", catValBuilder.build()); \n     ThreeDNode.PropertiesFilter.Builder propsBuilder = \n          ThreeDNode.PropertiesFilter.newBuilder(); \n     propsBuilder.addCategories(catBuilder.build()); \n     return propsBuilder.build(); \n } \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/nodes/byids": {
      "post": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "Get 3D nodes by ID",
        "description": "Retrieves specific nodes given by a list of IDs.",
        "operationId": "get3DNodesById",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "requestBody": {
          "description": "The request body containing the IDs of the nodes to retrieve. Will return error 400 if the revision is still being processed.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Node3DIds"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of nodes.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Node3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const nodes3d = await client.revisions3D.retrieve3DNodes(8252999965991682, 4190022127342195, [{id: 123}, {id: 456}]);"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<ThreeDNode> nodesByIds = client.threeD() \n          .models() \n          .revisions() \n          .nodes() \n          .retrieve(model.getId(), revision.getId(), byInternalIds); \n\nList<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \n List<ThreeDNode> nodesByIds = client.threeD() \n          .models() \n          .revisions() \n          .nodes() \n          .retrieve(model.getId(), revision.getId(), byExternalIds); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/nodes/{nodeId}/ancestors": {
      "get": {
        "tags": [
          "3D Model Revisions"
        ],
        "summary": "List 3D ancestor nodes",
        "description": "Retrieves a list of ancestor nodes of a given node, including itself, in the hierarchy of the 3D model. This operation supports pagination. Will return error 400 if the revision is still being processed.",
        "operationId": "get3DNodeAncestors",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "name": "nodeId",
            "in": "path",
            "description": "ID of the node to get the ancestors of.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of ancestor nodes.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Node3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const nodes3d = await client.revisions3D.list3DNodeAncestors(8252999965991682, 4190022127342195, 572413075141081);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.revisions.list_ancestor_nodes(model_id=1, revision_id=1, node_id=5, limit=10)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDNode> listResultsAncestorNodes = new ArrayList<>(); \nclient.threeD() \n          .models() \n          .revisions() \n          .nodes() \n          .list(model.getId(), revision.getId(), nodeDrawn.getId()) \n          .forEachRemaining(val -> listResultsAncestorNodes.addAll(val)); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/mappings": {
      "get": {
        "tags": [
          "3D Asset Mapping"
        ],
        "summary": "List 3D asset mappings",
        "description": "List all asset mappings\n\n\nAsset references obtained from a mapping - through asset ids - may be\ninvalid, simply by the non-transactional nature of HTTP.\nThey are NOT maintained by any means from CDF, meaning they will be stored until the\nreference is removed through the delete endpoint of 3d asset mappings.",
        "operationId": "get3DMappings",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "name": "nodeId",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "assetId",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "intersectsBoundingBox",
            "in": "query",
            "description": "Example: `{\"min\":[0.0, 0.0, 0.0], \"max\":[1.0, 1.0, 1.0]}`\n\nIf given, only return asset mappings for assets whose bounding box\nintersects the given bounding box.\n\nMust be a JSON object with `min`, `max` arrays of coordinates.\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of mappings between assets and 3D nodes",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetMapping3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const mappings3D = await client.assetMappings3D.list(3244265346345, 32423454353545);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.three_d.asset_mappings.list(model_id=1, revision_id=1)\n\nfrom cognite.client.data_classes import BoundingBox3D\nbbox = BoundingBox3D(min=[0.0, 0.0, 0.0], max=[1.0, 1.0, 1.0])\nres = client.three_d.asset_mappings.list(\n    model_id=1, revision_id=1, intersects_bounding_box=bbox)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Iterator<List<ThreeDAssetMapping>> itFilter = client.threeD() \n          .models() \n          .revisions() \n          .assetMappings() \n          .list(model.getId(), revision.getId()); \nList<ThreeDAssetMapping> listResultsList = itFilter.next(); \n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "3D Asset Mapping"
        ],
        "summary": "Create 3D asset mappings",
        "description": "Create asset mappings\n\nAsset mappings allows connections to be made between assets and 3D nodes. This can be used to contextualize 3D models.\n\nIn Hybrid CDF projects: When creating asset mappings, the asset ids and node Ids are allowed to be invalid or non-existing.\nThe mappings are NOT maintained by any means from CDF, meaning they will be stored until the\nmapping is removed through the 3d asset mappings delete endpoint.\n\nIn DataModelingOnly CDF projects: When creating asset mappings, the data model based assetInstanceId (with space and externalId),\nand the 3d model revision nodeId, must be accessible, existing and valid.",
        "operationId": "create3DMappings",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "requestBody": {
          "description": "The asset mappings to create.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CreateAssetMapping3DClassicBody"
                  },
                  {
                    "$ref": "#/components/schemas/CreateAssetMapping3DDmsOnlyBody"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of created asset mappings.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetMapping3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:UPDATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assetMappingsToCreate = [\n {\n   nodeId: 8252999965991682,\n   assetId: 4354399876978078\n },\n {\n   nodeId: 9034285498543958,\n   assetId: 1042345809544395\n }\n];\nconst mappings3D = await client.assetMappings3D.create(\n 25432542356436,\n 33485743958747,\n assetMappingsToCreate\n);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import ThreeDAssetMappingWrite\nmy_mapping = ThreeDAssetMappingWrite(node_id=1, asset_id=1)\nres = client.three_d.asset_mappings.create(model_id=1, revision_id=1, asset_mapping=my_mapping)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": " List<ThreeDAssetMapping> items = List.of(ThreeDAssetMapping.newBuilder() \n          .setAssetId(1L) \n          .setNodeId(1L) \n          .build()); \n\nList<ThreeDAssetMapping> listCreated = client.threeD() \n          .models() \n          .revisions() \n          .assetMappings() \n          .create(model.getId(), revision.getId(), items); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/mappings/delete": {
      "post": {
        "tags": [
          "3D Asset Mapping"
        ],
        "summary": "Delete 3D asset mappings",
        "description": "Delete a list of asset mappings",
        "operationId": "delete3DMappings",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "requestBody": {
          "description": "The IDs of the asset mappings to delete.",
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/DeleteAssetMapping3DClassicBody"
                  },
                  {
                    "$ref": "#/components/schemas/DeleteAssetMapping3DDmsOnlyBody"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:DELETE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const assetMappingsToDelete = [\n {\n   nodeId: 8252999965991682,\n   assetId: 4354399876978078\n },\n {\n   nodeId: 9034285498543958,\n   assetId: 1042345809544395\n }\n];\nawait client.assetMappings3D.delete(8252999965991682, 4190022127342195, assetMappingsToDelete);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "mapping_to_delete = client.three_d.asset_mappings.list(model_id=1, revision_id=1)[0]\nres = client.three_d.asset_mappings.delete(model_id=1, revision_id=1, asset_mapping=mapping_to_delete)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ThreeDAssetMapping> listCreated = //list of ThreeDAssetMapping; \nBoolean isDeleted = client.threeD() \n          .models() \n          .revisions() \n          .assetMappings() \n          .delete(model.getId(), revision.getId(), listCreated); \n\n"
          }
        ]
      }
    },
    "/3d/models/{modelId}/revisions/{revisionId}/mappings/list": {
      "post": {
        "tags": [
          "3D Asset Mapping"
        ],
        "summary": "Filter 3D asset mappings",
        "description": "Lists 3D assets mappings that match the specified filter parameter. Only\none type of filter can be specified for each request, either `assetIds`, `nodeIds` or `treeIndexes`.\n\n\nAsset references obtained from a mapping - through asset ids - may be\ninvalid, simply by the non-transactional nature of HTTP.\nThey are NOT maintained by any means from CDF, meaning they will be stored until the\nreference is removed through the delete endpoint of 3d asset mappings.",
        "operationId": "filter3DAssetMappings",
        "parameters": [
          {
            "$ref": "#/components/parameters/ModelId"
          },
          {
            "$ref": "#/components/parameters/RevisionId"
          }
        ],
        "requestBody": {
          "description": "The filter for asset mappings to get.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AssetMapping3DFilterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A list of matching asset mappings.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AssetMapping3DWithCursorResponse"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const mappings3D = await client.assetMappings3D.filter(3244265346345, 32423454353545, {\n  filter: {\n    treeIndexes: [1000, 1001, 1002]\n  }\n});"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": " Request request1 = \n          Request.create().withFilterParameter(\"assetIds\", List.of(1L, 2L)); \nIterator<List<ThreeDAssetMapping>> itFilter1 = client.threeD() \n          .models() \n          .revisions() \n          .assetMappings() \n          .filter(model.getId(), revision.getId(), request1); \n\n"
          }
        ]
      }
    },
    "/3d/mappings/{assetId}/modelnodes": {
      "get": {
        "tags": [
          "3D Asset Mapping"
        ],
        "summary": "List mappings for one assetID across all 3D models",
        "description": "Retrieves a list of `node IDs` from the hierarchy of all available 3D models which are mapped to the supplied `asset ID`. If a `node ID` is mapped to the `asset ID` but is invalid or does not exist anymore, it will be omitted from the results.\n\n\nAsset references obtained from a mapping - through asset id - may be\ninvalid, simply by the non-transactional nature of HTTP.\nThey are NOT maintained by any means from CDF, meaning they will be stored until the\nreference is removed through the delete endpoint of 3d asset mappings.",
        "parameters": [
          {
            "$ref": "#/components/parameters/AssetId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/Limit"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of mappings between assets and 3D valid nodes and revisions in which exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectAssetMapping3DList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "threedAcl:READ"
        ]
      }
    },
    "/timeseries": {
      "get": {
        "tags": [
          "Time series"
        ],
        "summary": "List time series",
        "description": "List time series. Use `nextCursor` to paginate through the results.",
        "operationId": "getTimeSeries",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Limits the number of results to return. CDF returns a maximum of 1000 results even if you specify a higher limit.",
            "schema": {
              "maximum": 1000,
              "minimum": 1,
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          },
          {
            "$ref": "#/components/parameters/IncludeMetadata"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/partition"
          },
          {
            "name": "assetIds",
            "in": "query",
            "description": "Gets the time series related to the assets. The format is a list of IDs serialized as a JSON array(int64). Takes [ 1 .. 100 ] unique items.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "name": "rootAssetIds",
            "in": "query",
            "description": "Only includes time series that have a related asset in a tree rooted at any of these root `assetIds`.",
            "example": "[363848954441724, 793045462540095, 1261042166839739]",
            "schema": {
              "$ref": "#/components/schemas/JsonArrayInt64"
            }
          },
          {
            "in": "query",
            "name": "externalIdPrefix",
            "schema": {
              "$ref": "#/components/schemas/CogniteExternalIdPrefix"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of time series in lexicographic order.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataWithCursorGetTimeSeriesMetadataDTO"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const timeseries = await client.timeseries.list({ filter: { assetIds: [1, 2] }});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.filters import Equals\nis_numeric = Equals(\"is_string\", False)\nres = client.time_series.filter(filter=is_numeric, sort=\"external_id\")\n\nfrom cognite.client.data_classes.filters import Equals\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty, SortableTimeSeriesProperty\nis_numeric = Equals(TimeSeriesProperty.is_string, False)\nres = client.time_series.filter(filter=is_numeric, sort=SortableTimeSeriesProperty.external_id)\nres = client.time_series.list(limit=5)\n\nfor ts in client.time_series:\n    ts # do something with the time series\n\nfor ts_list in client.time_series(chunk_size=2500):\n    ts_list # do something with the time series\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.time_series.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty, SortableTimeSeriesProperty\nin_timezone = filters.Prefix(TimeSeriesProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.time_series.list(\n    advanced_filter=in_timezone,\n    sort=(SortableTimeSeriesProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.time_series.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Create time series",
        "description": "Creates one or more time series.",
        "operationId": "postTimeSeries",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response with the created time series.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetTimeSeriesMetadataDTO"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/MissingField"
          },
          "409": {
            "description": "Time series with the specified externalIds already exists. Retry request, with the existing externalIds removed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalIdsAlreadyExistResponse"
                }
              }
            }
          },
          "422": {
            "description": "Duplicated externalIds found. Retry request, keeping only one instance of each duplicated externalId.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DuplicatedIdsInRequestResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const timeseries = [\n  { name: 'Pressure sensor', assetId: 123 },\n  { name: 'Temprature sensor', description: 'Pump abc', unit: 'C' },\n];\nconst createdTimeseries = await client.timeseries.create(timeseries);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import TimeSeriesWrite\nts = client.time_series.create(TimeSeriesWrite(name=\"my_ts\", data_set_id=123, external_id=\"foo\"))\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<TimeseriesMetadata> upsertTimeseriesList = List.of(TimeseriesMetadata.newBuilder() \n   .setExternalId(\"10\") \n   .setName(\"test_ts\") \n   .setIsString(false) \n   .setIsStep(false) \n   .setDescription(\"Description\") \n   .setUnit(\"TestUnits\") \n   .putMetadata(\"type\", \"sdk-data-generator\") \n   .putMetadata(\"sdk-data-generator\", \"sdk-data-generator\") \n .build()); \n\nclient.timeseries().upsert(upsertTimeseriesList); \n\n"
          }
        ]
      }
    },
    "/timeseries/byids": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Retrieve time series",
        "description": "Retrieves one or more time series by ID or external ID. The response returns the time series in the same order as in the request.",
        "operationId": "getTimeSeriesByIds",
        "requestBody": {
          "description": "List of the IDs of the time series to retrieve.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesLookupById"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with a list of time series matching the IDs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetTimeSeriesMetadataDTO"
                }
              }
            }
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          },
          "422": {
            "description": "Duplicate IDs found. Retry request, keeping only one instance of each duplicated ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DuplicatedIdsInRequestResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const timeseries = await client.timeseries.retrieve([\n  { id: 123 },\n  { externalId: 'abc' }\n]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.time_series.retrieve(id=1)\n\nres = client.time_series.retrieve(external_id=\"1\")\nres = client.time_series.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.time_series.retrieve_multiple(external_ids=[\"abc\", \"def\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<TimeseriesMetadata> retrievedAssets = client.timeseries().retrieve(byExternalIds);// by list of items \nList<TimeseriesMetadata> retrievedAssets = client.timeseries().retrieve(\"10\", \"20\");// by varargs of String \n\nList<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<TimeseriesMetadata> retrievedAssets = client.timeseries().retrieve(byInternalIds);// by list of items \nList<TimeseriesMetadata> retrievedAssets = client.timeseries().retrieve(10, 20);// by varargs of Long \n\n"
          }
        ]
      }
    },
    "/timeseries/list": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Filter time series",
        "description": "<details>\n<summary>\nRetrieves a list of time series that match the given criteria.\n</summary>\n\n### Advanced filtering\n\nThe `advancedFilter`\nfield lets you create complex filtering expressions that combine simple operations,\nsuch as `equals`, `prefix`, and `exists`, by using the Boolean operators `and`, `or`, and `not`.\nFiltering applies to basic fields as well as metadata. See the `advancedFilter` syntax in the request example.\n\n\n\n#### Supported leaf filters\n\n| Leaf filter    | Supported fields       | Description and example                                                                                                                                                            |\n|----------------|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `containsAll`  | Array type fields      | Only includes results which contain all of the specified values. <br /> `{\"containsAll\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                         |\n| `containsAny`  | Array type fields      | Only includes results which contain at least one of the specified values. <br /> `{\"containsAny\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                |\n| `equals`       | Non-array type fields  | Only includes results that are equal to the specified value. <br /> `{\"equals\": {\"property\": [\"property\"], \"value\": \"example\"}}`                                                   |\n| `exists`       | All fields             | Only includes results where the specified property exists (has a value). <br /> `{\"exists\": {\"property\": [\"property\"]}}`                                                           |\n| `in`           | Non-array type fields  | Only includes results that are equal to one of the specified values. <br /> `{\"in\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                              |\n| `prefix`       | String type fields     | Only includes results which start with the specified text. <br /> `{\"prefix\": {\"property\": [\"property\"], \"value\": \"example\"}}`                                                     |\n| `range`        | Non-array type fields  | Only includes results that fall within the specified range. <br /> `{\"range\": {\"property\": [\"property\"], \"gt\": 1, \"lte\": 5}}` <br /> Supported operators: `gt`, `lt`, `gte`, `lte` |\n | `search`       | `[\"name\"]` and `[\"description\"]` | Introduced to provide functional parity with the /timeseries/search endpoint. <br /> `{\"search\": {\"property\": [\"property\"], \"value\": \"example\"}}`                        |\n\n#### Supported properties\n\n| Property                          | Type               |\n|-----------------------------------|--------------------|\n| `[\"description\"]`                 | string             |\n| `[\"externalId\"]`                  | string             |\n| `[\"metadata\", \"<someCustomKey>\"]` | string             |\n| `[\"name\"]`                        | string             |\n| `[\"unit\"]`                         | string              |\n| `[\"unitExternalId\"]`               | string              |\n| `[\"unitQuantity\"]`                 | string              |\n| `[\"instanceId\", \"space\"]`          | string              |\n| `[\"instanceId\", \"externalId\"]`     | string              |\n| `[\"assetId\"]`                      | number              |\n| `[\"assetRootId\"]`                  | number              |\n| `[\"createdTime\"]`                  | number              |\n| `[\"dataSetId\"]`                    | number              |\n| `[\"id\"]`                           | number              |\n| `[\"lastUpdatedTime\"]`              | number              |\n| `[\"isStep\"]`                       | Boolean             |\n| `[\"isString\"]`                     | Boolean             |\n| `[\"accessCategories\"]`             | array of strings    |\n| `[\"securityCategories\"]`           | array of numbers    |\n\n#### Limits\n\n- Filter query max depth: 10.\n- Filter query max number of clauses: 100.\n- `and` and `or` clauses must have at least one element (and at most 99, since each element counts\n  towards the total clause limit, and so does the `and`/`or` clause itself).\n- The `property` array of each leaf filter has the following limitations:\n  - Number of elements in the array is 1 or 2.\n  - Elements must not be null or blank.\n  - Each element max length is 256 characters.\n  - The `property` array must match one of the existing properties (static top-level property or dynamic metadata property).\n- `containsAll`, `containsAny`, and `in` filter `values` array size must be in the range [1, 100].\n- `containsAll`, `containsAny`, and `in` filter `values` array must contain elements of number or string type (matching the type of the given property).\n- `range` filter must have at lest one of `gt`, `gte`, `lt`, `lte` attributes.\n  But `gt` is mutually exclusive to `gte`, while `lt` is mutually exclusive to `lte`.\n- `gt`, `gte`, `lt`, `lte` in the `range` filter must be of number or string type (matching the type of the given property).\n- `search` filter `value` must not be blank, and the length must be in the range [1, 128], and there\n  may be at most two `search` filters in the entire filter query.\n- The maximum length of the `value` of a leaf filter that is applied to a string property is 256.\n\n### Sorting\n\nBy default, time series are sorted by their creation time in ascending order.\nSorting by another property or by several other properties can be explicitly requested via the\n`sort` field, which must contain a list\nof one or more sort specifications. Each sort specification indicates the `property` to sort on\nand, optionally, the `order` in which to sort (defaults to `asc`). If multiple sort specifications are\nsupplied, the results are sorted on the first property, and those with the same value for the first\nproperty are sorted on the second property, and so on.  \nPartitioning is done independently of sorting; there is no guarantee of sort order between elements from different partitions.\n\n#### Null values\n\nIn case the `nulls` field has the `auto` value, or the field isn't specified, null (missing) values\nare considered bigger than any other values. They are placed last when sorting in the `asc`\norder and first in the `desc` order. Otherwise, missing values are placed according to\nthe `nulls` field (`last` or `first`), and their placement won't depend on the `order`\nfield. Note that the number zero, empty strings, and empty lists are all considered\n_not_ null.\n\n#### Example\n\n```json\n{\n  \"sort\": [\n    {\n      \"property\" : [\"createdTime\"],\n      \"order\": \"desc\",\n      \"nulls\": \"last\"\n    },\n    {\n      \"property\" : [\"metadata\", \"<someCustomKey>\"]\n    }\n  ]\n}\n```\n\n\n#### Properties\n\nYou can sort on the following properties:\n\n| Property                          |\n|-----------------------------------|\n| `[\"assetId\"]`                     |\n| `[\"createdTime\"]`                 |\n| `[\"dataSetId\"]`                   |\n| `[\"description\"]`                 |\n| `[\"externalId\"]`                  |\n| `[\"lastUpdatedTime\"]`             |\n| `[\"metadata\", \"<someCustomKey>\"]` |\n| `[\"name\"]`                        |\n| `[\"instanceId\", \"space\"]`         |\n| `[\"instanceId\", \"externalId\"]`    |\n\n#### Limits\n\nThe `sort` array must contain 1 to 2 elements.\n</details>",
        "operationId": "listTimeSeries",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesListDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with a list of time series matching the specified criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataWithCursorGetTimeSeriesMetadataDTO"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.filters import Equals\nis_numeric = Equals(\"is_string\", False)\nres = client.time_series.filter(filter=is_numeric, sort=\"external_id\")\n\nfrom cognite.client.data_classes.filters import Equals\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty, SortableTimeSeriesProperty\nis_numeric = Equals(TimeSeriesProperty.is_string, False)\nres = client.time_series.filter(filter=is_numeric, sort=SortableTimeSeriesProperty.external_id)\nres = client.time_series.list(limit=5)\n\nfor ts in client.time_series:\n    ts # do something with the time series\n\nfor ts_list in client.time_series(chunk_size=2500):\n    ts_list # do something with the time series\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.time_series.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty, SortableTimeSeriesProperty\nin_timezone = filters.Prefix(TimeSeriesProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.time_series.list(\n    advanced_filter=in_timezone,\n    sort=(SortableTimeSeriesProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.time_series.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<TimeseriesMetadata> listTimeseriesResults = new ArrayList<>(); \nclient.timeseries() \n .list() \n .forEachRemaining(timeseries -> listTimeseriesResults.addAll(timeseries)); \n\nList<TimeseriesMetadata> listTimeseriesResults = new ArrayList<>(); \nclient.timeseries() \n .list(Request.create() \n .withFilterMetadataParameter(\"source\", \"source\")) \n .forEachRemaining(timeseries -> listTimeseriesResults.addAll(timeseries)); \n\n"
          }
        ]
      }
    },
    "/timeseries/aggregate": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Aggregate time series",
        "operationId": "aggregateTimeSeries",
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "description": "The aggregation API allows you to compute aggregated results from a set of time series, such as\r\ngetting the number of time series in a project or checking what assets the different time series\r\nin your project are associated with (along with the number of time series for each asset).\r\nBy specifying `filter` and/or `advancedFilter`, the aggregation will take place only over those\r\ntime series that match the filters. `filter` and `advancedFilter` behave the same way as in the\r\n`list` endpoint.\r\n\r\n<details>\r\n<summary>\r\nThe default behavior, when the <code>aggregate</code> field is not specified the request body, is to return the\r\nnumber of time series that match the filters (if any), which is the same behavior as when the\r\n<code>aggregate</code> field is set to <code>count</code>.\r\n</summary>\r\n\r\nThe following requests will both return the total number of\r\ntime series whose `name` begins with `pump`:\r\n\r\n```\r\n{\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nand\r\n\r\n```\r\n{\r\n  \"aggregate\": \"count\",\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe response might be:\r\n\r\n```\r\n{\"items\": [{\"count\": 42}]}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>uniqueValues</code> and specifying a property in <code>properties</code> (this field is an array, but currently only supports one property) will\r\nreturn all unique values (up to a maximum of 1000) that are taken on by that property\r\nacross all the time series that match the filters, as well as the number of time series that\r\nhave each of those property values.\r\n</summary>\r\n\r\nThis example request finds all the unique asset ids that are\r\nreferenced by the time series in your project whose `name` begins with `pump`:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"uniqueValues\",\r\n  \"properties\": [{\"property\": [\"assetId\"]}],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe response might be the following, saying that 23 time series are associated with asset 18\r\nand 107 time series are associated with asset 76:\r\n\r\n```\r\n{\r\n  \"items\": [\r\n    {\"values\": [\"18\"], \"count\": 23},\r\n    {\"values\": [\"76\"], \"count\": 107}\r\n  ]\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>cardinalityValues</code> will instead return the approximate number of\r\ndistinct values that are taken on by the given property among the matching time series.\r\n</summary>\r\n\r\nExample request:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"cardinalityValues\",\r\n  \"properties\": [{\"property\": [\"assetId\"]}],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe result is likely exact when the set of unique values is small. In this example, there are likely two distinct asset ids among the matching time series:\r\n\r\n```\r\n{\"items\": [{\"count\": 2}]}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>uniqueProperties</code> will return the set of unique properties whose property\r\npath begins with <code>path</code> (which can currently only be <code>[\"metadata\"]</code>) that are contained in the time series that match the filters.\r\n</summary>\r\n\r\nExample request:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"uniqueProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe result contains all the unique metadata keys in the time series whose `name` begins with\r\n`pump`, and the number of time series that contains each metadata key:\r\n\r\n```\r\n{\r\n  \"items\": [\r\n    {\"values\": [{\"property\": [\"metadata\", \"tag\"]}], \"count\": 43},\r\n    {\"values\": [{\"property\": [\"metadata\", \"installationDate\"]}], \"count\": 97}\r\n  ]\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>cardinalityProperties</code> will instead return the approximate number of\r\ndifferent property keys whose path begins with <code>path</code> (which can currently only be <code>[\"metadata\"]</code>, meaning that this can only be used to count the approximate number of distinct metadata keys among the matching time series).\r\n</summary>\r\n\r\nExample request:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"cardinalityProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe result is likely exact when the set of unique values is small. In this example, there are likely two distinct metadata keys among the matching time series:\r\n\r\n```\r\n{\"items\": [{\"count\": 2}]}\r\n```\r\n</details>\r\n\r\nThe `aggregateFilter` field may be specified if `aggregate` is set to `cardinalityProperties` or `uniqueProperties`. The structure of this field is similar to that of `advancedFilter`, except that the set of leaf filters is smaller (`in`, `prefix`, and `range`), and that none of the leaf filters specify a property. Unlike `advancedFilter`, which is applied _before_ the aggregation (in order to restrict the set of time series that the aggregation operation should be applied to), `aggregateFilter` is applied _after_ the initial aggregation has been performed, in order to restrict the set of results.\r\n\r\n<details>\r\n<summary>\r\nClick here for more details about <code>aggregateFilter</code>. \r\n</summary>\r\n\r\nWhen `aggregate` is set to `uniqueProperties`, the result set contains a number of _property paths_, each with an associated count that shows how many time series contained that property (among those time series that matched the `filter` and `advancedFilter`, if they were specified) . If `aggregateFilter` is specified, it will restrict the property paths included in the output. Let us add an `aggregateFilter` to the `uniqueProperties` example from above:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"uniqueProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}},\r\n  \"aggregateFilter\": {\"prefix\": {\"value\": \"t\"}}\r\n}\r\n```\r\n\r\nNow, the result only contains those metadata properties whose key begins with `t` (but it will be the same set of metadata properties that begin with `t` as in the original query without `aggregateFilter`, and the counts will be the same):\r\n\r\n```\r\n{\r\n  \"items\": [\r\n    {\"values\": [{\"property\": [\"metadata\", \"tag\"]}], \"count\": 43}\r\n  ]\r\n}\r\n```\r\n\r\nSimilarly, adding `aggregateFilter` to `cardinalityProperties` will return the approximate number of properties whose property key matches `aggregateFilter` from those time series matching the `filter` and `advancedFilter` (or from all time series if neither `filter` nor `aggregateFilter` are specified):\r\n\r\n```\r\n{\r\n  \"aggregate\": \"cardinalityProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}},\r\n  \"aggregateFilter\": {\"prefix\": {\"value\": \"t\"}}\r\n}\r\n```\r\n\r\nAs we saw above, only one property matches:\r\n\r\n```\r\n{\"items\": [{\"count\": 1}]}\r\n```\r\n\r\nNote that `aggregateFilter` is also accepted when `aggregate` is set to `cardinalityValues` or `cardinalityProperties`. For those aggregations, the effect of any `aggregateFilter` could also be achieved via a similar `advancedFilter`. However, `aggregateFilter` is not accepted when `aggregate` is omitted or set to `count`.\r\n</details>\r\n\r\n### Rate and concurrency limits\r\n\r\nRate and concurrency limits apply this endpoint. If a request exceeds one of the limits,\r\nit will be throttled with a `429: Too Many Requests` response. More on limit types\r\nand how to avoid being throttled is described\r\n[here](https://developer.cognite.com/dev/concepts/request_throttling/).\r\n\r\n| Limit          | Per project           | Per user (identity)   |\r\n|----------------|-----------------------|-----------------------|\r\n| Rate           | 15 requests per second| 10 requests per second|\r\n| Concurrency    | 6 concurrent requests | 4 concurrent requests |\r\n",
        "requestBody": {
          "description": "Aggregates the time series that match the given criteria.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesAdvancedAggregateDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with the aggregated time series. The type of the response depends on the value of the `aggregate` parameter in the request.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/TimeSeriesCountAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/TimeSeriesCardinalityValuesAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/TimeSeriesCardinalityPropertiesAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/TimeSeriesUniqueValuesAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/TimeSeriesUniquePropertiesAggregateResponse"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregates = await client.timeseries.aggregate({ filter: { isString: true } });\nconsole.log('Number of string timeseries: ', aggregates[0].count)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.time_series.aggregate(filter={\"unit\": \"kpa\"})\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nkey_count = client.time_series.aggregate_cardinality_properties(TimeSeriesProperty.metadata)\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nunit_count = client.time_series.aggregate_cardinality_values(TimeSeriesProperty.unit)\n\nfrom cognite.client.data_classes import filters, aggregations as aggs\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nnot_america = aggs.Not(aggs.Prefix(\"america\"))\nis_critical = filters.Search(TimeSeriesProperty.description, \"critical\")\ntimezone_count = client.time_series.aggregate_cardinality_values(\n    TimeSeriesProperty.metadata_key(\"timezone\"),\n    advanced_filter=is_critical,\n    aggregate_filter=not_america)\ncount = client.time_series.aggregate_count()\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nis_numeric = filters.Equals(TimeSeriesProperty.is_string, False)\ncount = client.time_series.aggregate_count(advanced_filter=is_numeric)\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nresult = client.time_series.aggregate_unique_values(TimeSeriesProperty.metadata)\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nresult = client.time_series.aggregate_unique_values(TimeSeriesProperty.metadata_key(\"timezone\"))\nprint(result.unique)\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nfrom cognite.client.utils import timestamp_to_ms\nfrom datetime import datetime\ncreated_after_2020 = filters.Range(TimeSeriesProperty.created_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.time_series.aggregate_unique_values(TimeSeriesProperty.unit, advanced_filter=created_after_2020)\nprint(result.unique)\n\nfrom cognite.client.data_classes.time_series import TimeSeriesProperty\nfrom cognite.client.data_classes import aggregations as aggs, filters\nnot_test = aggs.Not(aggs.Prefix(\"test\"))\ncreated_after_2020 = filters.Range(TimeSeriesProperty.last_updated_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.time_series.aggregate_unique_values(TimeSeriesProperty.unit, advanced_filter=created_after_2020, aggregate_filter=not_test)\nprint(result.unique)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Aggregate aggregateResult = client.timeseries() \n .aggregate(Request.create() \n .withFilterMetadataParameter(\"source\", \"source\"));"
          }
        ]
      }
    },
    "/timeseries/search": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Search time series",
        "description": "Fulltext search for time series based on result relevance. Primarily meant\nfor human-centric use cases, not for programs, since matching and\norder may change over time. Additional filters can also be\nspecified. This operation does not support pagination.",
        "operationId": "searchTimeSeries",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesSearchDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of search results.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetTimeSeriesMetadataDTO"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const timeseries = await client.timeseries.search({\n  filter: {\n    isString: false,\n  },\n  search: {\n    query: 'Temperature'\n  }\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.time_series.search(name=\"some name\")\n\nres = client.time_series.search(filter={\"asset_ids\":[123]})\n"
          }
        ]
      }
    },
    "/timeseries/update": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Update time series",
        "description": "Updates one or more time series. Fields outside of the request remain unchanged.\n\nFor primitive fields (those whose type is string, number, or boolean), use `\"set\": value`\nto update the value; use `\"setNull\": true` to set the field to null.\n\nFor JSON array fields (for example `securityCategories`), use `\"set\": [value1, value2]` to\nupdate the value; use `\"add\": [value1, value2]` to add values; use\n`\"remove\": [value1, value2]` to remove values.",
        "operationId": "alterTimeSeries",
        "requestBody": {
          "description": "List of changes.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the corresponding time series after applying the updates.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetTimeSeriesMetadataDTO"
                }
              }
            }
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          },
          "409": {
            "description": "Time series with the specified externalIds already exists. Retry request, with the existing externalIds removed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExternalIdsAlreadyExistResponse"
                }
              }
            }
          },
          "422": {
            "description": "Duplicate IDs found. Retry request, keeping only one instance of each duplicated ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DuplicatedIdsInRequestResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const timeseries = await client.timeseries.update([{\n  id: 3785438579439,\n  update: {\n    name: { set: 'New name' }\n  }\n}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.time_series.retrieve(id=1)\nres.description = \"New description\"\nres = client.time_series.update(res)\n\nfrom cognite.client.data_classes import TimeSeriesUpdate\nmy_update = TimeSeriesUpdate(id=1).description.set(\"New description\").metadata.add({\"key\": \"value\"})\nres = client.time_series.update(my_update)\n\nfrom cognite.client.data_classes import TimeSeriesUpdate\nfrom cognite.client.data_classes.data_modeling import NodeId\n\nmy_update = (\n    TimeSeriesUpdate(instance_id=NodeId(\"test\", \"hello\"))\n    .external_id.set(\"test:hello\")\n    .metadata.add({\"test\": \"hello\"})\n)\nclient.time_series.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "client.timeseries().upsert(upsertTimeseriesList); \n\n"
          }
        ]
      }
    },
    "/timeseries/delete": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Delete time series",
        "description": "Deletes the time series with the specified IDs and their data points.",
        "operationId": "deleteTimeSeries",
        "requestBody": {
          "description": "Specify a list of the time series to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TimeSeriesLookupByIdWithoutInstanceId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponseWithoutInstanceId"
                }
              }
            }
          },
          "422": {
            "description": "Duplicate IDs found. Retry request, keeping only one instance of each duplicated ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DuplicatedIdsInRequestResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.timeseries.delete([\n  { id: 123 },\n  { externalId: 'abc' }\n]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.time_series.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<Item> deletedAssets = client.timeseries().delete(byInternalIds); \n\nList<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<Item> deletedAssets = client.timeseries().delete(byExternalIds); \n\n"
          }
        ]
      }
    },
    "/timeseries/data": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Insert data points",
        "description": "Insert data points into a time series. You can do this for multiple time series.\nIf you insert a data point with a timestamp that already exists, it will be overwritten with the new value.",
        "operationId": "postMultiTimeSeriesDatapoints",
        "requestBody": {
          "description": "The datapoints to insert.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatapointsInsertQuery"
              }
            },
            "application/protobuf": {
              "schema": {
                "type": "string",
                "format": "binary",
                "description": "Accepts protocol buffer serialized payload, based on the following proto definitions: [Data Point Insertion](<https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_point_insertion_request.proto>) and [Data Points](<https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_points.proto>)",
                "example": "Definitions: https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_point_insertion_request.proto https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_points.proto"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          },
          "422": {
            "description": "Duplicate IDs found. Retry request, keeping only one instance of each duplicated ID.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DuplicatedIdsInRequestResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.datapoints.insert([{ id: 123, datapoints: [{timestamp: 1557320284000, value: -2}] }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import NodeId\nfrom cognite.client.data_classes import StatusCode\nfrom datetime import datetime, timezone\nto_insert = [\n    {\"id\": 1, \"datapoints\": [\n        (datetime(2018,1,1, tzinfo=timezone.utc), 1000),\n        (datetime(2018,1,2, tzinfo=timezone.utc), 2000, StatusCode.Good)],\n    },\n    {\"external_id\": \"foo\", \"datapoints\": [\n        (datetime(2018,1,3, tzinfo=timezone.utc), 3000),\n        (datetime(2018,1,4, tzinfo=timezone.utc), 4000, StatusCode.Uncertain)],\n    },\n    {\"instance_id\": NodeId(\"my-space\", \"my-ts-xid\"), \"datapoints\": [\n        (datetime(2018,1,5, tzinfo=timezone.utc), 5000),\n        (datetime(2018,1,6, tzinfo=timezone.utc), None, StatusCode.Bad)],\n    }\n]\n\nimport math\nto_insert.append(\n    {\"external_id\": \"bar\", \"datapoints\": [\n        {\"timestamp\": 170000000, \"value\": 7000},\n        {\"timestamp\": 180000000, \"value\": 8000, \"status\": {\"symbol\": \"Uncertain\"}},\n        {\"timestamp\": 190000000, \"value\": None, \"status\": {\"code\": StatusCode.Bad}},\n        {\"timestamp\": 200000000, \"value\": math.inf, \"status\": {\"code\": StatusCode.Bad, \"symbol\": \"Bad\"}},\n]})\n\ndata_to_clone = client.time_series.data.retrieve(\n    external_id=\"bar\", include_status=True, ignore_bad_datapoints=False)\nto_insert.append({\"external_id\": \"bar-clone\", \"datapoints\": data_to_clone})\nclient.time_series.data.insert_multiple(to_insert)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<TimeseriesPointPost> items = new ArrayList<>(); items.add(TimeseriesPointPost.newBuilder() \n .setExternalId(\"TimeseriesMetadata.id\") \n .setTimestamp(timeStamp.toEpochMilli()) \n .setValueNum(ThreadLocalRandom.current().nextLong(-10, 20)) \n .build()); \nclient.timeseries().dataPoints().upsert(items); \n\n"
          }
        ]
      }
    },
    "/timeseries/data/list": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Retrieve data points",
        "description": "Retrieves a list of data points from multiple time series in a project.\nThis operation supports aggregation and pagination.\nLearn more about [aggregation](<https://docs.cognite.com/dev/concepts/aggregation/>).\n\nNote: when `start` isn't specified in the top level and for an individual item, it will default to epoch 0, which is 1 January, 1970, thus\nexcluding potential existent data points before 1970. `start` needs to be specified as a negative number to get data points before 1970.",
        "operationId": "getMultiTimeSeriesDatapoints",
        "requestBody": {
          "description": "Specify parameters to query for multiple data points. If you omit fields in individual data point query items, the top-level field values are used. For example, you can specify a default limit for all items by setting the top-level limit field. If you request aggregates, only the aggregates are returned. If you don't request any aggregates, all data points are returned.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatapointsMultiQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Lists of data points for the specified queries.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatapointsOrAggregatesResponse"
                }
              },
              "application/protobuf": {
                "schema": {
                  "type": "string",
                  "format": "binary",
                  "description": "Returns protocol buffer serialized payload, based on the following proto definitions: [Data Points List](<https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_point_list_response.proto>) and [Data Points](<https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_points.proto>)",
                  "example": "Definitions: https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_point_list_response.proto https://raw.githubusercontent.com/cognitedata/protobuf-files/master/v1/timeseries/data_points.proto"
                }
              }
            }
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const data = await client.datapoints.retrieve({ items: [{ id: 123 }] });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "dps = client.time_series.data.retrieve(id=42, start=\"2w-ago\")\nfrom cognite.client.data_classes.data_modeling import NodeId\ndps = client.time_series.data.retrieve(instance_id=NodeId(\"ts-space\", \"foo\"))\n\ndps_lst = client.time_series.data.retrieve(\n   external_id=[\"foo\", \"bar\"],\n   start=1514764800000,\n   end=1546300800000,\n   aggregates=[\"max\", \"average\"],\n   granularity=\"1d\")\n\nraw_data = dps.value\nfirst_dps = dps_lst[0]  # optionally: `dps_lst.get(external_id=\"foo\")`\navg_data = first_dps.average\nmax_data = first_dps.max\n\ndps_slice = dps[-10:]  # Last ten values\ndp = dps[3]  # The third value\nfor dp in dps_slice:\n    pass  # do something!\n\nfrom cognite.client.data_classes import DatapointsQuery\ndps_lst = client.time_series.data.retrieve(\n    id=[\n        DatapointsQuery(id=42, end=\"1d-ago\", aggregates=\"average\"),\n        DatapointsQuery(id=69, end=\"2d-ago\", aggregates=[\"average\"]),\n        DatapointsQuery(id=96, end=\"3d-ago\", aggregates=[\"min\", \"max\", \"count\"]),\n    ],\n    external_id=DatapointsQuery(external_id=\"foo\", aggregates=\"max\"),\n    start=\"5d-ago\",\n    granularity=\"1h\")\n\ndps = client.time_series.data.retrieve(\n    id=123,\n    aggregates=\"sum\",\n    granularity=\"1month\",\n    timezone=\"Europe/Oslo\")\n\nfrom datetime import datetime, timezone\nutc = timezone.utc\ndps_lst = client.time_series.data.retrieve(\n    start=datetime(1907, 10, 14, tzinfo=utc),\n    end=datetime(1907, 11, 6, tzinfo=utc),\n    id=[42, 43, 44, ..., 499, 500],\n)\nts_350 = dps_lst.get(id=350)  # ``Datapoints`` object\n\nperiods = client.events.list(type=\"alarm\", subtype=\"pressure\")\nsensor_xid = \"foo-pressure-bar\"\ndps_lst = client.time_series.data.retrieve(\n    id=[42, 43, 44],\n    external_id=[\n        DatapointsQuery(external_id=sensor_xid, start=ev.start_time, end=ev.end_time)\n        for ev in periods\n    ])\nts_44 = dps_lst.get(id=44)  # Single ``Datapoints`` object\nts_lst = dps_lst.get(external_id=sensor_xid)  # List of ``len(periods)`` ``Datapoints`` objects\n\nimport itertools\nmonth_starts = [\n    datetime(year, month, 1, tzinfo=utc)\n    for year, month in itertools.product(range(2000, 2011), range(1, 13))]\ndps_lst = client.time_series.data.retrieve(\n    external_id=[DatapointsQuery(external_id=\"foo\", start=start) for start in month_starts],\n    limit=1)\n\nfrom cognite.client.utils import MIN_TIMESTAMP_MS, MAX_TIMESTAMP_MS\ndps_backup = client.time_series.data.retrieve(\n    id=123,\n    start=MIN_TIMESTAMP_MS,\n    end=MAX_TIMESTAMP_MS + 1)  # end is exclusive\n\nclient.time_series.data.retrieve(\n  id=42, start=\"2w-ago\", target_unit=\"temperature:deg_f\")\n\nclient.time_series.data.retrieve(\n  id=42, start=\"2w-ago\", target_unit_system=\"Imperial\")\n\ndps = client.time_series.data.retrieve(\n  id=42, include_status=True, ignore_bad_datapoints=False)\ndps.status_code  # list of integer codes, e.g.: [0, 1073741824, 2147483648]\ndps.status_symbol  # list of symbolic representations, e.g. [Good, Uncertain, Bad]\nfrom datetime import datetime, timezone\ndps = client.time_series.data.retrieve_arrays(\n    id=42,\n    start=datetime(2020, 1, 1, tzinfo=timezone.utc),\n    aggregates=[\"min\", \"max\"],\n    granularity=\"7d\")\nweekly_range = dps.max - dps.min\n\nimport numpy as np\ndps = client.time_series.data.retrieve_arrays(\n    external_id=\"ts-noisy\",\n    start=\"2d-ago\",\n    limit=2_000_000)\nsmooth = np.convolve(dps.value, np.ones(5) / 5)  # doctest: +SKIP\nsmoother = np.convolve(dps.value, np.ones(20) / 20)  # doctest: +SKIP\n\nid_lst = [42, 43, 44]\ndps_lst = client.time_series.data.retrieve_arrays(\n    id=id_lst,\n    start=\"2h-ago\",\n    include_outside_points=True,\n    ignore_unknown_ids=True)\nlargest_gaps = [np.max(np.diff(dps.timestamp)) for dps in dps_lst]\n\nimport pandas as pd\ndps = client.time_series.data.retrieve_arrays(external_id=\"bar\", start=\"10w-ago\")\nseries = pd.Series(dps.value, index=dps.timestamp)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<TimeseriesPoint> results = new ArrayList<>(); \n\nList<Item> byExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nclient.timeseries().dataPoints()\n          .retrieveComplete(byExternalIds) \n          .forEachRemaining(result -> results.addAll(result));//by list of items  \nclient.timeseries().dataPoints()\n          .retrieveComplete(\"10\", \"20\") \n          .forEachRemaining(result -> results.addAll(result));//by varargs of String \n\nList<Item> byInternalIds = List.of(Item.newBuilder().setId(10).build()); \nclient.timeseries().dataPoints()\n          .retrieveComplete(byInternalIds) \n          .forEachRemaining(result -> results.addAll(result));//by list of items \nclient.timeseries().dataPoints() \n          .retrieveComplete(10, 20) \n          .forEachRemaining(result -> results.addAll(result));//by varargs of Long \n\n//with filter\nclient.timeseries().dataPoints() \n          .retrieve(Request.create().withRootParameter(\"includeOutsidePoints\", true)) \n          .forEachRemaining(items-> results.addAll(items)); \n\n"
          }
        ]
      }
    },
    "/timeseries/data/latest": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Retrieve latest data point",
        "description": "Retrieves the latest data point in one or more time series. Note that the latest data point\nin a time series is the one with the highest timestamp, which is not necessarily the one\nthat was ingested most recently.\n",
        "operationId": "getLatest",
        "requestBody": {
          "description": "The list of the queries to perform.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatapointsLatestQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of responses. Each response contains a list with the most recent data point or an empty list if no data points are found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DatapointsResponse"
                }
              }
            }
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const datapoints = await client.datapoints.retrieveLatest([\n  {\n   before: 'now',\n   id: 123\n },\n {\n   externalId: 'abc',\n   before: new Date('21 jan 2018'),\n }\n]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.time_series.data.retrieve_latest(id=1)[0]\n\nres = client.time_series.data.retrieve_latest(id=1, before=\"2d-ago\")[0]\n\nres = client.time_series.data.retrieve_latest(id=1, target_unit=\"temperature:deg_f\")[0]\nres = client.time_series.data.retrieve_latest(id=1, target_unit_system=\"Imperial\")[0]\n\nfrom cognite.client.data_classes import LatestDatapointQuery\nres = client.time_series.data.retrieve_latest(id=LatestDatapointQuery(id=1, before=60_000))[0]\n\nres = client.time_series.data.retrieve_latest(external_id=[\"abc\", \"def\"])\nlatest_abc = res[0][0]\nlatest_def = res[1][0]\n\nfrom datetime import datetime, timezone\nid_queries = [\n    123,\n    LatestDatapointQuery(id=456, before=\"1w-ago\"),\n    LatestDatapointQuery(id=789, before=datetime(2018,1,1, tzinfo=timezone.utc)),\n    LatestDatapointQuery(id=987, target_unit=\"temperature:deg_f\")]\next_id_queries = [\n    \"foo\",\n    LatestDatapointQuery(external_id=\"abc\", before=\"3h-ago\", target_unit_system=\"Imperial\"),\n    LatestDatapointQuery(external_id=\"def\", include_status=True),\n    LatestDatapointQuery(external_id=\"ghi\", treat_uncertain_as_bad=False),\n    LatestDatapointQuery(external_id=\"jkl\", include_status=True, ignore_bad_datapoints=False)]\nres = client.time_series.data.retrieve_latest(\n    id=id_queries, external_id=ext_id_queries)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\").build()); \nList<TimeseriesPoint> result = \n          client.timeseries().dataPoints() \n          .retrieveLatest(byExternalIds);//by list of items \nList<TimeseriesPoint> result = \n          client.timeseries().dataPoints() \n          .retrieveLatest(\"10\", \"20\");//by varargs of String \n\nList<Item> byInternalIds = List.of(Item.newBuilder() \n          .setId(10).build()); \nList<TimeseriesPoint> result = \n           client.timeseries().dataPoints() \n          .retrieveLatest(byInternalIds);//by list of items \nList<TimeseriesPoint> result = \n          client.timeseries().dataPoints() \n          .retrieveLatest(10, 20);//by varargs of Long \n\n"
          }
        ]
      }
    },
    "/timeseries/data/delete": {
      "post": {
        "tags": [
          "Time series"
        ],
        "summary": "Delete data points",
        "description": "Delete data points from time series.",
        "operationId": "deleteDatapoints",
        "requestBody": {
          "description": "The list of delete requests to perform.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DatapointsDeleteQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.datapoints.delete([{id: 123, inclusiveBegin: new Date('1 jan 2019')}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "ranges = [{\"id\": 1, \"start\": \"2d-ago\", \"end\": \"now\"},\n          {\"external_id\": \"abc\", \"start\": \"2d-ago\", \"end\": \"now\"}]\nclient.time_series.data.delete_ranges(ranges)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\").build()); \nList<Item> deletedItems = \n           client.timeseries().dataPoints().delete(byExternalIds); \n\nList<Item> byInternalIds = List.of(Item.newBuilder() \n          .setId(10).build()); \n List<Item> deletedItems = \n          client.timeseries().dataPoints().delete(byInternalIds); \n\n"
          }
        ]
      }
    },
    "/timeseries/subscriptions": {
      "post": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "Create subscriptions",
        "description": "Create one or more subscriptions that can be used to listen for changes in data points for a set of time series.",
        "operationId": "postSubscriptions",
        "requestBody": {
          "description": "The subscriptions to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionsCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of subscriptions that were created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSubscriptionDTO"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import DataPointSubscriptionWrite\nsub = DataPointSubscriptionWrite(\n    external_id=\"my_subscription\",\n    name=\"My subscription\",\n    partition_count=1,\n    time_series_ids=[\"myFistTimeSeries\", \"mySecondTimeSeries\"])\ncreated = client.time_series.subscriptions.create(sub)\n\nfrom cognite.client.data_classes import DataPointSubscriptionWrite\nfrom cognite.client.data_classes.data_modeling import NodeId\nsub = DataPointSubscriptionWrite(\n    external_id=\"my_subscription\",\n    name=\"My subscription with Data Model Ids\",\n    partition_count=1,\n    instance_ids=[NodeId(\"my_space\", \"myFistTimeSeries\"), NodeId(\"my_space\", \"mySecondTimeSeries\")])\ncreated = client.time_series.subscriptions.create(sub)\n\nfrom cognite.client.data_classes import DataPointSubscriptionWrite\nfrom cognite.client.data_classes import filters as flt\nfrom cognite.client.data_classes.datapoints_subscriptions import DatapointSubscriptionProperty\nis_numeric_stepwise = flt.And(\n    flt.Equals(DatapointSubscriptionProperty.is_string, False),\n    flt.Equals(DatapointSubscriptionProperty.is_step, True))\nsub = DataPointSubscriptionWrite(\n    external_id=\"my_subscription\",\n    name=\"My subscription for numeric, stepwise time series\",\n    partition_count=1,\n    filter=is_numeric_stepwise)\ncreated = client.time_series.subscriptions.create(sub)\n"
          }
        ]
      },
      "get": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "List subscriptions",
        "description": "List all subscriptions for the tenant. Use nextCursor to paginate through the results.",
        "operationId": "listSubscriptions",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Limit on the number of results to return.",
            "schema": {
              "maximum": 100,
              "minimum": 1,
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "A complete list of subscriptions in the tenant.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSubscriptionDTOWithCursor"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "subscriptions = client.time_series.subscriptions.list(limit=5)\n"
          }
        ]
      }
    },
    "/timeseries/subscriptions/members": {
      "get": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "List subscription members",
        "description": "List all member time series for a subscription.\n\nFor non-filter subscriptions, either `externalId` or `instanceId` will be set. This is to be\nable to see if each time series was added by external id or instance id. If a time series\nhas been added to a subscription both by external id and by instance id, it will be listed\ntwice in the output. If a time series that belonged to the subscription has been deleted,\n`id` will not be set.\n\nUse `nextCursor` to paginate through the results.",
        "operationId": "listSubscriptionMembers",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Limit on the number of results to return.",
            "schema": {
              "maximum": 100,
              "minimum": 1,
              "type": "integer",
              "format": "int32",
              "default": 100
            }
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "name": "externalId",
            "description": "External id of the subscription.",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A complete list of member time series in the subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSubscriptionMemberDTOWithCursor"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import DataPointSubscriptionUpdate\nmembers = client.time_series.subscriptions.list_member_time_series(\"my_subscription\")\ntimeseries_external_ids = members.as_external_ids()\n"
          }
        ]
      }
    },
    "/timeseries/subscriptions/byids": {
      "post": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "Retrieve subscriptions",
        "description": "Retrieve one or more subscriptions by external ID.",
        "operationId": "getSubscriptionsByIds",
        "requestBody": {
          "description": "Specify a list of the subscriptions to retrieve.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionsByIdsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "The retrieved subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSubscriptionDTO"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.time_series.subscriptions.retrieve(\"my_subscription\")\n"
          }
        ]
      }
    },
    "/timeseries/subscriptions/update": {
      "post": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "Update subscriptions",
        "description": "Updates one or more subscriptions. Fields that are not included in the request, are not changed.\n\nIf both `instanceIds` and `timeSeriesIds` are set, they must either both be add/remove or\nboth be set operations.",
        "operationId": "updateSubscriptions",
        "requestBody": {
          "description": "The subscriptions to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionsUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A list of subscriptions updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSubscriptionDTO"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import DataPointSubscriptionUpdate\nupdate = DataPointSubscriptionUpdate(\"my_subscription\").name.set(\"My New Name\")\nupdated = client.time_series.subscriptions.update(update)\n\nfrom cognite.client.data_classes import DataPointSubscriptionUpdate\nupdate = DataPointSubscriptionUpdate(\"my_subscription\").time_series_ids.add([\"MyNewTimeSeriesExternalId\"])\nupdated = client.time_series.subscriptions.update(update)\n"
          }
        ]
      }
    },
    "/timeseries/subscriptions/delete": {
      "post": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "Delete subscriptions",
        "description": "Delete subscription(s). This operation cannot be undone",
        "operationId": "deleteSubscriptions",
        "requestBody": {
          "description": "Specify a list of the subscriptions to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionsDeleteRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "description": "IDs not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.time_series.subscriptions.delete(\"my_subscription\")\n"
          }
        ]
      }
    },
    "/timeseries/subscriptions/data/list": {
      "post": {
        "tags": [
          "Data point subscriptions"
        ],
        "summary": "List subscription data",
        "description": "Fetch the next batch of data from a given subscription and partition(s).\nData can be ingested datapoints and time ranges where data is deleted.\nThis endpoint will also return changes to the subscription itself, that is, if time series\nare added or removed from the subscription.\n\nThe data can be returned multiple times, there is no mechanism to acknowledge or delete data.\nUse cursors to paginate through the results.",
        "operationId": "listSubscriptionData",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubscriptionsListDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A batch of data from the subscription.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubscriptionsListDataResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "timeSeriesSubscriptionsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "for batch in client.time_series.subscriptions.iterate_data(\"my_subscription\"):\n    # Changes to the subscription itself:\n    print(f\"Added {len(batch.subscription_changes.added)} timeseries\")\n    print(f\"Removed {len(batch.subscription_changes.removed)} timeseries\")\n    print(f\"Changed timeseries data in {len(batch.updates)} updates\")\n    # Changes to datapoints for time series in the subscription:\n    for update in batch.updates:\n        upserts.time_series  # The time series the update belongs to\n        upserts.upserts  # The upserted datapoints, if any\n        upserts.deletes  # Ranges of deleted periods, if any\n    if not batch.has_next:\n        break\n\nfor batch in client.time_series.subscriptions.iterate_data(\"my_subscription\", \"3d-ago\"):\n    pass  # do something\n"
          }
        ]
      }
    },
    "/timeseries/synthetic/query": {
      "post": {
        "tags": [
          "Synthetic Time Series"
        ],
        "summary": "Synthetic query",
        "description": "Execute an on-the-fly synthetic query",
        "operationId": "querySyntheticTimeseries",
        "requestBody": {
          "description": "The list of queries to perform",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SyntheticMultiQuery"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "List of datapoints for the specified queries.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SyntheticQueryResponses"
                }
              }
            }
          },
          "400": {
            "description": "Query error"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.timeseries.syntheticQuery([\n  {\n    expression: \"24 * TS{externalId='production/hour', aggregate='average', granularity='1d'}\",\n    start: '48h-ago',\n    end: 'now',\n    limit: 100\n  }\n]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "expression = '''\n    123\n    + ts{id:123}\n    + ts{externalId:'abc'}\n    + ts{space:'my-space',externalId:'my-ts-xid'}\n'''\ndps = client.time_series.data.synthetic.query(\n    expressions=expression,\n    start=\"2w-ago\",\n    end=\"now\")\n\nfrom cognite.client.data_classes.data_modeling.ids import NodeId\nts = client.time_series.retrieve(id=123)\nvariables = {\n    \"A\": ts,\n    \"B\": \"my_ts_external_id\",\n    \"C\": NodeId(\"my-space\", \"my-ts-xid\"),\n}\ndps = client.time_series.data.synthetic.query(\n    expressions=\"A+B+C\", start=\"2w-ago\", end=\"now\", variables=variables)\n\nfrom sympy import symbols, cos, sin\nx, y = symbols(\"x y\")\ndps = client.time_series.data.synthetic.query(\n    [sin(x), y*cos(x)],\n    start=\"2w-ago\",\n    end=\"now\",\n    variables={x: \"foo\", y: \"bar\"},\n    aggregate=\"interpolation\",\n    granularity=\"15m\",\n    target_unit=\"temperature:deg_c\")\n"
          }
        ]
      }
    },
    "/raw/dbs": {
      "get": {
        "tags": [
          "Raw"
        ],
        "summary": "List databases",
        "operationId": "getDBs",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Limit on the number of databases to be returned.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 1000,
              "default": 25
            }
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of databases.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataWithCursorRawDB"
                }
              }
            }
          }
        },
        "x-capability": [
          "rawAcl:LIST"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const databases = await client.raw.listDatabases();"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "db_list = client.raw.databases.list(limit=5)\n\nfor db in client.raw.databases:\n    db # do something with the db\n\nfor db_list in client.raw.databases(chunk_size=2500):\n    db_list # do something with the dbs\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> listDatabaseResults = new ArrayList<>(); \nclient.raw() \n          .databases() \n          .list() \n          .forEachRemaining(listDatabaseResults::addAll); \n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Raw"
        ],
        "summary": "Create databases",
        "description": "Create databases in a project. It is possible to post a maximum of 1000 databases per request.",
        "operationId": "createDBs",
        "requestBody": {
          "description": "List of names of databases to be created.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataRawDB"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created databases.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataRawDB"
                }
              }
            }
          }
        },
        "x-capability": [
          "rawAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const databases = await client.raw.createDatabases([{ name: 'My company' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.raw.databases.create(\"db1\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> createDatabasesList = \n          List.of(StringValue.of(\"dbName\").getValue()); \nclient.raw().databases().create(createDatabasesList);"
          }
        ]
      }
    },
    "/raw/dbs/delete": {
      "post": {
        "tags": [
          "Raw"
        ],
        "summary": "Delete databases",
        "description": "It deletes a database, but fails if the database is not empty and recursive is set to false (default).",
        "operationId": "deleteDBs",
        "requestBody": {
          "description": "List of names of the databases to be deleted.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteRawDB"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "rawAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.raw.deleteDatabases([{ name: 'My company' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.raw.databases.delete([\"db1\", \"db2\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> createDatabasesList = \n          List.of(StringValue.of(\"dbName\").getValue()); \nList<String> deleteItemsResults = \n          client.raw().databases().delete(createDatabasesList); \n\n //Allows to recursively \nclient.raw().databases().delete(createDatabasesList, true); \n\n"
          }
        ]
      }
    },
    "/raw/dbs/{dbName}/tables": {
      "get": {
        "tags": [
          "Raw"
        ],
        "summary": "List tables in a database",
        "operationId": "getTables",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "The name of a database to retrieve tables from.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Limit on the number of tables to be returned.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 1000,
              "default": 25
            }
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "A list of tables in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataWithCursorRawDBTable"
                }
              }
            }
          }
        },
        "x-capability": [
          "rawAcl:LIST"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const tables = await client.raw.listTables('My company');"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "table_list = client.raw.tables.list(\"db1\", limit=5)\n\nfor table in client.raw.tables(db_name=\"db1\"):\n    table # do something with the table\n\nfor table_list in client.raw.tables(db_name=\"db1\", chunk_size=2500):\n    table_list # do something with the tables\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> tablesResults = new ArrayList<>(); \nclient.raw().tables() \n          .list(\"dbName\") \n          .forEachRemaining(tablesResults::addAll); \n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Raw"
        ],
        "summary": "Create tables in a database",
        "description": "Create tables in a database. It is possible to post a maximum of 1000 tables per request.",
        "operationId": "createTables",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database to create tables in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ensureParent",
            "in": "query",
            "description": "Create database if it doesn't exist already",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "List of tables to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataRawDBTable"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "The created tables.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataRawDBTable"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/MissingField"
          }
        },
        "x-capability": [
          "rawAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const tables = await client.raw.createTables('My company', [{ name: 'Customers' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.raw.tables.create(\"db1\", \"table1\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> createTablesLists = \n          List.of(StringValue.of(\"tableName\").getValue()); \nclient.raw().tables().create(\"dbName\", createTablesLists, false); \n\n"
          }
        ]
      }
    },
    "/raw/dbs/{dbName}/tables/delete": {
      "post": {
        "tags": [
          "Raw"
        ],
        "summary": "Delete tables in a database",
        "operationId": "deleteTables",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database to delete tables in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "List of tables to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataRawDBTable"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/MissingField"
          }
        },
        "x-capability": [
          "rawAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.raw.deleteTables('My company', [{ name: 'Customers' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.raw.tables.delete(\"db1\", [\"table1\", \"table2\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> listDeleted = \n          client.raw().tables().delete(\"dbName\", List.of(\"TablesName\")); \n\n"
          }
        ]
      }
    },
    "/raw/dbs/{dbName}/tables/{tableName}/cursors": {
      "get": {
        "tags": [
          "Raw"
        ],
        "summary": "Retrieve cursors for parallel reads",
        "description": "Retrieve cursors based on the last updated time range. Normally this endpoint is used for reading in parallel.\n\nEach cursor should be supplied as the 'cursor' query parameter on GET requests to [Read Rows](#operation/getRows).\n**Note** that the 'minLastUpdatedTime' and the 'maxLastUpdatedTime' query parameter on [Read Rows](#operation/getRows) are ignored when a cursor is specified.\n",
        "operationId": "getCursors",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tableName",
            "in": "path",
            "description": "Name of the table.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "minLastUpdatedTime",
            "in": "query",
            "description": "An exclusive filter, specified as the number of milliseconds that have elapsed since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "name": "maxLastUpdatedTime",
            "in": "query",
            "description": "An inclusive filter, specified as the number of milliseconds that have elapsed since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "name": "numberOfCursors",
            "in": "query",
            "description": "The number of cursors to return, by default it's 10.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 10000
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with cursors",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataRawDBTableCursors"
                }
              }
            }
          }
        },
        "x-capability": [
          "rawAcl:READ"
        ]
      }
    },
    "/raw/dbs/{dbName}/tables/{tableName}/rows": {
      "get": {
        "tags": [
          "Raw"
        ],
        "summary": "Retrieve rows from a table",
        "operationId": "getRows",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "tableName",
            "in": "path",
            "description": "Name of the table.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Limit the number of results. The API may return fewer than the specified limit.",
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 10000,
              "default": 25
            }
          },
          {
            "name": "columns",
            "in": "query",
            "description": "Ordered list of column keys, separated by commas. Leave empty for all, use single comma to retrieve only row keys.",
            "schema": {
              "type": "string",
              "example": "column1,column2"
            }
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "name": "minLastUpdatedTime",
            "in": "query",
            "description": "An exclusive filter, specified as the number of milliseconds that have elapsed since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          },
          {
            "name": "maxLastUpdatedTime",
            "in": "query",
            "description": "An inclusive filter, specified as the number of milliseconds that have elapsed since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "schema": {
              "$ref": "#/components/schemas/EpochTimestamp"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Rows returned",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataWithCursorRawDBRow"
                }
              },
              "text/csv": {
                "schema": {
                  "$ref": "#/components/schemas/RawRowCSV"
                }
              }
            }
          }
        },
        "x-capability": [
          "rawAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.raw.listRows('My company', 'Employees', { columns: ['last_name'] });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "row_list = client.raw.rows.list(\"db1\", \"tbl1\", limit=5)\n\nrow_list = client.raw.rows.list(\"db1\", \"tbl1\", limit=None)\n\nfor row in client.raw.rows(\"db1\", \"t1\", columns=[\"col1\",\"col2\"]):\n    val1 = row[\"col1\"]  # You may access the data directly\n    val2 = row.get(\"col2\")  # ...or use '.get' when keys can be missing\n\nfor row_list in client.raw.rows(\"db1\", \"t1\", chunk_size=2500):\n    row_list  # Do something with the rows\n\nrows_iterator = client.raw.rows(\n    db_name=\"db1\", table_name=\"t1\", partitions=5, chunk_size=5000, limit=1_000_000\n)\nfor row_list in rows_iterator:\n    row_list  # Do something with the rows\ndf = client.raw.rows.retrieve_dataframe(\"db1\", \"t1\", limit=5)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<RawRow> listRowsResults = new ArrayList<>(); \nclient.raw().rows().list(\"dbName\", \"TablesName\") \n          .forEachRemaining(listRowsResults::addAll); \n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Raw"
        ],
        "summary": "Insert rows into a table",
        "description": "Insert rows into a table. It is possible to post a maximum of 10000 rows per request.\nIt will replace the columns of an existing row if the rowKey already exists.\n\nThe rowKey is limited to 1024 characters which also includes Unicode characters.\nThe maximum size of columns are 5 MiB, however the maximum size of one column name and value is 2621440 characters each.\nIf you want to store huge amount of data per row or column we recommend using the Files API to upload blobs, then reference it from the Raw row.\n\nThe columns object is a key value object, where the key corresponds to the column name while the value is the column value.\nIt supports all the valid types of values in JSON, so number, string, array, and even nested JSON structure (see payload example to the right).\n\nIf an error occurs during the write, partial data may be written as there is no rollback. However, it's safe to retry the request, since this endpoint supports both update and insert (upsert).\n\nA row's last updated timestamp will only be updated if the new column contents are considered different to the old one. An identical JSON string should always be counted as the same contents.\n",
        "operationId": "postRows",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database.",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "maxLength": 32
            }
          },
          {
            "name": "tableName",
            "in": "path",
            "description": "Name of the table.",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "maxLength": 64
            }
          },
          {
            "name": "ensureParent",
            "in": "query",
            "description": "Create database/table if it doesn't exist already",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "List of rows to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataRawDBRow"
              },
              "example": {
                "items": [
                  {
                    "key": "some rowKey",
                    "columns": {
                      "some int-col": 10,
                      "some string-col": "string example",
                      "some json-col": {
                        "test": {
                          "foo": "nested"
                        }
                      },
                      "some array-col": [
                        0,
                        1,
                        3,
                        4
                      ]
                    }
                  }
                ]
              }
            },
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "file": {
                    "type": "object"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/MissingField"
          }
        },
        "x-capability": [
          "rawAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.raw.insertRows('My company', 'Customers', [{ key: 'customer1', columns: { 'First name': 'Steve', 'Last name': 'Jobs' } }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import RowWrite\nrows = [RowWrite(key=\"r1\", columns={\"col1\": \"val1\", \"col2\": \"val1\"}),\n        RowWrite(key=\"r2\", columns={\"col1\": \"val2\", \"col2\": \"val2\"})]\nclient.raw.rows.insert(\"db1\", \"table1\", rows)\n\nrows = {\n    \"key-1\": {\"col1\": 1, \"col2\": 2},\n    \"key-2\": {\"col1\": 3, \"col2\": 4, \"col3\": \"high five\"},\n}\nclient.raw.rows.insert(\"db1\", \"table1\", rows)\nimport pandas as pd\ndf = pd.DataFrame(\n    {\"col-a\": [1, 3, None], \"col-b\": [2, -1, 9]},\n    index=[\"r1\", \"r2\", \"r3\"])\nres = client.raw.rows.insert_dataframe(\n    \"db1\", \"table1\", df, dropna=True)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<RawRow> createRowsList = List.of(RawRow.newBuilder() \n          .setDbName(\"dbName\") \n          .setTableName(\"tableName\") \n          .setKey(\"key\") \n          .setColumns(Struct.newBuilder() \n               .putFields(\"string\", Values.of(\"VAL\")) \n               .putFields(\"numeric\", Values.of(\"VAL\")) \n               .putFields(\"bool\", Values.of(ThreadLocalRandom.current().nextBoolean()))  \n               .putFields(\"null_value\", Values.ofNull())  \n               .putFields(\"array\", Values.of(ListValue.newBuilder()  \n                    .addValues(Values.of(ThreadLocalRandom.current().nextDouble(10000d)))  \n                    .build())) \n               .putFields(\"struct\", Values.of(Structs.of(\"nestedString\", Values.of(\"myTrickyStringValue\") \n               ))) \n          ).build()); \n\nList<RawRow> createRowsResults = client.raw().rows().upsert(createRowsList, false); \n\n"
          }
        ]
      }
    },
    "/raw/dbs/{dbName}/tables/{tableName}/rows/{rowKey}": {
      "get": {
        "tags": [
          "Raw"
        ],
        "summary": "Retrieve row by key",
        "operationId": "getRow",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database to retrieve the row from.",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "maxLength": 32
            }
          },
          {
            "name": "tableName",
            "in": "path",
            "description": "Name of the table to retrieve the row from.",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "maxLength": 64
            }
          },
          {
            "name": "rowKey",
            "in": "path",
            "description": "Row key of the row to retrieve.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Single row from the raw database table with the specified rowKey.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RawDBRow"
                }
              }
            }
          }
        },
        "x-capability": [
          "rawAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.raw.retrieveRow('My company', 'Customers', 'customer1');"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "row = client.raw.rows.retrieve(\"db1\", \"t1\", \"k1\")\n\nval1 = row[\"col1\"]\nval2 = row.get(\"col2\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<String> rowsToRetrieve = createRowsList.stream() \n          .filter(row -> ThreadLocalRandom.current().nextBoolean()) \n          .map(row -> row.getKey()) \n          .collect(Collectors.toList()); \n\nList<RawRow> rowsRetrieved = \n          client.raw().rows().retrieve(\"dbName\", \"tableName\", rowsToRetrieve); \n\n"
          }
        ]
      }
    },
    "/raw/dbs/{dbName}/tables/{tableName}/rows/delete": {
      "post": {
        "tags": [
          "Raw"
        ],
        "summary": "Delete rows in a table",
        "operationId": "deleteRows",
        "parameters": [
          {
            "name": "dbName",
            "in": "path",
            "description": "Name of the database containing the rows.",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "maxLength": 32
            }
          },
          {
            "name": "tableName",
            "in": "path",
            "description": "Name of the table containing the rows.",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1,
              "maxLength": 64
            }
          }
        ],
        "requestBody": {
          "description": "Keys to the rows to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataRawDBRowKey"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "rawAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.raw.deleteRows('My company', 'Customers', [{key: 'customer1'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "keys_to_delete = [\"k1\", \"k2\", \"k3\"]\nclient.raw.rows.delete(\"db1\", \"table1\", keys_to_delete)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<RawRow> rowsToDelete = //list of RawRow; \nList<RawRow> deleteRowResults = client.raw().rows().delete(rowsToDelete); \n\n"
          }
        ]
      }
    },
    "/groups": {
      "get": {
        "tags": [
          "Groups"
        ],
        "summary": "List groups",
        "description": "Retrieves a list of groups the asking principal a member of. Principals with groups:list capability can optionally ask for all groups in a project.",
        "operationId": "getGroups",
        "parameters": [
          {
            "name": "all",
            "in": "query",
            "description": "Whether to get all groups, only available with the groups:list acl.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of groups.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGroup"
                }
              }
            }
          }
        },
        "x-capability": [
          "groupsAcl:LIST"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const groups = await client.groups.list({ all: true });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "my_groups = client.iam.groups.list()\n\nall_groups = client.iam.groups.list(all=True)\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Groups"
        ],
        "summary": "Create groups",
        "description": "Creates one or more named groups, each with a set of capabilities.",
        "operationId": "createGroups",
        "requestBody": {
          "description": "List of groups to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataGroupSpec"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of the created groups.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGroup"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/MissingField"
          }
        },
        "x-capability": [
          "groupsAcl:CREATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const createdGroups = await client.groups.create([{\n  name: 'Developers',\n  capabilities: [{\n    assetsAcl: {\n      actions: ['READ'],\n      scope: { all: {}}\n    }\n  }],\n}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import GroupWrite\nfrom cognite.client.data_classes.capabilities import AssetsAcl, EventsAcl\nmy_capabilities = [\n    AssetsAcl([AssetsAcl.Action.Read], AssetsAcl.Scope.All()),\n    EventsAcl([EventsAcl.Action.Write], EventsAcl.Scope.DataSet([123, 456]))]\nmy_group = GroupWrite(name=\"My Group\", capabilities=my_capabilities)\nres = client.iam.groups.create(my_group)\n\ngrp = GroupWrite(\n    name=\"Externally managed group\",\n    capabilities=my_capabilities,\n    source_id=\"b7c9a5a4...\")\nres = client.iam.groups.create(grp)\n\nfrom cognite.client.data_classes import ALL_USER_ACCOUNTS\nall_group = GroupWrite(\n    name=\"Everyone is welcome!\",\n    capabilities=my_capabilities,\n    members=ALL_USER_ACCOUNTS,\n)\nuser_list_group = GroupWrite(\n    name=\"Specfic users only\",\n    capabilities=my_capabilities,\n    members=[\"XRsSD1k3mTIKG\", \"M0SxY6bM9Jl\"])\nres = client.iam.groups.create([user_list_group, all_group])\n\nfrom cognite.client.data_classes.capabilities import Capability\nunparsed_capabilities = [\n    {'assetsAcl': {'actions': ['READ', 'WRITE'], 'scope': {'all': {}}}},\n    {'eventsAcl': {'actions': ['WRITE'], 'scope': {'datasetScope': {'ids': [123]}}}},\n]\nacls = [Capability.load(cap) for cap in unparsed_capabilities]\ngroup = GroupWrite(name=\"Another group\", capabilities=acls)\n"
          }
        ]
      }
    },
    "/groups/delete": {
      "post": {
        "tags": [
          "Groups"
        ],
        "summary": "Delete groups",
        "description": "Deletes the groups with the given IDs.",
        "operationId": "deleteGroups",
        "requestBody": {
          "description": "List of group IDs to delete",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataLong"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "groupsAcl:DELETE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.groups.delete([921923342342323, 871621872721323]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.iam.groups.delete(1)\n"
          }
        ]
      }
    },
    "/projects": {},
    "/projects/{project}": {
      "parameters": [
        {
          "$ref": "#/components/parameters/project"
        }
      ]
    },
    "/update": {},
    "/securitycategories": {
      "get": {
        "tags": [
          "Security categories"
        ],
        "summary": "List security categories",
        "description": "Retrieves a list of all security categories for a project.",
        "operationId": "getSecurityCategories",
        "parameters": [
          {
            "name": "sort",
            "in": "query",
            "description": "Sort descending or ascending.",
            "schema": {
              "type": "string",
              "enum": [
                "ASC",
                "DESC"
              ],
              "default": "ASC"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "Cursor to use for paging through results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Return up to this many results. Maximum is 1000. Default is 25.",
            "schema": {
              "maximum": 1000,
              "type": "integer",
              "format": "int32",
              "default": 25
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of security categories.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SecurityCategoryWithCursorResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "securityCategoriesAcl:LIST"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const securityCategories = await client.securityCategories.list({ sort: 'ASC' });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.iam.security_categories.list()\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SecurityCategory> listSecurityCategoriesResults = new ArrayList<>(); \nclient.securityCategories(). \n          list(Request.create()) \n          .forEachRemaining(labels -> listSecurityCategoriesResults.addAll(labels)); \n\n "
          }
        ]
      },
      "post": {
        "tags": [
          "Security categories"
        ],
        "summary": "Create security categories",
        "description": "Creates security categories with the given names. Duplicate names in the request are ignored.\nIf a security category with one of the provided names exists already, then the request will fail and no security categories are created.\n",
        "operationId": "createSecurityCategories",
        "requestBody": {
          "description": "List of categories to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSecurityCategorySpecDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "A list of security categories.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SecurityCategoryResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "securityCategoriesAcl:CREATE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const securityCategories = [\n  { name: 'Admins' },\n  { name: 'Developers' },\n];\nconst createdSecurityCategories = await client.securityCategories.create(securityCategories);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import SecurityCategoryWrite\nmy_category = SecurityCategoryWrite(name=\"My Category\")\nres = client.iam.security_categories.create(my_category)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SecurityCategory> createSecurityCategoriesList = \n       List.of(SecurityCategory.newBuilder().setName(\"Name\").build()); \nclient.securityCategories().create(createSecurityCategoriesList); \n\n "
          }
        ]
      }
    },
    "/securitycategories/delete": {
      "post": {
        "tags": [
          "Security categories"
        ],
        "summary": "Delete security categories",
        "description": "Deletes the security categories that match the provided IDs.\nIf any of the provided IDs does not belong to an existing security category, then the request will fail and no security categories are deleted.\n",
        "operationId": "deleteSecurityCategories",
        "requestBody": {
          "description": "List of security category IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataLong"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "securityCategoriesAcl:DELETE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.securityCategories.delete([123, 456]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.iam.security_categories.delete(1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SecurityCategory> deleteItemsResults = \n          client.securityCategories() \n          .delete(listSecurityCategoriesResults); \n\n "
          }
        ]
      }
    },
    "/datasets": {
      "post": {
        "tags": [
          "Data sets"
        ],
        "summary": "Create data sets",
        "description": "You can create a maximum of 10 data sets per request.",
        "operationId": "createDataSets",
        "requestBody": {
          "description": "List of the data sets to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSetSpecList"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "datasetsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataSetListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const datasets = [\n  { externalId: 'sensitiveData' },\n  { writeProtected: true }\n];\nconst createdDatasets = await client.datasets.create(datasets);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import DataSetWrite\ndata_sets = [DataSetWrite(name=\"1st level\"), DataSetWrite(name=\"2nd level\")]\nres = client.data_sets.create(data_sets)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<DataSet> upsertDataSetList = List.of(DataSet.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"generated-\") \n          .setDescription(\"Generated description\") \n          .putMetadata(\"type\", \"sdk-data-generator\") \n          .putMetadata(\"source\", \"sdk-data-generator\") \n          .build()); \n\nList<DataSet> upsertDataSetsResults = \n          client.datasets().upsert(upsertDataSetList); \n\n"
          }
        ]
      }
    },
    "/datasets/list": {
      "post": {
        "tags": [
          "Data sets"
        ],
        "summary": "Filter data sets",
        "description": "Use advanced filtering options to find data sets.",
        "operationId": "listDataSets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSetFilterRequest"
              }
            }
          }
        },
        "x-capability": [
          "datasetsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataSetFilterResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const dataSets = await client.datasets.list({ filter: { createdTime: { min: new Date('1 jan 2018'), max: new Date('1 jan 2019') }}});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "data_sets_list = client.data_sets.list(limit=5, write_protected=False)\n\nfor data_set in client.data_sets:\n    data_set # do something with the data_set\n\nfor data_set_list in client.data_sets(chunk_size=2500):\n    data_set_list # do something with the list\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<DataSet> listDataSetsResults = new ArrayList<>(); \nclient.datasets() \n          .list(Request.create()) \n          .forEachRemaining(batch -> listDataSetsResults.addAll(batch)); \n\n"
          }
        ]
      }
    },
    "/datasets/aggregate": {
      "post": {
        "tags": [
          "Data sets"
        ],
        "summary": "Aggregate data sets",
        "description": "Aggregate data sets in the same project. Criteria can be applied to select a subset of data sets.",
        "operationId": "aggregateDataSets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSetAggregateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataSetAggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "datasetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregates = await client.datasets.aggregate({ filter: { writeProtected: true } });\nconsole.log('Number of write protected datasets: ', aggregates[0].count)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "aggregate_protected = client.data_sets.aggregate(filter={\"write_protected\": True})\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Aggregate aggregate = client \n          .datasets() \n          .aggregate(Request.create() \n          .withFilterParameter(\"source\",\"sdk-data-generator\")); \n\n"
          }
        ]
      }
    },
    "/datasets/byids": {
      "post": {
        "tags": [
          "Data sets"
        ],
        "summary": "Retrieve data sets",
        "description": "Retrieve data sets by IDs or external IDs.",
        "operationId": "getDataSets",
        "requestBody": {
          "description": "List of the IDs of the data sets to retrieve. You can retrieve a maximum of 1000 data sets per request. All IDs must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSetIdEitherList"
              }
            }
          }
        },
        "x-capability": [
          "datasetsAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataSetListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const dataSets = await client.datasets.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.data_sets.retrieve(id=1)\n\nres = client.data_sets.retrieve(external_id=\"1\")\nres = client.data_sets.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.data_sets.retrieve_multiple(external_ids=[\"abc\", \"def\"], ignore_unknown_ids=True)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> retrieveByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nList<DataSet> retrieveDataSetResults = client.datasets() \n          .retrieve(retrieveByExternalIds);//by list of items \nList<DataSet> retrieveDataSetResults = client.datasets() \n          .retrieve(\"10\", \"20\");//by varargs of String \n\nList<Item> retrieveByInternalIds = List.of(Item.newBuilder() \n          .setId(10) \n          .build()); \nList<DataSet> retrieveDataSetResults = client.datasets() \n          .retrieve(retrieveByInternalIds);//by list of items \nList<DataSet> retrieveDataSetResults = client.datasets() \n          .retrieve(10, 20);//by varargs of Long \n\n"
          }
        ]
      }
    },
    "/datasets/update": {
      "post": {
        "tags": [
          "Data sets"
        ],
        "summary": "Update data sets.",
        "operationId": "updateDataSets",
        "requestBody": {
          "description": "All provided IDs and external IDs must be unique. Fields that are not included in the request, are not changed.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSetUpdateList"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "datasetsAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DataSetListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const dataSets = await client.datasets.update([{id: 123, update: {description: {set: 'New description'}}}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "data_set = client.data_sets.retrieve(id=1)\ndata_set.description = \"New description\"\nres = client.data_sets.update(data_set)\n\nfrom cognite.client.data_classes import DataSetUpdate\nmy_update = DataSetUpdate(id=1).description.set(\"New description\").metadata.remove([\"key\"])\nres = client.data_sets.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<DataSet> upsertDataSetList = //list of DataSet; \nList<DataSet> upsertDataSetsResults = \n          client.datasets().upsert(upsertDataSetList); \n\n"
          }
        ]
      }
    },
    "/sequences": {
      "get": {
        "tags": [
          "Sequences"
        ],
        "summary": "List sequences",
        "operationId": "listSequences",
        "description": "List sequences. Use `nextCursor` to paginate through the results.",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/partition"
          },
          {
            "in": "query",
            "name": "limit",
            "description": "Limits the number of results to be returned. The server returns a maximum of 1000 results even if you specify a higher limit.",
            "schema": {
              "type": "integer",
              "default": 25,
              "minimum": 1,
              "maximum": 1000
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Paged response with a list of sequences.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SequenceWithCursorResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const sequences = await client.sequences.list({ filter: { name: 'sequence_name' } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nasset_filter = filters.Equals(\"asset_id\", 123)\nis_efficiency = filters.Equals([\"metadata\", \"type\"], \"efficiency\")\nres = client.sequences.filter(filter=filters.And(asset_filter, is_efficiency), sort=\"created_time\")\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.sequences import SequenceProperty, SortableSequenceProperty\nasset_filter = filters.Equals(SequenceProperty.asset_id, 123)\nis_efficiency = filters.Equals(SequenceProperty.metadata_key(\"type\"), \"efficiency\")\nres = client.sequences.filter(\n    filter=filters.And(asset_filter, is_efficiency),\n    sort=SortableSequenceProperty.created_time)\nres = client.sequences.list(limit=5)\n\nfor seq in client.sequences:\n    seq # do something with the sequence\n\nfor seq_list in client.sequences(chunk_size=2500):\n    seq_list # do something with the sequences\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.sequences.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.sequences import SequenceProperty, SortableSequenceProperty\nin_timezone = filters.Prefix(SequenceProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.sequences.list(\n    advanced_filter=in_timezone,\n    sort=(SortableSequenceProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.sequences.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Create sequences",
        "description": "Create one or more sequences.",
        "operationId": "createSequence",
        "requestBody": {
          "description": "Sequence to be stored.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataPostSequence"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Response with the created sequence.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetSequence"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "sequencesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const sequences = [\n {\n  externalId: 'sequence_name',\n  columns: [\n   {\n     externalId: 'one',\n     valueType: SequenceValueType.LONG,\n   },\n   {\n     externalId: 'two',\n   },\n   {\n     externalId: 'three',\n     valueType: SequenceValueType.STRING,\n   }\n  ]\n }\n];\nconst [sequence] = await client.sequences.create(sequences);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import SequenceWrite, SequenceColumnWrite\ncolumn_def = [\n    SequenceColumnWrite(value_type=\"String\", external_id=\"user\", description=\"some description\"),\n    SequenceColumnWrite(value_type=\"Double\", external_id=\"amount\")\n]\nseq = client.sequences.create(SequenceWrite(external_id=\"my_sequence\", columns=column_def))\n\nseq2 = client.sequences.create(SequenceWrite(external_id=\"my_copied_sequence\", columns=column_def))\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SequenceColumn> columns = List.of(SequenceColumn.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"test_column_\") \n          .setDescription(\"Description\") \n          .setValueTypeValue(SequenceColumn.ValueType.STRING_VALUE) \n     .build()); \n\n List<SequenceMetadata> upsertSequencesList = List.of( SequenceMetadata.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"test_sequence_\") \n          .setDescription(\"Description\") \n          .putMetadata(\"type\", \"sdk-data-generator\") \n          .addAllColumns(columns) \n     .build()); \n\n client.sequences().upsert(upsertSequencesList); \n\n"
          }
        ]
      }
    },
    "/sequences/list": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Filter sequences",
        "description": "<details>\n<summary>\nRetrieves a list of sequences that match the given criteria.\n</summary>\n\n### Advanced filtering\n\nThe `advancedFilter`\nfield lets you create complex filtering expressions that combine simple operations,\nsuch as `equals`, `prefix`, and `exists`, by using the Boolean operators `and`, `or`, and `not`.\nFiltering applies to basic fields as well as metadata. See the `advancedFilter` syntax in the request example.\n\n\n\n#### Supported leaf filters\n\n| Leaf filter    | Supported fields       | Description and example                                                                                                                                                            |\n|----------------|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `containsAll`  | Array type fields      | Only includes results which contain all of the specified values. <br /> `{\"containsAll\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                         |\n| `containsAny`  | Array type fields      | Only includes results which contain at least one of the specified values. <br /> `{\"containsAny\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                |\n| `equals`       | Non-array type fields  | Only includes results that are equal to the specified value. <br /> `{\"equals\": {\"property\": [\"property\"], \"value\": \"example\"}}`                                                   |\n| `exists`       | All fields             | Only includes results where the specified property exists (has a value). <br /> `{\"exists\": {\"property\": [\"property\"]}}`                                                           |\n| `in`           | Non-array type fields  | Only includes results that are equal to one of the specified values. <br /> `{\"in\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                              |\n| `prefix`       | String type fields     | Only includes results which start with the specified text. <br /> `{\"prefix\": {\"property\": [\"property\"], \"value\": \"example\"}}`                                                     |\n| `range`        | Non-array type fields  | Only includes results that fall within the specified range. <br /> `{\"range\": {\"property\": [\"property\"], \"gt\": 1, \"lte\": 5}}` <br /> Supported operators: `gt`, `lt`, `gte`, `lte` |\n | `search`       | `[\"name\"]` and `[\"description\"]` | Introduced to provide functional parity with the /sequences/search endpoint. <br /> `{\"search\": {\"property\": [\"property\"], \"value\": \"example\"}}`                        |\n\n#### Supported properties\n\n| Property                          | Type               |\n|-----------------------------------|--------------------|\n| `[\"description\"]`                 | string             |\n| `[\"externalId\"]`                  | string             |\n| `[\"metadata\", \"<someCustomKey>\"]` | string             |\n| `[\"name\"]`                        | string             |\n| `[\"assetId\"]`                      | number              |\n| `[\"assetRootId\"]`                  | number              |\n| `[\"createdTime\"]`                  | number              |\n| `[\"dataSetId\"]`                    | number              |\n| `[\"id\"]`                           | number              |\n| `[\"lastUpdatedTime\"]`              | number              |\n| `[\"accessCategories\"]`             | array of strings    |\n\n#### Limits\n\n- Filter query max depth: 10.\n- Filter query max number of clauses: 100.\n- `and` and `or` clauses must have at least one element (and at most 99, since each element counts\n  towards the total clause limit, and so does the `and`/`or` clause itself).\n- The `property` array of each leaf filter has the following limitations:\n  - Number of elements in the array is 1 or 2.\n  - Elements must not be null or blank.\n  - Each element max length is 256 characters.\n  - The `property` array must match one of the existing properties (static top-level property or dynamic metadata property).\n- `containsAll`, `containsAny`, and `in` filter `values` array size must be in the range [1, 100].\n- `containsAll`, `containsAny`, and `in` filter `values` array must contain elements of number or string type (matching the type of the given property).\n- `range` filter must have at lest one of `gt`, `gte`, `lt`, `lte` attributes.\n  But `gt` is mutually exclusive to `gte`, while `lt` is mutually exclusive to `lte`.\n- `gt`, `gte`, `lt`, `lte` in the `range` filter must be of number or string type (matching the type of the given property).\n- `search` filter `value` must not be blank, and the length must be in the range [1, 128], and there\n  may be at most two `search` filters in the entire filter query.\n- The maximum length of the `value` of a leaf filter that is applied to a string property is 256.\n\n### Sorting\n\nBy default, sequences are sorted by their creation time in ascending order.\nSorting by another property or by several other properties can be explicitly requested via the\n`sort` field, which must contain a list\nof one or more sort specifications. Each sort specification indicates the `property` to sort on\nand, optionally, the `order` in which to sort (defaults to `asc`). If multiple sort specifications are\nsupplied, the results are sorted on the first property, and those with the same value for the first\nproperty are sorted on the second property, and so on.  \nPartitioning is done independently of sorting; there is no guarantee of sort order between elements from different partitions.\n\n#### Null values\n\nIn case the `nulls` field has the `auto` value, or the field isn't specified, null (missing) values\nare considered bigger than any other values. They are placed last when sorting in the `asc`\norder and first in the `desc` order. Otherwise, missing values are placed according to\nthe `nulls` field (`last` or `first`), and their placement won't depend on the `order`\nfield. Note that the number zero, empty strings, and empty lists are all considered\n_not_ null.\n\n#### Example\n\n```json\n{\n  \"sort\": [\n    {\n      \"property\" : [\"createdTime\"],\n      \"order\": \"desc\",\n      \"nulls\": \"last\"\n    },\n    {\n      \"property\" : [\"metadata\", \"<someCustomKey>\"]\n    }\n  ]\n}\n```\n\n\n#### Properties\n\nYou can sort on the following properties:\n\n| Property                          |\n|-----------------------------------|\n| `[\"assetId\"]`                     |\n| `[\"createdTime\"]`                 |\n| `[\"dataSetId\"]`                   |\n| `[\"description\"]`                 |\n| `[\"externalId\"]`                  |\n| `[\"lastUpdatedTime\"]`             |\n| `[\"metadata\", \"<someCustomKey>\"]` |\n| `[\"name\"]`                        |\n\n#### Limits\n\nThe `sort` array must contain 1 to 2 elements.\n</details>",
        "operationId": "advancedListSequences",
        "requestBody": {
          "description": "Retrieves a list of sequences matching the given criteria.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SequencesAdvancedListDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with a list of sequences matching the given criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SequenceWithCursorResponse"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const sequences = await client.sequences.list({ filter: { name: 'sequence_name' } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nasset_filter = filters.Equals(\"asset_id\", 123)\nis_efficiency = filters.Equals([\"metadata\", \"type\"], \"efficiency\")\nres = client.sequences.filter(filter=filters.And(asset_filter, is_efficiency), sort=\"created_time\")\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.sequences import SequenceProperty, SortableSequenceProperty\nasset_filter = filters.Equals(SequenceProperty.asset_id, 123)\nis_efficiency = filters.Equals(SequenceProperty.metadata_key(\"type\"), \"efficiency\")\nres = client.sequences.filter(\n    filter=filters.And(asset_filter, is_efficiency),\n    sort=SortableSequenceProperty.created_time)\nres = client.sequences.list(limit=5)\n\nfor seq in client.sequences:\n    seq # do something with the sequence\n\nfor seq_list in client.sequences(chunk_size=2500):\n    seq_list # do something with the sequences\n\nfrom cognite.client.data_classes import filters\nin_timezone = filters.Prefix([\"metadata\", \"timezone\"], \"Europe\")\nres = client.sequences.list(advanced_filter=in_timezone, sort=(\"external_id\", \"asc\"))\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.sequences import SequenceProperty, SortableSequenceProperty\nin_timezone = filters.Prefix(SequenceProperty.metadata_key(\"timezone\"), \"Europe\")\nres = client.sequences.list(\n    advanced_filter=in_timezone,\n    sort=(SortableSequenceProperty.external_id, \"asc\"))\n\nfrom cognite.client.data_classes import filters\nnot_instrument_lvl5 = filters.And(\n   filters.ContainsAny(\"labels\", [\"Level5\"]),\n   filters.Not(filters.ContainsAny(\"labels\", [\"Instrument\"]))\n)\nres = client.sequences.list(asset_subtree_ids=[123456], advanced_filter=not_instrument_lvl5)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SequenceMetadata> listSequencesResults = new ArrayList<>(); \n client.sequences() \n          .list() \n          .forEachRemaining(sequences -> listSequencesResults.addAll(sequences)); \n\n client.sequences() \n          .list(Request.create() \n               .withFilterMetadataParameter(\"source\", \"sdk-data-generator\")) \n          .forEachRemaining(sequences -> listSequencesResults.addAll(sequences)); \n\n"
          }
        ]
      }
    },
    "/sequences/aggregate": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Aggregate sequences",
        "operationId": "aggregateSequences",
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "description": "The aggregation API allows you to compute aggregated results from a set of sequences, such as\r\ngetting the number of sequences in a project or checking what assets the different sequences\r\nin your project are associated with (along with the number of sequences for each asset).\r\nBy specifying `filter` and/or `advancedFilter`, the aggregation will take place only over those\r\nsequences that match the filters. `filter` and `advancedFilter` behave the same way as in the\r\n`list` endpoint.\r\n\r\n<details>\r\n<summary>\r\nThe default behavior, when the <code>aggregate</code> field is not specified the request body, is to return the\r\nnumber of sequences that match the filters (if any), which is the same behavior as when the\r\n<code>aggregate</code> field is set to <code>count</code>.\r\n</summary>\r\n\r\nThe following requests will both return the total number of\r\nsequences whose `name` begins with `pump`:\r\n\r\n```\r\n{\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nand\r\n\r\n```\r\n{\r\n  \"aggregate\": \"count\",\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe response might be:\r\n\r\n```\r\n{\"items\": [{\"count\": 42}]}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>uniqueValues</code> and specifying a property in <code>properties</code> (this field is an array, but currently only supports one property) will\r\nreturn all unique values (up to a maximum of 1000) that are taken on by that property\r\nacross all the sequences that match the filters, as well as the number of sequences that\r\nhave each of those property values.\r\n</summary>\r\n\r\nThis example request finds all the unique asset ids that are\r\nreferenced by the sequences in your project whose `name` begins with `pump`:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"uniqueValues\",\r\n  \"properties\": [{\"property\": [\"assetId\"]}],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe response might be the following, saying that 23 sequences are associated with asset 18\r\nand 107 sequences are associated with asset 76:\r\n\r\n```\r\n{\r\n  \"items\": [\r\n    {\"values\": [\"18\"], \"count\": 23},\r\n    {\"values\": [\"76\"], \"count\": 107}\r\n  ]\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>cardinalityValues</code> will instead return the approximate number of\r\ndistinct values that are taken on by the given property among the matching sequences.\r\n</summary>\r\n\r\nExample request:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"cardinalityValues\",\r\n  \"properties\": [{\"property\": [\"assetId\"]}],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe result is likely exact when the set of unique values is small. In this example, there are likely two distinct asset ids among the matching sequences:\r\n\r\n```\r\n{\"items\": [{\"count\": 2}]}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>uniqueProperties</code> will return the set of unique properties whose property\r\npath begins with <code>path</code> (which can currently only be <code>[\"metadata\"]</code>) that are contained in the sequences that match the filters.\r\n</summary>\r\n\r\nExample request:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"uniqueProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe result contains all the unique metadata keys in the sequences whose `name` begins with\r\n`pump`, and the number of sequences that contains each metadata key:\r\n\r\n```\r\n{\r\n  \"items\": [\r\n    {\"values\": [{\"property\": [\"metadata\", \"tag\"]}], \"count\": 43},\r\n    {\"values\": [{\"property\": [\"metadata\", \"installationDate\"]}], \"count\": 97}\r\n  ]\r\n}\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>\r\nSetting <code>aggregate</code> to <code>cardinalityProperties</code> will instead return the approximate number of\r\ndifferent property keys whose path begins with <code>path</code> (which can currently only be <code>[\"metadata\"]</code>, meaning that this can only be used to count the approximate number of distinct metadata keys among the matching sequences).\r\n</summary>\r\n\r\nExample request:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"cardinalityProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}}\r\n}\r\n```\r\n\r\nThe result is likely exact when the set of unique values is small. In this example, there are likely two distinct metadata keys among the matching sequences:\r\n\r\n```\r\n{\"items\": [{\"count\": 2}]}\r\n```\r\n</details>\r\n\r\nThe `aggregateFilter` field may be specified if `aggregate` is set to `cardinalityProperties` or `uniqueProperties`. The structure of this field is similar to that of `advancedFilter`, except that the set of leaf filters is smaller (`in`, `prefix`, and `range`), and that none of the leaf filters specify a property. Unlike `advancedFilter`, which is applied _before_ the aggregation (in order to restrict the set of sequences that the aggregation operation should be applied to), `aggregateFilter` is applied _after_ the initial aggregation has been performed, in order to restrict the set of results.\r\n\r\n<details>\r\n<summary>\r\nClick here for more details about <code>aggregateFilter</code>. \r\n</summary>\r\n\r\nWhen `aggregate` is set to `uniqueProperties`, the result set contains a number of _property paths_, each with an associated count that shows how many sequences contained that property (among those sequences that matched the `filter` and `advancedFilter`, if they were specified) . If `aggregateFilter` is specified, it will restrict the property paths included in the output. Let us add an `aggregateFilter` to the `uniqueProperties` example from above:\r\n\r\n```\r\n{\r\n  \"aggregate\": \"uniqueProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}},\r\n  \"aggregateFilter\": {\"prefix\": {\"value\": \"t\"}}\r\n}\r\n```\r\n\r\nNow, the result only contains those metadata properties whose key begins with `t` (but it will be the same set of metadata properties that begin with `t` as in the original query without `aggregateFilter`, and the counts will be the same):\r\n\r\n```\r\n{\r\n  \"items\": [\r\n    {\"values\": [{\"property\": [\"metadata\", \"tag\"]}], \"count\": 43}\r\n  ]\r\n}\r\n```\r\n\r\nSimilarly, adding `aggregateFilter` to `cardinalityProperties` will return the approximate number of properties whose property key matches `aggregateFilter` from those sequences matching the `filter` and `advancedFilter` (or from all sequences if neither `filter` nor `aggregateFilter` are specified):\r\n\r\n```\r\n{\r\n  \"aggregate\": \"cardinalityProperties\",\r\n  \"path\": [\"metadata\"],\r\n  \"advancedFilter\": {\"prefix\": {\"property\": [\"name\"], \"value\": \"pump\"}},\r\n  \"aggregateFilter\": {\"prefix\": {\"value\": \"t\"}}\r\n}\r\n```\r\n\r\nAs we saw above, only one property matches:\r\n\r\n```\r\n{\"items\": [{\"count\": 1}]}\r\n```\r\n\r\nNote that `aggregateFilter` is also accepted when `aggregate` is set to `cardinalityValues` or `cardinalityProperties`. For those aggregations, the effect of any `aggregateFilter` could also be achieved via a similar `advancedFilter`. However, `aggregateFilter` is not accepted when `aggregate` is omitted or set to `count`.\r\n</details>\r\n\r\n### Rate and concurrency limits\r\n\r\nRate and concurrency limits apply this endpoint. If a request exceeds one of the limits,\r\nit will be throttled with a `429: Too Many Requests` response. More on limit types\r\nand how to avoid being throttled is described\r\n[here](https://developer.cognite.com/dev/concepts/request_throttling/).\r\n\r\n| Limit          | Per project           | Per user (identity)   |\r\n|----------------|-----------------------|-----------------------|\r\n| Rate           | 15 requests per second| 10 requests per second|\r\n| Concurrency    | 6 concurrent requests | 4 concurrent requests |\r\n",
        "requestBody": {
          "description": "Aggregates the sequences that match the given criteria.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SequencesAdvancedAggregateDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with the aggregated sequences. The type of the response depends on the value of the `aggregate` parameter in the request.",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/SequencesCountAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/SequencesCardinalityValuesAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/SequencesCardinalityPropertiesAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/SequencesUniqueValuesAggregateResponse"
                    },
                    {
                      "$ref": "#/components/schemas/SequencesUniquePropertiesAggregateResponse"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregates = await client.sequences.aggregate({ filter: { name: \"Well\" } });\nconsole.log('Number of sequences named Well: ', aggregates[0].count)"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.sequences.aggregate(filter={\"external_id_prefix\": \"prefix\"})\nfrom cognite.client.data_classes.sequences import SequenceProperty\ncount = client.sequences.aggregate_cardinality_values(SequenceProperty.metadata)\nfrom cognite.client.data_classes.sequences import SequenceProperty\ncount = client.sequences.aggregate_cardinality_values(SequenceProperty.metadata_key(\"efficiency\"))\n\nfrom cognite.client.data_classes import filters, aggregations as aggs\nfrom cognite.client.data_classes.sequences import SequenceProperty\nnot_america = aggs.Not(aggs.Prefix(\"america\"))\nis_critical = filters.Search(SequenceProperty.description, \"critical\")\ntimezone_count = client.sequences.aggregate_cardinality_values(\n    SequenceProperty.metadata_key(\"timezone\"),\n    advanced_filter=is_critical,\n    aggregate_filter=not_america)\ncount = client.sequences.aggregate_count()\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.sequences import SequenceProperty\nis_mapping = filters.Prefix(SequenceProperty.external_id, \"mapping:\")\ncount = client.sequences.aggregate_count(advanced_filter=is_mapping)\nfrom cognite.client.data_classes.sequences import SequenceProperty\nresult = client.sequences.aggregate_unique_properties(SequenceProperty.metadata)\nfrom cognite.client.data_classes.sequences import SequenceProperty\nresult = client.sequences.aggregate_unique_values(SequenceProperty.metadata_key(\"timezone\"))\nprint(result.unique)\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.sequences import SequenceProperty\nfrom cognite.client.utils import timestamp_to_ms\nfrom datetime import datetime\ncreated_after_2020 = filters.Range(SequenceProperty.created_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.sequences.aggregate_unique_values(SequenceProperty.metadata, advanced_filter=created_after_2020)\nprint(result.unique)\n\nfrom cognite.client.data_classes.sequences import SequenceProperty\nfrom cognite.client.data_classes import aggregations as aggs, filters\nnot_test = aggs.Not(aggs.Prefix(\"test\"))\ncreated_after_2020 = filters.Range(SequenceProperty.last_updated_time, gte=timestamp_to_ms(datetime(2020, 1, 1)))\nresult = client.sequences.aggregate_unique_values(SequenceProperty.metadata, advanced_filter=created_after_2020, aggregate_filter=not_test)\nprint(result.unique)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Aggregate aggregateResult = \n          client.sequences().aggregate(Request.create().withFilterMetadataParameter(\"source\", \"source\")); \n\n"
          }
        ]
      }
    },
    "/sequences/byids": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Retrieve sequences",
        "description": "Retrieves one or more sequences by ID or external ID. The response returns the sequences in the same order as in the request.",
        "operationId": "getSequenceById",
        "requestBody": {
          "description": "Ids of the sequences",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataResourceIdsWithIgnoreUnknownIds"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with the requested sequences.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetSequence"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const [sequence1, sequence2] = await client.sequences.retrieve([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.sequences.retrieve(id=1)\n\nres = client.sequences.retrieve()\nres = client.sequences.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.sequences.retrieve_multiple(external_ids=[\"abc\", \"def\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SequenceMetadata> retrievedByExternalIds = client.sequences().retrieve(\"10\");//by varargs of String \nList<Item> listItemsExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<SequenceMetadata> retrievedSequencesExternalIds = client.sequences().retrieve(listItemsExternalIds);//by list of items \n\nList<SequenceMetadata> retrievedByInternalIds = client.sequences().retrieve(10, 20);//by varargs of Long \nList<Item> listItemsInternalIds = List.of(Item.newBuilder().setId(10).build()); \nList<SequenceMetadata> retrievedSequencesInternalIds = client.sequences().retrieve(listItemsInternalIds); \n\n"
          }
        ]
      }
    },
    "/sequences/search": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Search sequences",
        "description": "Retrieves a list of sequences matching the given criteria. This operation doesn't support pagination.",
        "operationId": "searchSequences",
        "requestBody": {
          "description": "Retrieves a list of sequences matching the given criteria. This operation doesn't support pagination.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SequencesSearchDTO"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with a list of sequences matching the given criteria.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetSequence"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const sequences = await client.sequences.search({\n  filter: {\n    assetIds: [1, 2]\n  },\n  search: {\n    query: 'n*m* desc*ion'\n  }\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.sequences.search(name=\"some name\")\n"
          }
        ]
      }
    },
    "/sequences/update": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Update sequences",
        "description": "Updates one or more sequences. Fields outside of the request remain unchanged.",
        "operationId": "updateSequences",
        "requestBody": {
          "description": "Patch definition",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSequenceChange"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with the updated sequences.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DataGetSequence"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const [updatedSequence] = await client.sequences.update([{id: 123, update: {name: {set: 'New name'}}}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.sequences.retrieve(id=1)\nres.description = \"New description\"\nres = client.sequences.update(res)\n\nfrom cognite.client.data_classes import SequenceUpdate\nmy_update = SequenceUpdate(id=1).description.set(\"New description\").metadata.add({\"key\": \"value\"})\nres = client.sequences.update(my_update)\n\nfrom cognite.client.data_classes import SequenceUpdate, SequenceColumn\nmy_update = SequenceUpdate(id=1).columns.add(SequenceColumn(value_type =\"String\",external_id=\"user\", description =\"some description\"))\nres = client.sequences.update(my_update)\n\nfrom cognite.client.data_classes import SequenceUpdate, SequenceColumn\ncolumn_def = [\n    SequenceColumn(value_type =\"String\",external_id=\"user\", description =\"some description\"),\n    SequenceColumn(value_type=\"Double\", external_id=\"amount\")]\nmy_update = SequenceUpdate(id=1).columns.add(column_def)\nres = client.sequences.update(my_update)\n\nfrom cognite.client.data_classes import SequenceUpdate\nmy_update = SequenceUpdate(id=1).columns.remove(\"col_external_id1\")\nres = client.sequences.update(my_update)\n\nfrom cognite.client.data_classes import SequenceUpdate\nmy_update = SequenceUpdate(id=1).columns.remove([\"col_external_id1\",\"col_external_id2\"])\nres = client.sequences.update(my_update)\n\nfrom cognite.client.data_classes import SequenceUpdate, SequenceColumnUpdate\ncolumn_updates = [\n    SequenceColumnUpdate(external_id=\"col_external_id_1\").external_id.set(\"new_col_external_id\"),\n    SequenceColumnUpdate(external_id=\"col_external_id_2\").description.set(\"my new description\"),\n]\nmy_update = SequenceUpdate(id=1).columns.modify(column_updates)\nres = client.sequences.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "\n client.sequences().upsert(upsertSequencesList); \n\n"
          }
        ]
      }
    },
    "/sequences/delete": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Delete sequences",
        "description": "Deletes the sequences with the specified IDs. If one or more of the sequences do not exist, the `ignoreUnknownIds` parameter controls what will happen: if it is `true`, the sequences that do exist will be deleted, and the request succeeds; if it is `false` or absent, nothing will be deleted, and the request fails.",
        "operationId": "deleteSequences",
        "requestBody": {
          "description": "Ids of the sequences to delete.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataResourceIdsWithIgnoreUnknownIds"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "sequencesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.sequences.delete([{id: 123}, {externalId: 'abc'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.sequences.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteItemsSequencesByExternalIds = List.of(Item.newBuilder().setExternalId(\"10\").build()); \nList<Item> externalIdsResults = client.sequences().delete(deleteItemsSequencesByExternalIds); \n\nList<Item> deleteItemsSequencesByInternalIds = List.of(Item.newBuilder().setId(10).build()); \n List<Item> InternalIdsResults = client.sequences().delete(deleteItemsSequencesByInternalIds); \n\n"
          }
        ]
      }
    },
    "/sequences/data": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Insert rows",
        "description": "Inserts rows into a sequence. This overwrites data in rows and columns that exist.",
        "operationId": "postSequenceData",
        "requestBody": {
          "description": "Data posted.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSequencePostData"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "sequencesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const rows = [\n { rowNumber: 0, values: [1, 2.2, 'three'] },\n { rowNumber: 1, values: [4, 5, 'six'] }\n];\nawait client.sequences.insertRows([{ id: 123, rows, columns: ['one', 'two', 'three'] }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import Sequence, SequenceColumn\nseq = client.sequences.create(Sequence(columns=[SequenceColumn(value_type=\"String\", external_id=\"col_a\"),\n    SequenceColumn(value_type=\"Double\", external_id =\"col_b\")]))\ndata = [(1, ['pi',3.14]), (2, ['e',2.72]) ]\nclient.sequences.data.insert(columns=[\"col_a\",\"col_b\"], rows=data, id=1)\n\ndata = [{\"rowNumber\": 123, \"values\": ['str',3]}, {\"rowNumber\": 456, \"values\": [\"bar\",42]} ]\nclient.sequences.data.insert(data, id=1, columns=[\"col_a\",\"col_b\"]) # implicit columns are retrieved from metadata\n\ndata = {123 : ['str',3], 456 : ['bar',42] }\nclient.sequences.data.insert(columns=['stringColumn','intColumn'], rows=data, id=1)\n\ndata = client.sequences.data.retrieve(id=2,start=0,end=10)\nclient.sequences.data.insert(rows=data, id=1,columns=None)\nimport pandas as pd\ndf = pd.DataFrame({'col_a': [1, 2, 3], 'col_b': [4, 5, 6]}, index=[1, 2, 3])\nclient.sequences.data.insert_dataframe(df, id=123)\nfrom cognite.client.data_classes import Sequence, SequenceColumn\nseq = client.sequences.create(Sequence(columns=[SequenceColumn(value_type=\"String\", external_id=\"col_a\"),\n    SequenceColumn(value_type=\"Double\", external_id =\"col_b\")]))\ndata = [(1, ['pi',3.14]), (2, ['e',2.72]) ]\nclient.sequences.data.insert(columns=[\"col_a\",\"col_b\"], rows=data, id=1)\n\ndata = [{\"rowNumber\": 123, \"values\": ['str',3]}, {\"rowNumber\": 456, \"values\": [\"bar\",42]} ]\nclient.sequences.data.insert(data, id=1, columns=[\"col_a\",\"col_b\"]) # implicit columns are retrieved from metadata\n\ndata = {123 : ['str',3], 456 : ['bar',42] }\nclient.sequences.data.insert(columns=['stringColumn','intColumn'], rows=data, id=1)\n\ndata = client.sequences.data.retrieve(id=2,start=0,end=10)\nclient.sequences.data.insert(rows=data, id=1,columns=None)\nimport pandas as pd\ndf = pd.DataFrame({'col_a': [1, 2, 3], 'col_b': [4, 5, 6]}, index=[1, 2, 3])\nclient.sequences.data.insert_dataframe(df, id=123)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SequenceMetadata> upsertSequencesList = DataGenerator.generateSequenceMetadata(); \nclient.sequences().upsert(upsertSequencesList); \n\n SequenceBody body = SequenceBody.newBuilder() \n .setExternalId(upsertSequencesList.get(1).getExternalId()) \n .addAllColumns(List.of(SequenceColumn.newBuilder().setExternalId(\"10\").build())) \n .addAllRows(List.of(SequenceRow.newBuilder().setRowNumber(1).addAllValues(List.of(Value.newBuilder().setNumberValue(10).build())).build())) \n .build(); \n List<SequenceBody> upsertSequenceBodyResponse = client.sequences().rows().upsert(List.of(body)); \n\n"
          }
        ]
      }
    },
    "/sequences/data/list": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Retrieve rows",
        "description": "Processes data requests and returns the result. Note that this operation uses a dynamic limit on the number of rows returned based on the number and type of columns; use the provided cursor to paginate and retrieve all data.",
        "operationId": "getSequenceData",
        "requestBody": {
          "description": "Description of data requested.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SequenceDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with the sequence data found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SequenceGetDataWithCursor"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const rows = await client.sequences.retrieveRows({ externalId: 'sequence1' }).autoPagingToArray({ limit: 100 });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.sequences.data.retrieve(id=1)\ntuples = [(r,v) for r,v in res.items()] # You can use this iterator in for loops and list comprehensions,\nsingle_value = res[23] # ... get the values at a single row number,\ncol = res.get_column(external_id='columnExtId') # ... get the array of values for a specific column,\ndf = res.to_pandas() # ... or convert the result to a dataframe\ndf = client.sequences.data.retrieve_dataframe(id=1, start=0, end=None)\nres = client.sequences.data.retrieve(id=1)\ntuples = [(r,v) for r,v in res.items()] # You can use this iterator in for loops and list comprehensions,\nsingle_value = res[23] # ... get the values at a single row number,\ncol = res.get_column(external_id='columnExtId') # ... get the array of values for a specific column,\ndf = res.to_pandas() # ... or convert the result to a dataframe\ndf = client.sequences.data.retrieve_dataframe(id=1, start=0, end=None)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Iterator<List<SequenceBody>> listRetrieved = client.sequences().rows().retrieve(Request.create()); \n\nIterator<List<SequenceBody>> list = client.sequences().rows().retrieveComplete(List.of(Item.newBuilder().setId(10).build()));//by list of items \nIterator<List<SequenceBody>> list = client.sequences().rows().retrieveComplete(10);//by varargs of Long \n\nIterator<List<SequenceBody>> list = client.sequences().rows().retrieveComplete(List.of(Item.newBuilder().setExternalId(\"10\").build()));//by list of items \nIterator<List<SequenceBody>> list = client.sequences().rows().retrieveComplete(\"10\");//by varargs of String \n\n"
          }
        ]
      }
    },
    "/sequences/data/latest": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Retrieve last row",
        "description": "Retrieves the last row in one or more sequences. Note that the last row in a sequence is the\none with the highest row number, which is not necessarily the one that was ingested most\nrecently.\n",
        "operationId": "getLatestSequenceRow",
        "requestBody": {
          "description": "Description of data requested.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SequenceLatestDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Response with the sequence data found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SequenceGetData"
                }
              }
            }
          }
        },
        "x-capability": [
          "sequencesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.sequences.data.retrieve_last_row(id=1, before=1000)\nres = client.sequences.data.retrieve_last_row(id=1, before=1000)\n"
          }
        ]
      }
    },
    "/sequences/data/delete": {
      "post": {
        "tags": [
          "Sequences"
        ],
        "summary": "Delete rows",
        "description": "Deletes the given rows of the sequence. All columns are affected.",
        "operationId": "deleteSequenceData",
        "requestBody": {
          "description": "Indicate the sequences and the rows where data should be deleted.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DataSequenceDataDeleteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-capability": [
          "sequencesAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.sequences.deleteRows([{ id: 32423849, rows: [1,2,3] }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.sequences.data.delete(id=1, rows=[1,2,42])\nclient.sequences.data.delete_range(id=1, start=0, end=None)\nclient.sequences.data.delete(id=1, rows=[1,2,42])\nclient.sequences.data.delete_range(id=1, start=0, end=None)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<SequenceBody> deleteRowsInput = listSequencesRowsResults; \nList<SequenceBody> deleteRowsResults = client.sequences().rows().delete(deleteRowsInput);"
          }
        ]
      }
    },
    "/labels": {
      "post": {
        "tags": [
          "Labels"
        ],
        "summary": "Create label definitions.",
        "description": "Creates label definitions that can be used across different resource types. The label definitions are uniquely identified by their external id.",
        "operationId": "createLabelDefinitions",
        "requestBody": {
          "description": "List of label definitions to create",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalLabelDefinitionList"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/LabelDefinitionCreateResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "labelsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const labels = [\n  { externalId: 'PUMP', name: \"Pump\" },\n  { externalId: 'ROTATING_EQUIPMENT', name: 'Rotating equipment', description: 'Asset with rotating parts' }\n];\nconst createdLabels = await client.labels.create(labels);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import LabelDefinitionWrite\nlabels = [LabelDefinitionWrite(external_id=\"ROTATING_EQUIPMENT\", name=\"Rotating equipment\"), LabelDefinitionWrite(external_id=\"PUMP\", name=\"pump\")]\nres = client.labels.create(labels)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Label> upsertLabelsList =  List.of(Label.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"Label name\") \n          .setDescription(\"Description\") \n          .build()); \n\nList<Label>  list = client.labels().upsert(upsertLabelsList); \n\n"
          }
        ]
      }
    },
    "/labels/list": {
      "post": {
        "tags": [
          "Labels"
        ],
        "summary": "Filter labels",
        "description": "Use advanced filtering options to find label definitions.",
        "operationId": "listLabels",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LabelDefinitionListScope"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/LabelDefinitionListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "labelsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const labels = await client.labels.list({ filter: { externalIdPrefix: 'Pu'}});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "label_list = client.labels.list(limit=5, name=\"Pump\")\n\nfor label in client.labels:\n    label # do something with the label definition\n\nfor label_list in client.labels(chunk_size=2500):\n    label_list # do something with the type definitions\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Label> listLabelsResults = new ArrayList<>(); \nclient.labels() \n          .list() \n          .forEachRemaining(labels -> listLabelsResults.addAll(labels)); \n\nclient.labels() \n          .list(Request.create() \n               .withFilterParameter(\"externalIdPrefix\", \"Val\")) \n          .forEachRemaining(labels -> listLabelsResults.addAll(labels)); \n\n"
          }
        ]
      }
    },
    "/labels/byids": {
      "post": {
        "tags": [
          "Labels"
        ],
        "summary": "Retrieve labels",
        "description": "Retrieve labels using their external ids",
        "operationId": "byIdsLabels",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LabelsIdsWithIgnoreUnknownIds"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/LabelDefinitionListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "labelsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.labels.retrieve(external_id=\"my_label\", ignore_unknown_ids=True)\n"
          }
        ]
      }
    },
    "/labels/delete": {
      "post": {
        "tags": [
          "Labels"
        ],
        "summary": "Delete label definitions.",
        "description": "Delete all the label definitions specified by their external ids. The resource items that have the corresponding label attached remain unmodified. It is up to the client to clean up the resource items from their attached labels if necessary.",
        "operationId": "deleteLabels",
        "requestBody": {
          "description": "List of external ids of label definitions to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LabelDefinitionExternalIdList"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "labelsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.labels.delete([{externalId: 'PUMP'}, {externalId: 'VALVE'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.labels.delete(external_id=[\"big_pump\", \"small_pump\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteItemsByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nList<Item> deleteItemsResults = \n          client.labels().delete(deleteItemsByExternalIds); \n\nList<Item> deleteItemsByInternalIds = List.of(Item.newBuilder() \n          .setId(10) \n          .build()); \nList<Item> deleteItemsResults = \n          client.labels().delete(deleteItemsByInternalIds); \n\n"
          }
        ]
      }
    },
    "/relationships": {
      "post": {
        "summary": "Create relationships",
        "tags": [
          "Relationships"
        ],
        "description": "List of the relationships to create. You can create a maximum of 1000 relationships per request. Relationships should be unique, but CDF does not prevent you from creating duplicates where only the externalId differs.\n\nRelationships are uniquely identified by their externalId. Non-unique relationships will not be created.\n\nThe order of relationships in the response equals the order in the request.",
        "operationId": "createRelationships",
        "responses": {
          "201": {
            "$ref": "#/components/responses/persistedRelationships"
          },
          "400": {
            "$ref": "#/components/responses/400GeneralError"
          },
          "409": {
            "$ref": "#/components/responses/409GeneralError"
          },
          "500": {
            "$ref": "#/components/responses/generalError"
          }
        },
        "requestBody": {
          "$ref": "#/components/requestBodies/newRelationship"
        },
        "deprecated": false,
        "x-capability": [
          "relationshipsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const relationships = [\n  {\n     externalId: 'some_relationship',\n     sourceExternalId: 'some_source_external_id',\n     sourceType: 'asset' as const,\n     targetExternalId: 'some_target_external_id',\n     targetType: 'event' as const\n  }\n];\nconst createdRelationships = await client.relationships.create(relationships);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import Relationship\nflowrel1 = Relationship(\n    external_id=\"flow_1\",\n    source_external_id=\"source_ext_id\",\n    source_type=\"asset\",\n    target_external_id=\"target_ext_id\",\n    target_type=\"event\",\n    confidence=0.1,\n    data_set_id=1234\n)\nflowrel2 = Relationship(\n    external_id=\"flow_2\",\n    source_external_id=\"source_ext_id\",\n    source_type=\"asset\",\n    target_external_id=\"target_ext_id\",\n    target_type=\"event\",\n    confidence=0.1,\n    data_set_id=1234\n)\nres = client.relationships.create([flowrel1,flowrel2])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Asset> assetUpsertList = //list of Asset; \nList<Event> eventUpsertList = //list of Event; \nList<TimeseriesMetadata> timseriesUpsertList = //list of TimeseriesMetadata; \nList<SequenceMetadata> sequenceUpsertList = // list of SequenceMetadata; \n\nList<Relationship> relationshipList = new ArrayList<>(); \n\n//EVENT AND ASSET \nrelationshipList.add( \n     Relationship.newBuilder() \n          .setStartTime(Instant.now().toEpochMilli()) \n          .setEndTime(Instant.now().toEpochMilli()) \n          .setSourceType(Relationship.ResourceType.EVENT) \n          .setSourceExternalId(eventUpsertList.get(0).getExternalId()) \n          .setTargetType(Relationship.ResourceType.ASSET) \n          .setTargetExternalId(assetUpsertList.get(0).getExternalId()) \n          .setConfidence(ThreadLocalRandom.current().nextFloat()) \n          .build()); \n\n//TIME_SERIES AND ASSET \nrelationshipList.add( \n     Relationship.newBuilder() \n          .setStartTime(Instant.now().toEpochMilli()) \n          .setEndTime(Instant.now().toEpochMilli()) \n          .setSourceType(Relationship.ResourceType.TIME_SERIES) \n          .setSourceExternalId(timseriesUpsertList.get(1).getExternalId()) \n          .setTargetType(Relationship.ResourceType.ASSET) \n          .setTargetExternalId(assetUpsertList.get(1).getExternalId()) \n          .setConfidence(ThreadLocalRandom.current().nextFloat()) \n          .build()); \n\n//SEQUENCE AND EVENT \nrelationshipList.add( \n     Relationship.newBuilder() \n          .setStartTime(Instant.now().toEpochMilli()) \n          .setEndTime(Instant.now().toEpochMilli()) \n          .setSourceType(Relationship.ResourceType.SEQUENCE) \n          .setSourceExternalId(sequenceUpsertList.get(2).getExternalId()) \n          .setTargetType(Relationship.ResourceType.EVENT) \n          .setTargetExternalId(eventUpsertList.get(2).getExternalId()) \n          .setConfidence(ThreadLocalRandom.current().nextFloat()) \n          .build()); \n\nList<Relationship> upsertRelationshipsList = client.relationships() \n          .upsert(relationshipList); \n\n"
          }
        ]
      },
      "get": {
        "summary": "List relationships",
        "tags": [
          "Relationships"
        ],
        "description": "Lists all relationships. The order of retrieved objects may change for two calls with the same parameters.\nThe endpoint supports pagination. The initial call to this endpoint should not contain a cursor, but the cursor parameter should be used to retrieve further pages of results.",
        "operationId": "getRelationships",
        "parameters": [
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/partition"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/pagedPersistedRelationships"
          },
          "500": {
            "$ref": "#/components/responses/generalError"
          }
        },
        "deprecated": false,
        "x-capability": [
          "relationshipsAcl:READ"
        ]
      }
    },
    "/relationships/update": {
      "post": {
        "summary": "Update relationships",
        "tags": [
          "Relationships"
        ],
        "description": "Update relationships between resources according to the partial definitions of the relationships given in the payload of the request. This means that fields not mentioned in the payload will remain unchanged. Up to 1000 relationships can be updated in one operation.\nTo delete a value from an optional value the `setNull` field should be set to `true`.\nThe order of the updated relationships in the response equals the order in the request.",
        "operationId": "updateRelationships",
        "requestBody": {
          "$ref": "#/components/requestBodies/updateObject"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/persistedRelationships"
          },
          "400": {
            "$ref": "#/components/responses/generalError"
          },
          "409": {
            "$ref": "#/components/responses/409GeneralError"
          }
        },
        "x-capability": [
          "relationshipsAcl:WRITE",
          "relationshipsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "rel = client.relationships.retrieve(external_id=\"flow1\")\nrel.confidence = 0.75\nres = client.relationships.update(rel)\n\nfrom cognite.client.data_classes import RelationshipUpdate\nmy_update = RelationshipUpdate(external_id=\"flow_1\").source_external_id.set(\"alternate_source\").confidence.set(0.97)\nres1 = client.relationships.update(my_update)\nanother_update = RelationshipUpdate(external_id=\"flow_1\").confidence.set(None)\nres2 = client.relationships.update(another_update)\n\nfrom cognite.client.data_classes import RelationshipUpdate\nmy_update = RelationshipUpdate(external_id=\"flow_1\").labels.add([\"PUMP\", \"VERIFIED\"])\nres = client.relationships.update(my_update)\n\nfrom cognite.client.data_classes import RelationshipUpdate\nmy_update = RelationshipUpdate(external_id=\"flow_1\").labels.remove(\"PUMP\")\nres = client.relationships.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Relationship> relationshipList = // list of Relationship for update; \nList<Relationship> upsertRelationshipsList = \n          client.relationships().upsert(relationshipList); \n\n"
          }
        ]
      }
    },
    "/relationships/delete": {
      "post": {
        "summary": "Delete relationships",
        "tags": [
          "Relationships"
        ],
        "description": "Delete the relationships between resources identified by the external IDs in the request. You can delete a maximum of 1000 relationships per request.",
        "operationId": "deleteRelationships",
        "requestBody": {
          "$ref": "#/components/requestBodies/delete"
        },
        "responses": {
          "202": {
            "$ref": "#/components/responses/emptyDeleteResponse"
          },
          "409": {
            "$ref": "#/components/responses/409GeneralError"
          },
          "500": {
            "$ref": "#/components/responses/generalError"
          }
        },
        "x-capability": [
          "relationshipsAcl:WRITE"
        ],
        "deprecated": false,
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.relationships.delete([{externalId: 'abc'}, {externalId: 'def'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.relationships.delete(external_id=[\"a\",\"b\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteItemsInput = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nList<Item> deleteItemsResults = \n          client.relationships().delete(deleteItemsInput); \n\n"
          }
        ]
      }
    },
    "/relationships/byids": {
      "post": {
        "summary": "Retrieve relationships",
        "tags": [
          "Relationships"
        ],
        "description": "Retrieve relationships by external IDs. You can retrieve a maximum of 1000 relationships per request.\nThe order of the relationships in the response equals the order in the request.",
        "operationId": "byidsRelationships",
        "requestBody": {
          "$ref": "#/components/requestBodies/listOfExternalIds"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/enrichedPersistedRelationships"
          },
          "400": {
            "$ref": "#/components/responses/generalError"
          },
          "409": {
            "$ref": "#/components/responses/409GeneralError"
          }
        },
        "x-capability": [
          "relationshipsAcl:READ"
        ],
        "deprecated": false,
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const relationships = await client.relationships.retrieve([{externalId: 'abc'}, {externalId: 'def'}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.relationships.retrieve_multiple(external_ids=[\"abc\", \"def\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nList<Relationship> list = \n          client.relationships().retrieve(byExternalIds);//by list of items \nList<Relationship> list = \n          client.relationships().retrieve(\"10\", \"20\");//by varargs of String \n\nList<Item> byInternalIds = List.of(Item.newBuilder() \n          .setId(10) \n          .build()); \nList<Relationship> list = \n          client.relationships().retrieve(byInternalIds, true);//by list of items \nList<Relationship> list1 = \n          client.relationships().retrieve(10,20);//by varargs of Long \n\n"
          }
        ]
      }
    },
    "/relationships/list": {
      "post": {
        "summary": "Filter relationships",
        "tags": [
          "Relationships"
        ],
        "description": "Lists relationships matching the query filter in the request. You can retrieve a maximum of 1000 relationships per request.",
        "operationId": "listRelationships",
        "requestBody": {
          "$ref": "#/components/requestBodies/advancedList"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/filteredRelationships"
          },
          "400": {
            "$ref": "#/components/responses/generalError"
          },
          "409": {
            "$ref": "#/components/responses/409GeneralError"
          }
        },
        "x-capability": [
          "relationshipsAcl:READ"
        ],
        "deprecated": false,
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const relationships = await client.relationships.list({ filter: { createdTime: { min: new Date('1 jan 2018'), max: new Date('1 jan 2019') }}});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "relationship_list = client.relationships.list(limit=5)\n\nfor relationship in client.relationships:\n    relationship # do something with the relationship\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Relationship> listRelationshipsResults = new ArrayList<>(); \nclient.relationships() \n          .list() \n          .forEachRemaining(listRelationshipsResults::addAll); \n\nclient.relationships() \n          .list(Request.create() \n               .withRootParameter(\"fetchResources\", true)) \n          .forEachRemaining(listRelationshipsResults::addAll); \n\n"
          }
        ]
      }
    },
    "/context/diagram/detect": {
      "post": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Detect annotations in engineering diagrams",
        "description": "Detect annotations in engineering diagrams. Note: All users in a CDF project with assets read-all and files read access to the requested files can access data sent to this endpoint.\nSupported input file mime_types are application/pdf, image/jpeg, image/png, image/tiff. Also note that the header of a successful response contains an `X-Job-Token` which allows to fetch the result of the\njob at `/context/diagram/detect/{jobId}` without requiring 'assetsAcl:READ'.",
        "operationId": "diagramDetect",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items",
                  "entities"
                ],
                "allOf": [
                  {
                    "properties": {
                      "items": {
                        "type": "array",
                        "description": "Files to run entity detection on.",
                        "minItems": 1,
                        "maxItems": 50,
                        "items": {
                          "$ref": "#/components/schemas/FileReferenceWithPageRange"
                        }
                      },
                      "entities": {
                        "$ref": "#/components/schemas/DiagramDetectEntities"
                      }
                    }
                  },
                  {
                    "$ref": "#/components/schemas/DiagramDetectConfig"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/FileReferenceWithPageRange"
                          }
                        },
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramDetectConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.contextualization import FileReference\ndetect_job = client.diagrams.detect(\n    entities=[\n        {\"userDefinedField\": \"21PT1017\",\"ignoredField\": \"AA11\"},\n        {\"userDefinedField\": \"21PT1018\"}],\n    search_field=\"userDefinedField\",\n    partial_match=True,\n    min_tokens=2,\n    file_ids=[101],\n    file_external_ids=[\"Test1\"],\n    file_references=[\n        FileReference(id=20, first_page=1, last_page=10),\n        FileReference(external_id=\"ext_20\", first_page=11, last_page=20)\n    ])\nresult = detect_job.result\nprint(result)\n\nfrom cognite.client.data_classes.contextualization import ConnectionFlags, DiagramDetectConfig\nconfig = DiagramDetectConfig(\n    remove_leading_zeros=True,\n    connection_flags=ConnectionFlags(\n        no_text_inbetween=True,\n        natural_reading_order=True,\n    )\n)\njob = client.diagrams.detect(entities=[{\"name\": \"A1\"}], file_id=123, config=config)\n"
          }
        ]
      }
    },
    "/context/diagram/detect/{jobId}": {
      "get": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Retrieve engineering diagram detect results",
        "description": "Get the results from an engineering diagram detect job. Providing the `X-Job-Token` header returned by the\n`/context/diagram/detect` endpoint is required unless the caller has read access to all assets.",
        "operationId": "diagramDetectResults",
        "parameters": [
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        },
                        "items": {
                          "$ref": "#/components/schemas/DiagramDetectResultSchema"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramDetectConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/context/diagram/convert": {
      "post": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Convert a diagram to image format",
        "description": "Convert interactive engineering diagrams to image format, with highlighted annotations.\nSupported input file mime_types are application/pdf, image/jpeg, image/png, image/tiff.\nSupported output image formats are PNG and SVG, only the svg embeds the input annotations.",
        "operationId": "diagramConvert",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "allOf": [
                  {
                    "properties": {
                      "items": {
                        "$ref": "#/components/schemas/DiagramConvertRequestSchema"
                      }
                    }
                  },
                  {
                    "$ref": "#/components/schemas/DiagramConvertConfig"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "items": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/OneOfFileId"
                          }
                        },
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramConvertConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/context/diagram/convert/{jobId}": {
      "get": {
        "tags": [
          "Engineering diagrams"
        ],
        "summary": "Get the results for converting an engineering diagram to an image",
        "description": "Get the results for converting an engineering diagram to SVG and PNG formats.",
        "operationId": "diagramConvertResults",
        "parameters": [
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/BatchJobStatus"
                        },
                        "items": {
                          "$ref": "#/components/schemas/DiagramConvertResultSchema"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "$ref": "#/components/schemas/DiagramConvertConfig"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "filesAcl:READ"
        ]
      }
    },
    "/context/entitymatching": {
      "get": {
        "tags": [
          "Entity matching"
        ],
        "summary": "List entity matching models",
        "description": "List all available entity matching models.",
        "operationId": "entityMatchingModels",
        "parameters": [
          {
            "in": "query",
            "name": "limit",
            "description": "Limits the number of results to be returned. The maximum results returned by the server is 1000 even if you specify a higher limit.",
            "schema": {
              "type": "integer",
              "default": 100,
              "minimum": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "items"
                  ],
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.entity_matching.list(limit=1, name=\"test\")\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Create entity matcher model",
        "description": "Train a model that predicts matches between entities (for example, time series names to asset names). This is also known as fuzzy joining. If there are no trueMatches (labeled data), you train a static (unsupervised) model, otherwise a machine learned (supervised) model is trained.",
        "operationId": "entityMatchingCreate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "sources",
                  "targets"
                ],
                "properties": {
                  "sources": {
                    "$ref": "#/components/schemas/Sources"
                  },
                  "targets": {
                    "$ref": "#/components/schemas/Targets"
                  },
                  "trueMatches": {
                    "$ref": "#/components/schemas/TrueMatches"
                  },
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  },
                  "name": {
                    "$ref": "#/components/schemas/ModelName"
                  },
                  "description": {
                    "$ref": "#/components/schemas/ModelDescription"
                  },
                  "featureType": {
                    "description": "Each feature type defines one combination of features that will be created and used in the entity matcher model. All features are based on matching tokens. Tokens are defined at the top of the Entity matching section.\nThe options are:\n  * Simple: Calculates the cosine-distance similarity score for each of the pairs of fields defined in `matchFields`. This is the fastest option.\n  * Insensitive: Similar to Simple, but ignores lowercase/uppercase differences.\n  * Bigram: Similar to `simple`, but adds similarity score based on matching bigrams of the tokens.\n  * FrequencyWeightedBigram: Similar to `bigram`, but give higher weights to less commonly occurring tokens.\n  * BigramExtraTokenizers: Similar to `bigram`, but able to learn that leading zeros, spaces, and uppercase/lowercase differences should be ignored in matching.\n  * BigramCombo: Calculates all of the above options, relying on the model to determine the appropriate features to use.\n  Hence, this option is only appropriate if there are  labeled data/trueMatches. This is the slowest option.\n",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/FeatureType"
                      }
                    ]
                  },
                  "matchFields": {
                    "$ref": "#/components/schemas/MatchFields"
                  },
                  "classifier": {
                    "$ref": "#/components/schemas/Classifier"
                  },
                  "ignoreMissingFields": {
                    "$ref": "#/components/schemas/IgnoreMissingFields"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const result = await client.entityMatching.create({\n sources: [{externalId: 'asset1', name: 'asset1'}, {externalId: 'asset2', name: 'asset2'}],\n targets: [{externalId: 'ts1', name: 'ts1'}, {externalId: 'ts2', name: 'ts2'}],\n externalId: 'model123',\n name: 'model123',\n});"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Struct> source = generateSourceStructs(); \nList<Struct> target = generateTargetTrainingStructs(); \n\n// Train the matching model \nRequest entityMatchFitRequest = Request.create() \n          .withRootParameter(\"sources\",  source) \n          .withRootParameter(\"targets\", target) \n          .withRootParameter(\"matchFields\", Map.of(\"source\", \"name\", \"target\", \"externalId\")) \n          .withRootParameter(\"featureType\", \"insensitive\"); \n\nList<EntityMatchModel> models = client.contextualization() \n          .entityMatching() \n          .create(List.of(entityMatchFitRequest)); \n\nprivate List<Struct> generateSourceStructs() { \n     Struct entityA = Struct.newBuilder() \n          .putFields(\"id\", Values.of(1D)) \n          .putFields(\"name\", Values.of(\"23-DB-9101\")) \n          .putFields(\"fooField\", Values.of(\"bar\")) \n          .build(); \n     Struct entityB = Struct.newBuilder() \n          .putFields(\"id\", Values.of(2D)) \n          .putFields(\"name\", Values.of(\"23-PC-9101\")) \n          .putFields(\"barField\", Values.of(\"foo\")) \n          .build(); \n     return List.of(entityA, entityB); \n} \n\nprivate List<Struct> generateTargetTrainingStructs() { \n    Struct targetA = Struct.newBuilder() \n          .putFields(\"id\", Values.of(1D)) \n          .putFields(\"externalId\", Values.of(\"IA-23_DB_9101\")) \n          .build(); \n     Struct targetB = Struct.newBuilder() \n          .putFields(\"id\", Values.of(2D)) \n          .putFields(\"externalId\", Values.of(\"VAL_23_PC_9101\")) \n          .build(); \n     return List.of(targetA, targetB); \n} \n\n"
          }
        ]
      }
    },
    "/context/entitymatching/{id}": {
      "get": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Retrieve an entity matching model by the ID of the model",
        "description": "Shows the status of the model. If the status is completed, shows the parameters used to train the model.",
        "operationId": "entityMatchingStatus",
        "parameters": [
          {
            "$ref": "#/components/parameters/CogniteInternalId"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "classifier",
                    "featureType"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ"
        ]
      }
    },
    "/context/entitymatching/byids": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Retrieve entity matching models",
        "description": "Retrieve entity matching models by IDs or external IDs.",
        "operationId": "entityMatchingRetrieve",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "$ref": "#/components/schemas/OneOfId"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "items"
                  ],
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const [result] = await client.entityMatching.retrieve([{ externalId: 'model123' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "retrieved_model = client.entity_matching.retrieve(id=1)\nretrieved_models = client.entity_matching.retrieve_multiple([1,2,3])\n"
          }
        ]
      }
    },
    "/context/entitymatching/list": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Filter models",
        "description": "Use filtering options to find entity matcher models.",
        "operationId": "entityMatchingFilter",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "filter"
                ],
                "properties": {
                  "limit": {
                    "description": "<- Limits the number of results to return.",
                    "type": "integer",
                    "format": "int32",
                    "minimum": 1,
                    "maximum": 1000,
                    "default": 100
                  },
                  "filter": {
                    "type": "object",
                    "allOf": [
                      {
                        "description": "Filter on models with strict matching."
                      },
                      {
                        "$ref": "#/components/schemas/EntityMatchingFilterSchema"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "items"
                  ],
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const { items } = await client.entityMatching.list({ filter: { name: 'model123' }});"
          }
        ]
      }
    },
    "/context/entitymatching/update": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Update entity matching models",
        "description": "Update entity matching models by IDs or external IDs.",
        "operationId": "entityMatchingUpdate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ModelChange"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "items"
                  ],
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const [updated] = await client.entityMatching.update([{\n externalId: 'model123',\n update: { description: { set: '' }}\n}]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.contextualization import EntityMatchingModelUpdate\nclient.entity_matching.update(EntityMatchingModelUpdate(id=1).name.set(\"New name\"))\n"
          }
        ]
      }
    },
    "/context/entitymatching/delete": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Delete entity matcher model",
        "description": "Deletes an entity matching model. Currently, this is a soft delete, and only removes the entry from listing.",
        "operationId": "entityMatchingDelete",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "$ref": "#/components/schemas/OneOfId"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Models deleted.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.entityMatching.delete([{ externalId: 'model123' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.entity_matching.delete(id=1)\n"
          }
        ]
      }
    },
    "/context/entitymatching/predict": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Predict matches",
        "description": "Predicts entity matches using a trained model. Note: 'assetsAcl:READ' capability is required unless both `sources` and `targets` are specified in the request. Also note that the header of a successful response contains a `X-Job-Token` which allows to fetch the result of the job at `/context/entitymatching/jobs/{jobId}` without requiring 'assetsAcl:READ'.",
        "operationId": "entityMatchingPredict",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityMatchingPredictSchema"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "headers": {
              "X-Job-Token": {
                "schema": {
                  "$ref": "#/components/schemas/JobToken"
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId"
                  ],
                  "allOf": [
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        }
                      }
                    },
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const response = await client.entityMatching.predict({\n externalId: 'model123',\n sources: [{externalId: 'asset1', name: 'asset1'}, {externalId: 'asset2', name: 'asset2'}],\n targets: [{externalId: 'ts1', name: 'ts1'}, {externalId: 'ts2', name: 'ts2'}],\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "sources = {'id': 101, 'name': 'ChildAsset1', 'description': 'Child of ParentAsset1'}\ntargets = {'id': 1, 'name': 'ParentAsset1', 'description': 'Parent to ChildAsset1'}\ntrue_matches = [(1, 101)]\nmodel = client.entity_matching.predict(\n    sources = sources,\n    targets = targets,\n    num_matches = 1,\n    score_threshold = 0.6,\n    id=1\n)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<EntityMatchModel> models = // list of EntityMatchModel; \nlong modelId = models.get(0).getId(); \nList<Struct> source = generateSourceStructs(); \nList<Struct> target = generateTargetStructs(); \nList<EntityMatchResult> matchResults = client.contextualization() \n          .entityMatching() \n          .predict(modelId, source, target); \n\nprivate List<Struct> generateSourceStructs() { \n     Struct entityA = Struct.newBuilder() \n          .putFields(\"id\", Values.of(1D)) \n          .putFields(\"name\", Values.of(\"23-DB-9101\")) \n          .putFields(\"fooField\", Values.of(\"bar\")) \n          .build(); \n     Struct entityB = Struct.newBuilder() \n          .putFields(\"id\", Values.of(2D)) \n          .putFields(\"name\", Values.of(\"23-PC-9101\")) \n          .putFields(\"barField\", Values.of(\"foo\")) \n          .build(); \n     return List.of(entityA, entityB); \n} \n\nprivate List<Struct> generateTargetStructs() { \n     Struct targetA = Struct.newBuilder() \n          .putFields(\"id\", Values.of(1D)) \n          .putFields(\"externalId\", Values.of(\"IA-23_DB_9101\")) \n          .putFields(\"uuid\", Values.of(UUID.randomUUID().toString())) \n          .build(); \n     Struct targetB = Struct.newBuilder() \n          .putFields(\"id\", Values.of(2D)) \n          .putFields(\"externalId\", Values.of(\"VAL_23_PC_9101\")) \n          .putFields(\"uuid\", Values.of(UUID.randomUUID().toString())) \n          .build(); \n     return List.of(targetA, targetB); \n} \n\n"
          }
        ]
      }
    },
    "/context/entitymatching/jobs/{jobId}": {
      "get": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Retrieve entity matcher predict results",
        "description": "Get the results from a predict job. Note: 'assetsAcl:READ' capability is required, unless you specify a valid `X-Job-Token` in the request header. The `X-Job-Token` is provided in the response header of the initial call to `/context/entitymatching/predict`",
        "operationId": "entityMatchingPredictResults",
        "parameters": [
          {
            "$ref": "#/components/parameters/jobId"
          },
          {
            "in": "header",
            "name": "X-Job-Token",
            "schema": {
              "$ref": "#/components/schemas/JobToken"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StatusSchema"
                    },
                    {
                      "properties": {
                        "jobId": {
                          "$ref": "#/components/schemas/JobId"
                        },
                        "status": {
                          "$ref": "#/components/schemas/JobStatus"
                        },
                        "items": {
                          "type": "array",
                          "description": "List of matched entities with confidence score.",
                          "items": {
                            "type": "object",
                            "required": [
                              "source",
                              "matches"
                            ],
                            "properties": {
                              "source": {
                                "type": "object",
                                "example": {
                                  "field": "value",
                                  "ignoredfield": {
                                    "key": "value"
                                  }
                                },
                                "description": "The source item given to predict."
                              },
                              "matches": {
                                "type": "array",
                                "required": [
                                  "score",
                                  "target"
                                ],
                                "description": "Matched items, sorted from highest score to lowest. May be empty.",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "score": {
                                      "type": "number",
                                      "example": 0.98,
                                      "description": "The model's confidence in the match."
                                    },
                                    "target": {
                                      "type": "object",
                                      "example": {
                                        "field": "value",
                                        "ignoredfield": {
                                          "key": "value"
                                        }
                                      },
                                      "description": "The target item given to predict."
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "assetsAcl:READ",
          "entitymatchingAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const { status, items } = await client.entityMatching.predictResult(12345678);"
          }
        ]
      }
    },
    "/context/entitymatching/refit": {
      "post": {
        "tags": [
          "Entity matching"
        ],
        "summary": "Re-fit entity matcher model",
        "description": "Creates a new model by re-training an existing model on existing data but with additional true matches. The old model is not changed. The new model gets a new id and new external id if `newExternalId` is set, or no external id if `newExternalId` is not set. Use for efficient re-training of the model after a user creates additional confirmed matches.",
        "operationId": "entityMatchingReFit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityMatchingRefitSchema"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "classifier",
                    "featureType",
                    "originalId"
                  ],
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/EntityMatcherResponseSchema"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "entitymatchingAcl:READ",
          "entitymatchingAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.entityMatching.refit({\n newExternalId: 'newModel123',\n sources: [{externalId: 'asset1', name: 'asset1'}, {externalId: 'asset2', name: 'asset2'}],\n targets: [{externalId: 'ts1', name: 'ts1'}, {externalId: 'ts2', name: 'ts2'}],\n externalId: 'model123',\n trueMatches: [{sourceExternalId: 'asset1', targetExternalId: 'ts1'}]\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "sources = [{'id': 101, 'name': 'ChildAsset1', 'description': 'Child of ParentAsset1'}]\ntargets = [{'id': 1, 'name': 'ParentAsset1', 'description': 'Parent to ChildAsset1'}]\ntrue_matches = [(1, 101)]\nmodel = client.entity_matching.refit(true_matches = true_matches, description=\"AssetMatchingJob1\", id=1)\n"
          }
        ]
      }
    },
    "/diagram-parsing/connections": {
      "get": {
        "tags": [
          "Connections"
        ],
        "summary": "List connections",
        "description": "List all connections defined in the current project.",
        "operationId": "listConnections",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/diagramId"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ConnectionsListWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "tags": [
          "Connections"
        ],
        "summary": "Create connections",
        "description": "Create connections between symbols in parsed diagrams.",
        "operationId": "createConnections",
        "requestBody": {
          "description": "Connections to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateConnectionsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ConnectionsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/connections/byids": {
      "post": {
        "tags": [
          "Connections"
        ],
        "summary": "Retrieve connections",
        "description": "Retrieve up to 100 connections by specifying their IDs.",
        "operationId": "multiGetConnections",
        "requestBody": {
          "description": "List of IDs for the connections to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ConnectionsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/connections/delete": {
      "post": {
        "tags": [
          "Connections"
        ],
        "summary": "Delete connections",
        "description": "Delete up to 100 connections by specifying their IDs.",
        "operationId": "deleteConnections",
        "requestBody": {
          "description": "List of connections IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/diagrams": {
      "get": {
        "tags": [
          "Diagrams"
        ],
        "summary": "List diagrams",
        "description": "List all diagrams defined in the current project.",
        "operationId": "listDiagrams",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DiagramsListWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/diagrams/byids": {
      "post": {
        "tags": [
          "Diagrams"
        ],
        "summary": "Retrieve diagrams",
        "description": "Retrieve up to 100 diagrams by specifying their external IDs.",
        "operationId": "multiGetDiagrams",
        "requestBody": {
          "description": "List of IDs for the diagrams to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DiagramsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/diagrams/list": {
      "post": {
        "tags": [
          "Diagrams"
        ],
        "summary": "Filter diagrams",
        "description": "Filter and retrieve up to 100 diagrams by specifying their properties.",
        "operationId": "filterDiagrams",
        "requestBody": {
          "description": "Body contains the properties to filter on.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiagramFilters"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DiagramsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/diagrams/{diagramId}": {
      "get": {
        "tags": [
          "Diagrams"
        ],
        "summary": "Get an extended diagram by external id",
        "description": "Get diagram information and its parsed outputs using the diagram ID. The parsed output includes all diagram entities and their connections extracted during the file parsing process.",
        "operationId": "getExtendedDiagramById",
        "parameters": [
          {
            "$ref": "#/components/parameters/diagramIdPath"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExtendedDiagramResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/diagrams/{fileSpace}/{fileExternalId}/{pageNumber}": {
      "get": {
        "tags": [
          "Diagrams"
        ],
        "summary": "Get an extended diagram by file reference",
        "description": "Get diagram information and its parsed outputs using its related fileId and pageNumber. The parsed output includes all diagram entities and their connections extracted during the file parsing process.",
        "operationId": "getExtendedDiagramByFilePage",
        "parameters": [
          {
            "$ref": "#/components/parameters/fileSpace"
          },
          {
            "$ref": "#/components/parameters/fileExternalId"
          },
          {
            "$ref": "#/components/parameters/pageNumber"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExtendedDiagramResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/diagrams/{diagramId}/with-paths": {
      "get": {
        "tags": [
          "Diagrams"
        ],
        "summary": "Get an extended diagram with paths by external id",
        "description": "Get a single diagram containing entities, connections, and SVG data by using its external id",
        "operationId": "getExtendedDiagramWithPaths",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/diagramIdPath"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExtendedDiagramWithPathsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/geometries": {
      "get": {
        "tags": [
          "Geometries"
        ],
        "summary": "List geometries",
        "description": "List all geometries (also called variants in documentation) defined in the current project.",
        "operationId": "listGeometries",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/symbolId"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeometriesListWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "tags": [
          "Geometries"
        ],
        "summary": "Create geometries",
        "description": "Create geometries.",
        "operationId": "createGeometries",
        "requestBody": {
          "description": "Geometries to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateGeometriesRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeometriesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/geometries/byids": {
      "post": {
        "tags": [
          "Geometries"
        ],
        "summary": "Retrieve geometries",
        "description": "Retrieve up to 100 geometries by specifying their IDs.",
        "operationId": "multiGetGeometries",
        "requestBody": {
          "description": "List of IDs for the geometries to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeometriesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/geometries/delete": {
      "post": {
        "tags": [
          "Geometries"
        ],
        "summary": "Delete geometries",
        "description": "Delete up to 100 geometries by specifying their IDs.",
        "operationId": "deleteGeometries",
        "requestBody": {
          "description": "List of geometry IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/geometries/update": {
      "post": {
        "tags": [
          "Geometries"
        ],
        "summary": "Update geometries",
        "description": "Update the properties of a set of geometries",
        "operationId": "updateGeometries",
        "requestBody": {
          "description": "List of geometries to be updated.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateGeometriesRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeometriesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/libraries": {
      "get": {
        "tags": [
          "Libraries"
        ],
        "summary": "List libraries",
        "description": "List all libraries defined in the current project.",
        "operationId": "listLibraries",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/LibrariesListWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "tags": [
          "Libraries"
        ],
        "summary": "Create libraries",
        "description": "Create libraries.",
        "operationId": "createLibraries",
        "requestBody": {
          "description": "Libraries to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateLibrariesRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/LibrariesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/libraries/{libraryId}": {
      "get": {
        "tags": [
          "Libraries"
        ],
        "summary": "Get a library with symbols",
        "description": "Returns a single library with all its symbols and geometries.",
        "operationId": "getExtendedLibrary",
        "parameters": [
          {
            "$ref": "#/components/parameters/libraryIdPath"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExtendedLibraryResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/libraries/{libraryId}/copy": {
      "post": {
        "tags": [
          "Libraries"
        ],
        "summary": "Copy library",
        "description": "Creates a new library by copying an existing library, including all its symbols and geometries.",
        "operationId": "copyLibrary",
        "parameters": [
          {
            "$ref": "#/components/parameters/libraryIdPath"
          }
        ],
        "requestBody": {
          "description": "Name of the new library",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CopyLibraryInput"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/CopyLibraryResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/libraries/byids": {
      "post": {
        "tags": [
          "Libraries"
        ],
        "summary": "Retrieve libraries",
        "description": "Retrieve up to 100 libraries by specifying their IDs.",
        "operationId": "multiGetLibraries",
        "requestBody": {
          "description": "List of IDs for the libraries to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/LibrariesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/libraries/delete": {
      "post": {
        "tags": [
          "Libraries"
        ],
        "summary": "Delete libraries",
        "description": "Delete up to 100 libraries by specifying their IDs.",
        "operationId": "deleteLibraries",
        "requestBody": {
          "description": "List of libraries IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/libraries/update": {
      "post": {
        "tags": [
          "Libraries"
        ],
        "summary": "Update libraries",
        "description": "Update the properties of a set of libraries.",
        "operationId": "updateLibraries",
        "requestBody": {
          "description": "List of libraries to be updated.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateLibrariesRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/LibrariesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/entities": {
      "get": {
        "tags": [
          "Entities"
        ],
        "summary": "List diagram entities",
        "description": "List all diagram entities defined for the diagram specified by the diagramId parameter.",
        "operationId": "listDiagramEntities",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/diagramId"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EntitiesListWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "tags": [
          "Entities"
        ],
        "summary": "Create diagram entities",
        "description": "Create diagram entities.",
        "operationId": "createDiagramEntities",
        "requestBody": {
          "description": "Diagram entities to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateEntitiesRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EntitiesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/entities/byids": {
      "post": {
        "tags": [
          "Entities"
        ],
        "summary": "Retrieve diagram entities",
        "description": "Retrieve up to 100 diagram entities by specifying their IDs.",
        "operationId": "multiGetDiagramEntities",
        "requestBody": {
          "description": "List of IDs for the diagram entities to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EntitiesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/entities/delete": {
      "post": {
        "tags": [
          "Entities"
        ],
        "summary": "Delete diagram entities",
        "description": "Delete up to 100 diagram entities by specifying their IDs.",
        "operationId": "deleteDiagramEntities",
        "requestBody": {
          "description": "List of diagram entity IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/entities/update": {
      "post": {
        "tags": [
          "Entities"
        ],
        "summary": "Update diagram entities",
        "description": "Update the properties of a set of diagram entities",
        "operationId": "updateDiagramEntities",
        "requestBody": {
          "description": "List of diagram entities to be updated.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateEntitiesRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EntitiesListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/parsing/symbol-detection": {
      "post": {
        "tags": [
          "Parsing"
        ],
        "summary": "Run parsing for files",
        "description": "Start a parsing job on files to detect their symbols and connections.",
        "operationId": "runSymbolDetectionParsing",
        "requestBody": {
          "description": "Specifies the library to use when parsing the given files.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DiagramParseInput"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/parsing/instant": {
      "post": {
        "tags": [
          "Parsing"
        ],
        "summary": "Run an instant parsing job for a file",
        "description": "Start an instant parsing job on a file to detect diagram symbols based on the specified library. Parsed outputs do not persist.",
        "operationId": "runInstantParsing",
        "requestBody": {
          "description": "Specifies the library to use when instant parsing the given file.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InstantParseInput"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/InstantParsingResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/api/v1/projects/{project}/diagram-parsing/parsing/full": {
      "post": {
        "tags": [
          "Parsing"
        ],
        "summary": "Run parsing with tag detection for files",
        "description": "A parsing job will be started on the files to detect their entities and connections and map assets.",
        "operationId": "runFullParsing",
        "parameters": [
          {
            "$ref": "#/components/parameters/project"
          }
        ],
        "requestBody": {
          "description": "Defines parsing options needed for symbol and tag detection jobs.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FullParseInput"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE",
          "DataModelInstancesAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/symbols": {
      "get": {
        "tags": [
          "Symbols"
        ],
        "summary": "List symbols",
        "description": "List all symbols defined in the current project.",
        "operationId": "listSymbols",
        "parameters": [
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/libraryIdQuery"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SymbolsListWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "tags": [
          "Symbols"
        ],
        "summary": "Create symbols",
        "description": "Create symbols",
        "operationId": "createSymbols",
        "requestBody": {
          "description": "List of symbols to create.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSymbolsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SymbolsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/symbols/byids": {
      "post": {
        "tags": [
          "Symbols"
        ],
        "summary": "Retrieve symbols",
        "description": "Retrieve up to 100 symbols by specifying their IDs.",
        "operationId": "multiGetSymbols",
        "requestBody": {
          "description": "List of IDs for the symbols to return.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SymbolsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/symbols/delete": {
      "post": {
        "tags": [
          "Symbols"
        ],
        "summary": "Delete symbols",
        "description": "Delete up to 100 symbols by specifying their IDs.",
        "operationId": "deleteSymbols",
        "requestBody": {
          "description": "List of symbols IDs to delete.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ExternalIdsResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/symbols/update": {
      "post": {
        "tags": [
          "Symbols"
        ],
        "summary": "Update symbols",
        "description": "Update the properties of a set of symbols",
        "operationId": "updateSymbols",
        "requestBody": {
          "description": "List of symbols to be updated.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateSymbolsRequest"
              }
            }
          },
          "required": true
        },
        "x-capability": [
          "DiagramParsingAcl:WRITE"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/SymbolsListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/svg-data/diagram/{diagramId}": {
      "get": {
        "tags": [
          "SVG Data"
        ],
        "summary": "Get SVG data by diagramId",
        "description": "Get the SVG data of a file by externalId of a diagram.",
        "operationId": "getSVGDataByDiagramId",
        "parameters": [
          {
            "$ref": "#/components/parameters/diagramIdPath"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ",
          "DataModelInstancesAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GetSVGDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/diagram-parsing/svg-data/file/{fileSpace}/{fileExternalId}/{pageNumber}": {
      "get": {
        "tags": [
          "SVG Data"
        ],
        "summary": "Get SVG data by file reference",
        "description": "Get the SVG data of a file by file instanceId and pageNumber.",
        "operationId": "getSVGDataByDocument",
        "parameters": [
          {
            "$ref": "#/components/parameters/fileSpace"
          },
          {
            "$ref": "#/components/parameters/fileExternalId"
          },
          {
            "$ref": "#/components/parameters/pageNumber"
          }
        ],
        "x-capability": [
          "DiagramParsingAcl:READ",
          "DataModelInstancesAcl:READ"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GetSVGDataResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/context/vision/extract": {
      "post": {
        "tags": [
          "Vision"
        ],
        "summary": "Extract features from images",
        "description": "Start an asynchronous prediction job for extracting features such as text, asset tags or industrial objects from images.\nThe response of the POST request contains a job ID, which can be used to make subsequent (GET) calls\nto check the status and retrieve the results of the job\n(see [Retrieve results from a feature extraction job](getVisionExtract)).\n\nIt is possible to have up to 20 concurrent jobs per CDF project.\n\nThe files referenced by `items` in the request body must fulfill the following requirements:\n\n* Must have file extension: `.jpeg`, `.jpg` or `.png`\n* Must have `image/png` or `image/jpeg` as `mimeType`\n\nNew feature extractors may be added in the future.\n",
        "operationId": "postVisionExtract",
        "parameters": [
          {
            "$ref": "#/components/parameters/cdfversionheader"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/VisionExtractPostRequestSchema"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/VisionExtractPostResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const job = await client.vision.extract(['TextDetection', 'AssetTagDetection', 'PeopleDetection'], [{ fileId: 1234 }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.contextualization import VisionFeature\nextract_job = client.vision.extract(features=VisionFeature.ASSET_TAG_DETECTION, file_ids=[1])\nextract_job.wait_for_completion()\nfor item in extract_job.items:\n    predictions = item.predictions\n    # do something with the predictions\nextract_job.save_predictions()\n"
          }
        ]
      }
    },
    "/context/vision/extract/{jobId}": {
      "get": {
        "tags": [
          "Vision"
        ],
        "summary": "Retrieve results from a feature extraction job on images",
        "description": "Retrieve results from a feature extraction job on images.\n\nNote that since files are split up into batches and processed independently of each other, the items in successfully completed batches will be returned even if files in other batches are still being processed. The job status will be `Running` until all batches have been processed. If one of the items in a batch fails, the results from items in other completed batches will still be returned. The corresponding items and error message(s) of failed batches will be populated in `failedItems`.\nAdditionally, the status of the job is set to `Completed` if at least one batch is successfully completed, otherwise the status is set to `Failed`.\n",
        "operationId": "getVisionExtract",
        "parameters": [
          {
            "$ref": "#/components/parameters/cdfversionheader"
          },
          {
            "$ref": "#/components/parameters/jobId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/VisionExtractGetResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const { items } = await client.vision.getExtractJob(12345678, true); // get an existing job, wait for it to complete, and get the results\nitems.forEach((item) => {\n const predictions = item.predictions // do something with the predictions\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "extract_job = client.vision.get_extract_job(job_id=1)\nextract_job.wait_for_completion()\nfor item in extract_job.items:\n    predictions = item.predictions\n    # do something with the predictions\n"
          }
        ]
      }
    },
    "/context/vision/segment": {},
    "/api/v1/projects/{projectName}/ai/chat/completions": {},
    "/api/v1/projects/{projectName}/ai/embeddings": {},
    "/api/v1/projects/{projectName}/ai/services/availability": {},
    "/api/v1/projects/{projectName}/ai/tools/documents/ask": {
      "post": {
        "description": "This API endpoint uses an LLM to answer questions about documents.\nGiven a question in natural language, and a list of files, this API returns\na multi-part answer with references to the locations in the given documents\nwhich were used to build the answer.\n\n### Limitations\n- Only PDF files are currently supported.\n- The PDF files must be maximum 400 pages long.\n- Only 100 files may be passed in a single request.",
        "operationId": "document_questioning_api_v1_projects__projectName__ai_tools_documents_ask_post",
        "parameters": [
          {
            "in": "header",
            "name": "content-type",
            "required": true,
            "schema": {
              "title": "Content-Type",
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/projectName"
          },
          {
            "$ref": "#/components/parameters/cdfversionheader"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentQARequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Answer"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "summary": "Ask questions about one or more documents",
        "tags": [
          "Document AI"
        ]
      }
    },
    "/api/v1/projects/{projectName}/ai/tools/documents/summarize": {
      "post": {
        "description": "This API generates concise summaries for a list of input documents using a large language model (LLM), returning a corresponding list of summaries. Only PDF files are currently supported.",
        "operationId": "documents_summary_api_v1_projects__projectName__ai_tools_documents_summarize_post",
        "parameters": [
          {
            "in": "header",
            "name": "content-type",
            "required": true,
            "schema": {
              "title": "Content-Type",
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/projectName"
          },
          {
            "$ref": "#/components/parameters/cdfversionheader"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentSummarizationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentSummarizationResponse"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "summary": "Summarize documents",
        "tags": [
          "Document AI"
        ]
      }
    },
    "/api/v1/projects/{projectName}/ai/tools/graphql/completions": {},
    "/api/v1/projects/{projectName}/ai/tools/pythonsdk/completions": {},
    "/api/v1/projects/{projectName}/ai/tools/pythonsdk/edit": {},
    "/api/v1/projects/{projectName}/ai/tools/query/generate": {},
    "/context/documentparser/jobs/start": {},
    "/context/documentparser/jobs": {},
    "/context/documentparser/jobs/byids": {},
    "/context/documentparser/{jobId}": {},
    "/context/documentparser/jobs/write": {
      "post": {
        "summary": "Write Results to Data Models (INTERNAL)",
        "operationId": "writeResultsToDataModels",
        "tags": [
          "Document parsing"
        ],
        "description": "Write results to data models.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentParserWriteResultsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Results written to data models successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentParserWriteResultsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/documents/search": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Search for documents",
        "description": "This endpoint lets you search for documents by using advanced filters and free text queries.\nFree text queries are matched against the documents' filenames and contents.\n\n### Free text search\n\n#### Boolean operators\n\nThe `+` symbol represents an AND operation, and the `|` symbol represents an OR.\nSearching for `lorem + ipsum` will match documents containing both \"lorem\" AND \"ipsum\" in the filename or content.\nSimilarly, searching for `lorem | ipsum` will match documents containing either \"lorem\" OR \"ipsum\" in the filename or\ncontent.\n\nThe default operator between the search keywords is AND.\nThat means that searching for two terms without any operator, for example, `lorem ipsum`, will\nmatch documents containing both the words \"lorem\" and \"ipsum\" in the filename or content.\n\nYou can use the operator `-` to exclude documents containing a specific word.\nFor instance, the search `lorem -ipsum` will match documents that contain the word \"lorem\", but does NOT contain the\nword \"ipsum\".\n\n#### Phrases\n\nEnclose multiple words inside double quotes `\"` to group these words together.\nNormally, the search query `lorem ipsum` will match not only \"lorem ipsum\" but also \"lorem cognite ipsum\",\nand in general, there can be any number of words between the two words in the query.\nThe search query `\"lorem ipsum\"`, however, will match only exactly \"lorem ipsum\" and not \"lorem cognite ipsum\".\n\n#### Escape\n\nTo search for the special characters (`+`, `|`, `-`, `\"`. `\\`), escape with a preceding backslash `\\`.\n\n#### Ordering\n\nWhen you search for a term, the endpoint tries to return the most relevant documents first, with less relevant documents further down\nthe list.\nThere are a few factors that determine the relevance of a document:\n\n- If the search terms are found multiple times within a document, the relevance of that document is higher.\n- For searches with multiple terms, documents containing all the terms are considered more relevant than documents\n  containing only some.\n- Matches of the terms in the filename field of the document are more relevant than matches in the document's content.\n\n#### Examples\n\nThe following request will return documents matching the specified search query.\n\n```json\n{\n  \"search\": {\n    \"query\": \"cognite \\\"lorem ipsum\\\"\"\n   }\n}\n ```\n\nThe following example combines a query with a filter.\nThe search request will return documents matching the search query, where `externalId` starts with \"1\".\nThe results will be ordered by how well they match the query string.\n\n```json\n{\n    \"search\":{\n        \"query\":\"cognite \\\"lorem ipsum\\\"\"\n    },\n    \"filter\":{\n        \"prefix\":{\n            \"property\":[\n                \"externalId\"\n            ],\n            \"value\":\"1\"\n        }\n    }\n}\n```\n\n### Highlights\n\nWhen you enable highlights for your search query, the response contains an additional highlight field for each\nsearch hit, including the highlighted fragments for your query matches. However, the result limit is 20 documents due to the operation costs.\n\n### Filtering\n\nFiltering uses a special JSON filtering language.\nIt's quite flexible and consists of a number of different \"leaf\" filters, which can be combined arbitrarily using the boolean clauses `and`, `or`, and `not`.\n\n#### Supported leaf filters\n\n<table>\n<tr>\n<th> <div style=\"width:150px\"> Leaf filter </div> </th> \n<th> <div style=\"width:200px\"> Supported fields </div> </th> \n<th> Description  </th>\n</tr>\n\n<tr>\n<td> <code>equals</code> </td> <td> Non-array type fields </td> <td> Only includes results that are equal to the specified value. \n\n```json\n{\n    \"equals\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"value\":\"example\"\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>in</code> </td> <td> Non-array type fields </td> <td> Only includes results that are equal to one of the specified values.  \n\n```json\n{\n    \"in\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"values\":[\n            1,\n            2,\n            3\n        ]\n    }\n}\n```\n</td>\n</tr>\n\n<td> <code>containsAll</code> </td> <td> Array type fields </td> <td> Only includes results which contain all of the specified values.  \n\n```json\n{\n    \"containsAll\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"values\":[\n            1,\n            2,\n            3\n        ]\n    }\n}\n```\n</td>\n<tr>\n\n<td> <code>containsAny</code> </td> <td> Array type fields </td> <td> Only includes results which contain all of the specified values.  \n\n```json\n{\n    \"containsAny\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"values\":[\n            1,\n            2,\n            3\n        ]\n    }\n}\n```\n</td>\n\n<tr>\n<td> <code>exists</code> </td> <td> All fields </td> <td> Only includes results where the specified property exists (has value).  \n\n```json\n{\n    \"exists\":{\n        \"property\":[\n            \"property\"\n        ]\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>prefix</code> </td> <td> String type fields </td> <td> Only includes results which start with the specified value. \n\n```json\n{\n    \"prefix\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"value\":\"example\"\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>range</code> </td> <td> Non-array type fields </td> <td> Only includes results that fall within the specified range. \n\nSupported operators: <code>gt</code>, <code>lt</code>, <code>gte</code>, <code>lte</code>\n\n```json\n{\n    \"range\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"gt\":1,\n        \"lte\":5\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>geojsonIntersects</code> </td> <td> <code>geoLocation</code> </td> <td> Only includes results where the geoshape intersects with the specified geometry.\n\n```json\n{\n    \"geojsonIntersects\":{\n        \"property\":[\n            \"sourceFile\",\n            \"geoLocation\"\n        ],\n        \"geometry\":{\n            \"type\":\"Polygon\",\n            \"coordinates\": [[[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]]],\n        }\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>geojsonDisjoint</code> </td> <td> <code>geoLocation</code> </td> <td> Only includes results where the geoshape has nothing in common with the specified geometry.\n\n```json\n{\n    \"geojsonDisjoint\":{\n        \"property\":[\n            \"sourceFile\",\n            \"geoLocation\"\n        ],\n        \"geometry\":{\n            \"type\":\"Polygon\",\n            \"coordinates\": [[[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]]],\n        }\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>geojsonWithin</code> </td> <td> <code>geoLocation</code> </td> <td> Only includes results where the geoshape falls within the specified geometry.\n\n```json\n{\n    \"geojsonWithin\":{\n        \"property\":[\n            \"sourceFile\",\n            \"geoLocation\"\n        ],\n        \"geometry\":{\n            \"type\":\"Polygon\",\n            \"coordinates\": [[[30, 10], [40, 40], [20, 40], [10, 20], [30, 10]]],\n        }\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>inAssetSubtree</code> </td> <td> <code>assetIds</code>, <code>assetExternalIds</code> </td> <td> Only includes results with a related asset in a subtree rooted at any specified IDs.\n\n```json\n{\n    \"filter\":{\n        \"inAssetSubtree\":{\n            \"property\":[\n                \"sourceFile\",\n                \"assetIds\"\n            ],\n            \"values\":[\n                1,\n                2,\n                3\n            ]\n        }\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>search</code> </td> <td> <code>name</code>, <code>content</code> </td> <td>\n\n```json\n{\n    \"search\":{\n        \"property\":[\n            \"property\"\n        ],\n        \"value\":\"example\"\n    }\n}\n```\n</td>\n</tr>\n\n</table>\n\n#### Properties\n\nThe following overview shows the properties you can filter and which filter applies to which property.\n\n| Property                                 | Type                | Applicable filters                                                                                                                                                             |\n|------------------------------------------|---------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `[\"id\"]`                                 | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"externalId\"]`                         | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"instanceId\"]`                         | string              | equals, in                                                                                                                                                                     |\n\n| `[\"title\"]`                              | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"author\"]`                             | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"createdTime\"]`                        | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"modifiedTime\"]`                       | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"lastIndexedTime\"]`                    | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"mimeType\"]`                           | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"extension\"]`                          | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"pageCount\"]`                          | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"type\"]`                               | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"geoLocation\"]`                        | geometry object     | geojsonIntersects, geojsonDisjoint, geojsonWithin, exists                                                                                                                      |\n| `[\"language\"]`                           | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"assetIds\"]`                           | array of integers   | containsAny, containsAll, exists, inAssetSubtree                                                                                                                               |\n| `[\"assetExternalIds\"]`                   | array of strings    | containsAny, containsAll, exists, inAssetSubtree                                                                                                                               |\n| `[\"labels\"]`                             | array of Labels     | containsAny, containsAll, exists                                                                                                                                               |\n| `[\"content\"]`                            | string              | search                                                                                                                                                                         |\n| `[\"sourceFile\", \"name\"]`                 | string              | equals, in, prefix, exists, search                                                                                                                                             |\n| `[\"sourceFile\", \"mimeType\"]`             | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"sourceFile\", \"size\"]`                 | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"sourceFile\", \"source\"]`               | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"sourceFile\", \"directory\"]`            | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"sourceFile\", \"assetIds\"]`             | array of integers   | containsAny, containsAll, exists, inAssetSubtree                                                                                                                               |\n| `[\"sourceFile\", \"assetExternalIds\"]`     | array of strings    | containsAny, containsAll, exists, inAssetSubtree                                                                                                                               |\n| `[\"sourceFile\", \"datasetId\"]`            | integer             | equals, in, range, exists                                                                                                                                                      |\n| `[\"sourceFile\", \"securityCategories\"]`   | array of integers   | containsAny, containsAll, exists                                                                                                                                               |\n| `[\"sourceFile\", \"geoLocation\"]`          | geometry object     | geojsonIntersects, geojsonDisjoint, geojsonWithin, exists                                                                                                                      |\n| `[\"sourceFile\", \"labels\"]`               | array of Labels     | containsAny, containsAll, exists                                                                                                                                               |\n| `[\"sourceFile\", \"metadata\", <key>]`      | string              | equals, in, prefix, exists                                                                                                                                                     |\n| `[\"sourceFile\", \"metadata\"]`             | string              | equals, in, prefix, exists<br><br>This is a special filter field that targets all metadata values. <br>An alternative to creating a filter for each key in the metadata field. |\n\n#### Full example\n\n```json\n{\n   \"filter\": {\n      \"and\": [\n         {\n            \"or\": [\n               {\n                  \"equals\": {\n                     \"property\": [\n                        \"type\"\n                     ],\n                     \"value\": \"PDF\"\n                  }\n               },\n               {\n                  \"prefix\": {\n                     \"property\": [\n                        \"externalId\"\n                     ],\n                     \"value\": \"hello\"\n                  }\n               }\n            ]\n         },\n         {\n            \"range\": {\n               \"property\": [\n                  \"createdTime\"\n               ],\n               \"lte\": 1519862400000\n            }\n         },\n         {\n            \"not\": {\n               \"in\": {\n                  \"property\": [\n                     \"sourceFile\",\n                     \"name\"\n                  ],\n                  \"values\": [\n                     \"My Document.doc\",\n                     \"My Other Document.docx\"\n                  ]\n               }\n            }\n         }\n      ]\n   }\n}\n ```\n\n### Sorting\n\nBy default, search results are ordered by relevance, meaning how well they match the given query string.\nHowever, it's possible to specify a different property to sort by.\nSorting can be ascending or descending. The sort order is ascending if none is specified.\n\n#### Properties\n\nThe following overview shows all properties that can be sorted on.\n\n| Property                        |\n|---------------------------------|\n| `[\"id\"]`                        |\n| `[\"externalId\"]`                |\n| `[\"mimeType\"]`                  |\n| `[\"extension\"]`                 |\n| `[\"pageCount\"]`                 |\n| `[\"author\"]`                    |\n| `[\"title\"]`                     |\n| `[\"language\"]`                  |\n| `[\"type\"]`                      |\n| `[\"createdTime\"]`               |\n| `[\"modifiedTime\"]`              |\n| `[\"lastIndexedTime\"]`           |\n| `[\"sourceFile\", \"name\"]`        |\n| `[\"sourceFile\", \"mimeType\"]`    |\n| `[\"sourceFile\", \"size\"]`        |\n| `[\"sourceFile\", \"source\"]`      |\n| `[\"sourceFile\", \"datasetId\"]`   |\n| `[\"sourceFile\", \"metadata\", *]` |\n\n#### Example\n\n```json\n{\n    \"sort\":[\n        {\n            \"property\":[\n                \"createdTime\"\n            ],\n            \"order\":\"asc\",\n            \n        }\n    ]\n}\n ```\n",
        "operationId": "documentsSearch",
        "requestBody": {
          "description": "Fields to be set for the search request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentSearchResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ",
          null
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const documents = await client.documents.search({\n  search: {\n    query: 'Stuck pipe'\n  },\n  filter: {\n    in: {\n      property: ['type'],\n      values: ['Document', 'PDF']\n    }\n  },\n  limit: 5\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nfrom cognite.client.data_classes.documents import DocumentProperty\nis_pdf = filters.Equals(DocumentProperty.mime_type, \"application/pdf\")\ndocuments = client.documents.search(\"pump 123\", filter=is_pdf)\n\nfrom datetime import datetime, timedelta\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.documents import DocumentProperty\nfrom cognite.client.utils import timestamp_to_ms\nis_plain_text = filters.Equals(DocumentProperty.mime_type, \"text/plain\")\nlast_week = filters.Range(DocumentProperty.created_time,\n    gt=timestamp_to_ms(datetime.now() - timedelta(days=7)))\ndocuments = client.documents.search('\"CPLEX Error 1217: No Solution exists.\"',\n    highlight=True,\n    filter=filters.And(is_plain_text, last_week))\n"
          }
        ]
      }
    },
    "/documents/passages/search": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Semantic search for passages",
        "description": "This endpoint lets you search for relevant passages of up to 100 PDF documents by using advanced filters and semantic search queries. \nWhere documents search results in a list of relevant documents, this endpoint gives you a result of the most relevant parts of a set of documents.\nFor each query you have to specify a list of document ids using the `in` filter (see exmple).\n\nSemantic search works by comparing the semantic meaning of the search query to the semantic meaning of the document passages. \nThe document passages are automatically derived and indexed upon file uploads (PDF only).\n\nA natural flow would be:\n 1. Upload a document\n 2. Query `/documents/status` to check if the document is ready (see beta documentation)\n 3. Query `/documents/passages/search` to find relevant passages in the document(s) \n\n### Passages search offers semantic search filters\n\n> This endpoint requires a list of document ids that you want to do semantic search on. \n> You can not currently search through all passages for the entire project in a single query.\n\n#### Ordering\n\nSearch results are ranked by relevance, with the most relevant appearing first. How relevance is determined depends on the filter you choose:\n\n - **Lexical Search Filter**: This filter looks for exact word matches, making it ideal for finding specific dates, names, or keywords. Use this when you know exactly what youre looking for. This is the default search behavior for the Documents API.\n\n - **Semantic Search Filter**: This filter understands the meaning behind words and phrases, even if they dont match exactly. Its useful for broader searches or when youre looking for related ideas or concepts.\n\nChoose the filter based on your needs: use Lexical for precise results and Semantic for more general, context-based searches.\n\nWhen both filters are used together, the results are combined to give you a balanced, relevant list. For best results, we recommend starting with both filters active.\n\n\n#### Examples\n\nThe following request will return document passages matching the specified search query for the document ids 1, 2, and 3.\n\n```json\n{\n    \"filter\":{\n        \"and\": [\n            {\n                \"semanticSearch\":{\n                    \"property\":[\"content\"],\n                    \"value\":\"I have an overheating pump that is 85 degrees celsius, what dangers are there with higher temperatures\"\n                }\n            },\n            {\n                \"in\":{\n                    \"property\":[\"document\", \"id\"],\n                    \"values\":[1, 2, 3]\n                }\n            }\n        ]\n    }\n}\n ```\n\nIf you need keyword matching you can specify a `lexicalSearch` filter. This helps with edge cases where it's hard to extract meaning such as numbers (eg. dates), names, etc.\n\n```json\n{\n    \"filter\":{\n        \"and\": [\n            {\n                \"semanticSearch\":{\n                    \"property\":[\"content\"],\n                    \"value\":\"I have an overheating pump that is 85 degrees celsius, what dangers are there with higher temperatures\"\n                }\n            },\n            {\n                \"lexicalSearch\":{\n                    \"property\":[\"content\"],\n                    \"value\":\"pump AJ523-253-133\"\n                }\n            },\n            {\n                \"in\":{\n                    \"property\":[\"document\", \"id\"],\n                    \"values\":[1, 2, 3]\n                }\n            }\n        ]\n    }\n}\n ```\n\nDoing just lexical search is also possible:\n\n```json\n{\n    \"filter\":{\n        \"and\": [\n            {\n                \"lexicalSearch\":{\n                    \"property\":[\"content\"],\n                    \"value\":\"pump AJ523-253-133\"\n                }\n            },\n            {\n                \"in\":{\n                    \"property\":[\"document\", \"id\"],\n                    \"values\":[1, 2, 3]\n                }\n            }\n        ]\n    }\n}\n ```\n\n\n### Filtering\n\nFiltering uses a special JSON filtering language.\nIt's flexible and consists of a number of different \"leaf\" filters, which can be combined arbitrarily using the boolean clauses `and`.\nThis is the same filters used in the search, list and aggregate endpoints, with some restrictions and the addition of \"semanticSearch\" filter.\n\n#### Supported leaf filters\n\n<table>\n<tr>\n<th> <div style=\"width:150px\"> Leaf filter </div> </th> \n<th> <div style=\"width:200px\"> Supported fields </div> </th> \n<th> Description  </th>\n</tr>\n\n<tr>\n<td> <code>equals</code> </td> <td> Non-array type fields </td> <td> Only includes results that are equal to the specified value. \n\n```json\n{\n    \"equals\":{\n        \"property\":[\"property\"],\n        \"value\":\"example\"\n    }\n}\n```\n</td>\n</tr>\n\n<tr>\n<td> <code>in</code> </td> <td> Non-array type fields </td> <td> Only includes results that are equal to one of the specified values.  \n\n```json\n{\n    \"in\":{\n        \"property\":[\"property\"],\n        \"values\":[\n            1,\n            2,\n            3\n        ]\n    }\n}\n```\n</td>\n</tr>\n\n\n<tr>\n<td> <code>semanticSearch</code> </td> <td> <code>content</code> </td> <td>\n\n```json\n{\n    \"semanticSearch\":{\n        \"property\":[\"property\"],\n        \"value\":\"example\"\n    }\n}\n```\n</td>\n</tr>\n\n\n<tr>\n<td> <code>lexicalSearch</code> </td> <td> <code>content</code> </td> <td>\n\n```json\n{\n    \"lexicalSearch\":{\n        \"property\":[\"property\"],\n        \"value\":\"example\"\n    }\n}\n```\n</td>\n</tr>\n\n</table>\n\n#### Properties\n\nThe following overview shows the properties you can filter on and which filter applies to which property.\n\n| Property                      | Type                | Applicable filters            |\n|-------------------------------|---------------------|-------------------------------|\n| `[\"document\", \"id\"]`          | integer             | equals, in                    |\n| `[\"document\", \"externalId\"]`  | string              | equals, in                    |\n| `[\"document\", \"instanceId\"]`  | object              | equals, in                    |\n| `[\"type\"]`                    | string              | equals                        |\n| `[\"content\"]`                 | string              | semanticSearch, lexicalSearch |\n\n#### Full example\n\n```json\n{\n    \"filter\":{\n      \"and\": [\n        {\n          \"in\": {\n            \"property\": [\"document\", \"instanceId\"],\n            \"values\": [\n              {\"space\": \"space1\", \"externalId\": \"my-ext-id-1\"},\n              {\"space\": \"space1\", \"externalId\": \"my-ext-id-45\"},\n              {\"space\": \"space1\", \"externalId\": \"some-other-ext-id\"},\n            ]\n          }\n        },\n        {\n          \"semanticSearch\":{\n              \"property\":[\"content\"],\n              \"value\":\"A person walking a dog at night time\"\n          }\n        },\n        {\n          \"lexicalSearch\":{\n              \"property\":[\"content\"],\n              \"value\":\"11:23pm\"\n          }\n        }\n      ]\n    }\n}\n ```\n",
        "operationId": "documentsPassagesSearch",
        "requestBody": {
          "description": "Fields to be set for the search request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentPassagesSearchRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentPassagesSearchResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/documents/status": {},
    "/documents/aggregate": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Aggregate documents",
        "description": "The aggregation API lets you compute aggregated results on documents, such as\ngetting the count of all documents in a project, checking\ndifferent authors of documents in a project and the count of documents in\neach of those aggregations. By specifying an additional filter or search, you can\naggregate only among documents matching the specified filter or search.\n\nWhen you don't specify the `aggregate` field in the request\nbody,  the default behavior is to return the count of all matched documents.\n\n### Supported aggregates\n\n<table>\n\n<tr>\n<th> <div style=\"width:200px\"> Aggregate </div> </th> \n<th> <div style=\"width:350px\"> Description </div> </th> \n<th> Example  </th>\n</tr>\n\n<tr>\n<td> <code>count</code> </td> <td> Count of documents matching the specified filters and search. </td> <td>  \n\n```json\n{\n    \"search\":{\n        \"query\":\"example\",\n        \n    },\n    \"aggregate\":\"count\",\n    \n}\n```\n\n<tr>\n<td> <code>cardinalityValues</code> </td> <td> Returns an approximate count of \ndistinct values for the specified properties. </td> <td>  \n\n```json\n{\n    \"aggregate\":\"cardinalityValues\",\n    \"properties\":[\n        {\n            \"property\":[\n                \"mimeType\"\n            ]\n        }\n    ]\n}\n```\n\n</td>\n</tr>\n\n<tr>\n<td> <code>cardinalityProperties</code> </td> <td> Returns an approximate count of\ndistinct properties for a given property path. Currently only implemented for the\n<code>[\"sourceFile\", \"metadata\"]</code> path.</td> <td>\n\n```json\n{\n    \"aggregate\":\"cardinalityProperties\",\n    \"path\":[\"sourceFile\", \"metadata\"]\n}\n```\n\n</td>\n</tr>\n\n</td>\n</tr>\n\n<tr>\n<td> <code>uniqueValues</code> </td> <td> Returns top unique values for specified properties (up to the\nrequested limit) and the count of each in the property specified in <code>properties</code>. \nThe list will have the highest count first. </td> <td>  \n\n```json\n{\n    \"aggregate\":\"uniqueValues\",\n    \"properties\":[\n        {\n            \"property\":[\n                \"author\"\n            ]\n        }\n    ]\n}\n```\n\n</td>\n</tr>\n\n<tr>\n<td> <code>uniqueProperties</code> </td> <td> Returns top unique properties values for specified properties (up to the\nrequested limit) and the count of each in the property specified in <code>properties</code>. \nThe list will have the highest count first.\n\nCurrently, the <code>uniqueProperties</code> aggregate is only supported for property \n<code>[\"sourceFile\", \"metadata\"]</code> .</td> <td>  \n\n```json\n{\n    \"aggregate\":\"uniqueProperties\",\n    \"properties\":[\n        {\n            \"property\":[\n                \"sourceFile\",\n                \"metadata\"\n            ]\n        }\n    ]\n}\n```\n\n</td>\n</tr>\n\n</table>\n\n### Aggregate filtering\n\n> Only some aggregate types currently support <code>aggregateFilter</code>\n\nAggregate filtering works directly on the aggregated result. While a normal filter filters relevant documents, aggregate filtering filters the aggregated bucket values. This is useful for e.g. listing metadata keys; while a normal filter will return all metadata keys for related documents, the aggregate filter can be used to reduce the aggregate result even further.\n\nTip: use both <code>filter</code> and <code>aggregateFilter</code> to potentially speed up queries, as the <code>aggregateFilter</code> is essentially a post filter.\n\n\n#### Filter metadata keys by prefix\n\nHere we only show metadata keys which starts with \"car\".\n```json\n{\n    \"aggregate\": \"uniqueProperties\",\n    \"properties\": [{\"property\": [\"sourceFile\", \"metadata\"]}],\n    \"aggregateFilter\": {\"prefix\": {\"value\": \"car\"}}\n}\n```\n\n#### Filter metadata values by prefix\n\nHere we only show metadata values which starts with \"ctx\", for the given metadata key \"car-codes\".\n```json\n{\n    \"aggregate\": \"uniqueValues\",\n    \"properties\": [{\"property\": [\"sourceFile\", \"metadata\", \"car-codes\"]}],\n    \"aggregateFilter\": {\"prefix\": {\"value\": \"ctx\"}}\n}\n```\n",
        "operationId": "documentsAggregate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateCountRequest"
                  },
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateCardinalityValuesRequest"
                  },
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateCardinalityPropertiesRequest"
                  },
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateUniqueValuesRequest"
                  },
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateUniquePropertiesRequest"
                  },
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateAllUniquePropertiesRequest"
                  },
                  {
                    "$ref": "#/components/schemas/DocumentsAggregateAllUniqueValuesRequest"
                  }
                ]
              },
              "examples": {
                "unique-values": {
                  "value": {
                    "filter": {
                      "equals": {
                        "property": [
                          "type"
                        ],
                        "value": "PDF"
                      }
                    },
                    "aggregate": "uniqueValues",
                    "properties": [
                      {
                        "property": [
                          "author"
                        ]
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsAggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.documents import SourceFileProperty\ncount = client.documents.aggregate_cardinality_properties(SourceFileProperty.metadata)\nfrom cognite.client.data_classes.documents import DocumentProperty\ncount = client.documents.aggregate_cardinality_values(DocumentProperty.type)\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.documents import DocumentProperty\nis_plain_text = filters.Equals(DocumentProperty.mime_type, \"text/plain\")\nplain_text_author_count = client.documents.aggregate_cardinality_values(DocumentProperty.author, filter=is_plain_text)\n\nfrom cognite.client.data_classes.documents import DocumentProperty\nfrom cognite.client.data_classes import aggregations\nagg = aggregations\nis_not_text = agg.Not(agg.Prefix(\"text\"))\ntype_count_excluded_text = client.documents.aggregate_cardinality_values(DocumentProperty.type, aggregate_filter=is_not_text)\ncount = client.documents.aggregate_count()\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.documents import DocumentProperty\nis_pdf = filters.Equals(DocumentProperty.mime_type, \"application/pdf\")\npdf_count = client.documents.aggregate_count(filter=is_pdf)\n\nclient.documents.aggregate_count(\n    filter=filters.InAssetSubtree(\n        property=DocumentProperty.asset_external_ids,\n        values=['Plant_1', 'Plant_2'],\n    )\n)\nfrom cognite.client.data_classes.documents import SourceFileProperty\nresult = client.documents.aggregate_unique_values(SourceFileProperty.metadata)\nfrom cognite.client.data_classes.documents import DocumentProperty\nresult = client.documents.aggregate_unique_values(DocumentProperty.mime_type)\nunique_types = result.unique\n\nfrom cognite.client.data_classes import filters\nfrom cognite.client.data_classes.documents import DocumentProperty\nis_abc = filters.Prefix(DocumentProperty.external_id, \"abc\")\nresult = client.documents.aggregate_unique_values(DocumentProperty.language, filter=is_abc)\nunique_languages = result.unique\n\nfrom cognite.client.data_classes.documents import DocumentProperty\nfrom cognite.client.data_classes import aggregations\nagg = aggregations\nis_not_text = agg.Not(agg.Prefix(\"text\"))\nresult = client.documents.aggregate_unique_values(DocumentProperty.mime_type, aggregate_filter=is_not_text)\nunique_mime_types = result.unique\n"
          }
        ]
      }
    },
    "/documents/list": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "List documents",
        "description": "Retrieves a list of the documents in a project. You can use filters to narrow down the list.\nUnlike the search endpoint, the pagination isn't restricted to 1000 documents in total, meaning\nthis endpoint can be used to iterate through all the documents in your project.\n\nFor more information on how the filtering works, see the documentation for the search endpoint.",
        "operationId": "documentsList",
        "requestBody": {
          "description": "Fields to be set for the list request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentListRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentListResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import filters\nfrom cognite.client.data_classes.documents import DocumentProperty\nis_pdf = filters.Equals(DocumentProperty.mime_type, \"application/pdf\")\npdf_documents = client.documents.list(filter=is_pdf)\n\nfrom cognite.client.data_classes.documents import DocumentProperty\nfor document in client.documents:\n   print(document.name)\n\nfrom cognite.client.data_classes.documents import SortableDocumentProperty\ndocuments = client.documents.list(sort=(SortableDocumentProperty.mime_type, \"desc\"))\n"
          }
        ]
      }
    },
    "/documents/{id}/content": {
      "get": {
        "deprecated": true,
        "tags": [
          "Documents"
        ],
        "summary": "Retrieve document content",
        "description": "Returns extracted textual information for the given document.\nThe documents pipeline extracts up to 1MiB of textual information from each processed document.\nThe search and list endpoints truncate the textual content of each document, in order to reduce the size\nof the returned payload. If you want the whole text for a document, you can use this endpoint.\nThe `accept` request header MUST be set to `text/plain`. Other values will\ngive an HTTP 406 error.",
        "operationId": "documentsContent",
        "parameters": [
          {
            "$ref": "#/components/parameters/CogniteInternalId"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "description": "The textual content of the document, truncated to the first 1MB of text",
                  "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "content = client.documents.retrieve_content(id=123)\nfrom pathlib import Path\nwith Path(\"my_file.txt\").open(\"wb\") as buffer:\n    client.documents.retrieve_content_buffer(id=123, buffer=buffer)\n"
          }
        ]
      }
    },
    "/documents/content": {
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Retrieve document content",
        "description": "Returns extracted textual information for the given document.\n\nThe documents pipeline extracts up to 1MiB of textual information from each processed document.\nThe search and list endpoints truncate the textual content of each document, in order to reduce the size\nof the returned payload. If you want the whole text for a document, you can use this endpoint.\n\nThe `accept` request header MUST be set to `text/plain`. Other values will\ngive an HTTP 406 error.",
        "operationId": "documentsContentPost",
        "requestBody": {
          "description": "Fields to be set for the content request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentContentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "text/plain": {
                "schema": {
                  "type": "string",
                  "description": "The textual content of the document, truncated to the first 1MB of text",
                  "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ]
      }
    },
    "/documents/{documentId}/preview/image/pages/{pageNumber}": {
      "get": {
        "tags": [
          "Document preview"
        ],
        "summary": "Retrieve a image preview of a page from a document",
        "operationId": "documentsPreviewImagePage",
        "description": "This endpoint returns a rendered image preview for a specific page of the specified document.\n\nThe `accept` request header MUST be set to `image/png`. Other values will\ngive an HTTP 406 error.\n\nThe rendered image will be downsampled to a maximum of 2400x2400 pixels.\nOnly PNG format is supported and only the first 10 pages can be rendered.\n\nPreviews will be rendered if neccessary during the request. Be prepared\nfor the request to take a few seconds to complete.",
        "parameters": [
          {
            "in": "path",
            "name": "documentId",
            "schema": {
              "type": "integer"
            },
            "required": true,
            "description": "Internal ID for document to preview"
          },
          {
            "in": "path",
            "name": "pageNumber",
            "schema": {
              "type": "integer",
              "minimum": 1,
              "maximum": 10
            },
            "required": true,
            "description": "Page number to preview. Starting at 1 for first page"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "image/png": {
                "schema": {
                  "description": "Rendered PNG image",
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "401": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "406": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.documents.previews.download_page_as_png(\"previews\", id=123, page_number=5)\ncontent = client.documents.previews.download_page_as_png_bytes(id=123, page_number=5)\n\nfrom IPython.display import Image\nbinary_png = client.documents.previews.download_page_as_png_bytes(id=123, page_number=5)\nImage(binary_png)\n"
          }
        ]
      }
    },
    "/documents/{documentId}/preview/pdf": {
      "get": {
        "tags": [
          "Document preview"
        ],
        "summary": "Retrieve a PDF preview of a document",
        "operationId": "documentsPreviewPdf",
        "description": "This endpoint returns a rendered PDF preview for a specified document.\n\nThe `accept` request header MUST be set to `application/pdf`. Other values will\ngive an HTTP 406 error.\n\nThis endpoint is optimized for in-browser previews. We reserve the right\nto adjust the quality and other attributes of the output with this in mind.\nPlease reach out to us if you have a different use case and requirements.\n\nPreviews will be rendered if neccessary during the request. Be prepared\nfor the request to take a few seconds to complete.",
        "parameters": [
          {
            "$ref": "#/components/parameters/cdfversionheader"
          },
          {
            "in": "path",
            "name": "documentId",
            "schema": {
              "type": "integer"
            },
            "required": true,
            "description": "Internal ID for document to preview"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/pdf": {
                "schema": {
                  "description": "Rendered PDF document",
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "401": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "406": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.documents.previews.download_document_as_pdf(\"previews\", id=123)\ncontent = client.documents.previews.download_document_as_pdf_bytes(id=123)\n"
          }
        ]
      }
    },
    "/documents/{documentId}/preview/pdf/temporarylink": {
      "get": {
        "tags": [
          "Document preview"
        ],
        "summary": "Retrieve a temporary link to a PDF preview of a document",
        "operationId": "documentsPreviewPdfTemporaryLink",
        "description": "This endpoint works similar as the normal preview endpoint except\nit returns a short-lived temporary link to download the rendered preview instead\nof returning the binary data.",
        "parameters": [
          {
            "$ref": "#/components/parameters/cdfversionheader"
          },
          {
            "in": "path",
            "name": "documentId",
            "schema": {
              "type": "integer"
            },
            "required": true,
            "description": "Internal ID for document to preview"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DocumentsPreviewTemporaryLinkResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "401": {
            "$ref": "#/components/responses/ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "filesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "link = client.documents.previews.retrieve_pdf_link(id=123)\n"
          }
        ]
      }
    },
    "/geospatial/crs": {
      "get": {
        "tags": [
          "Geospatial"
        ],
        "summary": "List Coordinate Reference Systems",
        "description": "List the defined Coordinate Reference Systems. The list can be limited to the custom Coordinate Reference Systems defined for the tenant.",
        "operationId": "listGeospatialCoordinateReferenceSystems",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFilterOnlyCustom"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialCoordinateReferenceSystemResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialCrsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const allCRS = await client.geospatial.crs.list({ filterOnlyCustom : true });"
          }
        ]
      },
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Create Coordinate Reference Systems",
        "description": "Creates custom Coordinate Reference Systems.",
        "operationId": "createGeospatialCoordinateReferenceSystems",
        "requestBody": {
          "description": "List of custom Coordinate Reference Systems to be created.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialCustomCoordinateReferenceSystemSpecs"
              },
              "examples": {
                "GeospatialCreateCoordinateReferenceSystemsExample": {
                  "$ref": "#/components/examples/GeospatialCreateCoordinateReferenceSystemsExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/GeospatialCustomCoordinateReferenceSystemResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialCrsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const crsToCreate = [{\n srid: 456789,\n wkt: 'GEOGCS[\\\"WGS 84\\\",DATUM[\\\"WGS_1984\\\",SPHEROID[\\\"WGS 84\\\",6378137,298.257223563,AUTHORITY[\\\"EPSG\\\",\\\"7030\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"6326\\\"]],PRIMEM[\\\"Greenwich\\\",0,AUTHORITY[\\\"EPSG\\\",\\\"8901\\\"]],UNIT[\\\"degree\\\",0.0174532925199433,AUTHORITY[\\\"EPSG\\\",\\\"9122\\\"]],AUTHORITY[\\\"EPSG\\\",\\\"4326\\\"]]',\n projString: '+proj=longlat +datum=WGS84 +no_defs \\\"\\\"'\n }];\n\nconst createdCRS = await client.geospatial.crs.create(crsToCreate);"
          }
        ]
      }
    },
    "/geospatial/crs/byids": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Get Coordinate Reference Systems",
        "description": "Get Coordinate Reference Systems by their Spatial Reference IDs",
        "operationId": "getCoordinateReferenceSystem",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialReferenceIds"
              },
              "examples": {
                "CoordinateReferenceSystemRequestExample": {
                  "$ref": "#/components/examples/GeospatialCoordinateReferenceSystemRequestExample"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialCoordinateReferenceSystemResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialCrsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const retrievedCRS = await client.geospatial.crs.retrieve([{ srid: 4326 }]);"
          }
        ]
      }
    },
    "/geospatial/crs/delete": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Delete Coordinate Reference Systems",
        "description": "Delete custom Coordinate Reference Systems.",
        "operationId": "deleteGeospatialCoordinateReferenceSystems",
        "requestBody": {
          "description": "List of custom Coordinate Reference Systems to be deleted.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialReferenceIds"
              },
              "examples": {
                "CoordinateReferenceSystemRequestExample": {
                  "$ref": "#/components/examples/GeospatialCoordinateReferenceSystemRequestExample"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialCrsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.geospatial.crs.delete([{ srid: 4326}]);"
          }
        ]
      }
    },
    "/geospatial/featuretypes": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Create feature types",
        "description": "Creates feature types. Each tenant can have up to 100 feature types.",
        "operationId": "createFeatureTypes",
        "requestBody": {
          "description": "List of feature types to be created. It is possible to create up to 100 feature types in one request provided the total number of feature types on the tenant will not exceed 100.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureTypeSpecs"
              },
              "examples": {
                "GeospatialFeatureTypesRequestExample": {
                  "$ref": "#/components/examples/GeospatialFeatureTypesRequestExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/GeospatialFeatureTypesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const featureTypes = [\n  {\n     externalId: 'ocean_temperature',\n     properties: { temperature: { type: 'DOUBLE' as const }, location: { type: 'POINT' as const, srid: 4326 } } ,\n     searchSpec: { location_idx: { properties : ['location'] } }\n  }\n];\nconst createdFeatureTypes = await client.geospatial.featureType.create(featureTypes);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/byids": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Retrieve feature types",
        "description": "Retrieves feature types by external ids. It is possible to retrieve up to 100 items per request, i.e. the maximum number of feature types for a tenant.",
        "operationId": "getFeatureTypesByIds",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureTypeExternalIds"
              },
              "examples": {
                "ExternalIdsExample": {
                  "$ref": "#/components/examples/GeospatialFeatureTypeExternalIdsExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeatureTypesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const retrievedFeatureTypes = await client.geospatial.featureType.retrieve([ { externalId: 'ocean_temperature' } ]);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/list": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "List feature types",
        "description": "List all feature types",
        "operationId": "listFeatureTypes",
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeatureTypesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const allFeatureTypes = await client.geospatial.featureType.list();"
          }
        ]
      }
    },
    "/geospatial/featuretypes/update": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Update feature types",
        "description": "Update one or more feature types",
        "operationId": "updateFeatureTypes",
        "requestBody": {
          "description": "List of feature types to be updated. It is possible to add and remove properties and indexes. WARNING: removing properties will result in data loss in corresponding features.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialUpdateFeatureTypeSpecs"
              },
              "examples": {
                "GeospatialFeatureTypesUpdateRequestExample": {
                  "$ref": "#/components/examples/GeospatialFeatureTypesUpdateRequestExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeatureTypesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const featureTypesToUpdate = [\n {\n   externalId: 'ocean_temperature',\n   update: {\n       properties: { add: { depth: { type: 'DOUBLE'} }, remove: ['temperature'] },\n       searchSpec: { add: { depth_idx: { properties: ['depth'] } } }\n   }\n }\n];\nconst updatedFeatureTypes = await client.geospatial.featureType.update(featureTypesToUpdate);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/delete": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Delete feature types",
        "description": "Delete feature types.",
        "operationId": "GeospatialDeleteFeatureTypes",
        "requestBody": {
          "description": "List of feature types to be deleted. It is possible to delete a maximum of 10 feature types per request. Feature types must not have related features. Feature types with related features can be deleted using force flag.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialDeleteFeatureType"
              },
              "examples": {
                "ExternalIdsExample": {
                  "$ref": "#/components/examples/GeospatialFeatureTypeExternalIdsExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "await client.geospatial.featureType.delete([{ externalId: 'ocean_temperature'}], { recursive : true });"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Create features",
        "description": "Create features",
        "operationId": "createFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureSpecs"
              },
              "examples": {
                "GeospatialFeaturesRequestExample": {
                  "$ref": "#/components/examples/GeospatialFeaturesRequestExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/GeospatialFeaturesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const featureTypeExternalId = 'ocean_temperature';\nconst features = [\n  { externalId: 'measurement_point_765', temperature: 5.65, location: { wkt: 'POINT(60.547602 -5.423433)' }},\n  { externalId: 'measurement_point_863', temperature: 5.03, location: { wkt: 'POINT(60.585858 -6.474416)' }},\n];\nconst createdFeatures = await client.geospatial.feature.create(featureTypeExternalId, features);"
          }
        ]
      },
      "get": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Get features",
        "description": "Get features with paging support",
        "operationId": "getFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "in": "query",
            "name": "limit",
            "schema": {
              "$ref": "#/components/schemas/SearchLimit"
            }
          },
          {
            "in": "query",
            "name": "allowCrsTransformation",
            "schema": {
              "$ref": "#/components/schemas/GeospatialAllowCrsTransformation"
            }
          },
          {
            "in": "query",
            "name": "allowDimensionalityMismatch",
            "schema": {
              "$ref": "#/components/schemas/GeospatialAllowDimensionalityMismatch"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeaturesWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/list": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Filter all features",
        "description": "List features based on the feature property filter passed in the body of the request. This operation supports pagination by cursor.",
        "operationId": "listFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureListRequest"
              },
              "examples": {
                "GeospatialFeatureExternalIdsExample": {
                  "$ref": "#/components/examples/GeospatialListExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeaturesWithCursorResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const params = {\n filter: {\n   and: [\n     { range:{ property: 'temperature', gt:4.54 } },\n     { stWithin: { property:'location', value:'POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))' } }\n  ]\n },\n};\n\nconst allFeaturesList = await client.geospatial.feature.list('ocean_temperature', params);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/byids": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Retrieve features",
        "description": "Retrieves features by external ids. It is possible to retrieve up to 1000 items per request.",
        "operationId": "getFeaturesByIds",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureIdsWithOutput"
              },
              "examples": {
                "GeospatialFeatureExternalIdsExample": {
                  "$ref": "#/components/examples/GeospatialFeatureExternalIdsExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeaturesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const featuresToRetrieve = [{ externalId: 'measurement_point_765' }, { externalId: 'measurement_point_765' }];\nconst outputParams = { output: { geometryFormat: 'GEOJSON' as const } };\n\nconst retrievedFeatures = await client.geospatial.feature.retrieve('ocean_temperature', featuresToRetrieve, outputParams);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/update": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Update features",
        "description": "Update features. This is a replace operation, i.e., all feature properties have to be sent in the request body even if their values do not change.",
        "operationId": "updateFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "description": "List of features to update.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureSpecs"
              },
              "examples": {
                "GeospatialFeaturesRequestExample": {
                  "$ref": "#/components/examples/GeospatialFeaturesRequestExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeaturesResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const featuresToDelete = [{ externalId: 'measurement_point_765' }, { externalId: 'measurement_point_765' }];\n\nawait client.geospatial.feature.delete('ocean_temperature', featuresToDelete);\n\nconst featuresToUpdate = [\n{ externalId: 'measurement_point_765', temperature: 5.65, location: { wkt: 'POINT(60.547602 -5.423433)' } },\n{ externalId: 'measurement_point_863', temperature: 5.03, location: { wkt: 'POINT(60.585858 -6.474416)' } }\n];\n\nconst updatedFeatures = await client.geospatial.feature.update('ocean_temperature', featuresToUpdate);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/delete": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Delete features",
        "description": "Delete features.",
        "operationId": "deleteFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "description": "List of features to be deleted. It is possible to post a maximum of 1000 items per request.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureIds"
              },
              "examples": {
                "GeospatialFeatureExternalIdsExample": {
                  "$ref": "#/components/examples/GeospatialFeatureExternalIdsExample"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialAcl:WRITE"
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/search": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Search features",
        "description": "Search for features based on the feature property filter passed in the body of the request. The result of the search is limited to a maximum of 1000 items. Results in excess of the limit are truncated. This means that the complete result set of the search cannot be retrieved with this method. However, for a given unmodified feature collection, the result of the search is deterministic and does not change over time.",
        "operationId": "searchFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureSearchRequest"
              },
              "examples": {
                "GeospatialSearchExample": {
                  "$ref": "#/components/examples/GeospatialSearchExample"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeatureSearchResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const params = {\n filter: {\n   and: [\n     { range:{ property: 'temperature', gt:4.54 } },\n     { stWithin: { property:'location', value:'POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))' } }\n  ]\n },\n limit: 100,\n sort: [ 'temperature:ASC','location']\n};\n\nconst searchedFeatures = await client.geospatial.feature.search('ocean_temperature', params);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/search-streaming": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Search and stream features",
        "description": "Search for features based on the feature property filter passed in the body of the request. The streaming response format can be length prefixed, new line delimited, record separator delimited or concatenated depending on requested output (see https://en.wikipedia.org/wiki/JSON_streaming).",
        "operationId": "searchFeaturesStreaming",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureSearchStreamingRequest"
              },
              "examples": {
                "GeospatialSearchStreamingExample": {
                  "$ref": "#/components/examples/GeospatialSearchStreamingExample"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeatureSearchStreamingResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const params = {\n filter: {\n   and: [\n     { range:{ property: 'temperature', gt:4.54 } },\n     { stWithin: { property:'location', value:'POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))' } }\n  ]\n },\n limit: 100,\n output: { jsonStreamFormat: 'NEW_LINE_DELIMITED' as const }\n};\n\nconst featureStreamString = await client.geospatial.feature.searchStream('ocean_temperature', params);"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/aggregate": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Aggregate features",
        "description": "Search for features based on the feature property filter and perform requested aggregations on a given property. Aggregations are supported for all filters that do not contain `stWithin`, `stWithinProperly`, `stContains` and `stContainsProperly` search in 3D geometries.",
        "operationId": "aggregateFeatures",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialFeatureAggregateRequest"
              },
              "examples": {
                "FeatureAggregateExample": {
                  "$ref": "#/components/examples/GeospatialFeatureAggregateExample"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialFeatureAggregateResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const aggregateParams = {\n filter: {\n   and: [\n     { range:{ property: 'temperature', gt:4.54 } },\n     { stWithin: { property:'location', value:'POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))' } }\n  ]\n },\n property: 'temperature',\n aggregates: ['min', 'max', 'average'],\n groupBy: ['category']\n};\n\nconst featureStream = await client.geospatial.feature.searchStream('ocean_temperature', aggregateParams);"
          }
        ]
      }
    },
    "/geospatial/compute": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Compute",
        "description": "Compute custom json output structures or well known binary format responses based on calculation or selection of feature properties or direct values given in the request.",
        "operationId": "compute",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialComputeRequest"
              },
              "examples": {
                "StTransformGeometryExample": {
                  "$ref": "#/components/examples/GeospatialComputeRequestExample"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialComputeResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialCrsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const response = await client.geospatial.compute.compute({\n  output: {\n    \"output\": {\n      stTransform: {\n        geometry: {\n          ewkt: \"SRID=4326;POLYGON((0 0,10 0,10 10,0 10,0 0))\"\n        },\n        srid: 4326,\n      }\n    }\n  }\n});"
          }
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/{featureExternalId}/rasters/{rasterPropertyName}": {
      "put": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Put a raster into a feature property",
        "description": "Put a raster into a feature property. The feature property must be of type RASTER.",
        "operationId": "putRaster",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          },
          {
            "$ref": "#/components/parameters/geospatialFeatureExternalId"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterPropertyName"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterSrid"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterInputFormat"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterPixelScaleX"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterPixelScaleY"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterAllowCrsTransformation"
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "format": "binary"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/GeospatialRasterMetadataResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialAcl:WRITE"
        ]
      },
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Get a raster from a feature property",
        "description": "Get a raster from a feature property. The feature property must be of type RASTER.",
        "operationId": "getRaster",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          },
          {
            "$ref": "#/components/parameters/geospatialFeatureExternalId"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterPropertyName"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GeospatialRasterOutputSpec"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The binary file of the raster in the specified format",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ"
        ]
      }
    },
    "/geospatial/featuretypes/{featureTypeExternalId}/features/{featureExternalId}/rasters/{rasterPropertyName}/delete": {
      "post": {
        "tags": [
          "Geospatial"
        ],
        "summary": "Delete a raster from a feature property",
        "description": "Delete a raster from a feature property. If there is no raster already, the operation is a no-op.",
        "operationId": "deleteRaster",
        "parameters": [
          {
            "$ref": "#/components/parameters/geospatialFeatureTypeExternalId"
          },
          {
            "$ref": "#/components/parameters/geospatialFeatureExternalId"
          },
          {
            "$ref": "#/components/parameters/geospatialRasterPropertyName"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/GeospatialErrorResponse"
          }
        },
        "x-capability": [
          "geospatialAcl:READ",
          "geospatialAcl:WRITE"
        ]
      }
    },
    "/reportdeletion": {},
    "/reportdeletion/pending": {},
    "/reportdeletion/reset": {},
    "/sessions/batchrefresh": {},
    "/sessions/token": {},
    "/sessions/detach": {},
    "/sessions": {
      "get": {
        "x-capability": "sessionsAcl:LIST",
        "tags": [
          "Sessions"
        ],
        "operationId": "listSessions",
        "summary": "List sessions",
        "description": "List all sessions in the current project.",
        "parameters": [
          {
            "in": "query",
            "name": "status",
            "description": "If given, only sessions with the given status are returned.\n",
            "schema": {
              "type": "string",
              "enum": [
                "ready",
                "active",
                "cancelled",
                "revoked",
                "access_lost"
              ]
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "Cursor to use for paging through results.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Return up to this many results. Maximum is 1000. Default is 25.",
            "schema": {
              "maximum": 1000,
              "type": "integer",
              "format": "int32",
              "default": 25
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A list of sessions in the current project.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      },
      "post": {
        "x-capability": "sessionsAcl:CREATE",
        "tags": [
          "Sessions"
        ],
        "operationId": "createSessions",
        "summary": "Create sessions",
        "description": "Create sessions",
        "requestBody": {
          "description": "A request containing the information needed to create a session.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateSessionRequestList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of session creation related information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateSessionResponseList"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/sessions/byids": {
      "post": {
        "x-capability": "sessionsAcl:LIST",
        "tags": [
          "Sessions"
        ],
        "operationId": "getSessionsByIds",
        "summary": "Retrieve sessions with given IDs",
        "description": "Retrieves sessions with given IDs. The request will fail if any of the IDs does not belong to an existing session.",
        "requestBody": {
          "description": "List of session IDs to retrieve",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SessionReferenceIds"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "A list of sessions with the given ids",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionByIds"
                },
                "example": {
                  "items": [
                    {
                      "id": 105049194919491,
                      "type": "TOKEN_EXCHANGE",
                      "status": "ACTIVE",
                      "creationTime": 1638795559528,
                      "expirationTime": 1638795559628
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/sessions/revoke": {
      "post": {
        "x-capability": "sessionsAcl:DELETE",
        "tags": [
          "Sessions"
        ],
        "operationId": "revokeSessions",
        "summary": "Revoke sessions",
        "description": "Revoke access to a session. Revocation is idempotent.\nRevocation of a session may in some cases take up to 1 hour to take effect.\n",
        "requestBody": {
          "description": "A request containing the information needed to revoke sessions.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeSessionRequestList"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of revoked sessions.\nIf the user does not have the `sessionsAcl:LIST` capability, then only the session IDs will be present in the response.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SessionList"
                },
                "example": {
                  "items": [
                    {
                      "id": 0,
                      "type": "CLIENT_CREDENTIALS",
                      "status": "REVOKED",
                      "creationTime": 1638795554528,
                      "expirationTime": 1638795554528,
                      "clientId": "client-123"
                    }
                  ]
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/extpipes": {
      "get": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "List extraction pipelines",
        "description": "Returns a list of all extraction pipelines for a given project",
        "operationId": "listExtPipes",
        "parameters": [
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipesWithCursor"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "ep_list = client.extraction_pipelines.list(limit=5)\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Create extraction pipelines",
        "description": "Creates multiple new extraction pipelines. A maximum of 1000 extraction pipelines can be created per request.",
        "operationId": "createExtPipes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_CreateExtPipe_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipesWithCursor"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:WRITE",
          "datasetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import ExtractionPipelineWrite\nextpipes = [ExtractionPipelineWrite(name=\"extPipe1\",...), ExtractionPipelineWrite(name=\"extPipe2\",...)]\nres = client.extraction_pipelines.create(extpipes)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ExtractionPipeline> upsertPipelinesList = List.of(ExtractionPipeline.newBuilder() \n          .setExternalId(\"10\") \n          .setName(\"generated-\") \n          .setDescription(\"Generated description\") \n          .setDataSetId(dataSetId) \n          .setSource(\"sdk-data-generator\") \n          .putMetadata(\"type\", \"sdk-data-generator\") \n          .addContacts(ExtractionPipeline.Contact.newBuilder() \n               .setName(\"generated-\") \n               .setRole(\"generated\") \n               .build()) \n          .build()); \n\nclient.extractionPipelines().upsert(upsertPipelinesList); \n\n"
          }
        ]
      }
    },
    "/extpipes/delete": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Delete extraction pipelines",
        "description": "Delete extraction pipelines for given list of ids and externalIds. When the extraction pipeline is deleted, all extraction pipeline runs related to the extraction pipeline are automatically deleted.",
        "operationId": "deleteExtPipes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExtendedItemsRequest_ExtPipeId_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:WRITE",
          "datasetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.extraction_pipelines.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nList<Item> deleteItemsResults =  \n          client.extractionPipelines().delete(deleteByExternalIds); \n\nList<Item> deleteByInternalIds = List.of(Item.newBuilder()\n          .setId(10) \n          .build()); \nList<Item> deleteItemsResults =  \n          client.extractionPipelines().delete(deleteByInternalIds); \n\n"
          }
        ]
      }
    },
    "/extpipes/update": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Update extraction pipelines",
        "description": "Update information for a list of extraction pipelines. Fields that are not included in the request, are not changed.",
        "operationId": "updateExtPipes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_ExtPipeUpdate_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of updated extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:WRITE",
          "datasetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import ExtractionPipelineUpdate\nupdate = ExtractionPipelineUpdate(id=1)\nupdate.description.set(\"Another new extpipe\")\nres = client.extraction_pipelines.update(update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ExtractionPipeline> upsertPipelinesList = //list of ExtractionPipeline \nclient.extractionPipelines().upsert(upsertPipelinesList); \n\n"
          }
        ]
      }
    },
    "/extpipes/{id}": {
      "get": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Retrieve an extraction pipeline by its ID.",
        "description": "Retrieve an extraction pipeline by its ID. If you want to retrieve extraction pipelines by externalIds, use Retrieve extraction pipelines instead.",
        "operationId": "showExtPipe",
        "parameters": [
          {
            "$ref": "#/components/parameters/CogniteInternalId"
          }
        ],
        "responses": {
          "200": {
            "description": "Single extraction pipeline response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipe"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.extraction_pipelines.retrieve(id=1)\n\nres = client.extraction_pipelines.retrieve(external_id=\"1\")\n"
          }
        ]
      }
    },
    "/extpipes/byids": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Retrieve extraction pipelines",
        "description": "Retrieves information about multiple extraction pipelines in the same project. All ids and externalIds must be unique.",
        "operationId": "byidsExtPipes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExtendedItemsRequest_ExtPipeId_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.extraction_pipelines.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.extraction_pipelines.retrieve_multiple(external_ids=[\"abc\", \"def\"], ignore_unknown_ids=True)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> itemsByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nList<ExtractionPipeline> retrievedEvents = \n          client.extractionPipelines().retrieve(itemsByExternalIds);//by list of items \nList<ExtractionPipeline> retrievedEvents = \n          client.extractionPipelines().retrieve(\"10\");//by varargs of String \n\nList<Item> itemsByInternalIds = List.of(Item.newBuilder() \n          .setId(10) \n          .build()); \nList<ExtractionPipeline> retrievedEvents = \n          client.extractionPipelines().retrieve(itemsByInternalIds); \n List<ExtractionPipeline> retrievedEvents = \n          client.extractionPipelines().retrieve(10);//by varargs of Long \n\n"
          }
        ]
      }
    },
    "/extpipes/list": {
      "post": {
        "tags": [
          "Extraction Pipelines"
        ],
        "summary": "Filter extraction pipelines",
        "description": "Use advanced filtering options to find extraction pipelines.",
        "operationId": "filterExtPipes",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExtPipesFilterRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the list of extraction pipelines",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExtPipes"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionpipelinesAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ExtractionPipeline> listPipelinesResults = new ArrayList<>(); \nclient.extractionPipelines() \n          .list(Request.create() \n               .withFilterParameter(\"source\", \"source\")) \n          .forEachRemaining(events -> listPipelinesResults.addAll(events)); \n\n"
          }
        ]
      }
    },
    "/extpipes/config": {
      "get": {
        "tags": [
          "Extraction Pipelines Config"
        ],
        "summary": "Get a single configuration revision",
        "description": "Retrieves a single configuration revision. By default, the latest revision is retrieved.",
        "operationId": "getExtPipeConfigRevision",
        "parameters": [
          {
            "name": "externalId",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "revision",
            "in": "query",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "format": "int32",
              "default": 0
            }
          },
          {
            "name": "activeAtTime",
            "in": "query",
            "required": false,
            "schema": {
              "minimum": 0,
              "type": "integer",
              "format": "int64",
              "default": 0
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the retrieved configuration revision",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionconfigsAcl:READ"
        ]
      },
      "post": {
        "tags": [
          "Extraction Pipelines Config"
        ],
        "summary": "Create extraction configuration revision",
        "description": "Creates a configuration revision for the given extraction pipeline.",
        "operationId": "createExtPipeConfig",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the created configuration revision",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionconfigsAcl:WRITE"
        ]
      }
    },
    "/extpipes/config/revisions": {
      "get": {
        "tags": [
          "Extraction Pipelines Config"
        ],
        "summary": "List configuration revisions",
        "description": "Lists configuration revisions for the given extraction pipeline.",
        "operationId": "listExtPipeConfigRevisions",
        "parameters": [
          {
            "name": "externalId",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the retrieved configuration revisions and an optional cursor",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_ListConfigResponse_"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionconfigsAcl:READ"
        ]
      }
    },
    "/extpipes/config/revert": {
      "post": {
        "tags": [
          "Extraction Pipelines Config"
        ],
        "summary": "Revert configuration revision",
        "description": "Reverts the latest configuration revision to an older revision. Equivalent to creating a new revision identical to the old revision.",
        "operationId": "revertExtPipeConfigRevision",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevertConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with the new latest configuration revision",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigResponse"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionconfigsAcl:WRITE"
        ]
      }
    },
    "/extpipes/runs": {
      "get": {
        "tags": [
          "Extraction Pipelines Runs"
        ],
        "summary": "List extraction pipeline runs",
        "description": "List of all extraction pipeline runs for a given extraction pipeline. Sorted by createdTime value with descendant order.",
        "operationId": "runs",
        "parameters": [
          {
            "name": "externalId",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "Response with list of extraction pipeline runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_ExtPipeRunResponse_"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionrunsAcl:READ"
        ]
      },
      "post": {
        "tags": [
          "Extraction Pipelines Runs"
        ],
        "summary": "Create extraction pipeline runs",
        "description": "Create multiple extraction pipeline runs. Current version supports one extraction pipeline run per request. Extraction pipeline runs support three statuses: success, failure, seen. The content of the Error Message parameter is configurable and will contain any messages that have been configured within the extraction pipeline.",
        "operationId": "createRuns",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsRequest_ExtPipeRunRequest_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of extraction pipeline runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_CreateExtPipeRunResponse_"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionrunsAcl:WRITE",
          "datasetsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import ExtractionPipelineRunWrite\nres = client.extraction_pipelines.runs.create(\n    ExtractionPipelineRunWrite(status=\"success\", extpipe_external_id=\"extId\"))\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ExtractionPipeline> listPipelinesResults = //list of ExtractionPipeline; \nList<ExtractionPipelineRun> upsertPipelineRunsList = \n          List.of(ExtractionPipelineRun.newBuilder() \n          .setExternalId(listPipelinesResults.get(0).getExternalId()) \n          .setCreatedTime(Instant.now().toEpochMilli()) \n          .setMessage(\"generated-\") \n          .setStatus(ExtractionPipelineRun.Status.SUCCESS) \n          .build()); \n\n client.extractionPipelines().runs().create(upsertPipelineRunsList); \n\n"
          }
        ]
      }
    },
    "/extpipes/runs/list": {
      "post": {
        "tags": [
          "Extraction Pipelines Runs"
        ],
        "summary": "Filter extraction pipeline runs",
        "description": "Use advanced filtering options to find extraction pipeline runs. Sorted by createdTime value with descendant order.",
        "operationId": "filterRuns",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RunsFilterRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of extraction pipeline runs",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsResponse_ExtPipeRunResponse_"
                }
              }
            }
          },
          "400": {
            "description": "Response for a failed request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DefaultError"
                }
              }
            }
          }
        },
        "x-capability": [
          "extractionrunsAcl:READ"
        ],
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "runsList = client.extraction_pipelines.runs.list(external_id=\"test ext id\", limit=5)\n\nruns_list = client.extraction_pipelines.runs.list(external_id=\"test ext id\", statuses=[\"seen\"], limit=5)\n\nfrom cognite.client.data_classes import ExtractionPipelineRun\nres = client.extraction_pipelines.runs.list(external_id=\"extId\", statuses=\"failure\", created_time=\"24h-ago\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<ExtractionPipelineRun> listPipelinesRunsResults = new ArrayList<>(); \nclient.extractionPipelines() \n          .runs() \n          .list() \n          .forEachRemaining(run -> listPipelinesRunsResults.addAll(run)); \n\nclient.extractionPipelines() \n          .runs() \n          .list(Request.create().withFilterParameter(\"statuses\", \"success\")) \n          .forEachRemaining(run -> listPipelinesRunsResults.addAll(run)); \n\n"
          }
        ]
      }
    },
    "/transformations": {
      "get": {
        "tags": [
          "Transformations"
        ],
        "summary": "List transformations",
        "description": "List transformations. Use nextCursor to paginate through the results.",
        "operationId": "getTransformations",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Limits the number of results to be returned. The maximum is 1000, default limit is 100.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 1000
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "Cursor for paging through results.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "includePublic",
            "in": "query",
            "description": "Whether public transformations should be included in the results. The default is true.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "withJobDetails",
            "in": "query",
            "description": "Whether transformations should contain information about jobs. The default is true.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Paged response with list of transformations.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_TransformationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ"
      },
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Create transformations",
        "description": "Create a maximum of 1000 transformations per request.",
        "operationId": "createTransformations",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_TransformationCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of transformations.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_TransformationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import TransformationWrite, TransformationDestination\nfrom cognite.client.data_classes.transformations.common import ViewInfo, EdgeType, DataModelInfo\ntransformations = [\n    TransformationWrite(\n        external_id=\"transformation1\",\n        name=\"transformation1\",\n        ignore_null_fields=False,\n        destination=TransformationDestination.assets()\n    ),\n    TransformationWrite(\n        external_id=\"transformation2\",\n        name=\"transformation2\",\n        ignore_null_fields=False,\n        destination=TransformationDestination.raw(\"myDatabase\", \"myTable\")\n    ),\n     TransformationWrite(\n         external_id=\"transformation3\",\n         name=\"transformation3\",\n         ignore_null_fields=False,\n         view = ViewInfo(space=\"TypeSpace\", external_id=\"TypeExtId\", version=\"version\"),\n         destination=TransformationDestination.nodes(view, \"InstanceSpace\")\n     ),\n     TransformationWrite(\n         external_id=\"transformation4\",\n         name=\"transformation4\",\n         ignore_null_fields=False,\n         view = ViewInfo(space=\"TypeSpace\", external_id=\"TypeExtId\", version=\"version\"),\n         destination=TransformationDestination.edges(view, \"InstanceSpace\")\n     ),\n     TransformationWrite(\n         external_id=\"transformation5\",\n         name=\"transformation5\",\n         ignore_null_fields=False,\n         edge_type = EdgeType(space=\"TypeSpace\", external_id=\"TypeExtId\"),\n         destination=TransformationDestination.edges(edge_type,\"InstanceSpace\")\n     ),\n     TransformationWrite(\n         external_id=\"transformation6\",\n         name=\"transformation6\",\n         ignore_null_fields=False,\n         data_model = DataModelInfo(space=\"modelSpace\", external_id=\"modelExternalId\",version=\"modelVersion\",destination_type=\"viewExternalId\"),\n         destination=TransformationDestination.instances(data_model,\"InstanceSpace\")\n     ),\n     TransformationWrite(\n         external_id=\"transformation7\",\n         name=\"transformation7\",\n         ignore_null_fields=False,\n         data_model = DataModelInfo(space=\"modelSpace\", external_id=\"modelExternalId\",version=\"modelVersion\",destination_type=\"viewExternalId\", destination_relationship_from_type=\"connectionPropertyName\"),\n         destination=TransformationDestination.instances(data_model,\"InstanceSpace\")\n     ),\n]\nres = client.transformations.create(transformations)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Transformation.Builder builder = Transformation.newBuilder() \n          .setName(\"TransformationTestSDK-\") \n          .setQuery(\"select * from teste\") \n          .setConflictMode(\"upsert\") \n          .setIsPublic(true) \n          .setExternalId(\"TestSKD-\") \n          .setIgnoreNullFields(true) \n          .setDataSetId(dataSetId) \n          .setDestination(Transformation.Destination.newBuilder() \n               .setType(\"raw\") \n               .setDatabase(\"Test\") \n               .setTable(\"Test\") \n               .build() \n          ); \nList<Transformation> createdList = client.transformations().upsert(List.of(builder.build())); \n\n"
          }
        ]
      }
    },
    "/transformations/byids": {
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Retrieve transformations",
        "description": "Retrieve a maximum of 1000 transformations by ids and externalIds per request.",
        "operationId": "getTransformationsByIds",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithByIdsFlags_CogniteId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of transformations.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_TransformationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.transformations.retrieve(id=1)\n\nres = client.transformations.retrieve(external_id=\"1\")\nres = client.transformations.retrieve_multiple(ids=[1,2,3], external_ids=['transform-1','transform-2'])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> byExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \nclient.transformations().retrieve(byExternalIds);"
          }
        ]
      }
    },
    "/transformations/filter": {
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Filter transformations",
        "description": "Filter transformations. Use nextCursor to paginate through the results.",
        "operationId": "filterTransformations",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransformationAdvancedList"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Paged response with list of transformations.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_TransformationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "transformations_list = client.transformations.list()\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Transformation> listTransformationResults = new ArrayList<>(); \nclient.transformations()\n          .list(Request.create().withFilterParameter(\"isPublic\", true))\n          .forEachRemaining(listTransformationResults::addAll); \n\n"
          }
        ]
      }
    },
    "/transformations/delete": {
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Delete transformations",
        "description": "Delete a maximum of 1000 transformations by ids and externalIds per request.",
        "operationId": "deleteTransformations",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_CogniteId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Empty response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.transformations.delete(id=[1,2,3], external_id=\"function3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteByExternalIds = List.of(Item.newBuilder() \n          .setExternalId(\"10\") \n          .build()); \n\nList<Item> deleteItemsResults = client.transformations().delete(deleteByExternalIds);\n\n"
          }
        ]
      }
    },
    "/transformations/update": {
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Update transformations",
        "description": "Update the attributes of transformations, maximum 1000 per request.",
        "operationId": "updateTransformations",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_UpdateItem_TransformationUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of transformations.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_TransformationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "transformation = client.transformations.retrieve(id=1)\ntransformation.query = \"SELECT * FROM _cdf.assets\"\nres = client.transformations.update(transformation)\n\nfrom cognite.client.data_classes import TransformationUpdate\nmy_update = TransformationUpdate(id=1).query.set(\"SELECT * FROM _cdf.assets\").is_public.set(False)\nres = client.transformations.update(my_update)\n\nfrom cognite.client.data_classes import NonceCredentials\nto_update = client.transformations.list(data_set_external_ids=[\"foo\"])\nnew_session = client.iam.sessions.create()\nnew_nonce = NonceCredentials(\n    session_id=new_session.id,\n    nonce=new_session.nonce,\n    cdf_project_name=client.config.project\n)\nfor tr in to_update:\n    tr.source_nonce = new_nonce\n    tr.destination_nonce = new_nonce\nres = client.transformations.update(to_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Transformation> editedInput = // List of Transformations \nList<Transformation> updatedList = client.transformations().upsert(editedInput);\n\n"
          }
        ]
      }
    },
    "/transformations/run": {
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Run a transformation",
        "operationId": "runTransformation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TransformationRunWithExternalId"
                  },
                  {
                    "$ref": "#/components/schemas/TransformationRunWithId"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with a single job.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JobRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.transformations.run(transformation_id = 1)\n\nres = client.transformations.run(transformation_id = 1, wait = False)\nimport asyncio\nasync def run_transformation():\n    res = await client.transformations.run_async(id = 1)\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run_transformation())\nloop.close()\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Transformation.Job jobRead =  \n          client.transformations().jobs().run(10L);"
          }
        ]
      }
    },
    "/transformations/jobs": {
      "get": {
        "tags": [
          "Transformation Jobs"
        ],
        "summary": "List jobs",
        "operationId": "getTransformationJobs",
        "parameters": [
          {
            "name": "transformationId",
            "in": "query",
            "description": "List only jobs for the specified transformation. The transformation is identified by ID.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "transformationExternalId",
            "in": "query",
            "description": "List only jobs for the specified transformation. The transformation is identified by external ID.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Limits the number of results to be returned. The maximum is 1000, default limit is 100.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 1000
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "Cursor for paging through results.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with list of jobs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_JobRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "transformation_jobs_list = client.transformations.jobs.list()\n\ntransformation_jobs_list = client.transformations.jobs.list(transformation_id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Iterator<List<Transformation.Job>> listJobs =   \n          client.transformations().jobs().list();  \n\n client.  \n          transformations()  \n          .jobs()  \n          .list(Request.create()  \n              .withRootParameter(\"transformationId\", 10)); \n\n client  \n          .transformations()  \n          .jobs()  \n          .list(Request.create()  \n              .withRootParameter(\"transformationExternalId\", 10)); \n\n"
          }
        ]
      }
    },
    "/transformations/jobs/byids": {
      "post": {
        "tags": [
          "Transformation Jobs"
        ],
        "summary": "Retrieve jobs by ids",
        "description": "Retrieve a maximum of 1000 jobs by ids per request.",
        "operationId": "getTransformationJobsByIds",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_CogniteInternalId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of jobs.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_JobRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.transformations.jobs.retrieve(id=1)\nres = client.transformations.jobs.retrieve_multiple(ids=[1, 2, 3])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> retrieveItems = new ArrayList<>(); \nretrieveItems.add(Item.newBuilder()  \n          .setId(10)  \n          .build()); \nList<Transformation.Job> retrievedItems =  \n          client.transformations().jobs().retrieve(retrieveItems); \n\n"
          }
        ]
      }
    },
    "/transformations/jobs/{id}/metrics": {
      "get": {
        "tags": [
          "Transformation Jobs"
        ],
        "summary": "List job metrics by job id",
        "operationId": "getTransformationJobsMetrics",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "The job id.",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Metrics for how many resources has been read/written by the transformation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_MetricCounter"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.transformations.jobs.list_metrics(id=1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Iterator<List<Transformation.Job.Metric>> it =   \n          client.transformations().jobs().metrics().list(10); \n\n"
          }
        ]
      }
    },
    "/transformations/cancel": {
      "post": {
        "tags": [
          "Transformations"
        ],
        "summary": "Cancel a transformation",
        "operationId": "postApiV1ProjectsProjectTransformationsCancel",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TransformationCogniteExternalId"
                  },
                  {
                    "$ref": "#/components/schemas/TransformationCogniteInternalId"
                  }
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Empty response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import TransformationJobStatus\nres = client.transformations.run(id = 1, timeout = 60.0)\nif res.status == TransformationJobStatus.RUNNING:\n    res.cancel()\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Boolean jobResult1 =  \n          client.transformations().jobs().cancel(10L);"
          }
        ]
      }
    },
    "/transformations/schedules": {
      "get": {
        "tags": [
          "Transformation Schedules"
        ],
        "summary": "List all schedules",
        "description": "List all transformation schedules. Use nextCursor to paginate through the results.",
        "operationId": "getTransformationSchedules",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Limits the number of results to be returned. The maximum is 1000, default limit is 100.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 1000
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "Cursor for paging through results.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "includePublic",
            "in": "query",
            "description": "Whether public transformations should be included in the results. The default is true.",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with list of schedules.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Schedule"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "schedules_list = client.transformations.schedules.list()\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Iterator<List<Transformation.Schedule>> it =   \n          client.transformations().schedules().list();\n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Transformation Schedules"
        ],
        "summary": "Schedule transformations",
        "description": "Schedule transformations with the specified configurations.",
        "operationId": "createTransformationSchedules",
        "requestBody": {
          "description": "List of the schedules to create. Must be up to a maximum of 1000 items.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_ScheduleParameters"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Response with list of schedules.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Schedule"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import TransformationScheduleWrite\nschedules = [TransformationScheduleWrite(id = 1, interval = \"0 * * * *\"), TransformationScheduleWrite(external_id=\"transformation2\", interval = \"5 * * * *\"))]\nres = client.transformations.schedules.create(schedules)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Transformation.Schedule> objects = new ArrayList<>(); \nobjects.add(Transformation.Schedule.newBuilder()  \n          .setExternalId(\"10\")  \n          .setInterval(\"*/5 * * * *\")  \n          .setIsPaused(false)  \n          .build());\nList<Transformation.Schedule> createdListSchedules =  \n          client.transformations().schedules().schedule(objects);\n\n"
          }
        ]
      }
    },
    "/transformations/schedules/byids": {
      "post": {
        "tags": [
          "Transformation Schedules"
        ],
        "summary": "Retrieve schedules",
        "description": "Retrieve transformation schedules by transformation IDs or external IDs.",
        "operationId": "getTransformationSchedulesByIds",
        "requestBody": {
          "description": "List of transformation IDs of schedules to retrieve. Must be up to a maximum of 1000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_CogniteId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of schedules.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Schedule"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.transformations.schedules.retrieve(id=1)\n\nres = client.transformations.schedules.retrieve(external_id=\"1\")\nres = client.transformations.schedules.retrieve_multiple(ids=[1, 2, 3])\n\nres = client.transformations.schedules.retrieve_multiple(external_ids=[\"t1\", \"t2\"])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> itemsToRetrieve = List.of(Item.newBuilder()   \n          .setExternalId(\"10\")   \n          .build());\nList<Transformation.Schedule> retrievedItems =   \n          client.transformations().schedules().retrieve(itemsToRetrieve);\n\n"
          }
        ]
      }
    },
    "/transformations/schedules/delete": {
      "post": {
        "tags": [
          "Transformation Schedules"
        ],
        "summary": "Unschedule transformations",
        "description": "Unschedule transformations by IDs or externalIds.",
        "operationId": "deleteTransformationSchedules",
        "requestBody": {
          "description": "List of transformation IDs of schedules to delete. Must be up to a maximum of 1000 items and all of them must be unique.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_CogniteId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Empty response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.transformations.schedules.delete(id=[1,2,3], external_id=\"3\")\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteSchedule = List.of(Item.newBuilder()   \n          .setExternalId(\"10\")   \n          .build());\nBoolean isUnSchedule =   \n          client.transformations().schedules().unSchedule(deleteSchedule);\n\n"
          }
        ]
      }
    },
    "/transformations/schedules/update": {
      "post": {
        "tags": [
          "Transformation Schedules"
        ],
        "summary": "Update schedules",
        "operationId": "updateTransformationSchedules",
        "requestBody": {
          "description": "List of schedule updates. Must be up to a maximum of 1000 items.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_UpdateItem_ScheduleUpdate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of schedules.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Schedule"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "transformation_schedule = client.transformations.schedules.retrieve(id=1)\ntransformation_schedule.is_paused = True\nres = client.transformations.schedules.update(transformation_schedule)\n\nfrom cognite.client.data_classes import TransformationScheduleUpdate\nmy_update = TransformationScheduleUpdate(id=1).interval.set(\"0 * * * *\").is_paused.set(False)\nres = client.transformations.schedules.update(my_update)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Transformation.Schedule> editedInput = List.of(Transformation.Schedule.newBuilder()   \n          .setExternalId(\"10\")   \n          .setIsPaused(true)   \n          .setInterval(\"*/10 * * * *\")   \n          .build());\nList<Transformation.Schedule> updatedList =   \n          client.transformations().schedules().schedule(editedInput);\n\n"
          }
        ]
      }
    },
    "/transformations/notifications": {
      "get": {
        "tags": [
          "Transformation Notifications"
        ],
        "summary": "List notification subscriptions",
        "operationId": "getTransformationNotifications",
        "parameters": [
          {
            "name": "transformationId",
            "in": "query",
            "description": "List only notifications for the specified transformation. The transformation is identified by ID.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "transformationExternalId",
            "in": "query",
            "description": "List only notifications for the specified transformation. The transformation is identified by external ID.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "destination",
            "in": "query",
            "description": "Filter by notification destination.",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "Limits the number of results to be returned. The maximum is 1000, default limit is 100.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 1000
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "description": "Cursor for paging through results.",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with paged list of notification subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_NotificationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "notifications_list = client.transformations.notifications.list()\n\nnotifications_list = client.transformations.notifications.list(transformation_id = 1)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "Iterator<List<Transformation.Notification>> itNotifications =   \n          client.transformations().notifications().list();\n\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Transformation Notifications"
        ],
        "summary": "Subscribe for notifications",
        "description": "Subscribe for notifications on the transformation errors.",
        "operationId": "createTransformationNotifications",
        "requestBody": {
          "description": "List of the notifications for new subscriptions. Must be up to a maximum of 1000 items.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_NotificationCreate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with list of created notification subscriptions.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_NotificationRead"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import TransformationNotification\nnotifications = [TransformationNotification(transformation_id = 1, destination=\"my@email.com\"), TransformationNotification(transformation_external_id=\"transformation2\", destination=\"other@email.com\"))]\nres = client.transformations.notifications.create(notifications)\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Transformation.Notification.Subscription> subscribes =  \n          List.of(Transformation.Notification.Subscription.newBuilder()  \n          .setDestination(\"test@test.com\")  \n          .setTransformationId(10)  \n          .build());\nList<Transformation.Notification> createdSubscribes =  \n          client.transformations().notifications().subscribe(subscribes);\n\n"
          }
        ]
      }
    },
    "/transformations/notifications/delete": {
      "post": {
        "tags": [
          "Transformation Notifications"
        ],
        "summary": "Delete notification subscriptions by notification ID",
        "description": "Deletes the specified notification subscriptions on the transformation. Requests to delete non-existing subscriptions do nothing, but do not throw an error.",
        "operationId": "deleteTransformationNotifications",
        "requestBody": {
          "description": "List of IDs to be deleted.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CogniteInternalId"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Empty response.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "The response for a conflict.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:WRITE",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.transformations.notifications.delete(id=[1,2,3])\n"
          },
          {
            "lang": "Java",
            "label": "Java SDK",
            "source": "List<Item> deleteNotification = List.of(Item.newBuilder()  \n          .setId(10)  \n          .build());\nList<Item> deletedItems =   \n          client.transformations().notifications().delete(deleteNotification);\n\n"
          }
        ]
      }
    },
    "/transformations/schema/sequence_rows": {
      "get": {
        "tags": [
          "Schema"
        ],
        "summary": "Get the schema of a sequence",
        "operationId": "getTransformationSequenceRowSchema",
        "parameters": [
          {
            "name": "externalId",
            "in": "query",
            "description": "External ID of the Sequence",
            "required": true,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the schema columns of the target schema type",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_ColumnType"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ"
      }
    },
    "/transformations/schema/instances": {
      "get": {
        "tags": [
          "Schema"
        ],
        "summary": "Get Instance schema.",
        "description": "For View centric schema, `viewSpace`, `viewExternalId`, `viewVersion` need to be specified while `withInstanceSpace`, `isConnectionDefinition`, `instanceType` are optional . For Data Model centric schema, `dataModelSpace`, `dataModelExternalId`, `dataModelVersion`, `type` need to be specified and `relationshipFromType` is optional. For Both scenarios `conflictMode` is required.",
        "operationId": "getFlexibleDataModelInstanceSchema",
        "parameters": [
          {
            "name": "conflictMode",
            "in": "query",
            "description": "conflict mode of the transformation.\n One of the following conflictMode types can be provided:\n `upsert`, `delete`\n ",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "abort",
                "upsert",
                "update",
                "delete"
              ]
            }
          },
          {
            "name": "viewSpace",
            "in": "query",
            "description": "Space of the View. Not required if `isConnectionDefinition` is true. Relevant for View centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "viewExternalId",
            "in": "query",
            "description": "External id of the View. Not required if `isConnectionDefinition` is true. Relevant for View centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "viewVersion",
            "in": "query",
            "description": "Version of the View. Not required if `isConnectionDefinition` is true. Relevant for View centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "instanceType",
            "in": "query",
            "description": "Instance type to deal with",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "nodes",
                "edges"
              ]
            }
          },
          {
            "name": "withInstanceSpace",
            "in": "query",
            "description": "Is instance space set at the transformation config or not",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "isConnectionDefinition",
            "in": "query",
            "description": "If the edge is a connection definition or not",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "dataModelSpace",
            "in": "query",
            "description": "Space of the Data Model. Relevant for Data Model centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "dataModelExternalId",
            "in": "query",
            "description": "External id of the Data Model. Relevant for Data Model centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "dataModelVersion",
            "in": "query",
            "description": "Version of the Data Model. Relevant for Data Model centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "External id of the View in the Data model. Relevant for Data Model centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          },
          {
            "name": "relationshipFromType",
            "in": "query",
            "description": "Property Identifier of Connection Definition in `type`. Relevant for Data Model centric schema.",
            "required": false,
            "schema": {
              "type": "string",
              "minLength": 1
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the schema columns of the target schema type",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_ColumnType"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ"
      }
    },
    "/transformations/schema/{schemaType}": {
      "get": {
        "tags": [
          "Schema"
        ],
        "summary": "Get the schema of resource type",
        "operationId": "getTransformationSchema",
        "parameters": [
          {
            "name": "schemaType",
            "in": "path",
            "description": "Name of the target schema type, please provide one of the following:\n `assets`, `timeseries`, `asset_hierarchy`, `events`, `datapoints`\n `string_datapoints`, `sequences`, `files`, `labels`,\n `relationships`, `raw`, `data_sets`",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "conflictMode",
            "in": "query",
            "description": "One of the following conflictMode types can be provided:\n `abort`, `upsert`, `update`, `delete`",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Response with the schema columns of the target schema type",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_ColumnType"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import TransformationDestination\ncolumns = client.transformations.schema.retrieve(destination = TransformationDestination.assets())\n"
          }
        ]
      }
    },
    "/transformations/query/run": {
      "post": {
        "tags": [
          "Query"
        ],
        "summary": "Run query",
        "description": "Preview a SQL query.",
        "operationId": "runPreview",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with resulting rows from the query.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryResultsBody"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "The response for a forbidden request.",
            "content": {
              "application/json": {
                "schema": {
                  "required": [
                    "error"
                  ],
                  "type": "object",
                  "properties": {
                    "error": {
                      "required": [
                        "code",
                        "message"
                      ],
                      "type": "object",
                      "properties": {
                        "code": {
                          "type": "integer",
                          "description": "HTTP status code."
                        },
                        "message": {
                          "type": "string",
                          "description": "Error message."
                        },
                        "missing": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of lookup objects that do not match any results."
                        },
                        "duplicated": {
                          "type": "array",
                          "items": {
                            "oneOf": [
                              {
                                "$ref": "#/components/schemas/TransformationCogniteExternalId"
                              },
                              {
                                "$ref": "#/components/schemas/TransformationCogniteInternalId"
                              }
                            ]
                          },
                          "description": "List of objects that are not unique."
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-capability": "transformationsAcl:READ",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "query_result = client.transformations.preview(query=\"select * from _cdf.assets\")\n\ndf = client.transformations.preview(query=\"select * from _cdf.assets\").to_pandas()\n\nresult = client.transformations.preview(query=\"select * from my_raw_db.my_raw_table\", limit=None)\nprint(result.results)\n\nresult = client.transformations.preview(query=\"select * from my_raw_db.my_raw_table\", limit=None, source_limit=None)\nprint(result.results)\n"
          }
        ]
      }
    },
    "/annotations": {
      "post": {
        "tags": [
          "Annotations"
        ],
        "summary": "Create annotations",
        "description": "Creates the given annotations.\n\n### Identifiers\nAn annotation _must_ reference an **annotated resource**.\n\nThe reference can be made by providing the internal ID of the annotated resource.\n\n### Status\nThe annotation _must_ have the `status` field set to either \"suggested\", \"rejected\", or \"approved\"\n\n### Access control\nThe caller _must_ have read-access on all the **annotated resources**, otherwise the call will fail.\n\n### Annotation types and Data\nThe annotation **type** property _must_ be set to one of the globally available annotation types.\nSee the documentation of the `annotationType` and `data` attributes for details.\n\nThe annotation **data** _must_ conform to the schema provided by the annotation type.\n\n### Creating Application and User\nThe creating application and its version _must_ be provided. The creating user _must_ be provided, but if the\nannotation is being created by a service, this _can_ be set to `null`.",
        "operationId": "annotationsCreate",
        "requestBody": {
          "$ref": "#/components/requestBodies/AnnotationsV2CreateRequestSchema"
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/AnnotationsV2CreateResponseSchema"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "annotationsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const data = {\n  pageNumber: 7,\n  textRegion: { xMin: 0, xMax: 0.1, yMin: 0, yMax: 0.2 },\n  extractedText: 'i am your father',\n};\nconst annotation = {\n  annotatedResourceType: 'file' as const,\n  annotatedResourceId: 1,\n  annotationType: 'documents.ExtractedText',\n  creatingApp: 'integration-tests',\n  creatingAppVersion: '0.0.1',\n  creatingUser: 'integration-tests',\n  status: 'suggested' as const,\n  data,\n};\nconst created = await client.annotations.create([annotation]);"
          }
        ]
      }
    },
    "/annotations/suggest": {
      "post": {
        "tags": [
          "Annotations"
        ],
        "summary": "Suggest annotations",
        "description": "Suggests the given annotations, i.e. creates them with `status` set to \"suggested\"\n\n### Identifiers\nAn annotation _must_ reference an **annotated resource**.\n\nThe reference can be made by providing the internal ID of the annotated resource.\n\n### Access control\nThe caller _must_ have read-access on all the **annotated resources**, otherwise the call will fail.\n\n### Annotation types and Data\nThe annotation **type** property _must_ be set to one of the globally available annotation types.\nSee the documentation of the `annotationType` and `data` attributes for details.\n\nThe annotation **data** _must_ conform to the schema provided by the annotation type.\n\n### Creating Application and User\nThe creating application and its version _must_ be provided. The creating user _must_ be provided, but if the\nannotation is being created by a service, this _can_ be set to `null`.",
        "operationId": "annotationsSuggest",
        "requestBody": {
          "$ref": "#/components/requestBodies/AnnotationsV2SuggestRequestSchema"
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/AnnotationsV2CreateResponseSchema"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "annotationsAcl:SUGGEST"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const data = {\n  pageNumber: 7,\n  textRegion: { xMin: 0, xMax: 0.1, yMin: 0, yMax: 0.2 },\n  extractedText: 'i am your father',\n};\nconst partial = {\n  annotatedResourceType: 'file' as const,\n  annotatedResourceId: 1,\n  annotationType: 'documents.ExtractedText',\n  creatingApp: 'integration-tests',\n  creatingAppVersion: '0.0.1',\n  creatingUser: 'integration-tests',\n  data,\n};\n\nconst created = await client.annotations.suggest([partial]);"
          }
        ]
      }
    },
    "/annotations/{annotationId}": {
      "get": {
        "tags": [
          "Annotations"
        ],
        "summary": "Get an annotation",
        "description": "Retrieves the referenced annotation.\n\nThe caller _must_ have read-access on the **annotated resource**, otherwise the call will fail.",
        "operationId": "annotationsGet",
        "parameters": [
          {
            "$ref": "#/components/parameters/AnnotationId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/AnnotationsV2ResponseSchema"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const annotationIds = [{ id: 1 }, { id: 2 }];\n\nconst response = await client.annotations.retrieve(annotationIds);"
          }
        ]
      }
    },
    "/annotations/list": {
      "post": {
        "tags": [
          "Annotations"
        ],
        "summary": "Filter annotations",
        "description": "Lists the annotations the caller has access to, based on a filter.\n\nThe caller _must_ have read-access on the **annotated resources** listed in the filter, otherwise the call will\nfail.",
        "operationId": "annotationsFilter",
        "requestBody": {
          "$ref": "#/components/requestBodies/AnnotationsV2ListRequestSchema"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AnnotationsV2CursoredListResponseSchema"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const annotatedFileId = 1;\nconst limitOne = await client.annotations.list({\n  limit: 1,\n  filter: {\n   annotatedResourceType: 'file',\n   annotatedResourceIds: [{ id: 1 }],\n },\n});"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import AnnotationFilter\nflt = AnnotationFilter(annotated_resource_type=\"file\", annotated_resource_ids=[{\"id\": 123}])\nres = client.annotations.list(flt, limit=None)\n"
          }
        ]
      }
    },
    "/annotations/byids": {
      "post": {
        "tags": [
          "Annotations"
        ],
        "summary": "Retrieve annotations",
        "description": "Retrieves the referenced annotations.\n\nThe caller _must_ have read-access on all the **annotated resources**, otherwise the call will fail.",
        "operationId": "annotationsByids",
        "requestBody": {
          "$ref": "#/components/requestBodies/AnnotationsV2ByIdsRequestSchema"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AnnotationsV2ListResponseSchema"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const annotationIds = [{ id: 1 }, { id: 2 }];\n\nconst response = await client.annotations.retrieve(annotationIds);"
          }
        ]
      }
    },
    "/annotations/delete": {
      "post": {
        "tags": [
          "Annotations"
        ],
        "summary": "Delete annotations",
        "description": "Deletes the referenced annotations completely.\n\nThe caller _must_ have read-access on all the **annotated resources**, otherwise the call will fail.",
        "operationId": "annotationsDelete",
        "requestBody": {
          "$ref": "#/components/requestBodies/AnnotationsV2ByIdsRequestSchema"
        },
        "responses": {
          "200": {
            "description": "Successful deletion"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "annotationsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const annotationIds = [{ id: 1 }, { id: 2 }];\n\nawait client.annotations.delete(annotationIds);"
          }
        ]
      }
    },
    "/annotations/update": {
      "post": {
        "tags": [
          "Annotations"
        ],
        "summary": "Update annotations",
        "description": "Updates the referenced annotations.\n\nThe caller _must_ have read-access on all the **annotated resources**, otherwise the call will fail.",
        "operationId": "annotationsUpdate",
        "requestBody": {
          "$ref": "#/components/requestBodies/AnnotationsV2UpdateRequestSchema"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/AnnotationsV2UpdateResponseSchema"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "annotationsAcl:WRITE"
        ],
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const data = {\n  pageNumber: 8,\n  fileRef: { externalId: 'def_file_changed' },\n  textRegion: { xMin: 0, xMax: 0.1, yMin: 0, yMax: 0.2 },\n};\nconst changes = [\n  {\n    id: 1,\n    update: {\n      data: {\n        set: data,\n      },\n    },\n  },\n];\n\nconst updatedResp = await client.annotations.update(changes);"
          }
        ]
      }
    },
    "/seismic/seismics/segy/{seismicId}": {
      "get": {
        "tags": [
          "Seismic"
        ],
        "summary": "Download a seismic object as a SEG-Y file",
        "description": "Retrieves a SEG-Y file with all traces contained within the given seismic object.",
        "operationId": "downloadSeismic",
        "parameters": [
          {
            "$ref": "#/components/parameters/seismicId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/DownloadSeismicResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "seismicAcl:READ"
        ]
      }
    },
    "/seismic/batchdownload": {
      "post": {
        "tags": [
          "Seismic"
        ],
        "summary": "Download multiple seismic objects as a ZIP archive",
        "description": "Download multiple seismic objects specified by the filter, as a streamed ZIP archive file.",
        "operationId": "batchDownloadSeismic",
        "requestBody": {
          "description": "The filter that determines the seismic objects to return.",
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/BatchDownloadRequestSeismic"
                  },
                  {
                    "$ref": "#/components/schemas/BatchDownloadRequestFilter"
                  }
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "The generated ZIP archive file",
            "content": {
              "application/zip": {
                "schema": {
                  "type": "string",
                  "format": "binary/zip"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-capability": [
          "seismicAcl:READ",
          "experimentAcl:USE"
        ]
      }
    },
    "/profiles": {
      "get": {
        "deprecated": true,
        "x-capability": [
          "userProfilesAcl:READ"
        ],
        "tags": [
          "User profiles"
        ],
        "operationId": "listUserProfiles",
        "summary": "List all user profiles in the current project",
        "description": "Deprecated in favor of the [List principals](#tag/Principals/operation/listPrincipals) endpoint.\n\nList all user profiles in the current project. This operation supports pagination by cursor.\nThe results are ordered alphabetically by name.",
        "parameters": [
          {
            "name": "identityType",
            "in": "query",
            "schema": {
              "$ref": "#/components/schemas/IdentityTypeFilter"
            }
          },
          {
            "name": "limit",
            "description": "Limits the number of results to be returned. The server returns no more than 1000 results even if the specified limit is larger. The default limit is 25.",
            "in": "query",
            "schema": {
              "type": "integer",
              "default": 25,
              "minimum": 1,
              "maximum": 1000
            }
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserProfilesListResponse"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const response = await client.profiles.list({ limit: 1000 });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.iam.user_profiles.list(limit=None)\n"
          }
        ]
      }
    },
    "/profiles/me": {
      "get": {
        "deprecated": true,
        "x-capability": [
          "userProfilesAcl:READ"
        ],
        "tags": [
          "User profiles"
        ],
        "operationId": "getRequesterUserProfile",
        "summary": "(deprecated) Get the user profile of the principal issuing the request",
        "description": "Deprecated in favor of the new [endpoint](#tag/Principals/operation/getMe).\n\nRetrieves the user profile of the principal issuing the request.\nIf a principal doesn't have a user profile, you get a not found (404) response code.\nNote: User profiles are created asyncronously, so the endpoint might return 404 for\na new principal for a while (usually seconds) until the profile has been created.",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserProfileItem"
                }
              }
            }
          },
          "404": {
            "description": "The user profile for the requesting principal was not found.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserProfilesNotFoundResponse"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const response = await client.profiles.me();"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.iam.user_profiles.me()\n"
          }
        ]
      }
    },
    "/profiles/byids": {
      "post": {
        "deprecated": true,
        "x-capability": [
          "userProfilesAcl:READ"
        ],
        "tags": [
          "User profiles"
        ],
        "operationId": "getUserProfilesByIds",
        "summary": "Retrieve profiles by ID in the current project",
        "description": "Deprecated in favor of the [Retrieve principals](#tag/Principals/operation/getPrincipalsById) endpoint.\n\nRetrieve one or more user profiles indexed by the user identifier in the same CDF project.",
        "requestBody": {
          "description": "Specify a maximum of 1000 unique IDs.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserProfilesByIdsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserProfilesByIdsResponse"
                }
              }
            }
          },
          "400": {
            "description": "The response for a failed request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserProfilesErrorResponse"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const response = await client.profiles.retrieve([{ userIdentifier: 'abcd' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.iam.user_profiles.retrieve(\"foo\")\n\nres = client.iam.user_profiles.retrieve([\"bar\", \"baz\"])\n"
          }
        ]
      }
    },
    "/profiles/search": {
      "post": {
        "deprecated": true,
        "x-capability": [
          "userProfilesAcl:READ"
        ],
        "tags": [
          "User profiles"
        ],
        "operationId": "userProfilesSearch",
        "summary": "Search user profiles in the current project",
        "description": "Deprecated in favor of the [List principals](#tag/Principals/operation/listPrincipals) endpoint.\n\nSearch user profiles in the current project. The result set ordering and match criteria\nthreshold may change over time. This operation does not support pagination.",
        "requestBody": {
          "description": "Query for user profile search.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserProfilesSearchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of matched user profiles. If no user profile matches, you'll receive an empty set.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserProfilesSearchResponse"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const response = await client.profiles.search({ search: { name: 'John' } });"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.iam.user_profiles.search(name=\"Alex\")\n"
          }
        ]
      }
    },
    "/principals/me": {
      "servers": [
        {
          "url": "https://auth.cognite.com/api/v1"
        }
      ],
      "get": {
        "deprecated": true,
        "operationId": "getRequesterProfile",
        "summary": "Get the user profile of the principal issuing the request",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Deprecated in favor of the new [endpoint](#tag/Principals/operation/getMe).\n\nRetrieves the user profile of the principal issuing the request.",
        "tags": [
          "User profiles"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PrincipalProfileDto"
          }
        }
      }
    },
    "/workflows": {
      "post": {
        "operationId": "CreateOrUpdateWorkflow",
        "summary": "Create or update a workflow",
        "description": "Create or update a workflow. Limited to a single workflow per request.",
        "tags": [
          "Workflows"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "items"
                ],
                "properties": {
                  "items": {
                    "type": "array",
                    "maxItems": 1,
                    "minItems": 1,
                    "items": {
                      "type": "object",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/WorkflowExternalId"
                        },
                        "description": {
                          "type": "string",
                          "maxLength": 500
                        },
                        "dataSetId": {
                          "$ref": "#/components/schemas/dataSetIdWorkflows"
                        }
                      },
                      "required": [
                        "externalId"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of created workflows",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/WorkflowView"
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import WorkflowUpsert\nwf = WorkflowUpsert(external_id=\"my_workflow\", description=\"my workflow description\")\nres = client.workflows.upsert(wf)\n\nwf2 = WorkflowUpsert(external_id=\"other\", data_set_id=123)\nres = client.workflows.upsert([wf, wf2])\n"
          }
        ]
      },
      "get": {
        "operationId": "FetchAllWorkflows",
        "summary": "List workflows",
        "description": "List workflows in the project.",
        "tags": [
          "Workflows"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/limit"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/cursor"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of workflows",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/WorkflowView"
                      }
                    },
                    "nextCursor": {
                      "$ref": "#/components/schemas/nextCursor"
                    }
                  }
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.list(limit=None)\n"
          }
        ]
      }
    },
    "/workflows/delete": {
      "post": {
        "operationId": "DeleteWorkflows",
        "summary": "Delete workflows",
        "description": "Delete workflows, including all associated workflow versions.",
        "tags": [
          "Workflows"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "parameters": [
          {
            "name": "ignoreUnknownIds",
            "in": "query",
            "required": false,
            "description": "If `true`, ignore unknown workflow ids. If `false`, a `404 Not Found` error is returned and none of the workflows are deleted if any of the workflow ids are unknown.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 100,
                    "items": {
                      "type": "object",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/WorkflowExternalId"
                        }
                      },
                      "required": [
                        "externalId"
                      ]
                    },
                    "required": [
                      "items"
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "404": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.workflows.delete(\"my_workflow\")\n"
          }
        ]
      }
    },
    "/workflows/{workflowExternalId}": {
      "parameters": [
        {
          "name": "workflowExternalId",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          }
        }
      ],
      "get": {
        "operationId": "fetchWorkflowDetails",
        "summary": "Retrieve a workflow",
        "description": "Retrieve a workflow by its external id.",
        "tags": [
          "Workflows"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "responses": {
          "200": {
            "description": "Information about the workflow",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowView"
                }
              }
            }
          },
          "404": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "workflow = client.workflows.retrieve(\"my_workflow\")\n\nworkflow_list = client.workflows.retrieve([\"foo\", \"bar\"])\n"
          }
        ]
      }
    },
    "/workflows/versions/list": {
      "post": {
        "operationId": "ListWorkflowVersions",
        "summary": "Filter workflow versions",
        "description": "List workflow versions matching a given filter.",
        "tags": [
          "Workflow versions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListVersionsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of workflow versions",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "items": {
                      "type": "array",
                      "maxItems": 1000,
                      "items": {
                        "$ref": "#/components/schemas/WorkflowVersionView"
                      }
                    },
                    "nextCursor": {
                      "$ref": "#/components/schemas/nextCursor"
                    }
                  },
                  "required": [
                    "items"
                  ]
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.versions.list([\"my_workflow\", \"my_workflow_2\"])\n\nfrom cognite.client.data_classes import WorkflowVersionId\nres = client.workflows.versions.list(\n    [WorkflowVersionId(\"my_workflow\"), WorkflowVersionId(\"my_workflow_2\")])\n\nres = client.workflows.versions.list(\n    [(\"my_workflow\", \"1\"), (\"my_workflow_2\", \"2\")])\n"
          }
        ]
      }
    },
    "/workflows/versions": {
      "post": {
        "operationId": "CreateOrUpdateWorkflowVersion",
        "summary": "Create or update a workflow version",
        "description": "Create or update a workflow version. Limited to a single workflow version per request.",
        "tags": [
          "Workflow versions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 1,
                    "items": {
                      "type": "object",
                      "properties": {
                        "workflowExternalId": {
                          "$ref": "#/components/schemas/WorkflowExternalId"
                        },
                        "version": {
                          "$ref": "#/components/schemas/Version"
                        },
                        "workflowDefinition": {
                          "$ref": "#/components/schemas/WorkflowDefinition"
                        }
                      },
                      "required": [
                        "workflowExternalId",
                        "version",
                        "workflowDefinition"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Workflow version created/updated",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "minItems": 1,
                      "maxItems": 1,
                      "items": {
                        "$ref": "#/components/schemas/WorkflowVersionView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import (\n    WorkflowVersionUpsert, WorkflowDefinitionUpsert,\n    WorkflowTask, FunctionTaskParameters,\n)\nfunction_task = WorkflowTask(\n    external_id=\"my_workflow-task1\",\n    parameters=FunctionTaskParameters(\n        external_id=\"my_fn_xid\",\n        data={\"a\": 1, \"b\": 2},\n    ),\n)\nnew_version = WorkflowVersionUpsert(\n   workflow_external_id=\"my_workflow\",\n   version=\"1\",\n   workflow_definition=WorkflowDefinitionUpsert(\n       tasks=[function_task],\n       description=\"This workflow has one step\",\n   ),\n)\nres = client.workflows.versions.upsert(new_version)\n"
          }
        ]
      }
    },
    "/workflows/{workflowExternalId}/versions/{version}": {
      "parameters": [
        {
          "name": "workflowExternalId",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          }
        },
        {
          "name": "version",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/Version"
          }
        }
      ],
      "get": {
        "operationId": "GetSpecificVersion",
        "summary": "Retrieve a workflow version",
        "description": "Retrieve a version of a given workflow.",
        "tags": [
          "Workflow versions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "responses": {
          "200": {
            "description": "Specific version of a workflow",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowVersionView"
                }
              }
            }
          },
          "404": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import WorkflowVersionId\nres = client.workflows.versions.retrieve(WorkflowVersionId(\"my_workflow\", \"v1\"))\n\nres = client.workflows.versions.retrieve(\n    [WorkflowVersionId(\"my_workflow\", \"v1\"), WorkflowVersionId(\"other\", \"v3.2\")],\n    ignore_unknown_ids=True,\n)\nres = client.workflows.versions.retrieve([(\"my_workflow\", \"v1\"), (\"other\", \"v3.2\")])\n\nres = client.workflows.versions.retrieve(\"my_workflow\", \"v1\")\n"
          }
        ]
      }
    },
    "/workflows/versions/delete": {
      "post": {
        "operationId": "DeleteSpecificVersionsOfWorkflow",
        "summary": "Delete workflow versions",
        "description": "Delete specific versions of one or more workflows.",
        "tags": [
          "Workflow versions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "parameters": [
          {
            "name": "ignoreUnknownIds",
            "in": "query",
            "required": false,
            "description": "If `true`, ignore unknown version ids. If `false`, a `404 Not Found` error is returned and none of the versions are deleted if any of the version ids are unknown.",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 100,
                    "items": {
                      "type": "object",
                      "properties": {
                        "version": {
                          "$ref": "#/components/schemas/Version"
                        },
                        "workflowExternalId": {
                          "$ref": "#/components/schemas/WorkflowExternalId"
                        }
                      },
                      "required": [
                        "version",
                        "workflowExternalId"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "404": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.workflows.versions.delete((\"my workflow\", \"1\"))\n\nfrom cognite.client.data_classes import WorkflowVersionId\nclient.workflows.versions.delete([WorkflowVersionId(\"my workflow\", \"1\"), WorkflowVersionId(\"my workflow 2\", \"2\")])\n"
          }
        ]
      }
    },
    "/workflows/{workflowExternalId}/versions/{version}/run": {
      "parameters": [
        {
          "name": "workflowExternalId",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          }
        },
        {
          "name": "version",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/Version"
          }
        }
      ],
      "post": {
        "operationId": "TriggerRunOfSpecificVersionOfWorkflow",
        "summary": "Run a workflow",
        "description": "Start an execution of a specific version of a workflow.",
        "tags": [
          "Workflow executions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "authentication": {
                    "$ref": "#/components/schemas/Authentication"
                  },
                  "input": {
                    "$ref": "#/components/schemas/ExecutionInput"
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/metadata"
                  }
                },
                "required": [
                  "authentication"
                ]
              }
            }
          }
        },
        "responses": {
          "202": {
            "description": "Information about the workflow execution",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowExecutionResponse"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes import WorkflowTask, FunctionTaskParameters\ntask = WorkflowTask(\n    external_id=\"my_workflow-task1\",\n    parameters=FunctionTaskParameters(\n        external_id=\"cdf_deployed_function:my_function\",\n        data={\"workflow_data\": \"${workflow.input}\"}))\n\nres = client.workflows.executions.run(\"foo\", \"1\")\n\nres = client.workflows.executions.run(\"foo\", \"1\", input={\"a\": 1, \"b\": 2})\n\nimport os\nfrom cognite.client.data_classes import ClientCredentials\ncredentials = ClientCredentials(\"my-client-id\", os.environ[\"MY_CLIENT_SECRET\"])\nres = client.workflows.executions.run(\"foo\", \"1\", client_credentials=credentials)\n"
          }
        ]
      }
    },
    "/workflows/executions/list": {
      "post": {
        "operationId": "ListWorkflowExecutions",
        "summary": "Filter workflow executions",
        "description": "List workflow executions matching a given filter.",
        "tags": [
          "Workflow executions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListExecutionsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Filtered list of workflow executions",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "items": {
                      "type": "array",
                      "maxItems": 1000,
                      "items": {
                        "$ref": "#/components/schemas/WorkflowExecutionResponse"
                      }
                    },
                    "nextCursor": {
                      "$ref": "#/components/schemas/nextCursor"
                    }
                  },
                  "required": [
                    "items"
                  ]
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.executions.list((\"my_workflow\", \"1\"))\n\nfrom cognite.client.utils import timestamp_to_ms\nres = client.workflows.executions.list(\n    created_time_start=timestamp_to_ms(\"1d-ago\"))\n"
          }
        ]
      }
    },
    "/workflows/executions/{executionId}": {
      "parameters": [
        {
          "name": "executionId",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/WorkflowExecutionId"
          }
        }
      ],
      "get": {
        "operationId": "ExecutionOfSpecificRunOfWorkflow",
        "summary": "Retrieve workflow execution details",
        "description": "Retrieve detailed information about a specific workflow execution.",
        "tags": [
          "Workflow executions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "responses": {
          "200": {
            "description": "Details of a workflow execution",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowExecution"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.executions.retrieve_detailed(\"000560bc-9080-4286-b242-a27bb4819253\")\n\nres = client.workflows.executions.list()\nres = client.workflows.executions.retrieve_detailed(res[0].id)\n"
          }
        ]
      }
    },
    "/workflows/executions/{executionId}/cancel": {
      "post": {
        "operationId": "WorkflowExecutionCancellation",
        "summary": "Cancel a workflow execution",
        "description": "Stops the specified execution from starting new workflow tasks and sets the workflow execution status to `TERMINATED`. Already running tasks will be marked as CANCELED. Note that the actions taken by the canceled tasks won't be stopped, and these need to be canceled separately if desired. For example, to cancel a running transformation, use the [/transformations/cancel](#/Transformations/postApiV1ProjectsProjectTransformationsCancel) endpoint.",
        "tags": [
          "Workflow executions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/WorkflowExecutionId"
            }
          }
        ],
        "requestBody": {
          "required": false,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CancelExecution"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated workflow execution",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowExecutionResponse"
                }
              }
            }
          },
          "404": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.executions.run(\"foo\", \"1\")\nclient.workflows.executions.cancel(id=\"foo\", reason=\"test cancellation\")\n"
          }
        ]
      }
    },
    "/workflows/executions/{executionId}/retry": {
      "post": {
        "operationId": "WorkflowExecutionRetry",
        "summary": "Retry workflow execution",
        "description": "This endpoint restarts a previously failed, timed out, or terminated workflow execution by retrying tasks that did not complete successfully. It aims to resume execution activity from the point(s) of failure.\n\nBehavior of the retry operation:\n- Targeted Task Retry: Only retries tasks that have stopped in a terminal state such as `CANCELED`, `FAILED`, `FAILED_WITH_TERMINAL_ERROR`, and `TIMED_OUT`. Optional tasks are not retried.\n- Subworkflows and Dynamic Tasks: When a failure occurs within a subworkflow or as part of a dynamic task, only the individual nested tasks that failed are retried. The subworkflow or dynamic task container itself is not retried.\n- Retry Limits: Tasks that have reached or exceeded their designated retry limits will not have their retry counts reset to zero. Instead, each retry request permits these tasks a single additional retry.\n",
        "tags": [
          "Workflow executions"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "parameters": [
          {
            "name": "executionId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/WorkflowExecutionId"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RetryExecution"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated workflow execution",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/WorkflowExecutionResponse"
                }
              }
            }
          },
          "404": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/workflows/tasks/{taskId}/update": {
      "parameters": [
        {
          "name": "taskId",
          "in": "path",
          "required": true,
          "schema": {
            "$ref": "#/components/schemas/TaskExecutionId"
          }
        }
      ],
      "post": {
        "operationId": "UpdateTaskStatus",
        "summary": "Update task status",
        "description": "Update the status of a task that is defined to be completed asynchronously (i.e. task parameter `isAsyncComplete` is set to `true`). The status can be set to `COMPLETED`, `FAILED`, or `FAILED_WITH_TERMINAL_ERROR`.\n\n - `COMPLETED`: the workflow execution will continue according to the workflow definition.\\\n - `FAILED`: the task will be retried according to the `retries` parameter for the task in the workflow definition.\\\n - `FAILED_WITH_TERMINAL_ERROR`: the task won't be retried.\\\nIf an `output` is provided, it'll be merged with the original output of the task.",
        "tags": [
          "Tasks"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "status": {
                    "type": "string",
                    "enum": [
                      "COMPLETED",
                      "FAILED",
                      "FAILED_WITH_TERMINAL_ERROR"
                    ]
                  },
                  "output": {
                    "type": "object",
                    "example": {
                      "key1": "value1",
                      "key2": "value2"
                    },
                    "description": "Custom output data of the task, which will be merged with the original output of the task. The output data should be in JSON format, and is limited to 100KB in size."
                  }
                },
                "required": [
                  "status"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Updated task",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskExecution"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.tasks.update(\"000560bc-9080-4286-b242-a27bb4819253\", \"completed\")\n\nres = client.workflows.tasks.update(\"000560bc-9080-4286-b242-a27bb4819253\", \"failed\", output={\"a\": 1, \"b\": 2})\n\nres = client.workflows.executions.run(\"my workflow\", \"1\")\nres = client.workflows.executions.retrieve_detailed(res.id)\nres = client.workflows.tasks.update(res.tasks[1].id, \"completed\")\n"
          }
        ]
      }
    },
    "/workflows/triggers": {
      "get": {
        "operationId": "FetchAllTriggers",
        "summary": "List triggers",
        "description": "List all triggers. The results are sorted by `externalId` in ascending order.",
        "tags": [
          "Workflow triggers"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/limit"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/cursor"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of triggers",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/TriggerView"
                      }
                    },
                    "nextCursor": {
                      "$ref": "#/components/schemas/nextCursor"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "CreateOrUpdateTriggers",
        "summary": "Create or update triggers",
        "description": "Create or update a trigger.",
        "tags": [
          "Workflow triggers"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 1,
                    "items": {
                      "type": "object",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/TriggerExternalId"
                        },
                        "triggerRule": {
                          "$ref": "#/components/schemas/TriggerRule"
                        },
                        "input": {
                          "$ref": "#/components/schemas/ExecutionInput"
                        },
                        "metadata": {
                          "description": "Static custom, application-specific metadata to add to the executions started by the trigger.\nString key -> String value. Keys have a maximum length of 32 characters,\nvalues a maximum of 255, and there can be a maximum of 10 key-value pairs.\n",
                          "allOf": [
                            {
                              "$ref": "#/components/schemas/metadata"
                            }
                          ]
                        },
                        "workflowExternalId": {
                          "$ref": "#/components/schemas/WorkflowExternalId"
                        },
                        "workflowVersion": {
                          "$ref": "#/components/schemas/Version"
                        },
                        "authentication": {
                          "$ref": "#/components/schemas/Authentication"
                        }
                      },
                      "required": [
                        "externalId",
                        "triggerRule",
                        "workflowExternalId",
                        "workflowVersion",
                        "authentication"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of created or updated triggers",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/TriggerView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.workflows import WorkflowTriggerUpsert, WorkflowScheduledTriggerRule\nclient.workflows.triggers.upsert(\n    WorkflowTriggerUpsert(\n        external_id=\"my_trigger\",\n        trigger_rule=WorkflowScheduledTriggerRule(cron_expression=\"0 0 * * *\"),\n        workflow_external_id=\"my_workflow\",\n        workflow_version=\"1\",\n        input={\"a\": 1, \"b\": 2},\n        metadata={\"key\": \"value\"},\n    )\n)\n\nfrom cognite.client.data_classes.workflows import WorkflowDataModelingTriggerRule, WorkflowTriggerDataModelingQuery\nfrom cognite.client.data_classes.data_modeling.query import NodeResultSetExpression, Select, SourceSelector\nfrom cognite.client.data_classes.data_modeling import ViewId\nfrom cognite.client.data_classes.filters import Equals\nview_id = ViewId(\"my_space_id\", \"view_external_id\", \"v1\")\nclient.workflows.triggers.upsert(\n    WorkflowTriggerUpsert(\n        external_id=\"my_trigger\",\n        trigger_rule=WorkflowDataModelingTriggerRule(\n            data_modeling_query=WorkflowTriggerDataModelingQuery(\n                with_={\"timeseries\": NodeResultSetExpression(filter=Equals(view_id.as_property_ref(\"name\"), value=\"my_name\"))},\n                select={\"timeseries\": Select([SourceSelector(view_id, [\"name\"])])},\n            ),\n            batch_size=500,\n            batch_timeout=300,\n        ),\n        workflow_external_id=\"my_workflow\",\n        workflow_version=\"1\",\n    )\n)\n"
          }
        ]
      }
    },
    "/workflows/triggers/delete": {
      "post": {
        "operationId": "deleteTriggers",
        "summary": "Delete triggers",
        "description": "Delete a trigger.",
        "tags": [
          "Workflow triggers"
        ],
        "x-capability": [
          "workflowOrchestrationACL:WRITE"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "items": {
                    "type": "array",
                    "minItems": 1,
                    "maxItems": 1,
                    "items": {
                      "type": "object",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/TriggerExternalId"
                        }
                      },
                      "required": [
                        "externalId"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.workflows.triggers.delete(\"my_trigger\")\n\nclient.workflows.triggers.delete([\"my_trigger\", \"another_trigger\"])\n"
          }
        ]
      }
    },
    "/workflows/triggers/{triggerExternalId}/history": {
      "get": {
        "parameters": [
          {
            "name": "triggerExternalId",
            "in": "path",
            "required": true,
            "schema": {
              "$ref": "#/components/schemas/TriggerExternalId"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/limit"
            }
          },
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "$ref": "#/components/schemas/cursor"
            }
          }
        ],
        "operationId": "getTriggerHistory",
        "summary": "Get the run history of a trigger",
        "description": "Get information about every run of a trigger. This includes timing information and a reference to the started execution (or an explanation as to why it failed). The returned items are sorted by `fireTime` in descending order (newest first), followed by `externalId` in ascending order.",
        "tags": [
          "Workflow triggers"
        ],
        "x-capability": [
          "workflowOrchestrationACL:READ"
        ],
        "responses": {
          "200": {
            "description": "A list of runs of the trigger",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "fireTime": {
                            "type": "integer",
                            "minimum": 0,
                            "format": "int64",
                            "description": "The time that the trigger attempted to start the execution. Provided as epoch time in milliseconds (UTC)."
                          },
                          "externalId": {
                            "$ref": "#/components/schemas/TriggerExternalId"
                          },
                          "workflowExternalId": {
                            "$ref": "#/components/schemas/WorkflowExternalId"
                          },
                          "workflowVersion": {
                            "$ref": "#/components/schemas/Version"
                          },
                          "workflowExecutionId": {
                            "anyOf": [
                              {
                                "type": "string",
                                "maxLength": 36,
                                "minLength": 36
                              },
                              {
                                "type": "null"
                              }
                            ],
                            "description": "UUIDv4 identifier for a workflow execution.",
                            "example": "059edaa4-a17a-4102-910e-2c3591500cce"
                          },
                          "status": {
                            "type": "string",
                            "enum": [
                              "success",
                              "failed"
                            ],
                            "description": "status of the trigger run, a being successful means that the execution has started, failure denotes that an execution could not be started."
                          },
                          "reasonForFailure": {
                            "anyOf": [
                              {
                                "type": "string"
                              },
                              {
                                "type": "null"
                              }
                            ],
                            "description": "a human readable reason for the failure, null if the trigger run was successful"
                          }
                        },
                        "required": [
                          "fireTime",
                          "externalId",
                          "workflowExternalId",
                          "workflowVersion",
                          "status"
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "The trigger was not found",
            "$ref": "#/components/responses/ErrorResponse"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.workflows.triggers.list_runs(\"my_trigger\", limit=None)\n"
          }
        ]
      }
    },
    "/hostedextractors/destinations": {
      "get": {
        "tags": [
          "Destinations"
        ],
        "operationId": "list_destinations",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "description": "List all destinations in a given project. If more than `limit` destinations exist, a cursor for pagination will be returned with the response.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Destination_"
                }
              }
            },
            "description": "List of destinations and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse",
            "description": "Validation Error"
          }
        },
        "summary": "List Destinations",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "destination_list = client.hosted_extractors.destinations.list(limit=5)\n\nfor destination in client.hosted_extractors.destinations:\n    destination # do something with the destination\n\nfor destination_list in client.hosted_extractors.destinations(chunk_size=25):\n    destination_list # do something with the destinationss\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Destinations"
        ],
        "operationId": "create_destinations",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Create up to 100 destinations.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateDestination_"
              }
            }
          },
          "required": true,
          "description": "Destinations to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Destination_"
                }
              }
            },
            "description": "List of created destinations"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response for a failed request"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Create Destinations",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import DestinationWrite, SessionWrite\ndestination = DestinationWrite(external_id='my_dest', credentials=SessionWrite(\"my_nonce\"), target_data_set_id=123)\nres = client.hosted_extractors.destinations.create(destination)\n"
          }
        ]
      }
    },
    "/hostedextractors/destinations/byIds": {
      "post": {
        "tags": [
          "Destinations"
        ],
        "operationId": "retrieve_destinations",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "Retrieve a list of up to 100 destinations by their external ID, optionally ignoring unknown IDs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of destinations to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Destination_"
                }
              }
            },
            "description": "List of retrieved destinations."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Retrieve Destinations",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.hosted_extractors.destinations.retrieve('myDestination')\n\nres = client.hosted_extractors.destinations.retrieve([\"myDestination\", \"myDestination2\"], ignore_unknown_ids=True)\n"
          }
        ]
      }
    },
    "/hostedextractors/destinations/delete": {
      "post": {
        "tags": [
          "Destinations"
        ],
        "operationId": "delete_destinations",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Delete a list of destinations by their external ID. This operation will fail if any destination in the request is associated with a job, unless the `force` query parameter is set to `true`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIdsAndForce_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of destinations to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Delete Destinations",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.hosted_extractors.destinations.delete([\"myDest\", \"MyDest2\"])\n"
          }
        ]
      }
    },
    "/hostedextractors/destinations/update": {
      "post": {
        "tags": [
          "Destinations"
        ],
        "operationId": "update_destinations",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Update up to 100 destinations.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_DestinationUpdateItem_"
              }
            }
          },
          "required": true,
          "description": "Destinations to update."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Destination_"
                }
              }
            },
            "description": "List of updated destinations."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Update Destinations",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import DestinationUpdate\ndestination = DestinationUpdate('my_dest').target_data_set_id.set(123)\nres = client.hosted_extractors.destinations.update(destination)\n"
          }
        ]
      }
    },
    "/hostedextractors/jobs": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "operationId": "list_jobs",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "List all jobs in a given project. If more than `limit` jobs exist, a cursor for pagination will be returned with the response.",
        "parameters": [
          {
            "$ref": "#/components/parameters/100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "in": "query",
            "name": "source",
            "description": "External ID of source the returned jobs must be tied to.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Source"
            }
          },
          {
            "in": "query",
            "name": "destination",
            "description": "External ID of destination the returned jobs must be tied to.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Destination"
            }
          },
          {
            "in": "query",
            "name": "mapping",
            "description": "External ID of mapping the returned jobs must be tied to.",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Mapping"
            }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_MinimalJob_"
                }
              }
            },
            "description": "List of jobs and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "List Jobs",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "job_list = client.hosted_extractors.jobs.list(limit=5)\n\nfor job in client.hosted_extractors.jobs:\n    job # do something with the job\n\nfor job_list in client.hosted_extractors.jobs(chunk_size=25):\n    job_list # do something with the jobs\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Jobs"
        ],
        "operationId": "create_jobs",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Create up to 100 jobs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateJob_"
              }
            }
          },
          "required": true,
          "description": "Jobs to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_MinimalJob_"
                }
              }
            },
            "description": "Successful Response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Create Jobs",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import EventHubSourceWrite\njob_write = EventHubSourceWrite('my_event_hub', 'http://myeventhub.com', \"My EventHub\", 'my_key', 'my_value')\njob = client.hosted_extractors.jobs.create(job_write)\n"
          }
        ]
      }
    },
    "/hostedextractors/jobs/byIds": {
      "post": {
        "tags": [
          "Jobs"
        ],
        "operationId": "retrieve_jobs",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "Retrieve a list of up to 100 jobs by their external ID, optionally ignoring unknown IDs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of jobs to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_MinimalJob_"
                }
              }
            },
            "description": "List of retrieved jobs."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Retrieve Jobs",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.hosted_extractors.jobs.retrieve('myJob')\n\nres = client.hosted_extractors.jobs.retrieve([\"myJob\", \"myOtherJob\"], ignore_unknown_ids=True)\n"
          }
        ]
      }
    },
    "/hostedextractors/jobs/delete": {
      "post": {
        "tags": [
          "Jobs"
        ],
        "operationId": "delete_jobs",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Delete a list of jobs by their external ID.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of jobs to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Delete Jobs",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.hosted_extractors.jobs.delete([\"myMQTTJob\", \"MyEventHubJob\"])\n"
          }
        ]
      }
    },
    "/hostedextractors/jobs/logs": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "operationId": "get_job_logs",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "List logs, optionally filtering on job, source, or destination. Logs are retrieved in reverse chronological order.",
        "parameters": [
          {
            "in": "query",
            "name": "job",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Job"
            },
            "description": "Require returned logs to belong to the job given by this external ID."
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "in": "query",
            "name": "source",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Source"
            },
            "description": "Require returned logs to belong to the any job with source given by this external ID."
          },
          {
            "in": "query",
            "name": "destination",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Destination"
            },
            "description": "Require returned logs to belong to the any job with destination given by this external ID."
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_JobLogEntry_"
                }
              }
            },
            "description": "List of retrieved job logs"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Get Job Logs",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.hosted_extractors.jobs.list_logs(job=\"myJob\")\n"
          }
        ]
      }
    },
    "/hostedextractors/jobs/metrics": {
      "get": {
        "tags": [
          "Jobs"
        ],
        "operationId": "get_job_metrics",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "List metrics, optionally filtering on job, source, or destination. Logs are retrieved in reverse chronological order.",
        "parameters": [
          {
            "in": "query",
            "name": "job",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Job"
            },
            "description": "Require returned metrics to belong to the job given by this external ID."
          },
          {
            "$ref": "#/components/parameters/Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "in": "query",
            "name": "source",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Source"
            },
            "description": "Require returned metrics to belong to the any job with source given by this external ID."
          },
          {
            "in": "query",
            "name": "destination",
            "required": false,
            "schema": {
              "type": "string",
              "title": "Destination"
            },
            "description": "Require returned metrics to belong to the any job with destination given by this external ID."
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_JobMetrics_"
                }
              }
            },
            "description": "List of retrieved job metrics."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Get Job Metrics",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.hosted_extractors.jobs.list_metrics(job=\"myJob\")\n"
          }
        ]
      }
    },
    "/hostedextractors/jobs/update": {
      "post": {
        "tags": [
          "Jobs"
        ],
        "operationId": "update_jobs",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Update a list of up to 100 jobs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_JobUpdateItem_"
              }
            }
          },
          "required": true,
          "description": "Jobs to update."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_MinimalJob_"
                }
              }
            },
            "description": "List of updated jobs."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Update Jobs",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import EventHubSourceUpdate\njob = EventHubSourceUpdate('my_event_hub').event_hub_name.set(\"My Updated EventHub\")\nupdated_job = client.hosted_extractors.jobs.update(job)\n"
          }
        ]
      }
    },
    "/hostedextractors/sources": {
      "get": {
        "tags": [
          "Sources"
        ],
        "operationId": "list_sources",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "List all sources in a given project. If more than `limit` sources exist, a cursor for pagination will be returned with the response.",
        "parameters": [
          {
            "$ref": "#/components/parameters/100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Source_"
                }
              }
            },
            "description": "List of sources and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response for a failed request"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse",
            "description": "Validation Error"
          }
        },
        "summary": "List Sources",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "source_list = client.hosted_extractors.sources.list(limit=5)\n\nfor source in client.hosted_extractors.sources:\n    source # do something with the source\n\nfor source_list in client.hosted_extractors.sources(chunk_size=25):\n    source_list # do something with the sources\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Sources"
        ],
        "operationId": "create_sources",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "Create up to 100 sources.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateSource_"
              }
            }
          },
          "required": true,
          "description": "Sources to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Source_"
                }
              }
            },
            "description": "List of created sources."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Create Sources",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import EventHubSourceWrite\nsource = EventHubSourceWrite('my_event_hub', 'http://myeventhub.com', \"My EventHub\", 'my_key', 'my_value')\nres = client.hosted_extractors.sources.create(source)\n"
          }
        ]
      }
    },
    "/hostedextractors/sources/byIds": {
      "post": {
        "tags": [
          "Sources"
        ],
        "operationId": "retrieve_sources",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "Retrieve a list of up to 100 sources by their external ID, optionally ignoring unknown IDs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of sources to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Source_"
                }
              }
            },
            "description": "List of retrieved sources."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Retrieve Sources",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.hosted_extractors.sources.retrieve('myMQTTSource')\n\nres = client.hosted_extractors.sources.retrieve([\"myMQTTSource\", \"MyEventHubSource\"], ignore_unknown_ids=True)\n"
          }
        ]
      }
    },
    "/hostedextractors/sources/delete": {
      "post": {
        "tags": [
          "Sources"
        ],
        "operationId": "delete_sources",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Delete a list of sources by their external ID. This operation will fail if any destination in the request is associated with a job, unless the `force` query parameter is set to `true`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIdsAndForce_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of sources to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Delete Sources",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.hosted_extractors.sources.delete([\"myMQTTSource\", \"MyEventHubSource\"])\n"
          }
        ]
      }
    },
    "/hostedextractors/sources/update": {
      "post": {
        "tags": [
          "Sources"
        ],
        "operationId": "update_sources",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Update up to 100 sources.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_UpdateSource_"
              }
            }
          },
          "description": "Sources to update."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Source_"
                }
              }
            },
            "description": "List of updated sources."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Update Sources",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import EventHubSourceUpdate\nsource = EventHubSourceUpdate('my_event_hub').event_hub_name.set(\"My Updated EventHub\")\nres = client.hosted_extractors.sources.update(source)\n"
          }
        ]
      }
    },
    "/hostedextractors/mappings": {
      "get": {
        "tags": [
          "Mappings"
        ],
        "operationId": "list_mappings",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "description": "List all mappings in a given project. If more than `limit` mappings exist, a cursor for pagination will be returned with the response.",
        "parameters": [
          {
            "$ref": "#/components/parameters/100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Mapping_"
                }
              }
            },
            "description": "List of mappings and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "List Mappings",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "mapping_list = client.hosted_extractors.mappings.list(limit=5)\n\nfor mapping in client.hosted_extractors.mappings:\n    mapping # do something with the mapping\n\nfor mapping_list in client.hosted_extractors.mappings(chunk_size=25):\n    mapping_list # do something with the mappings\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Mappings"
        ],
        "operationId": "create_mappings",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "description": "Create up to 100 mappings.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateMapping_"
              }
            }
          },
          "required": true,
          "description": "Mappings to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Mapping_"
                }
              }
            },
            "description": "List of created mappings"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Create Mappings",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import MappingWrite, CustomMapping\nmapping = MappingWrite(external_id=\"my_mapping\", mapping=CustomMapping(\"some expression\"), published=True, input=\"json\")\nres = client.hosted_extractors.mappings.create(mapping)\n"
          }
        ]
      }
    },
    "/hostedextractors/mappings/byIds": {
      "post": {
        "operationId": "retrieve_mappings",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "tags": [
          "Mappings"
        ],
        "description": "Retrieve a list of up to 100 mappings by their external ID, optionally ignoring unknown IDs.",
        "parameters": [
          {
            "in": "header",
            "name": "cdf-version",
            "required": false,
            "schema": {
              "title": "Cdf-Version",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of mappings to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Mapping_"
                }
              }
            },
            "description": "List of retrieved mappings."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Retrieve Mappings",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.hosted_extractors.mappings.retrieve('myMapping')\n\nres = client.hosted_extractors.mappings.retrieve([\"myMapping\", \"myMapping2\"], ignore_unknown_ids=True)\n"
          }
        ]
      }
    },
    "/hostedextractors/mappings/delete": {
      "post": {
        "operationId": "delete_mappings",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "tags": [
          "Mappings"
        ],
        "description": "Delete a list of mappings by their external ID. This operation will fail if any mapping in the request is associated with a job, unless the `force` query parameter is set to `true`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIdsAndForce_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of mappings to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Delete Mappings",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.hosted_extractors.mappings.delete([\"myMapping\", \"MyMapping2\"])\n"
          }
        ]
      }
    },
    "/hostedextractors/mappings/update": {
      "post": {
        "operationId": "update_mappings",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "tags": [
          "Mappings"
        ],
        "description": "Update up to 100 mappings.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_MappingUpdateItem_"
              }
            }
          },
          "required": true,
          "description": "Mappings to update."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Mapping_"
                }
              }
            },
            "description": "List of updated mappings."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Update Mappings",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.hosted_extractors import MappingUpdate\nmapping = MappingUpdate('my_mapping').published.set(False)\nres = client.hosted_extractors.mappings.update(mapping)\n"
          }
        ]
      }
    },
    "/hostedextractors/preview": {
      "post": {
        "operationId": "create_preview",
        "x-capability": [
          "hostedExtractors:WRITE"
        ],
        "tags": [
          "Previews"
        ],
        "description": "Create a preview job. Previews will run for up to 10 minutes, and return once they receive any data. Use the /result endpoint to check the status of the preview.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreatePreview"
              }
            }
          },
          "required": true,
          "description": "Preview to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MinimalPreview"
                }
              }
            },
            "description": "Created preview."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Create Preview"
      }
    },
    "/hostedextractors/preview/result": {
      "post": {
        "operationId": "get_preview_result",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "tags": [
          "Previews"
        ],
        "description": "Get the result of a preview job. Note that previews may be automatically deleted as soon as 1 hour after they are created.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdWrapper"
              }
            }
          },
          "required": true,
          "description": "External ID of preview job to get result for."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PreviewResult"
                }
              }
            },
            "description": "Current status of the preview."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Get preview result"
      }
    },
    "/hostedextractors/preview/download": {
      "post": {
        "operationId": "download_preview_payload",
        "x-capability": [
          "hostedExtractors:READ"
        ],
        "tags": [
          "Previews"
        ],
        "description": "Download the raw, binary result of a preview job, before it is passed throguh any transformations. Note that this endpoint will return 404 if there is no raw data.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExternalIdWrapper"
              }
            }
          },
          "required": true,
          "description": "External ID of preview job to get result for."
        },
        "responses": {
          "200": {
            "content": {
              "application/binary": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            },
            "description": "Raw result from the preview."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError"
          }
        },
        "summary": "Download preview result"
      }
    },
    "/postgresgateway": {
      "get": {
        "tags": [
          "Postgres Gateway Users"
        ],
        "operationId": "list_users",
        "x-capability": [
          "postgresGateway:READ"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/100Limit_"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "description": "List all users in a given project. If more than `limit` users exist, a cursor for pagination will be returned with the response.",
        "responses": {
          "200": {
            "description": "List of users paginated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_User_"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "List users"
      },
      "post": {
        "tags": [
          "Postgres Gateway Users"
        ],
        "operationId": "create_users",
        "x-capability": [
          "postgresGateway:WRITE"
        ],
        "description": "Create postgres users.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateUser_"
              }
            }
          },
          "description": "List of postgres users to create"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_UserCreated_"
                }
              }
            },
            "description": "List of created users"
          },
          "400": {
            "description": "Response of a failed request",
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Create users",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "import os\nfrom cognite.client.data_classes.postgres_gateway import UserWrite, SessionCredentials\nfrom cognite.client.data_classes import ClientCredentials\nsession = client.iam.sessions.create(\n    ClientCredentials(os.environ[\"IDP_CLIENT_ID\"], os.environ[\"IDP_CLIENT_SECRET\"]),\n    session_type=\"CLIENT_CREDENTIALS\"\n)\nuser = UserWrite(credentials=SessionCredentials(nonce=session.nonce))\nres = client.postgres_gateway.users.create(user)\n"
          }
        ]
      }
    },
    "/postgresgateway/list": {
      "post": {
        "summary": "Filter users",
        "tags": [
          "Postgres Gateway Users"
        ],
        "operationId": "filter_users",
        "description": "List all postgres users for a given project. If more than `limit` users exist, a cursor for pagination will be returned with the response.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FilterUsers"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of users paginated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_User_"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse",
            "description": "Validation Error"
          }
        },
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "user_list = client.postgres_gateway.users.list(limit=5)\n\nfor user in client.postgres_gateway.users:\n    user # do something with the user\n\nfor user_list in client.postgres_gateway.users(chunk_size=25):\n    user_list # do something with the users\n"
          }
        ]
      }
    },
    "/postgresgateway/byids": {
      "post": {
        "tags": [
          "Postgres Gateway Users"
        ],
        "operationId": "retreive_users",
        "x-capability": "postgresGateway:READ",
        "description": "Retreive a list of postgres users by their usernames, optionally ignoring unknown usernames",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknown_Username_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of users retrieved by their usernames",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithoutCursor_User_"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response of a failed request"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Retrieve users",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.postgres_gateway.users.retrieve(\"myUser\", ignore_unknown_ids=True)\n"
          }
        ]
      }
    },
    "/postgresgateway/update": {
      "post": {
        "tags": [
          "Postgres Gateway Users"
        ],
        "operationId": "update_users",
        "x-capability": [
          {
            "postgresGateway": "postgresGateway:WRITE"
          }
        ],
        "description": "Update postgres users",
        "requestBody": {
          "required": true,
          "description": "Users to update",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_UserUpdate_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Returns users with updates",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_User_"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Update users",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "import os\nfrom cognite.client.data_classes.postgres_gateway import UserUpdate, SessionCredentials\nfrom cognite.client.data_classes import ClientCredentials\nsession = client.iam.sessions.create(\n    ClientCredentials(os.environ[\"IDP_CLIENT_ID\"], os.environ[\"IDP_CLIENT_SECRET\"]),\n    session_type=\"CLIENT_CREDENTIALS\"\n)\nupdate = UserUpdate('myUser').credentials.set(SessionCredentials(nonce=session.nonce))\nres = client.postgres_gateway.users.update(update)\n"
          }
        ]
      }
    },
    "/postgresgateway/delete": {
      "post": {
        "tags": [
          "Postgres Gateway Users"
        ],
        "operationId": "delete_users",
        "x-capability": [
          {
            "postgresGateway": "WRITE"
          }
        ],
        "description": "Delete postgres users",
        "requestBody": {
          "required": true,
          "description": "Postgres users to delete",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknown_Username_1_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Delete users",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.postgres_gateway.users.delete([\"myUser\", \"myUser2\"])\n"
          }
        ]
      }
    },
    "/postgresgateway/tables/{username}": {
      "get": {
        "tags": [
          "Postgres Gateway Tables"
        ],
        "operationId": "list_tables",
        "x-capability": [
          "postgresGateway:READ"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/Username"
          },
          {
            "$ref": "#/components/parameters/100Limit_"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "in": "query",
            "name": "includeBuiltIns",
            "description": "Determines if API should return built-in tables or not",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "description": "List all tables in a given project. If more than `limit` tables exist, a cursor for pagination will be returned with the response.",
        "responses": {
          "200": {
            "description": "List of tables paginated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Table_"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "List tables",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "custom_table_list = client.postgres_gateway.tables.list(\"myUserName\", limit=5)\n\nfor table in client.postgres_gateway.tables:\n    table # do something with the custom table\n\nfor table_list in client.postgres_gateway.tables(chunk_size=25):\n    table_list # do something with the custom tables\n"
          }
        ]
      },
      "post": {
        "tags": [
          "Postgres Gateway Tables"
        ],
        "operationId": "create_tables",
        "x-capability": [
          "postgresGateway:WRITE"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/Username"
          }
        ],
        "description": "Create up to 10 tables.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateTable_"
              }
            }
          },
          "description": "List of tables to create"
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithoutCursor_TableCreated_"
                }
              }
            },
            "description": "List of created tables"
          },
          "400": {
            "description": "Response of a failed request",
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Create tables",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "from cognite.client.data_classes.data_modeling import ViewId\nfrom cognite.client.data_classes.postgres_gateway import ViewTableWrite\ntable = ViewTableWrite(tablename=\"myCustom\", options=ViewId(space=\"mySpace\", external_id=\"myExternalId\", version=\"v1\"))\nres = client.postgres_gateway.tables.create(\"myUserName\",table)\n"
          }
        ]
      }
    },
    "/postgresgateway/tables/{username}/byids": {
      "post": {
        "tags": [
          "Postgres Gateway Tables"
        ],
        "operationId": "retrieve_tables",
        "parameters": [
          {
            "$ref": "#/components/parameters/Username"
          }
        ],
        "x-capability": "postgresGateway:READ",
        "description": "Retreive a list of postgres tables for a user by their table names, optionally ignoring unknown table names",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknown_Tablename_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List postgres tables by table names",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithoutCursor_Table_"
                }
              }
            }
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response of a failed request"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Retrieve tables",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.postgres_gateway.tables.retrieve(\"myUserName\", 'myCustom')\n\nres = client.postgres_gateway.tables.retrieve(\"myUserName\", [\"myCustom\", \"myCustom2\"])\n"
          }
        ]
      }
    },
    "/postgresgateway/tables/{username}/delete": {
      "post": {
        "tags": [
          "Postgres Gateway Tables"
        ],
        "operationId": "delete_tables",
        "parameters": [
          {
            "$ref": "#/components/parameters/Username"
          }
        ],
        "x-capability": [
          {
            "postgresGateway": "WRITE"
          }
        ],
        "description": "Delete up to 10 tables",
        "requestBody": {
          "required": true,
          "description": "Tables to delete",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknown_Tablename_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ValidationError_"
          }
        },
        "summary": "Delete tables",
        "x-code-samples": [
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "client.postgres_gateway.tables.delete(\"myUserName\", [\"myCustom\", \"myCustom2\"])\n"
          }
        ]
      }
    },
    "/writeback/sap/instances": {
      "get": {
        "tags": [
          "SAP Instances"
        ],
        "operationId": "list_instances",
        "x-capability": [
          "SapWritebackAcl:READ"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/Writeback100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "description": "List all SAP instances in a given CDF project. If more instances exist than what the limit specifies, a pagination cursor is returned in the response body.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Instance_"
                }
              }
            },
            "description": "List of SAP instances, and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse",
            "description": "Validation Error"
          }
        },
        "summary": "List SAP Instances"
      },
      "post": {
        "tags": [
          "SAP Instances"
        ],
        "operationId": "create_instances",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "description": "Create up to 100 SAP instances.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateInstance_"
              }
            }
          },
          "required": true,
          "description": "Instance to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Instance_"
                }
              }
            },
            "description": "List of created instances"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response for a failed request"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Create SAP Instances"
      }
    },
    "/writeback/sap/instances/byids": {
      "post": {
        "tags": [
          "SAP Instances"
        ],
        "operationId": "retrieve_instances",
        "x-capability": [
          "SapWritebackAcl:READ"
        ],
        "description": "Retrieve a list of up to 100 SAP instances by their external ID, optionally ignoring unknown IDs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of SAP instances to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Instance_"
                }
              }
            },
            "description": "List of retrieved instances."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Retrieve SAP Instances"
      }
    },
    "/writeback/sap/instances/delete": {
      "post": {
        "tags": [
          "SAP Instances"
        ],
        "operationId": "delete_instances",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "description": "Delete a list of SAP instance configurations by their external ID. This operation will fail if any destination in the request is associated with an SAP endpoint configuration, unless the `force` query parameter is set to `true`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackItemsWithIgnoreUnknownIdsAndForce_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of SAP instance configuration external IDs to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Delete SAP Instances"
      }
    },
    "/writeback/sap/endpoints": {
      "get": {
        "tags": [
          "SAP Endpoints"
        ],
        "operationId": "list_endpoints",
        "x-capability": [
          "SapWritebackAcl:READ"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/Writeback100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "description": "List all SAP endpoints in a given CDF project. If more instances exist than what the limit specifies, a pagination cursor is returned in the response body.",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_Endpoint_"
                }
              }
            },
            "description": "List of endpoints and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/ErrorResponse",
            "description": "Validation Error"
          }
        },
        "summary": "List SAP Endpoints"
      },
      "post": {
        "tags": [
          "SAP Endpoints"
        ],
        "operationId": "create_endpoints",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "description": "Create up to 100 SAP endpoints.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateEndpoint_"
              }
            }
          },
          "required": true,
          "description": "Endpoint to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Endpoint_"
                }
              }
            },
            "description": "List of created endpoints"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response for a failed request"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Create SAP Endpoints"
      }
    },
    "/writeback/sap/endpoints/byids": {
      "post": {
        "tags": [
          "SAP Endpoints"
        ],
        "operationId": "retrieve_endpoints",
        "x-capability": [
          "SapWritebackAcl:READ"
        ],
        "description": "Retrieve a list of up to 100 SAP endpoints by their external ID, optionally ignoring unknown IDs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of SAP endpoint configurations to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Endpoint_"
                }
              }
            },
            "description": "List of retrieved SAP endpoint configurations."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Retrieve SAP Endpoints"
      }
    },
    "/writeback/sap/endpoints/delete": {
      "post": {
        "tags": [
          "SAP Endpoints"
        ],
        "operationId": "delete_endpoints",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "description": "Delete a list of SAP endpoint configurations by their external ID. This operation will fail if any endpoint in the request is associated to a SAP instance configuration.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "A list of External IDs for SAP endpoint configurations to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Delete SAP Endpoints"
      }
    },
    "/writeback/sap/endpoints/verify": {
      "post": {
        "tags": [
          "SAP Endpoints"
        ],
        "operationId": "verify_endpoints",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "description": "Verify the connectivity between the writeback API, and the SAP endpoint destination.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackExternalIdWrapper"
              }
            }
          },
          "required": true,
          "description": "SAP Endpoint external ID which the connection test should be verified."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ConnectionCheck",
            "description": "Connection Check Result"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Verify SAP Endpoint"
      }
    },
    "/writeback/sap/mappings": {
      "get": {
        "tags": [
          "Schema Mappings"
        ],
        "operationId": "list_schema_mappings",
        "x-capability": [
          "SapWritebackAcl:READ"
        ],
        "description": "List all mappings in a given CDF project. If more instances exist than what the limit specifies, a pagination cursor is returned in the response body.",
        "parameters": [
          {
            "$ref": "#/components/parameters/Writeback100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_SchemaMapping_"
                }
              }
            },
            "description": "List of mappings and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "List Mappings"
      },
      "post": {
        "tags": [
          "Schema Mappings"
        ],
        "operationId": "create_schema_mappings",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "description": "Create a maximum of 100 mappings.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateSchemaMapping_"
              }
            }
          },
          "required": true,
          "description": "Mappings to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_SchemaMapping_"
                }
              }
            },
            "description": "List of created mappings"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Create Mappings"
      }
    },
    "/writeback/sap/mappings/byids": {
      "post": {
        "operationId": "retrieve_schema_mappings",
        "x-capability": [
          "SapWritebackAcl:READ"
        ],
        "tags": [
          "Schema Mappings"
        ],
        "description": "Retrieve a list of up to 100 mappings by their external ID, optionally ignoring unknown IDs.",
        "parameters": [
          {
            "in": "header",
            "name": "cdf-version",
            "required": false,
            "schema": {
              "title": "Cdf-Version",
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of mappings to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_Mapping_"
                }
              }
            },
            "description": "List of retrieved mappings."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Retrieve Mappings"
      }
    },
    "/writeback/sap/mappings/delete": {
      "post": {
        "operationId": "delete_schema_mappings",
        "x-capability": [
          "SapWritebackAcl:WRITE"
        ],
        "tags": [
          "Schema Mappings"
        ],
        "description": "Delete a list of mappings by their external ID.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritebackItemsWithIgnoreUnknownIds_ExternalId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of mappings to delete."
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/EmptyResponse",
            "description": "Empty response"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Delete Mappings"
      }
    },
    "/writeback/sap/requests": {
      "get": {
        "tags": [
          "Writeback Requests"
        ],
        "operationId": "list_writeback_requests",
        "x-capability": [
          "SapWritebackRequestsAcl:LIST"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/Writeback100Limit"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          }
        ],
        "description": "List all writeback requests in a given CDF project. If more instances exist than what the limit specifies, a pagination cursor is returned in the response body.",
        "responses": {
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ItemsWithCursor_ListRequestMinimal_"
                }
              }
            },
            "description": "List of endpoints and an optional cursor."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError",
            "description": "Validation Error"
          }
        },
        "summary": "List Writeback Requests"
      },
      "post": {
        "tags": [
          "Writeback Requests"
        ],
        "operationId": "create_writeback_requests",
        "x-capability": [
          "SapWritebackRequestsAcl:WRITE"
        ],
        "description": "Create a writeback request",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Items_CreateRequest_"
              }
            }
          },
          "required": true,
          "description": "Request to create."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_CreateRequestResponse_"
                }
              }
            },
            "description": "List of created writeback requests"
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse",
            "description": "Response for a failed request"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Create Writeback Requests"
      }
    },
    "/writeback/sap/requests/byids": {
      "post": {
        "tags": [
          "Writeback Requests"
        ],
        "operationId": "retrieve_writeback_requests",
        "x-capability": [
          "SapWritebackRequestsAcl:WRITE"
        ],
        "description": "Retrieve a list of up to 100 writeback requests by their external ID, optionally ignoring unknown IDs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ItemsWithIgnoreUnknownIds_RequestId_"
              }
            }
          },
          "required": true,
          "description": "List of external IDs of writeback requests to retrieve."
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Items_RequestFull_"
                }
              }
            },
            "description": "List of retrieved writeback requests."
          },
          "400": {
            "$ref": "#/components/responses/400ErrorResponse"
          },
          "422": {
            "$ref": "#/components/responses/WritebackValidationError"
          }
        },
        "summary": "Retrieve Writeback Requests"
      }
    },
    "/simulators/run": {
      "post": {
        "tags": [
          "Simulation Runs"
        ],
        "summary": "Run Simulation",
        "description": "Request to run a simulator routine asynchronously.",
        "operationId": "run_simulation_simulators_run_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_Union_SimulationRunCommandByRoutine__SimulationRunCommandByRoutineRevision__"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulationRunView_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/runs/list": {
      "post": {
        "tags": [
          "Simulation Runs"
        ],
        "summary": "Filter Simulation Runs",
        "description": "Retrieves a list of simulation runs that match the given criteria.",
        "operationId": "filter_simulation_runs_simulators_runs_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulationRunsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewListWithCursor_SimulationRunView_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/run/callback": {},
    "/simulators/runs/byids": {
      "post": {
        "tags": [
          "Simulation Runs"
        ],
        "summary": "Simulation By Id",
        "description": "Retrieve a simulation run by ID.",
        "operationId": "simulation_by_id_simulators_runs_byids_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_IdRef_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulationRunView_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/runs/data/list": {
      "post": {
        "tags": [
          "Simulation Runs"
        ],
        "summary": "Simulation Data By Run Id",
        "description": "Retrieve data associated with a simulation run by ID.",
        "operationId": "simulation_data_by_run_id_simulators_runs_data_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_RunIdRef_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulationRunDataItem_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/integrations/list": {
      "post": {
        "tags": [
          "Simulator Integrations"
        ],
        "summary": "Filter Simulator Integrations",
        "description": "Retrieves a list of simulator integrations that match the given criteria.",
        "operationId": "filter_simulator_integrations_simulators_integrations_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulatorIntegrationsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorIntegration_"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/integrations/update": {},
    "/simulators/integrations/delete": {
      "post": {
        "tags": [
          "Simulator Integrations"
        ],
        "summary": "Delete Simulator Integrations",
        "description": "Delete a simulator integration. This will also delete all associated simulator resources (e.g. routines, runs).",
        "operationId": "delete_simulator_integrations_simulators_integrations_delete_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_Union_IdRef__ExternalIdRef__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/integrations": {},
    "/simulators/models": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Create Simulator Model",
        "description": "Create a simulator model.",
        "operationId": "create_simulator_model_simulators_models_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_SimulatorModelCreateCommand_"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorModel_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/list": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Filter Simulator Models",
        "description": "Retrieves a list of simulator models that match the given criteria.",
        "operationId": "filter_simulator_models_simulators_models_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulatorModelsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewListWithCursor_SimulatorModel_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/aggregate": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Aggregate Simulator Models",
        "description": "Calculate aggregates for simulator models, considering the optional filter specification.",
        "operationId": "aggregate_simulator_models_simulators_models_aggregate_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AggregateSimulatorModelsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_AggregateCount_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/delete": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Delete Simulator Model",
        "description": "Delete a simulator model. This will also delete all associated simulator resources (e.g. revisions, routines, runs).",
        "operationId": "delete_simulator_model_simulators_models_delete_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_Union_IdRef__ExternalIdRef__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/update": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Update Simulator Model",
        "description": "Update a simulator model.",
        "operationId": "update_simulator_model_simulators_models_update_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_SimulatorModelUpdateCommand_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorModel_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/byids": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Retrieve Simulator Model",
        "description": "Retrieve a simulator model by ID or external ID.",
        "operationId": "retrieve_simulator_model_simulators_models_byids_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_Union_IdRef__ExternalIdRef__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorModel_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/revisions": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Create Simulator Model Revision",
        "description": "Create a simulator model revision.",
        "operationId": "create_simulator_model_revision_simulators_models_revisions_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_SimulatorModelRevisionCreateCommand_"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorModelRevision_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/revisions/list": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Filter Simulator Model Revisions",
        "description": "Retrieves a list of simulator model revisions that match the given criteria.",
        "operationId": "filter_simulator_model_revisions_simulators_models_revisions_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulatorModelRevisionsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewListWithCursor_SimulatorModelRevision_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/revisions/byids": {
      "post": {
        "tags": [
          "Simulator Models"
        ],
        "summary": "Retrieve Simulator Model Revisions",
        "description": "Retrieve one or more simulator model revisions by IDs or external IDs.",
        "operationId": "retrieve_simulator_model_revisions_simulators_models_revisions_byids_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InputItemsList_Union_IdRef__ExternalIdRef__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorModelRevision_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/models/revisions/update": {},
    "/simulators/models/revisions/data/list": {},
    "/simulators/models/revisions/data/update": {},
    "/simulators/routines": {
      "post": {
        "tags": [
          "Simulator Routines"
        ],
        "summary": "Create Simulator Routine",
        "description": "Create a simulator routine.",
        "operationId": "create_simulator_routine_simulators_routines_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_SimulatorRoutineCreateCommand_"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorRoutineBase_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/routines/list": {
      "post": {
        "tags": [
          "Simulator Routines"
        ],
        "summary": "Filter Simulator Routines",
        "description": "Retrieves a list of simulator routines that match the given criteria.",
        "operationId": "filter_simulator_routines_simulators_routines_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulatorRoutinesQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewListWithCursor_SimulatorRoutineBase_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/routines/delete": {
      "post": {
        "tags": [
          "Simulator Routines"
        ],
        "summary": "Delete Simulator Routine",
        "description": "Delete a simulator routine. This will also delete all associated simulator resources (e.g. revisions, runs, data).",
        "operationId": "delete_simulator_routine_simulators_routines_delete_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_Union_IdRef__ExternalIdRef__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmptyResponse"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/routines/revisions": {
      "post": {
        "tags": [
          "Simulator Routines"
        ],
        "summary": "Create Simulator Routine Revision",
        "description": "Create a simulator routine revision.",
        "operationId": "create_simulator_routine_revision_simulators_routines_revisions_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SingleItemList_SimulatorRoutineRevisionCreateCommand_"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorRoutineRevision_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/routines/revisions/list": {
      "post": {
        "tags": [
          "Simulator Routines"
        ],
        "summary": "Filter Simulator Routine Revisions",
        "description": "Retrieves a list of simulator routine revisions that match the given criteria.",
        "operationId": "filter_simulator_routine_revisions_simulators_routines_revisions_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulatorRoutineRevisionsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/ViewListWithCursor_SimulatorRoutineRevision_"
                    },
                    {
                      "$ref": "#/components/schemas/ViewListWithCursor_SimulatorRoutineRevisionView_"
                    }
                  ],
                  "title": "Response Filter Simulator Routine Revisions Simulators Routines Revisions List Post"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/routines/revisions/byids": {
      "post": {
        "tags": [
          "Simulator Routines"
        ],
        "summary": "Retrieve Simulator Routine Revisions",
        "description": "Retrieve one or more simulator routine revisions by IDs or external IDs.",
        "operationId": "retrieve_simulator_routine_revisions_simulators_routines_revisions_byids_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InputItemsList20_Union_IdRef__ExternalIdRef__"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorRoutineRevision_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/logs/update": {},
    "/simulators/logs/byids": {
      "post": {
        "tags": [
          "Simulator Logs"
        ],
        "summary": "Simulator Logs By Ids",
        "description": "Retrieve one or more simulator logs by IDs.",
        "operationId": "simulator_logs_by_ids_simulators_logs_byids_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InputItemsList_IdRef_"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_SimulatorLog_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Bad Request"
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators/list": {
      "post": {
        "tags": [
          "Simulators"
        ],
        "summary": "Filter Simulators",
        "description": "List simulators.",
        "operationId": "filter_simulators_simulators_list_post",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListSimulatorsQuery"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_Simulator_"
                }
              }
            }
          },
          "403": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Forbidden"
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorBase"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/simulators": {},
    "/simulators/delete": {},
    "/simulators/update": {},
    "/units/byids": {
      "post": {
        "tags": [
          "Units"
        ],
        "summary": "Retrieve units by external IDs",
        "description": "Retrieves one or more units by external ID. The response returns the units in the same order as in the request.",
        "operationId": "byIdsUnits",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RestrictedItemList_ExternalIdRef_"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Response with a list of units",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_Unit_"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIError"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const units = await client.units.retrieve([{ externalId: 'temperature:deg_c' }, { externalId: 'pressure:bar' }]);"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.units.retrieve('temperature:deg_c')\n\nres = client.units.retrieve(['temperature:deg_c', 'pressure:bar'])\n"
          }
        ]
      }
    },
    "/units/systems": {
      "get": {
        "tags": [
          "Unit Systems"
        ],
        "summary": "List all unit systems",
        "description": "List all unit systems.",
        "operationId": "listUnitSystems",
        "responses": {
          "200": {
            "description": "Response with a list of unit systems",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_UnitSystem_"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const units = await client.units.listUnitSystems();"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.units.systems.list()\n"
          }
        ]
      }
    },
    "/units/{externalId}": {
      "get": {
        "tags": [
          "Units"
        ],
        "summary": "Retrieve unit by external ID",
        "description": "Retrieve a single unit by its external ID.",
        "operationId": "getUnit",
        "parameters": [
          {
            "name": "externalId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "External ID of the unit",
              "title": "Externalid"
            },
            "description": "External ID of the unit"
          }
        ],
        "responses": {
          "200": {
            "description": "Response with a single unit",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_Unit_"
                }
              }
            }
          },
          "400": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIError"
                }
              }
            },
            "description": "Bad Request"
          }
        }
      }
    },
    "/units": {
      "get": {
        "tags": [
          "Units"
        ],
        "summary": "List all units",
        "description": "List all units.",
        "operationId": "listUnits",
        "responses": {
          "200": {
            "description": "Response with a list of units",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ViewList_Unit_"
                }
              }
            }
          }
        },
        "x-code-samples": [
          {
            "lang": "JavaScript",
            "label": "JavaScript SDK",
            "source": "const units = await client.units.list();"
          },
          {
            "lang": "Python",
            "label": "Python SDK",
            "source": "res = client.units.list()\n"
          }
        ]
      }
    },
    "/api/v1/orgs/{org}/orgs": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "post": {
        "operationId": "createChildOrg",
        "summary": "Create an organization",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Create a child organization under the specified organization.\n\n#### Access control\nRequires the caller to be an admin in the parent organization (i.e. the one on the path), or any of its ancestors.\nIn addition, the flag `adminsCanCreateOrgsInSubtree` must be set to `true` in that organization.\n\n_Example:_ Assume an organization hierarchy like: `org-a` -> `org-b` -> `org-c`.\nTo create a new organization under `org-c`, which means calling 'POST /api/v1/orgs/org-c/orgs', the caller must be an\nadmin in at least one of `org-a`, `org-b`, or `org-c`, and `adminsCanCreateOrgsInSubtree` must be `true` in that same organization.",
        "tags": [
          "Organizations"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/OrganizationRequestDto"
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/OrganizationResponseDto"
          },
          "403": {
            "description": "Creation forbidden: The caller is not allowed to create sub-organizations."
          }
        }
      },
      "get": {
        "operationId": "listChildOrgs",
        "summary": "List child organizations",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "List all child organizations under the specified parent organization.\n\n#### Access control\nRequires the caller to be an admin in the parent organization (i.e. the one on the path), or any of its ancestors.\n\n_Example:_ Assume an organization hierarchy like: `org-a` -> `org-b` -> `org-c`.\nTo list child organizations under `org-b`, which means calling 'GET /api/v1/orgs/org-b/orgs', the caller must be an\nadmin in `org-a` or `org-b`.",
        "tags": [
          "Organizations"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/OrganizationListResponse"
          }
        }
      }
    },
    "/api/v1/orgs/{org}": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "get": {
        "operationId": "getOrg",
        "summary": "Retrieve an organization",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Retrieve an organization by its ID.\n\n#### Access control\nRequires the caller to be an admin in the organization, or any of its ancestors.\n\n_Example:_ Assume an organization hierarchy like: `org-a` -> `org-b` -> `org-c`.\nTo retrieve `org-c`, which means calling 'GET /api/v1/orgs/org-c', the caller must be an admin in `org-a`, `org-b` or\n`org-c`.",
        "tags": [
          "Organizations"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/OrganizationWithContactPersonsResponseDto"
          }
        }
      }
    },
    "/api/v1/orgs/{org}/delete": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "post": {
        "operationId": "deleteOrg",
        "summary": "Delete an organization",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Delete an organization. Users will be locked out of the organization immediately. This also applies to the caller.\n\nThe organization cannot contain sub-organizations or projects at the time of deletion.\n\nThis is a soft-delete, so Cognite Support can restore the organization in case of accidents.\n\n#### Access control\nRequires the caller to be an admin in the organization, or any of its ancestors.\n\n_Example:_ Assume an organization hierarchy like: `org-a` -> `org-b` -> `org-c`.\nTo delete `org-c`, which means calling 'POST /api/v1/orgs/org-c/delete', the caller must be an admin in `org-a`, `org-b` or\n`org-c`.",
        "tags": [
          "Organizations"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful deletion",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/orgs/{org}/projects": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "post": {
        "operationId": "createChildProject",
        "summary": "Create a project",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Create a project in the specified organization, in the given cluster. The project is immediately available\nfor login in Cognite applications, for example through Cognite Data Fusion.\n\n#### Cluster placement\nThe chosen cluster must be one of the allowed clusters for the organization.\n\nThe project cannot be moved to a different cluster after creation, so make sure to choose the correct one\nwith respect to data locality requirements.\n\n#### Project OIDC configuration\nThe OIDC configuration will be copied from the immediate parent organization.\n\nThe caller can, and should, set an initial admin group ID for the project. That group is managed by the external\nidentity provider, as for the organization.\nIf that group is not set, the project will inherit the admin group ID of the organization it's created in.\nSee the `projectAdminGroupId` field in the request body for more details on this behavior.\n\n#### Access control\nRequires the caller to be an admin in the organization, or any of its ancestors.\nIn addition, the flag `adminsCanCreateProjectsInSubtree` must be set to `true` in that organization.\n\n_Example:_ Assume an organization hierarchy like: `org-a` -> `org-b` -> `org-c`.\nTo create a project in `org-c`, which means calling 'POST /api/v1/orgs/org-c/projects', the caller must be an admin in\n`org-a`, `org-b` or `org-c`.\nAlso, `adminsCanCreateProjectsInSubtree` must be `true` in that same organization.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/NewProjectListRequestDto"
        },
        "responses": {
          "201": {
            "$ref": "#/components/responses/NewProjectListResponseDto"
          },
          "403": {
            "description": "Creation forbidden: The caller is not allowed to create projects."
          }
        }
      },
      "get": {
        "operationId": "listChildProjects",
        "summary": "List projects in an organization",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "List all projects in the specified organization.\n\n#### Access control\nIf `includeAdminProperties` is true, it requires the caller to be an admin in the organization, or any of its ancestors.\nOtherwise, it requires the caller to be a member of the organization.\n\n_Example:_ Assume an organization hierarchy like: `org-a` -> `org-b` -> `org-c`.\nTo list projects in `org-c`, which means calling 'GET /api/v1/orgs/org-c/projects?includeAdminProperties',\nthe caller must be an admin in `org-a`, `org-b` or `org-c`.",
        "tags": [
          "Projects"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          },
          {
            "name": "includeAdminProperties",
            "in": "query",
            "description": "Whether to include admin properties of the projects in the response.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ProjectResponseDto"
          }
        }
      }
    },
    "/api/v0/orgs/{org}/projects": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ]
    },
    "/api/v1/principals/me": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "get": {
        "operationId": "getMe",
        "summary": "Get the current caller's information",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Retrieves the information of the principal issuing the request.\n\nThis endpoint is useful for clients to verify their own identity.\nAll authenticated principals can call this endpoint.",
        "tags": [
          "Principals"
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/MeResponse"
          }
        }
      }
    },
    "/api/v1/orgs/{org}/principals": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "get": {
        "operationId": "listPrincipals",
        "summary": "List principals",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "List principals in an organization.\n\nAll principal types are supported.\n\n#### Access control\nRequires the caller to be logged into the target organization, or\nto be an admin in any of its the ancestor organizations.",
        "tags": [
          "Principals"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          },
          {
            "$ref": "#/components/parameters/Cursor"
          },
          {
            "$ref": "#/components/parameters/ListLimit"
          },
          {
            "$ref": "#/components/parameters/PrincipalTypes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/PrincipalsPaginatedListResponse"
          }
        }
      }
    },
    "/api/v1/orgs/{org}/principals/byids": {
      "servers": [
        {
          "url": "https://auth.cognite.com"
        }
      ],
      "post": {
        "operationId": "getPrincipalsById",
        "summary": "Retrieve principals by reference",
        "security": [
          {
            "org-oidc-token": []
          }
        ],
        "description": "Retrieve principals in an organization by ID or external ID.\n\nService accounts can be retrieved by ID or external ID.\nUsers can be retrieved by ID.\n\n#### Access control\nRequires the caller to be logged into the target organization, or\nto be an admin in any of its the ancestor organizations.",
        "tags": [
          "Principals"
        ],
        "parameters": [
          {
            "$ref": "#/components/parameters/OrgId"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/PrincipalsListByIdsRequest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/PrincipalsListResponse"
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "oidc-token": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "OpenID Connect or OAuth2 token",
        "description": "Access token issued by the CDF project's configured identity provider. Access token must be an OpenID Connect token, and the project must be configured to accept OpenID Connect tokens. Use a header key of 'Authorization' with a value of 'Bearer $accesstoken'. The token can be obtained through any flow supported by the identity provider."
      },
      "oauth2-client-credentials": {
        "type": "oauth2",
        "description": "Access token issued by the CDF project's configured identity provider. Access token must be an OpenID Connect token, and the project must be configured to accept OpenID Connect tokens. Use a header key of 'Authorization' with a value of 'Bearer $accesstoken'. The token can be obtained through any flow supported by the identity provider.",
        "flows": {
          "clientCredentials": {
            "tokenUrl": "https://your-idps.token.url/",
            "scopes": {
              "default": "https://{cluster}.cognitedata.com/.default"
            }
          }
        }
      },
      "oauth2-auth-code": {
        "type": "oauth2",
        "description": "Access token issued by the CDF project's configured identity provider. Access token must be an OpenID Connect token, and the project must be configured to accept OpenID Connect tokens. Use a header key of 'Authorization' with a value of 'Bearer $accesstoken'. The token can be obtained through any flow supported by the identity provider.",
        "flows": {
          "authorizationCode": {
            "authorizationUrl": "https://your-idps.authorization.url/",
            "tokenUrl": "https://your-idps.token.url/",
            "scopes": {
              "default": "https://{cluster}.cognitedata.com/.default"
            }
          }
        }
      },
      "oauth2-open-industrial-data": {
        "type": "oauth2",
        "description": "Auth flow for Open Industrial Data. Get your client secret from https://hub.cognite.com/open-industrial-data-211.",
        "flows": {
          "clientCredentials": {
            "tokenUrl": "https://login.microsoftonline.com/48d5043c-cf70-4c49-881c-c638f5796997/oauth2/v2.0/token",
            "scopes": {
              "default": "https://api.cognitedata.com/.default"
            }
          }
        }
      },
      "token": {
        "type": "http",
        "description": "Users log in via an OpenID/OAuth flow. Use the /login/redirect flow to obtain a bearer access token. Use a header key of 'Authorization' with a value of 'Bearer: $accesstoken'",
        "scheme": "bearer"
      },
      "org-oidc-token": {
        "type": "openIdConnect",
        "openIdConnectUrl": "https://auth.cognite.com/.well-known/openid-configuration",
        "description": "Access token issued by the Cognite authorization server, and valid for the target organization. The token must\nbe an OpenID Connect token, and it can be obtained by performing an OIDC login flow toward `auth.cognite.com`.\nThis is a single URL for all CDF organizations."
      }
    },
    "schemas": {
      "TokenInspectionResponse": {
        "type": "object",
        "required": [
          "subject",
          "projects",
          "capabilities"
        ],
        "properties": {
          "subject": {
            "type": "string",
            "description": "Subject (sub claim) of JWT"
          },
          "projects": {
            "$ref": "#/components/schemas/Projects"
          },
          "capabilities": {
            "$ref": "#/components/schemas/Capabilities"
          }
        }
      },
      "Projects": {
        "type": "array",
        "title": "projects",
        "items": {
          "type": "object",
          "required": [
            "projectUrlName",
            "groups"
          ],
          "properties": {
            "projectUrlName": {
              "type": "string",
              "description": "Project url name"
            },
            "groups": {
              "type": "array",
              "description": "Group IDs",
              "items": {
                "type": "integer",
                "description": "group ids",
                "format": "int64"
              }
            }
          }
        }
      },
      "Capabilities": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/Capability"
        }
      },
      "Capability": {
        "type": "object",
        "oneOf": [
          {
            "title": "Groups Capability",
            "properties": {
              "groupsAcl": {
                "$ref": "#/components/schemas/cognitegroups_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Assets Capability",
            "properties": {
              "assetsAcl": {
                "$ref": "#/components/schemas/cogniteassets_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Events Capability",
            "properties": {
              "eventsAcl": {
                "$ref": "#/components/schemas/cogniteevents_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Files Capability",
            "properties": {
              "filesAcl": {
                "$ref": "#/components/schemas/cognitefiles_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Projects Capability",
            "properties": {
              "projectsAcl": {
                "$ref": "#/components/schemas/cogniteprojects_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Security Category Capability",
            "properties": {
              "securityCategoriesAcl": {
                "$ref": "#/components/schemas/cognitesecuritycategories_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Raw Capability",
            "properties": {
              "rawAcl": {
                "$ref": "#/components/schemas/cogniteraw_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "TimeSeries Capability",
            "properties": {
              "timeSeriesAcl": {
                "$ref": "#/components/schemas/cognitetimeseries_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Threed Capability",
            "properties": {
              "threedAcl": {
                "$ref": "#/components/schemas/cognitethreed_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Sequences Capability",
            "properties": {
              "sequencesAcl": {
                "$ref": "#/components/schemas/cognitesequences_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Labels Capability",
            "properties": {
              "labelsAcl": {
                "$ref": "#/components/schemas/cognitelabels_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Analytics Capability",
            "properties": {
              "analyticsAcl": {
                "$ref": "#/components/schemas/cogniteanalytics_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Digital Twin Capability",
            "properties": {
              "digitalTwinAcl": {
                "$ref": "#/components/schemas/cognitedigitaltwin_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Data Modeling Schema Capability",
            "properties": {
              "digitalTwinAcl": {
                "$ref": "#/components/schemas/cognitedatamodels_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Data Modeling Instances Capability",
            "properties": {
              "digitalTwinAcl": {
                "$ref": "#/components/schemas/cognitedatamodelinstances_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Industrial Log Analytics Instances Capability",
            "properties": {
              "ilaInstancesAcl": {
                "$ref": "#/components/schemas/cogniteilainstances_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Relationships Capability",
            "properties": {
              "relationshipsAcl": {
                "$ref": "#/components/schemas/cogniterelationships_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Datasets Capability",
            "properties": {
              "datasetsAcl": {
                "$ref": "#/components/schemas/cognitedatasets_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Seismic Capability",
            "properties": {
              "seismicAcl": {
                "$ref": "#/components/schemas/cogniteseismic_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Types Capability",
            "properties": {
              "typesAcl": {
                "$ref": "#/components/schemas/cognitetypes_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Functions Capability",
            "properties": {
              "functionsAcl": {
                "$ref": "#/components/schemas/functions_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Extraction Pipelines Capability",
            "properties": {
              "extractionpipelinesAcl": {
                "$ref": "#/components/schemas/extractionpipelines_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          },
          {
            "title": "Extraction Pipeline Runs Capability",
            "properties": {
              "extractionrunsAcl": {
                "$ref": "#/components/schemas/extractionruns_aclAcl"
              },
              "projectScope": {
                "$ref": "#/components/schemas/ProjectScope"
              }
            }
          }
        ]
      },
      "ProjectScope": {
        "oneOf": [
          {
            "type": "object",
            "title": "allProjects",
            "required": [
              "allProjects"
            ],
            "properties": {
              "allProjects": {
                "type": "object",
                "description": "All projects"
              }
            }
          },
          {
            "type": "object",
            "title": "projectsList",
            "required": [
              "projects"
            ],
            "properties": {
              "projects": {
                "type": "array",
                "title": "projectUrlNames",
                "items": {
                  "$ref": "#/components/schemas/ProjectUrlName"
                }
              }
            }
          }
        ]
      },
      "NextCursorV3": {
        "description": "The cursor value used to return (paginate to) the next page of results, when more data is available.",
        "type": "string"
      },
      "InstanceSpace": {
        "type": "string",
        "pattern": "^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$",
        "minLength": 1,
        "maxLength": 43
      },
      "InstanceExternalId": {
        "type": "string",
        "pattern": "^[a-zA-Z]([a-zA-Z0-9_]{0,253}[a-zA-Z0-9])?$",
        "minLength": 1,
        "maxLength": 255
      },
      "SessionCredentials": {
        "additionalProperties": false,
        "properties": {
          "nonce": {
            "title": "Nonce",
            "type": "string",
            "description": "Session nonce for a recently created CDF Session."
          }
        },
        "required": [
          "nonce"
        ],
        "title": "SessionCredentials",
        "type": "object",
        "description": "Credentials for authenticating towards CDF using a CDF session."
      },
      "ResourceDescription": {
        "type": "string",
        "description": "The description of the resource type.",
        "maxLength": 500
      },
      "IgnoreUnknownIdsField": {
        "type": "object",
        "properties": {
          "ignoreUnknownIds": {
            "description": "Ignore IDs and external IDs that are not found",
            "type": "boolean",
            "default": false
          }
        }
      },
      "Limit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to return.",
            "type": "integer",
            "default": 100,
            "minimum": 1,
            "maximum": 1000
          }
        }
      },
      "ExternalIdPrefixFilter": {
        "description": "filter external ids starting with the prefix specified",
        "type": "string",
        "maxLength": 255
      },
      "DataLong": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "example": [
              23872937137,
              1238712837,
              128371973
            ],
            "minItems": 1,
            "uniqueItems": true,
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "Error": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 401
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "429Error": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API throttling.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "429 HTTP status code.",
            "format": "int32",
            "example": 429
          },
          "message": {
            "type": "string",
            "description": "The error message specifies which kind of throttling happened:\n  - Too many concurrent requests for a single project or an identity.\n  - Too high rate of requests for a single project or an identity.\n\nSee more [here](https://docs.cognite.com/dev/concepts/request_throttling/ \"requests throttling\").",
            "example": "Project exceeded maximum number='50' of concurrent requests. Please try again later."
          }
        }
      },
      "ObjectPatch": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemove"
          }
        ]
      },
      "ObjectPatchSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchEvent": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated event: Maximum length of key is 128 bytes, value 128000 bytes, up to 256 key-value pairs, of total size at most 200000.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchEventSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchEventAddRemove"
          }
        ]
      },
      "ObjectPatchEventSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 128000
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 200000,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchEventAddRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 128000
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 200000,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchAsset": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated asset: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSetAsset"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemoveAsset"
          }
        ]
      },
      "ObjectPatchSetAsset": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemoveAsset": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ObjectPatchDataSet": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated asset: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ObjectPatchSetDataSet"
          },
          {
            "$ref": "#/components/schemas/ObjectPatchAddRemoveDataSet"
          }
        ]
      },
      "ObjectPatchSetDataSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "object",
            "description": "Set the key-value pairs. All existing key-value pairs will be removed.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          }
        }
      },
      "ObjectPatchAddRemoveDataSet": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "object",
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "additionalProperties": {
              "type": "string",
              "maxLength": 10240
            },
            "x-maxKeyLength": 128,
            "x-maxTotalSize": 10240,
            "maxProperties": 256,
            "example": {
              "key1": "value1",
              "key2": "value2"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "example": [
              "value1",
              "value2"
            ],
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchLongSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "ArrayPatchLongAddOrRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "ArrayPatchLong": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ArrayPatchLongSet"
          },
          {
            "$ref": "#/components/schemas/ArrayPatchLongAddOrRemove"
          }
        ],
        "description": "Change that will be applied to the array."
      },
      "ArrayPatchStringSet": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchStringAddOrRemove": {
        "title": "add/remove",
        "type": "object",
        "properties": {
          "add": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "remove": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ArrayPatchString": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ArrayPatchStringSet"
          },
          {
            "$ref": "#/components/schemas/ArrayPatchStringAddOrRemove"
          }
        ],
        "description": "Change that will be applied to the array."
      },
      "SinglePatchBoolean": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        }
      },
      "JsonArrayInt64": {
        "type": "string",
        "format": "jsonArray(int64)",
        "example": "[1238712837, 238712361376, 23786237623]"
      },
      "JsonArrayString": {
        "type": "string",
        "format": "jsonArray(string)"
      },
      "EpochTimestamp": {
        "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
        "type": "integer",
        "minimum": 0,
        "format": "int64",
        "example": 1730204346000
      },
      "EpochTimestampRange": {
        "description": "Range between two timestamps (inclusive).",
        "type": "object",
        "properties": {
          "max": {
            "description": "Maximum timestamp (inclusive). The timestamp is represented as number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "type": "integer",
            "minimum": 0,
            "format": "int64"
          },
          "min": {
            "description": "Minimum timestamp (inclusive). The timestamp is represented as number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "type": "integer",
            "minimum": 0,
            "format": "int64"
          }
        }
      },
      "IsNull": {
        "type": "object",
        "properties": {
          "isNull": {
            "type": "boolean",
            "example": true,
            "description": "Set to true if you want to search for data with field value not set, false to search for cases where some value is present."
          }
        }
      },
      "Partition": {
        "description": "Splits the data set into `N` partitions.\nThe attribute is specified as a \"M/N\" string, where `M` is a natural number in the interval of `[1, N]`.\nYou need to follow the cursors within each partition in order to receive all the data.\n\nTo prevent unexpected problems and maximize read throughput, you should at most use 10 (N <= 10) partitions.\n\nWhen using more than 10 partitions, CDF may reduce the number of partitions silently.\nFor example, CDF may reduce the number of partitions to `K = 10` so if you specify an `X/N` `partition` value where `X = 8` and `N = 20` - i.e. `\"partition\": \"8/20\"`- then\nCDF will change `N` to `N = K = 10` and process the request.\nBut if you  specify the `X/N` `partition` value where `X = 11` (`X > K`) and `N = 20` - i.e. `\"partition\": \"11/20\"`- then\nCDF will reply with an empty result list and no cursor in the response.\\\n\nIn future releases of the resource APIs, Cognite may reject requests if you specify more than 10 partitions.\nWhen Cognite enforces this behavior, the requests will result in a 400 Bad Request status.\n",
        "type": "string",
        "example": "1/10"
      },
      "PartitionLimited10": {
        "description": "Splits the data set into `N` partitions.\nThe attribute is specified as a \"M/N\" string, where `M` is a natural number in the interval of `[1, N]`.\nYou need to follow the cursors within each partition in order to receive all the data.\n\nThe maximum number of allowed partitions (`N`) is 10.\n\nCognite rejects requests if you specify more than 10 partitions.\nWhen Cognite enforces this behavior, the requests result in a 400 Bad Request status.\n",
        "type": "string",
        "example": "1/3"
      },
      "PartitionObject": {
        "type": "object",
        "properties": {
          "partition": {
            "$ref": "#/components/schemas/Partition"
          }
        }
      },
      "PartitionObjectLimited10": {
        "type": "object",
        "properties": {
          "partition": {
            "$ref": "#/components/schemas/PartitionLimited10"
          }
        }
      },
      "Cursor": {
        "description": "Cursor for paging through results.",
        "type": "object",
        "properties": {
          "cursor": {
            "type": "string",
            "example": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo"
          }
        }
      },
      "SetLongField": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SetStringField": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "string"
          }
        }
      },
      "SetIntegerField": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "integer"
          }
        }
      },
      "SetBooleanField": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        }
      },
      "GeoLocationFilter": {
        "description": "Only include files matching the specified geographic relation.",
        "type": "object",
        "required": [
          "relation",
          "shape"
        ],
        "properties": {
          "relation": {
            "type": "string",
            "enum": [
              "INTERSECTS",
              "DISJOINT",
              "WITHIN"
            ],
            "description": "One of the supported queries."
          },
          "shape": {
            "type": "object",
            "description": "Represents the points, curves and surfaces in the coordinate space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/Point"
              },
              {
                "$ref": "#/components/schemas/LineString"
              },
              {
                "$ref": "#/components/schemas/Polygon"
              },
              {
                "$ref": "#/components/schemas/MultiLineString"
              },
              {
                "$ref": "#/components/schemas/MultiPolygon"
              }
            ],
            "discriminator": {
              "propertyName": "type"
            }
          }
        }
      },
      "GeoLocationGeometry": {
        "type": "object",
        "required": [
          "type"
        ],
        "description": "Represents the points, curves and surfaces in the coordinate space.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Point"
          },
          {
            "$ref": "#/components/schemas/LineString"
          },
          {
            "$ref": "#/components/schemas/Polygon"
          },
          {
            "$ref": "#/components/schemas/MultiPoint"
          },
          {
            "$ref": "#/components/schemas/MultiLineString"
          },
          {
            "$ref": "#/components/schemas/MultiPolygon"
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "Point": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Point"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/PointCoordinates"
          }
        }
      },
      "PointCoordinates": {
        "description": "Coordinates of a point in 2D space, described as an array of 2 numbers.\n\nExample: `[4.306640625, 60.205710352530346]`\n",
        "type": "array",
        "minItems": 2,
        "maxItems": 2,
        "items": {
          "type": "number"
        }
      },
      "LineString": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "LineString"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/LineStringCoordinates"
          }
        }
      },
      "LineStringCoordinates": {
        "description": "Coordinates of a line described by a list of two or more points.\nEach point is defined as a pair of two numbers in an array, representing coordinates of a point in 2D space.\n\nExample: `[[30, 10], [10, 30], [40, 40]]`\n",
        "type": "array",
        "minItems": 2,
        "items": {
          "$ref": "#/components/schemas/PointCoordinates"
        }
      },
      "Polygon": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Polygon"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/PolygonCoordinates"
          }
        }
      },
      "PolygonCoordinates": {
        "description": "List of one or more linear rings representing a shape.\n\nA linear ring is the boundary of a surface or the boundary of a hole in a surface. It is defined as a list consisting of 4 or more Points, where the first and last Point is equivalent.\n\nEach Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[[35, 10], [45, 45], [15, 40], [10, 20], [35, 10]], [[20, 30], [35, 35], [30, 20], [20, 30]]]`\n",
        "type": "array",
        "minItems": 2,
        "items": {
          "$ref": "#/components/schemas/LineStringCoordinates"
        }
      },
      "MultiPoint": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "MultiPoint"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiPointCoordinates"
          }
        }
      },
      "MultiPointCoordinates": {
        "description": "List of Points. Each Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[35, 10], [45, 45]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PointCoordinates"
        }
      },
      "MultiLineString": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "MultiLineString"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiLineStringCoordinates"
          }
        }
      },
      "MultiLineStringCoordinates": {
        "description": "List of lines where each line (LineString) is defined as a list of two or more points.\nEach point is defined as a pair of two numbers in an array, representing coordinates of a point in 2D space.\n\nExample: `[[[30, 10], [10, 30]], [[35, 10], [10, 30], [40, 40]]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/LineStringCoordinates"
        }
      },
      "MultiPolygon": {
        "type": "object",
        "required": [
          "type",
          "coordinates"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "MultiPolygon"
            ]
          },
          "coordinates": {
            "$ref": "#/components/schemas/MultiPolygonCoordinates"
          }
        }
      },
      "MultiPolygonCoordinates": {
        "description": "List of multiple polygons.\n\nEach polygon is defined as a list of one or more linear rings representing a shape.\n\nA linear ring is the boundary of a surface or the boundary of a hole in a surface. It is defined as a list consisting of 4 or more Points, where the first and last Point is equivalent.\n\nEach Point is defined as an array of 2 numbers, representing coordinates of a point in 2D space.\n\nExample: `[[[[30, 20], [45, 40], [10, 40], [30, 20]]], [[[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]]]`\n",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/PolygonCoordinates"
        }
      },
      "GeoLocation": {
        "description": "Geographic metadata.",
        "required": [
          "type",
          "geometry"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "Feature"
            ],
            "description": "One of the GeoJSON types. Currently only the 'Feature' type is supported."
          },
          "geometry": {
            "$ref": "#/components/schemas/GeoLocationGeometry"
          },
          "properties": {
            "type": "object",
            "description": "Additional properties in a String key -> Object value format."
          }
        }
      },
      "SinglePatchGeoLocation": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetGeoLocation"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the geoLocation, or remove the value."
      },
      "SetGeoLocation": {
        "title": "set",
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/GeoLocation"
          }
        }
      },
      "RemoveField": {
        "title": "remove",
        "type": "object",
        "required": [
          "setNull"
        ],
        "properties": {
          "setNull": {
            "type": "boolean",
            "example": true
          }
        }
      },
      "SetExternalId": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "SetDataSetId": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/DataSetId"
          }
        }
      },
      "SetDescription": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ResourceDescription"
          }
        }
      },
      "SinglePatchResourceDescription": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDescription"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchDataSetId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDataSetId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchExternalId": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetExternalId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the externalId, or remove the value. Must be unique for the resource type."
      },
      "SinglePatchLong": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetLongField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the long, or remove the value."
      },
      "ModifyPatchInteger": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetIntegerField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the integer, or remove the value"
      },
      "ModifyPatchBoolean": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetBooleanField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the boolean, or remove the value"
      },
      "SinglePatchString": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetStringField"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the string, or remove the value."
      },
      "SinglePatchRequiredString": {
        "title": "set",
        "type": "object",
        "properties": {
          "set": {
            "type": "string"
          }
        },
        "description": "Set a new value for the string.",
        "required": [
          "set"
        ]
      },
      "CogniteInternalId": {
        "description": "A server-generated ID for the object.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "CogniteExternalId": {
        "description": "The external ID provided by the client. Must be unique for the resource type.",
        "type": "string",
        "maxLength": 255,
        "example": "my.known.id"
      },
      "CogniteInstanceId": {
        "description": "The ID of an [instance in Cognite Data Models](https://docs.cognite.com/cdf/dm/dm_concepts/dm_spaces_instances#instance).",
        "type": "object",
        "required": [
          "space",
          "externalId"
        ],
        "properties": {
          "space": {
            "type": "string",
            "minLength": 1,
            "maxLength": 43
          },
          "externalId": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          }
        }
      },
      "CogniteExternalIdPrefix": {
        "description": "Filter by this (case-sensitive) prefix for the external ID.",
        "type": "string",
        "maxLength": 255,
        "example": "my.known.prefix"
      },
      "DataSetInternalId": {
        "type": "object",
        "title": "DataSetInternalId",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DataSetExternalId": {
        "type": "object",
        "title": "DataSetExternalId",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "DataSetIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DataSetInternalId"
          },
          {
            "$ref": "#/components/schemas/DataSetExternalId"
          }
        ]
      },
      "DataSetIdEithers": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/DataSetIdEither"
        }
      },
      "IdEither": {
        "type": "object",
        "description": "Either an internal ID, or an external ID.",
        "oneOf": [
          {
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            },
            "required": [
              "id"
            ]
          },
          {
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            },
            "required": [
              "externalId"
            ]
          }
        ],
        "example": {
          "externalId": "my.known.id"
        }
      },
      "DataSetId": {
        "description": "The dataSet Id for the item.",
        "type": "integer",
        "minimum": 1,
        "maximum": 9007199254740991,
        "format": "int64"
      },
      "DataModelingStatus": {
        "type": "string",
        "description": "Status of data modeling for a project.",
        "enum": [
          "DATA_MODELING_ONLY",
          "DATA_MODELING_FIRST",
          "HYBRID"
        ]
      },
      "TimestampOrStringStart": {
        "oneOf": [
          {
            "type": "integer",
            "default": 0
          },
          {
            "type": "string"
          }
        ],
        "description": "Get datapoints starting from, and including, this time. The format is N[timeunit]-ago where\ntimeunit is w,d,h,m,s. Example: '2d-ago' gets datapoints that are up to 2 days\nold. You can also specify time in milliseconds since epoch. Note that for aggregates, the start time is rounded down to a whole granularity unit (in UTC timezone). Daily granularities (d)\nare rounded to 0:00 AM; hourly granularities (h) to the start of the hour, etc."
      },
      "TimestampOrStringEnd": {
        "oneOf": [
          {
            "type": "integer"
          },
          {
            "type": "string",
            "default": "now"
          }
        ],
        "description": "Get datapoints up to, but excluding, this point in time. Same format as for start. Note that when using aggregates, the end will be rounded up such that the last aggregate represents a full aggregation interval containing the original end, where the interval is the granularity unit times the granularity multiplier. For granularity 2d, the aggregation interval is 2 days, if end was originally 3 days after the start, it will be rounded to 4 days after the start."
      },
      "CountAggregateResult": {
        "description": "Common aggregate structure to represent aggregate result which have one count for filter resultset (Documents Count, Property Cardinality, etc).",
        "title": "CountResult",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "description": "Number of items in this aggregation group.",
                  "format": "int64"
                }
              }
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 10
            }
          ]
        }
      },
      "StringValue": {
        "title": "String",
        "description": "A unique string value in the field.",
        "type": "object",
        "required": [
          "value"
        ],
        "properties": {
          "value": {
            "type": "string"
          }
        }
      },
      "AggregateStringValues": {
        "title": "Strings",
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "description": "Number of items in this aggregation bucket.",
            "type": "integer",
            "format": "int64"
          },
          "values": {
            "description": "An array of unique string values in the property.",
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "string"
            }
          },
          "value": {
            "deprecated": true,
            "description": "A unique string value in the field.",
            "type": "string"
          }
        }
      },
      "AggregateIntegerValues": {
        "title": "Integers",
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "description": "Number of items in this aggregation bucket.",
            "type": "integer",
            "format": "int64"
          },
          "values": {
            "description": "An array of unique integer values in the property.",
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "integer",
              "format": "int64"
            }
          },
          "value": {
            "deprecated": true,
            "description": "A unique integer value in the field.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "AggregatePropertyValues": {
        "title": "Properties",
        "description": "A single bucket to represent `uniqueProperties` aggregate result.\n",
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "description": "Number of items in this aggregation bucket.",
            "type": "integer",
            "format": "int64"
          },
          "values": {
            "description": "An array of unique properties for UniqueProperties aggregate.\n",
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "property"
              ],
              "properties": {
                "property": {
                  "$ref": "#/components/schemas/AggregateProperty"
                }
              },
              "example": {
                "property": [
                  "metadata",
                  "key1"
                ]
              }
            }
          },
          "value": {
            "deprecated": true,
            "description": "A unique property for UniqueProperties aggregate.\n",
            "type": "object",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregateProperty"
              }
            }
          }
        }
      },
      "ValuesAggregateResult": {
        "description": "Common aggregate structure to represent aggregate result which have count buckets for filter resultset (Unique Property Values, Not Null Document Properties, etc).",
        "title": "BucketsResult",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "oneOf": [
                {
                  "$ref": "#/components/schemas/AggregateStringValues"
                },
                {
                  "$ref": "#/components/schemas/AggregateIntegerValues"
                },
                {
                  "$ref": "#/components/schemas/AggregatePropertyValues"
                }
              ]
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 5,
              "values": [
                "value_1"
              ]
            },
            {
              "count": 10,
              "values": [
                "value_2"
              ]
            }
          ]
        }
      },
      "AggregateResult": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/CountAggregateResult"
          },
          {
            "$ref": "#/components/schemas/ValuesAggregateResult"
          }
        ]
      },
      "Label": {
        "type": "object",
        "title": "Label",
        "required": [
          "externalId"
        ],
        "description": "A label assigned to a resource.",
        "properties": {
          "externalId": {
            "description": "An external ID to a predefined label definition.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          }
        }
      },
      "LabelList": {
        "type": "array",
        "description": "A list of the labels associated with this resource item.",
        "minItems": 0,
        "maxItems": 10,
        "uniqueItems": true,
        "items": {
          "$ref": "#/components/schemas/Label"
        }
      },
      "LabelFilter": {
        "description": "Return only the resource matching the specified label constraints.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/LabelContainsAllFilter"
          }
        ]
      },
      "LabelContainsAnyFilter": {
        "type": "object",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "description": "The resource item contains at least one of the listed labels.",
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelContainsAllFilter": {
        "type": "object",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "description": "The resource item contains at least all the listed labels.",
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelDefinitionExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "LabelDefinitionExternalIdList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/LabelDefinitionExternalId"
            }
          }
        }
      },
      "LabelsPatch": {
        "description": "Updates the resource's assigned labels.\n\nLabels can be added, removed or replaced (set). Adding an already attached label is an idempotent operation. Removing a label with no matching externalId is silently ignored.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/LabelsAddRemove"
          },
          {
            "$ref": "#/components/schemas/LabelsSet"
          }
        ]
      },
      "LabelsAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "A list of the labels to add to a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          },
          "remove": {
            "type": "array",
            "description": "A list of the labels to remove from a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "LabelsSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "A list of the labels to replace (set) to a resource.",
            "minItems": 0,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Label"
            }
          }
        }
      },
      "EqualsFilter": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the given property is **exactly** equal to the given value.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/Value"
              }
            }
          }
        }
      },
      "InFilter": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the given property is **exactly** equal to one of the given values. This filter can only be applied to single-valued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/Values"
              }
            }
          }
        }
      },
      "GenericRangeFilter": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain terms within the provided range.\nIt is not allowed to specify both inclusive and exclusive bounds (such as `gte`, `gt`) together.\n`gte`: Greater than or equal to.\n`gt`: Greater than.\n`lte`: Less than or equal to.\n`lt`: Less than.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/RangeValue"
              },
              "gt": {
                "$ref": "#/components/schemas/RangeValue"
              },
              "lte": {
                "$ref": "#/components/schemas/RangeValue"
              },
              "lt": {
                "$ref": "#/components/schemas/RangeValue"
              }
            }
          }
        }
      },
      "PrefixFilter": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contain a specific prefix in the provided property.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/StringValue"
              }
            }
          }
        }
      },
      "AggregateInFilter": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "values"
            ],
            "description": "Matches items where the given property is **exactly** equal to one of the given values. This filter can only be applied to single-valued properties.\n",
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/Values"
              }
            }
          }
        }
      },
      "AggregatePrefixFilter": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "value"
            ],
            "description": "Matches aggregate values that contain a specific prefix.\n",
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/StringValue"
              }
            }
          }
        }
      },
      "AggregateRangeFilter": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "description": "Matches items that contain terms within the provided range.\nIt's not allowed to specify both inclusive and exclusive bounds (such as `gte`, `gt`) together.\n`gte`: Greater than or equal to.\n`gt`: Greater than.\n`lte`: Less than or equal to.\n`lt`: Less than.\n",
            "type": "object",
            "properties": {
              "gte": {
                "$ref": "#/components/schemas/RangeValue"
              },
              "gt": {
                "$ref": "#/components/schemas/RangeValue"
              },
              "lte": {
                "$ref": "#/components/schemas/RangeValue"
              },
              "lt": {
                "$ref": "#/components/schemas/RangeValue"
              }
            }
          }
        }
      },
      "ExistsFilter": {
        "type": "object",
        "title": "exists",
        "required": [
          "exists"
        ],
        "properties": {
          "exists": {
            "required": [
              "property"
            ],
            "description": "Will match items that have a value in the specified property.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              }
            }
          }
        }
      },
      "ContainsAnyFilter": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more of the given values.\nThis filter can only be applied to multivalued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/Values"
              }
            }
          }
        }
      },
      "ContainsAllFilter": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains all the given values.\nThis filter can only be applied to multivalued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/Values"
              }
            }
          }
        }
      },
      "SearchFilter": {
        "type": "object",
        "title": "search",
        "required": [
          "search"
        ],
        "properties": {
          "search": {
            "required": [
              "property",
              "value"
            ],
            "description": "Fuzzy search in the specified property. Introduced to provide functional parity with `/search` endpoints.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/FilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/Value"
              }
            }
          }
        }
      },
      "FilterProperty": {
        "description": "Property you want to filter. Use a list of strings to specify nested properties.\n\n<u>Example:</u>\n\nYou have the object\n```\n{\n  \"room\": {\n    \"id\": \"b53\"\n  },\n  \"roomId\": \"a23\"\n}\n```\n\nUse `[\"room\", \"id\"]` to return the value in the nested `id` property, which is a part of the `room` object.\n\nYou can also read the value(s) in the standalone property `roomId` with `[\"roomId\"]`.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 3,
        "items": {
          "type": "string"
        }
      },
      "AggregateProperty": {
        "description": "Property you want to aggregate.\nUse a list of strings to specify nested properties.\nThe same way the properties are represented in aggregate responses.\n\n<u>Example:</u>\n\nYou have the object\n```\n{\n  \"metadata\": {\n    \"id\": \"b53\"\n  },\n  \"source\": \"a23\"\n}\n```\n\nTo address \"id\" metadata key use `[\"metadata\", \"id\"]` property.\\\nYou can also aggregate the value(s) for the standalone property `source` with `[\"source\"]`.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 2,
        "items": {
          "type": "string"
        },
        "example": [
          "metadata",
          "key1"
        ]
      },
      "Value": {
        "description": "Value you wish to find in the provided property.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "Values": {
        "description": "One or more values you wish to find in the provided property.",
        "type": "array",
        "minItems": 1,
        "maxItems": 5000,
        "items": {
          "$ref": "#/components/schemas/Value"
        }
      },
      "RangeValue": {
        "title": "rangeBound",
        "description": "Value you wish to find in the provided property using a range clause.",
        "oneOf": [
          {
            "type": "string",
            "title": "string"
          },
          {
            "type": "number",
            "title": "number"
          },
          {
            "type": "integer",
            "title": "integer"
          }
        ]
      },
      "MatchAllFilter": {
        "type": "object",
        "title": "matchAll",
        "required": [
          "matchAll"
        ],
        "properties": {
          "matchAll": {
            "description": "All the listed items must match the clause.",
            "type": "object",
            "maxProperties": 0
          }
        }
      },
      "ProjectUrlName": {
        "type": "string",
        "description": "The URL name of the project. This is used as part of the request path in API calls.\n\nValid URL names contains between 3 and 32 characters, and may only contain\nEnglish letters, digits and hyphens, must contain at least one letter\nand may not start or end with a hyphen.\n",
        "minLength": 3,
        "maxLength": 32,
        "example": "publicdata"
      },
      "CreateAdvancedJoinsRequestSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoin"
            },
            "minItems": 1,
            "maxItems": 100
          }
        }
      },
      "CreateAdvancedJoinsResponseSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoin"
            },
            "minItems": 1,
            "maxItems": 100
          }
        }
      },
      "ListAdvancedJoinsResponseSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoin"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "nextCursor": {
            "type": "string",
            "description": "A cursor that can be passed to this endpoint to get the next page of items."
          }
        }
      },
      "UpdateAdvancedJoinMatchersRequestSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoinsUpdateItem"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "AdvancedJoinsUpdateItem": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/AdvancedJoinPatch"
          }
        }
      },
      "AdvancedJoinPatch": {
        "type": "object",
        "description": "Matchers can be added, removed, or replaced (set).",
        "required": [
          "matchers"
        ],
        "properties": {
          "matchers": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AdvancedJoinPatchSetMatchers"
              },
              {
                "$ref": "#/components/schemas/AdvancedJoinPatchAddRemoveMatchers"
              }
            ]
          }
        }
      },
      "AdvancedJoinPatchSetMatchers": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "The matchers to replace the advanced join's matchers entirely.",
            "items": {
              "$ref": "#/components/schemas/Matcher"
            },
            "minItems": 0,
            "maxItems": 100
          }
        }
      },
      "AdvancedJoinPatchAddRemoveMatchers": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "The matchers to add to the advanced join's matchers.\nThey will be added if they aren't already assigned.",
            "items": {
              "$ref": "#/components/schemas/Matcher"
            },
            "minItems": 0,
            "maxItems": 100
          },
          "remove": {
            "type": "array",
            "description": "The matchers to remove from the advanced join's matchers.\nThey will be removed if they exist.",
            "items": {
              "$ref": "#/components/schemas/Matcher"
            },
            "minItems": 0,
            "maxItems": 100
          }
        }
      },
      "AdvancedJoin": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "matchers": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Matcher"
                },
                "minItems": 0,
                "maxItems": 100
              }
            }
          },
          {
            "oneOf": [
              {
                "$ref": "#/components/schemas/DirectRelationTarget"
              }
            ]
          }
        ]
      },
      "Matcher": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RAWMatcher"
          }
        ]
      },
      "RAWMatcher": {
        "type": "object",
        "description": "The Raw matcher can be used when you already have a collection of known matches, stored in a Raw table.",
        "required": [
          "type",
          "dbName",
          "tableName",
          "fromColumnKey",
          "toColumnKey"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "raw"
            ]
          },
          "dbName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "description": "Name of the Raw database"
          },
          "tableName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "description": "Name of the Raw database table"
          },
          "fromColumnKey": {
            "type": "string",
            "description": "The column containing the external ids of the node at the start of the relationship."
          },
          "toColumnKey": {
            "type": "string",
            "description": "The column containing the external ids of the node at the end of the relationship."
          }
        }
      },
      "DirectRelationTarget": {
        "type": "object",
        "required": [
          "type",
          "space",
          "viewExternalId",
          "viewVersion",
          "propertyName"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "direct"
            ]
          },
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "viewExternalId": {
            "$ref": "#/components/schemas/DMSExternalId"
          },
          "viewVersion": {
            "$ref": "#/components/schemas/DMSVersion"
          },
          "propertyName": {
            "type": "string",
            "description": "The name of the property that holds the direct relation"
          }
        }
      },
      "DeleteAdvancedJoinsRequestSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            },
            "minItems": 1,
            "maxItems": 100
          }
        }
      },
      "CreateAdvancedJoinMatchesRequestSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoinMatch"
            },
            "minItems": 1,
            "maxItems": 100
          }
        }
      },
      "CreateAdvancedJoinMatchesResponseSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoinMatch"
            },
            "minItems": 1,
            "maxItems": 100
          }
        }
      },
      "ListAdvancedJoinMatchesResponseSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AdvancedJoinMatch"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "nextCursor": {
            "type": "string",
            "description": "A cursor that can be passed to this endpoint to get the next page of items."
          }
        }
      },
      "DeleteAdvancedJoinMatchesRequestSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            },
            "minItems": 1,
            "maxItems": 100
          }
        }
      },
      "AdvancedJoinMatch": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "externalId",
              "advancedJoinExternalId",
              "originExternalId",
              "linkedExternalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "advancedJoinExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "originExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "linkedExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "AdvancedJoinJobId": {
        "type": "string",
        "description": "ID of an advanced join job. These are always UUIDs."
      },
      "RunAdvancedJoinRequestSchema": {
        "type": "object",
        "required": [
          "advancedJoinExternalId"
        ],
        "properties": {
          "advancedJoinExternalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "RunAdvancedJoinResponseSchema": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "jobId"
            ],
            "properties": {
              "jobId": {
                "$ref": "#/components/schemas/AdvancedJoinJobId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          },
          {
            "type": "object",
            "required": [
              "advancedJoinExternalId"
            ],
            "properties": {
              "advancedJoinExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "MeasureMappedPercentageRequestSchema": {
        "type": "object",
        "required": [
          "space",
          "viewExternalId",
          "viewVersion"
        ],
        "properties": {
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "viewExternalId": {
            "$ref": "#/components/schemas/DMSExternalId"
          },
          "viewVersion": {
            "$ref": "#/components/schemas/DMSVersion"
          },
          "dummyResponse": {
            "type": "boolean",
            "description": "Whether to return a bogus response that complies with the expected schema.\nThis will be removed in a future iteration.",
            "default": false
          }
        }
      },
      "MeasureMappedPercentageResponseSchema": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "jobId"
            ],
            "properties": {
              "jobId": {
                "$ref": "#/components/schemas/AdvancedJoinJobId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          },
          {
            "type": "object",
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": [
                    "propertyName",
                    "mappedPercentage"
                  ],
                  "properties": {
                    "propertyName": {
                      "type": "string",
                      "description": "The name of this property"
                    },
                    "mappedPercentage": {
                      "type": "number",
                      "minimum": 0,
                      "maximum": 100
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "EstimateQualityRequestSchema": {
        "type": "object",
        "required": [
          "advancedJoinExternalId",
          "matcher"
        ],
        "properties": {
          "advancedJoinExternalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "dummyResponse": {
            "type": "boolean",
            "description": "Whether to return a bogus response that complies with the expected schema.\nThis will be removed in a future iteration.",
            "default": false
          },
          "matcher": {
            "$ref": "#/components/schemas/Matcher"
          }
        }
      },
      "EstimateQualityResponseSchema": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "jobId"
            ],
            "properties": {
              "jobId": {
                "$ref": "#/components/schemas/AdvancedJoinJobId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          },
          {
            "type": "object",
            "required": [
              "advancedJoinExternalId",
              "matcher"
            ],
            "properties": {
              "advancedJoinExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "matcher": {
                "$ref": "#/components/schemas/Matcher"
              },
              "qualityScorePercent": {
                "type": "number",
                "description": "The quality of the Join, calculated as the ratio of correctly mapped instances to all mapped instances.",
                "minimum": 0,
                "maximum": 100
              },
              "confidencePercent": {
                "type": "number",
                "minimum": 0,
                "maximum": 100
              },
              "contextualizationScorePercent": {
                "type": "number",
                "minimum": 0,
                "maximum": 100
              }
            }
          }
        ]
      },
      "SuggestImprovementsRequestSchema": {
        "type": "object",
        "required": [
          "advancedJoinExternalId"
        ],
        "properties": {
          "advancedJoinExternalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "limit": {
            "type": "integer",
            "default": 20,
            "minimum": 1,
            "maximum": 1000
          }
        }
      },
      "DirectRelationImprovementSuggestion": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "direct"
            ]
          },
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "originExternalId": {
            "$ref": "#/components/schemas/NodeOrEdgeExternalId"
          },
          "propertyName": {
            "type": "string",
            "description": "The name of the property"
          }
        }
      },
      "ImprovementSuggestion": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DirectRelationImprovementSuggestion"
          }
        ]
      },
      "SuggestImprovementsResponseSchema": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "jobId"
            ],
            "properties": {
              "jobId": {
                "$ref": "#/components/schemas/AdvancedJoinJobId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          },
          {
            "type": "object",
            "required": [
              "advancedJoinExternalId"
            ],
            "properties": {
              "advancedJoinExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "improvementSuggestions": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ImprovementSuggestion"
                }
              }
            }
          }
        ]
      },
      "AssetName": {
        "type": "string",
        "description": "The name of the asset.",
        "minLength": 1,
        "maxLength": 140
      },
      "AssetDescription": {
        "type": "string",
        "description": "The description of the asset.",
        "maxLength": 500
      },
      "AssetQuery": {
        "type": "string",
        "description": "Whitespace-separated terms to search for in assets. Does a best-effort fuzzy search in relevant fields (currently name and description) for variations of any of the search terms, and orders results by relevance. Uses a different search algorithm than the name and description parameters, and will generally give much better results. Matching and ordering is not guaranteed to be stable over time, and the fields being searched may be extended.",
        "minLength": 1,
        "maxLength": 140
      },
      "AssetMetadata": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "additionalProperties": {
          "type": "string",
          "maxLength": 10240
        },
        "x-maxKeyLength": 128,
        "x-maxTotalSize": 10240,
        "maxProperties": 256
      },
      "AssetParentExternalId": {
        "description": "The external ID of the parent. This will be resolved to an internal ID and stored as `parentId`.",
        "type": "string",
        "maxLength": 255,
        "example": "my.known.id"
      },
      "AssetSource": {
        "type": "string",
        "maxLength": 128,
        "description": "The source of the asset."
      },
      "SetAssetSource": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/AssetSource"
          }
        }
      },
      "AssetInternalId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "AssetExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "AssetIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/AssetInternalId"
          },
          {
            "$ref": "#/components/schemas/AssetExternalId"
          }
        ]
      },
      "AssetIdentifier": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DeleteRequest": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AssetIdEither"
                },
                "maxItems": 1000,
                "minItems": 1
              },
              "recursive": {
                "description": "Recursively delete all asset subtrees under the specified IDs.",
                "type": "boolean",
                "default": false
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "AssetDataIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/AssetIdEither"
                },
                "maxItems": 1000,
                "minItems": 1
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          },
          {
            "$ref": "#/components/schemas/AggregatedProperties"
          }
        ]
      },
      "ExternalAsset": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "$ref": "#/components/schemas/AssetName"
          },
          "parentId": {
            "description": "The parent node's ID used to specify parent-child relationship.\n\nYou should not use this field in combination with the parentExternalId field.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "parentExternalId": {
            "description": "The parent node's external ID used to specify the parent-child relationship.\nWhen specifying this field, the API will resolve the external ID into an internal ID and use the internal ID to store the parent-child relation.\nAs a result, a later change to update the parent's external ID will not affect this parent-child relationship as it is based on internal ID.\n\nYou should not use this field in combination with the parentId field.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          },
          "description": {
            "$ref": "#/components/schemas/AssetDescription"
          },
          "dataSetId": {
            "description": "The id of the dataset this asset belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/AssetMetadata"
          },
          "source": {
            "$ref": "#/components/schemas/AssetSource"
          },
          "labels": {
            "$ref": "#/components/schemas/LabelList"
          },
          "geoLocation": {
            "$ref": "#/components/schemas/GeoLocation"
          }
        },
        "description": "A representation of a physical asset, for example a factory or a piece of equipment."
      },
      "Asset": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "rootId",
              "createdTime",
              "lastUpdatedTime"
            ],
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "rootId": {
                "description": "The ID of the root asset. The root asset is the asset spanning the entire asset hierarchy that this asset belongs to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                ]
              },
              "aggregates": {
                "$ref": "#/components/schemas/AggregateResultItem"
              },
              "parentId": {
                "description": "The ID of the parent of this node, null if it is the root node.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                ]
              },
              "parentExternalId": {
                "description": "The external ID of the parent. The property is omitted if the asset doesn't have a parent or if the parent doesn't have externalId.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/ExternalAsset"
          },
          {
            "$ref": "#/components/schemas/AssetInternalId"
          }
        ]
      },
      "AggregateResultItem": {
        "description": "Aggregated metrics of the asset.",
        "type": "object",
        "properties": {
          "childCount": {
            "type": "integer",
            "description": "Number of direct descendants for the asset.",
            "format": "int32",
            "minimum": 0
          },
          "depth": {
            "type": "integer",
            "description": "Asset path depth (number of levels below root node).",
            "format": "int32",
            "minimum": 0
          },
          "path": {
            "description": "IDs of assets on the path to the asset.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetIdentifier"
            }
          }
        }
      },
      "DataAsset": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Asset"
            }
          }
        }
      },
      "DataAssetChange": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetChange"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "DataExternalAssetItem": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExternalAsset"
          },
          {
            "type": "object",
            "properties": {
              "parentExternalId": {
                "$ref": "#/components/schemas/AssetParentExternalId"
              }
            }
          }
        ]
      },
      "DataExternalAsset": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataExternalAssetItem"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "DataWithCursorAsset": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Asset"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next or previous page of results."
      },
      "AggregatedProperty": {
        "type": "string",
        "enum": [
          "childCount",
          "path",
          "depth"
        ]
      },
      "AggregatedProperties": {
        "type": "object",
        "properties": {
          "aggregatedProperties": {
            "description": "Set of aggregated properties to include",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AggregatedProperty"
            }
          }
        }
      },
      "AssetFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "type": "object",
            "description": "Filter on assets with strict matching.",
            "title": "Filter",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/AssetName"
              },
              "parentIds": {
                "description": "Return only the direct descendants of the specified assets.",
                "type": "array",
                "minItems": 1,
                "maxItems": 100,
                "items": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              },
              "parentExternalIds": {
                "description": "Return only the direct descendants of the specified assets.",
                "type": "array",
                "minItems": 1,
                "maxItems": 100,
                "items": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              },
              "rootIds": {
                "description": "This parameter is deprecated. Use `assetSubtreeIds` instead. Only include these root assets and their descendants.",
                "deprecated": true,
                "type": "array",
                "minItems": 1,
                "maxItems": 100,
                "items": {
                  "$ref": "#/components/schemas/AssetIdEither"
                }
              },
              "assetSubtreeIds": {
                "type": "array",
                "minItems": 1,
                "maxItems": 100,
                "description": "Only include assets in subtrees rooted at the specified assets (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
                "items": {
                  "$ref": "#/components/schemas/AssetIdEither"
                }
              },
              "dataSetIds": {
                "type": "array",
                "maxItems": 1000,
                "items": {
                  "$ref": "#/components/schemas/DataSetIdEither"
                }
              },
              "metadata": {
                "$ref": "#/components/schemas/AssetMetadata"
              },
              "source": {
                "$ref": "#/components/schemas/AssetSource"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "root": {
                "type": "boolean",
                "description": "Whether the filtered assets are root assets, or not. Set to True to only list root assets."
              },
              "externalIdPrefix": {
                "$ref": "#/components/schemas/CogniteExternalIdPrefix"
              },
              "labels": {
                "$ref": "#/components/schemas/LabelFilter"
              },
              "geoLocation": {
                "$ref": "#/components/schemas/GeoLocationFilter"
              }
            }
          }
        }
      },
      "AssetLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to return.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "AssetSort": {
        "type": "object",
        "properties": {
          "sort": {
            "description": "Sort by array of selected properties.\n",
            "type": "array",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "$ref": "#/components/schemas/AssetSortProperty"
            },
            "example": [
              {
                "property": [
                  "createdTime"
                ],
                "order": "desc"
              },
              {
                "property": [
                  "metadata",
                  "customMetadataKey"
                ],
                "nulls": "first"
              }
            ]
          }
        }
      },
      "AssetSortProperty": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "type": "array",
            "description": "Property to sort on.\nSorting can be done on the following properties:\n  | Property                        |\n  |---------------------------------|\n  | `[\"createdTime\"]`               |\n  | `[\"dataSetId\"]`                 |\n  | `[\"description\"]`               |\n  | `[\"externalId\"]`                |\n  | `[\"lastUpdatedTime\"]`           |\n  | `[\"metadata\", \"someCustomKey\"]` |\n  | `[\"name\"]`                      |\n  | `[\"source\"]`                    |\n  | `[\"_score_\"]`                   |",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "type": "string"
            }
          },
          "order": {
            "type": "string",
            "description": "The `order` attribute is optional and defaults to `desc` for `_score_` and `asc` for all other properties.",
            "enum": [
              "asc",
              "desc"
            ]
          },
          "nulls": {
            "type": "string",
            "description": "The `nulls` attribute is optional and defaults to `auto`.\n`auto` is translated to `last` for the `asc` order and to `first` for the `desc` order by the service.",
            "enum": [
              "first",
              "last",
              "auto"
            ],
            "default": "auto"
          }
        }
      },
      "AssetAggregateRequest": {
        "description": "Aggregation request of assets. Filters behave the same way as for the `filter` endpoint. Default aggregation is `count`.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/AssetCountAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetWithPropertyCountAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetCardinalityValuesAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetCardinalityPropertiesAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetUniqueValuesAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetUniquePropertiesAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetMetadataKeysAggregate"
          },
          {
            "$ref": "#/components/schemas/AssetMetadataValuesAggregate"
          }
        ]
      },
      "AssetCardinalityValuesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "ApproximateCardinalityForValues",
            "description": "Request values approximate cardinality aggregate on a specific property.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`cardinalityValues`: Get approximate number of unique values for the specified property.\n",
                "type": "string",
                "enum": [
                  "cardinalityValues"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/AssetAggregateFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "$ref": "#/components/schemas/AssetAggregateProperties"
          }
        ]
      },
      "AssetCardinalityPropertiesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "ApproximateCardinalityForProperties",
            "description": "Request resource properties approximate cardinality aggregate.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`cardinalityProperties`: Get approximate number of unique properties.\n",
                "type": "string",
                "enum": [
                  "cardinalityProperties"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/AssetAggregateFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "properties": {
              "path": {
                "description": "The scope in every document to aggregate properties.\nThe only value allowed now is [\"metadata\"].\nIt means to aggregate only metadata properties (aka keys).\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "string",
                  "enum": [
                    "metadata"
                  ]
                },
                "default": [
                  "metadata"
                ]
              }
            }
          }
        ]
      },
      "AssetUniqueValuesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "UniqueValues",
            "description": "Request unique value buckets aggregate on a specific Asset property.\nEach bucket is defined by the `values` array and has the number of the `values` occurrences.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`uniqueValues`: Get unique values (up to max 1000) in the specified property ordered by the frequency.\nNote: When aggregate on the `[\"metadata\"]` property, a value may occur multiple times in one Asset for different metadata keys.\nEach occurrence is counted.\n",
                "type": "string",
                "enum": [
                  "uniqueValues"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/AssetAggregateFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "$ref": "#/components/schemas/AssetAggregateProperties"
          }
        ]
      },
      "AssetUniquePropertiesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "UniqueProperties",
            "description": "Request unique non-null property buckets aggregate.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`uniqueProperties`: Get unique properties (up to max 1000) in the specified document path (default path is [\"metadata\"] - metadata keys only).\nOrdered by frequency.\n",
                "type": "string",
                "enum": [
                  "uniqueProperties"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/AssetAggregateFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "properties": {
              "path": {
                "description": "The scope in every document to aggregate properties.\nThe only value allowed now is [\"metadata\"].\nIt means to aggregate only metadata properties (aka keys).\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "string",
                  "enum": [
                    "metadata"
                  ]
                },
                "default": [
                  "metadata"
                ]
              }
            }
          }
        ]
      },
      "AssetCountAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "AssetCount",
            "description": "Request aggregate to count number of Assets matching the filters. Default aggregate for the endpoint.",
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`count`: Get approximate number of Assets matching the filters.\n",
                "type": "string",
                "enum": [
                  "count"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          }
        ]
      },
      "AssetWithPropertyCountAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "AssetWithPropertyCount",
            "description": "Request aggregate to count the number of Assets with the specific property (property is not null)\nand matching the filters.",
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`count`: Get an approximate number of Assets with the specific property (property is not null) and matching the filters.\n",
                "type": "string",
                "enum": [
                  "count"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "$ref": "#/components/schemas/AssetAggregateProperties"
          }
        ]
      },
      "AssetMetadataKeysAggregate": {
        "deprecated": true,
        "allOf": [
          {
            "type": "object",
            "title": "MetadataKeys",
            "description": "Get unique values (up to max 1000) of metadata keys ordered by frequency.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`metadataKeys`: Get unique values of metadata keys ordered by frequency.\n",
                "type": "string",
                "enum": [
                  "metadataKeys"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          }
        ]
      },
      "AssetMetadataValuesAggregate": {
        "deprecated": true,
        "allOf": [
          {
            "type": "object",
            "title": "MetadataValues",
            "description": "Get unique values (up to max 1000) of values for a particular metadata key, ordered by frequency.",
            "required": [
              "aggregate",
              "keys"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`metadataValues`: Get unique values of values for a particular metadata key, ordered by frequency.\n",
                "type": "string",
                "enum": [
                  "metadataValues"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "$ref": "#/components/schemas/AssetAggregateKeys"
          }
        ]
      },
      "AssetAggregateProperties": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "description": "The property name(s) to apply the aggregation on. Currently limited to one property per request.",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "property"
              ],
              "properties": {
                "property": {
                  "type": "array",
                  "description": "It's an array of strings to allow specifying nested properties.\n  Supported properties:\\\n  | Property                        | Type                         |\n  |---------------------------------|------------------------------|\n  | `[\"dataSetId\"]`                 | number                       |\n  | `[\"description\"]`               | string                       |\n  | `[\"labels\"]`                    | array of [string]            |\n  | `[\"name\"]`                      | string                       |\n  | `[\"parentId\"]`                  | number                       |\n  | `[\"rootId\"]`                    | number                       |\n  | `[\"source\"]`                    | string                       |\n  | `[\"metadata\"]`                  | string                       |\n  | `[\"metadata\", <key>]`           | string                       |",
                  "minItems": 1,
                  "maxItems": 2,
                  "items": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 128
                  },
                  "example": [
                    "parentId"
                  ]
                },
                "filter": {
                  "$ref": "#/components/schemas/AssetAggregateFilter"
                }
              }
            }
          }
        }
      },
      "AssetAggregateKeys": {
        "type": "object",
        "properties": {
          "keys": {
            "description": "For `metadataValues`, `aggregateType` sets the metadata key(s) to apply the aggregation on. Currently supports exactly one key per request.\n",
            "type": "array",
            "maxItems": 1,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AssetListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "$ref": "#/components/schemas/AssetAdvancedFilter"
          },
          {
            "$ref": "#/components/schemas/AssetLimit"
          },
          {
            "$ref": "#/components/schemas/AssetSort"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/AggregatedProperties"
          },
          {
            "$ref": "#/components/schemas/PartitionObjectLimited10"
          }
        ]
      },
      "AssetAggregateFilter": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define aggregate filter queries.\n\nSee more information about filtering DSL [here](https://docs.cognite.com/dev/concepts/resource_filtering_dsl/ \"filtering DSL\").\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/AssetAggregateBoolFilter"
          },
          {
            "$ref": "#/components/schemas/AssetAggregateLeafFilter"
          }
        ],
        "example": {
          "or": [
            {
              "not": {
                "and": [
                  {
                    "equals": {
                      "value": 10
                    }
                  },
                  {
                    "in": {
                      "values": [
                        11,
                        12
                      ]
                    }
                  },
                  {
                    "range": {
                      "gte": 13,
                      "lt": 15
                    }
                  }
                ]
              }
            },
            {
              "and": [
                {
                  "equals": {
                    "value": 42
                  }
                }
              ]
            }
          ]
        }
      },
      "AssetAggregateLeafFilter": {
        "description": "Aggregate leaf filter.",
        "title": "AggregateLeafFilter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/AggregateInFilter"
          },
          {
            "$ref": "#/components/schemas/AggregatePrefixFilter"
          },
          {
            "$ref": "#/components/schemas/AggregateRangeFilter"
          }
        ]
      },
      "AssetAggregateBoolFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt's built using one or more boolean clauses of the following types: `and`, `or`, or `not`.\n",
        "title": "AggregateBoolFilter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/AssetAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/AssetAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetAggregateFilter"
                  }
                ]
              }
            }
          }
        ]
      },
      "AssetAdvancedFilter": {
        "type": "object",
        "properties": {
          "advancedFilter": {
            "type": "object",
            "description": "A filter DSL (Domain Specific Language) to define advanced filter queries.\n\nSee more information about filtering DSL [here](https://docs.cognite.com/dev/concepts/resource_filtering_dsl/ \"filtering DSL\").\n\nSupported properties:\n\n  | Property                        | Type                                    |\n  |---------------------------------|-----------------------------------------|\n  | `[\"labels\"]`                    | array of [string]                       |\n  | `[\"createdTime\"]`               | number                                  |\n  | `[\"dataSetId\"]`                 | number                                  |\n  | `[\"id\"]`                        | number                                  |\n  | `[\"lastUpdatedTime\"]`           | number                                  |\n  | `[\"parentId\"]`                  | number                                  |\n  | `[\"rootId\"]`                    | number                                  |\n  | `[\"description\"]`               | string                                  |\n  | `[\"externalId\"]`                | string                                  |\n  | `[\"metadata\"]`                  | string                                  |\n  | `[\"metadata\", \"someCustomKey\"]` | string                                  |\n  | `[\"name\"]`                      | string                                  |\n  | `[\"source\"]`                    | string                                  |\n\n  Note: Filtering on the `[\"metadata\"]` property has the following logic:\n  If a value of any metadata keys in an asset matches the filter, the asset matches the filter.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssetBoolFilter"
              },
              {
                "$ref": "#/components/schemas/AssetLeafFilter"
              }
            ],
            "example": {
              "or": [
                {
                  "not": {
                    "and": [
                      {
                        "equals": {
                          "property": [
                            "metadata",
                            "asset_type"
                          ],
                          "value": "gas pump"
                        }
                      },
                      {
                        "in": {
                          "property": [
                            "source"
                          ],
                          "values": [
                            "blueprint",
                            "inventory"
                          ]
                        }
                      },
                      {
                        "range": {
                          "property": [
                            "dataSetId"
                          ],
                          "gte": 1,
                          "lt": 10
                        }
                      }
                    ]
                  }
                },
                {
                  "and": [
                    {
                      "containsAny": {
                        "property": [
                          "labels"
                        ],
                        "values": [
                          "pump",
                          "cooler"
                        ]
                      }
                    },
                    {
                      "equals": {
                        "property": [
                          "parentId"
                        ],
                        "value": 95867294876
                      }
                    }
                  ]
                },
                {
                  "search": {
                    "property": [
                      "description"
                    ],
                    "value": "My favorite pump"
                  }
                }
              ]
            }
          }
        }
      },
      "AssetLeafFilter": {
        "description": "Leaf filter.",
        "title": "LeafFilter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EqualsFilter"
          },
          {
            "$ref": "#/components/schemas/InFilter"
          },
          {
            "$ref": "#/components/schemas/GenericRangeFilter"
          },
          {
            "$ref": "#/components/schemas/PrefixFilter"
          },
          {
            "$ref": "#/components/schemas/ExistsFilter"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/ContainsAllFilter"
          },
          {
            "$ref": "#/components/schemas/SearchFilter"
          }
        ]
      },
      "AssetBoolFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt is built using one or more boolean clauses of the following types: `and`, `or`, or `not`.",
        "title": "BoolFilter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/AssetAdvancedFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/AssetAdvancedFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AssetAdvancedFilter"
                  }
                ]
              }
            }
          }
        ]
      },
      "AssetSearchFilter": {
        "description": "Search request with filter capabilities.",
        "example": {
          "filter": {
            "parentIds": [
              1293812938,
              293823982938
            ]
          },
          "search": {
            "name": "flow",
            "description": "upstream"
          }
        },
        "allOf": [
          {
            "$ref": "#/components/schemas/AssetFilter"
          },
          {
            "$ref": "#/components/schemas/AssetLimit"
          },
          {
            "$ref": "#/components/schemas/AssetSearch"
          }
        ]
      },
      "AssetSearch": {
        "type": "object",
        "properties": {
          "search": {
            "type": "object",
            "title": "Search",
            "description": "Fulltext search for assets. Primarily meant for for human-centric use-cases, not for programs. The query parameter uses a different search algorithm than the deprecated name and description parameters, and will generally give much better results.",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/AssetName"
              },
              "description": {
                "$ref": "#/components/schemas/AssetDescription"
              },
              "query": {
                "$ref": "#/components/schemas/AssetQuery"
              }
            }
          }
        }
      },
      "AssetChange": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/AssetChangeById"
          },
          {
            "$ref": "#/components/schemas/AssetChangeByExternalId"
          }
        ]
      },
      "AssetChangeById": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AssetPatch"
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "AssetChangeByExternalId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AssetPatch"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "AssetPatch": {
        "type": "object",
        "description": "Changes applied to asset",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/SinglePatchExternalId"
              },
              "name": {
                "$ref": "#/components/schemas/SinglePatchRequiredName"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchResourceDescription"
              },
              "dataSetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "metadata": {
                "$ref": "#/components/schemas/ObjectPatchAsset"
              },
              "source": {
                "$ref": "#/components/schemas/SinglePatchAssetSource"
              },
              "parentId": {
                "$ref": "#/components/schemas/SinglePatchRequiredInternalId"
              },
              "parentExternalId": {
                "$ref": "#/components/schemas/SinglePatchRequiredParentExternalId"
              },
              "labels": {
                "$ref": "#/components/schemas/LabelsPatch"
              },
              "geoLocation": {
                "$ref": "#/components/schemas/SinglePatchGeoLocation"
              }
            }
          }
        }
      },
      "SinglePatchRequiredName": {
        "title": "AssetName",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/AssetName"
          }
        },
        "description": "Set a new value for the asset name.",
        "required": [
          "set"
        ]
      },
      "SinglePatchAssetSource": {
        "title": "Source",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetAssetSource"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the source, or remove the value."
      },
      "SinglePatchRequiredInternalId": {
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "Change the ID of the object.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredExternalId": {
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "description": "Change the external ID of the object.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredParentExternalId": {
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/AssetParentExternalId"
          }
        },
        "description": "Change the external ID of the object.",
        "required": [
          "set"
        ]
      },
      "NodeOrEdge": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/NodeDefinition"
          },
          {
            "$ref": "#/components/schemas/EdgeDefinition"
          }
        ]
      },
      "SlimNodeOrEdge": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SlimNodeDefinition"
          },
          {
            "$ref": "#/components/schemas/SlimEdgeDefinition"
          }
        ]
      },
      "ViewPropertyReference": {
        "type": "object",
        "required": [
          "view",
          "identifier"
        ],
        "deprecated": true,
        "properties": {
          "view": {
            "description": "Reference to a view - this is deprecated, use `source` with ViewReference instead",
            "allOf": [
              {
                "$ref": "#/components/schemas/ViewReference"
              }
            ]
          },
          "identifier": {
            "description": "The unique identifier, from the view, for the property",
            "allOf": [
              {
                "$ref": "#/components/schemas/PropertyIdentifierV3"
              }
            ]
          }
        }
      },
      "ThroughReference": {
        "type": "object",
        "title": "direct reference",
        "description": "Traverse a direct relation. Only applicable when `from` is specified. The view or container property to use when we traverse direct relations. Has to reference a direct relation property.",
        "required": [
          "source",
          "identifier"
        ],
        "properties": {
          "source": {
            "$ref": "#/components/schemas/SourceReference"
          },
          "identifier": {
            "$ref": "#/components/schemas/PropertyIdentifierV3"
          }
        }
      },
      "ViewReference": {
        "type": "object",
        "description": "Reference to a view",
        "required": [
          "type",
          "space",
          "externalId",
          "version"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "view"
            ]
          },
          "space": {
            "description": "Id of the space that the view belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "External-id of the view",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "version": {
            "description": "Version of the view",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSVersion"
              }
            ]
          }
        }
      },
      "DataModelReference": {
        "type": "object",
        "description": "Data model reference",
        "required": [
          "space",
          "externalId",
          "version"
        ],
        "properties": {
          "space": {
            "description": "Id of the space that the data model belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "External-id of the data model",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "version": {
            "description": "Version of the data model",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSVersion"
              }
            ]
          }
        }
      },
      "CreateViewProperty": {
        "type": "object",
        "required": [
          "container",
          "containerPropertyIdentifier"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Readable property name.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description of the content and suggested use for this property.",
            "maxLength": 1024
          },
          "container": {
            "$ref": "#/components/schemas/ContainerReference"
          },
          "containerPropertyIdentifier": {
            "description": "The unique identifier for the property (Unique within the referenced container).",
            "allOf": [
              {
                "$ref": "#/components/schemas/PropertyIdentifierV3"
              }
            ]
          },
          "source": {
            "description": "Indicates on what type a referenced direct relation is expected to be (although not required). Only applicable for direct relation properties.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ViewReference"
              }
            ]
          }
        }
      },
      "ContainerReference": {
        "type": "object",
        "description": "Reference to an existing container",
        "required": [
          "type",
          "space",
          "externalId"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "container"
            ]
          },
          "space": {
            "description": "Id of the space hosting (containing) the container",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "External-id of the container",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          }
        }
      },
      "DataModelCore": {
        "type": "object",
        "required": [
          "space",
          "externalId",
          "version"
        ],
        "properties": {
          "space": {
            "description": "Id of the space that the data model belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "External id that uniquely identifies this data model",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "Readable name meant for use in UIs",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description of the content and intended use of the data model",
            "maxLength": 1024
          },
          "version": {
            "description": "Data model version (opaque string controlled by client applications)",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSVersion"
              }
            ]
          }
        }
      },
      "DataModel": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataModelCore"
          },
          {
            "type": "object",
            "required": [
              "createdTime",
              "lastUpdatedTime",
              "isGlobal"
            ],
            "properties": {
              "views": {
                "type": "array",
                "description": "List of views included in this data model.  We can expand the views to use the full view definitions,\ni.e. with all the dependent views.\n\nUse the ```InlineViews``` query parameter to request expansion.  If you do not set the\n```InlineViews``` query parameter, we will return the references to views instead.\n",
                "items": {
                  "$ref": "#/components/schemas/DataModelProperty"
                }
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "isGlobal": {
                "description": "Is this a global data model.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "DataModelProperty": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/ViewReference"
          },
          {
            "$ref": "#/components/schemas/ViewDefinition"
          }
        ]
      },
      "DataModelCreate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataModelCore"
          },
          {
            "type": "object",
            "properties": {
              "views": {
                "type": "array",
                "description": "List of views included in this data model.  You can use a reference to an existing view to specify the new view.  Or you can create a new view/update an existing view by including an existing view specification.",
                "items": {
                  "$ref": "#/components/schemas/DataModelCreateProperty"
                }
              }
            }
          }
        ]
      },
      "DataModelCreateProperty": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/ViewReference"
          },
          {
            "$ref": "#/components/schemas/ViewCreateDefinition"
          }
        ]
      },
      "ViewCreateDefinition": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "description": "External id uniquely identifying this view. The values ```Query```, ```Mutation```, ```Subscription```, ```String```, ```Int32```, ```Int64```, ```Int```, ```Float32```, ```Float64```, ```Float```, ```Timestamp```, ```JSONObject```, ```Date```, ```Numeric```, ```Boolean```, ```PageInfo```, ```File```, ```Sequence``` and ```TimeSeries``` are reserved.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DMSExternalId"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/ViewCommon"
          },
          {
            "type": "object",
            "properties": {
              "properties": {
                "type": "object",
                "description": "View with included properties and expected edges, indexed by a unique space-local identifier. The view identifier has to have a length of between 1 and 255 characters.  It must also match the pattern ```^[a-zA-Z0-9][a-zA-Z0-9_-]{0,253}[a-zA-Z0-9]?$```, and it cannot be any of the following reserved identifiers: ```space```, ```externalId```, ```createdTime```, ```lastUpdatedTime```, ```deletedTime```, ```edge_id```, ```node_id```, ```project_id```, ```property_group```, ```seq```, ```tg_table_name```, and ```extensions```. The maximum number of properties depends on the project subscription and is by default 100.",
                "additionalProperties": {
                  "x-additionalPropertiesName": "property-identifier",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ViewCreateDefinitionProperty"
                    }
                  ]
                }
              }
            }
          }
        ]
      },
      "ViewCreateDefinitionProperty": {
        "description": "A reference to a container property or a connection describing edges that are expected to\nexist (ConnectionDefinition).\n\nIf the referenced container property is a direct relation, a view of the node can be specified. The view is\na hint to the consumer on what type of data is expected to be of interest in the context of this view.\n\nA connection describes the edges that are likely to exist to aid in discovery and documentation of the view.\nA listed edge is not required. i.e. It does not have to exist when included in this list. The target nodes of\nthis connection will match the view specified in the source property. A connection has a max distance of one hop\nin the underlying graph.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/CreateViewProperty"
          },
          {
            "$ref": "#/components/schemas/ConnectionDefinition"
          }
        ]
      },
      "ViewDefinition": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "description": "External id uniquely identifying this view",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DMSExternalId"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/ViewCommon"
          },
          {
            "type": "object",
            "required": [
              "createdTime",
              "lastUpdatedTime",
              "writable",
              "queryable",
              "properties",
              "usedFor",
              "isGlobal",
              "mappedContainers"
            ],
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "writable": {
                "type": "boolean",
                "description": "Does the view support write operations, i.e. is it ```writable```?  You can write to a view if the view maps all non-nullable properties."
              },
              "queryable": {
                "type": "boolean",
                "description": "Does the view support queries, i.e. is it queryable? You can query a view if it either has a filter or at least one property mapped to a container."
              },
              "usedFor": {
                "$ref": "#/components/schemas/UsedFor"
              },
              "isGlobal": {
                "type": "boolean",
                "description": "Is this a global view."
              },
              "properties": {
                "type": "object",
                "description": "List of properties and connections included in this view.  The view identifier has to have a length of between 1 and 255 characters.  It must also match the pattern ```^[a-zA-Z0-9][a-zA-Z0-9_-]{0,253}[a-zA-Z0-9]?$```.",
                "additionalProperties": {
                  "x-additionalPropertiesName": "view-property-identifier",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/ViewDefinitionProperty"
                    }
                  ]
                }
              },
              "mappedContainers": {
                "type": "array",
                "description": "List of containers with properties mapped by this view.",
                "items": {
                  "$ref": "#/components/schemas/ContainerReference"
                }
              }
            }
          }
        ]
      },
      "ViewDefinitionProperty": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ViewPropertyDefinition"
          },
          {
            "$ref": "#/components/schemas/ConnectionDefinitionRead"
          }
        ]
      },
      "ViewCommon": {
        "type": "object",
        "required": [
          "space",
          "version"
        ],
        "properties": {
          "space": {
            "description": "Id of the space that the view belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "Readable name, meant for use in UIs",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description. Intended to describe the content, and use, of this view.",
            "maxLength": 1024
          },
          "filter": {
            "$ref": "#/components/schemas/FilterDefinition"
          },
          "implements": {
            "type": "array",
            "description": "References to the views from where this view will inherit properties - both mapped properties (properties pointing to container properties like text, integers, direct relations) and connection properties (like reverse direct relations). \n\n\nNote: The order you list the views in is significant. We use this order to deduce the priority when we encounter duplicate property references.\n\n\nIf you do not specify a view version, we will use the most recent version available at the time of creation. ",
            "items": {
              "$ref": "#/components/schemas/ViewReference"
            }
          },
          "version": {
            "$ref": "#/components/schemas/DMSVersion"
          }
        }
      },
      "ConnectionDefinition": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/EdgeConnection"
          },
          {
            "$ref": "#/components/schemas/ReverseDirectRelationConnection"
          }
        ]
      },
      "ConnectionDefinitionRead": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/EdgeConnection"
          },
          {
            "$ref": "#/components/schemas/ReverseDirectRelationConnectionRead"
          }
        ]
      },
      "EdgeConnection": {
        "type": "object",
        "required": [
          "type",
          "source"
        ],
        "description": "Describes the edge(s) that are likely to exist to aid in discovery and documentation of the view. A listed edge is not required. i.e. It does not have to exist when included in this list. A connection has a max distance of one hop.",
        "properties": {
          "connectionType": {
            "type": "string",
            "description": "The type of connection, either a single or multi edge connections are expected to exist.",
            "enum": [
              "single_edge_connection",
              "multi_edge_connection"
            ],
            "default": "multi_edge_connection"
          },
          "name": {
            "type": "string",
            "description": "Readable property name.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description of the content and suggested use for this property.",
            "maxLength": 1024
          },
          "type": {
            "$ref": "#/components/schemas/DirectRelationReference"
          },
          "source": {
            "description": "The target node(s) of this connection can be read through the view specified in 'source'.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ViewReference"
              }
            ]
          },
          "edgeSource": {
            "description": "The edge(s) of this connection can be read through the view specified in 'edgeSource'.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ViewReference"
              }
            ]
          },
          "direction": {
            "type": "string",
            "enum": [
              "outwards",
              "inwards"
            ],
            "default": "outwards"
          }
        }
      },
      "ReverseDirectRelationConnection": {
        "type": "object",
        "required": [
          "connectionType",
          "source",
          "through"
        ],
        "description": "Describes the direct relation(s) pointing to instances read through this view. This connection type is used to aid in discovery and documentation of the view.",
        "properties": {
          "connectionType": {
            "type": "string",
            "description": "The type of connection. The ```single_reverse_direct_relation``` type is used to indicate that only a single direct relation is expected to exist. The ```multi_reverse_direct_relation``` type is used to indicate that multiple direct relations are expected to exist.",
            "enum": [
              "single_reverse_direct_relation",
              "multi_reverse_direct_relation"
            ]
          },
          "name": {
            "type": "string",
            "description": "Readable property name.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description of the content and suggested use for this property.",
            "maxLength": 1024
          },
          "source": {
            "description": "The node(s) containing the direct relation property can be read through the view specified in 'source'.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ViewReference"
              }
            ]
          },
          "through": {
            "description": "The view or container of the node containing the direct relation property.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ThroughReference"
              }
            ]
          }
        }
      },
      "ReverseDirectRelationConnectionRead": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ReverseDirectRelationConnection"
          },
          {
            "type": "object",
            "required": [
              "targetsList"
            ],
            "properties": {
              "targetsList": {
                "description": "Whether or not this reverse direct relation targets a _list_ of direct relations.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "ContainerDefinition": {
        "required": [
          "space",
          "externalId",
          "properties",
          "usedFor",
          "createdTime",
          "lastUpdatedTime",
          "isGlobal"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/ContainerCreateDefinition"
          },
          {
            "type": "object",
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "isGlobal": {
                "type": "boolean",
                "description": "Is this a global container."
              }
            }
          }
        ]
      },
      "ContainerCreateDefinition": {
        "type": "object",
        "description": "Container for properties you can access through views.  Container specifications give details about storage related details. For instance, how to index the data, and what constraints should be present.     You can define a single container to only contain nodes (```node```), only contain edges (```edge```), or to contain both (```all```).",
        "required": [
          "space",
          "externalId",
          "properties"
        ],
        "properties": {
          "space": {
            "description": "Id of the space the container belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "External-id of the container. The values ```Query```, ```Mutation```, ```Subscription```, ```String```, ```Int32```, ```Int64```, ```Int```, ```Float32```, ```Float64```, ```Float```, ```Timestamp```, ```JSONObject```, ```Date```, ```Numeric```, ```Boolean```, ```PageInfo```, ```File```, ```Sequence``` and ```TimeSeries``` are reserved.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "name": {
            "type": "string",
            "description": "Readable name for container meant for use in UIs",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description of what the property contains, and how you intend to use it.",
            "maxLength": 1024
          },
          "usedFor": {
            "$ref": "#/components/schemas/UsedFor"
          },
          "properties": {
            "type": "object",
            "description": "We index the property by a local unique identifier. The identifier has to have a length of between 1 and 255 characters.  It must also match the pattern ```^[a-zA-Z0-9][a-zA-Z0-9_-]{0,253}[a-zA-Z0-9]?$``` , and it cannot be any of the following reserved identifiers: ```space```, ```externalId```, ```createdTime```, ```lastUpdatedTime```, ```deletedTime```, ```edge_id```, ```node_id```, ```project_id```, ```property_group```, ```seq```, ```tg_table_name```, and ```extensions```. The maximum number of properties depends on the project subscription and is by default 100.",
            "minProperties": 1,
            "additionalProperties": {
              "x-additionalPropertiesName": "containerPropertyIdentifier",
              "allOf": [
                {
                  "$ref": "#/components/schemas/ContainerPropertyDefinition"
                }
              ]
            }
          },
          "constraints": {
            "type": "object",
            "description": "Set of constraints to apply to the container",
            "additionalProperties": {
              "x-additionalPropertiesName": "constraint-identifier",
              "allOf": [
                {
                  "$ref": "#/components/schemas/ConstraintDefinition"
                }
              ]
            }
          },
          "indexes": {
            "type": "object",
            "description": "Set of indexes to apply to the container. Up to 10 indexes can be added on a container.",
            "additionalProperties": {
              "x-additionalPropertiesName": "index-identifier",
              "allOf": [
                {
                  "$ref": "#/components/schemas/IndexDefinition"
                }
              ]
            }
          }
        }
      },
      "ConstraintDefinition": {
        "type": "object",
        "description": "Defines a constraint across the properties you include.\n\n\nYou can use constraints to enforce that;\n * Certain properties must be present,\n * A value must be unique across a single or several properties.\n\nA 'uniqueness' constraint can only apply to properties that are in the same container. Up to 10 'uniqueness' constraints can be added per container. \n\n\nA 'requires' constraint can reference other containers. As a result, the properties in those other containers must then also be set. Up to 25 'requires' constraints can be added per container. ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/RequiresConstraintDefinition"
          },
          {
            "$ref": "#/components/schemas/UniquenessConstraintDefinition"
          }
        ]
      },
      "UniquenessConstraintDefinition": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "constraintType": {
            "type": "string",
            "enum": [
              "uniqueness"
            ],
            "default": "uniqueness"
          },
          "properties": {
            "type": "array",
            "description": "List of properties included in the constraint. The order you list the properties in is significant.",
            "items": {
              "type": "string"
            }
          },
          "bySpace": {
            "type": "boolean",
            "description": "Whether to make the constraint space-specific",
            "default": false
          }
        }
      },
      "RequiresConstraintDefinition": {
        "type": "object",
        "required": [
          "require"
        ],
        "properties": {
          "constraintType": {
            "type": "string",
            "enum": [
              "requires"
            ],
            "default": "requires"
          },
          "require": {
            "$ref": "#/components/schemas/ContainerReference"
          }
        }
      },
      "IndexDefinition": {
        "type": "object",
        "description": "You can optimize query performance by defining an index to apply to a container.  You can only create an index across properties belonging to the same container.\n\n\nOrdering of the properties included in the index definition list is significant.  The order should match the queries you expect. The properties of an index cannot be updated after creation. If you need to change the index, it must be recreated.\n\n\nIndexes have different requirements for the different property data types.  As a result, the create index operation will fail if you specify an invalid combination.\n\n\nUp to 10 indexes can be added on a container.' ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/BtreeIndex"
          },
          {
            "$ref": "#/components/schemas/InvertedIndex"
          }
        ]
      },
      "BtreeIndex": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "description": "List of properties to define the index across",
            "items": {
              "type": "string"
            }
          },
          "indexType": {
            "type": "string",
            "enum": [
              "btree"
            ],
            "default": "btree",
            "description": "The B-tree index supports the following operations;\n\n * less than,\n * less than or equal,\n * equality (is equal),\n * larger than or equal, and\n * larger than.\n\n\nBy enabling the index to be cursorable, you can use it to efficiently query with custom sort options, and queries will emit cursors that can be used to paginate through the results. "
          },
          "cursorable": {
            "type": "boolean",
            "description": "Whether the index can be used for cursor-based pagination",
            "default": false
          },
          "bySpace": {
            "type": "boolean",
            "description": "Whether to make the index space-specific",
            "default": false
          }
        }
      },
      "InvertedIndex": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "description": "List of properties to define the index across",
            "items": {
              "type": "string"
            }
          },
          "indexType": {
            "type": "string",
            "enum": [
              "inverted"
            ],
            "default": "inverted",
            "description": "An inverted index can be used to index composite values, and the queries to be handled by the index need to search for element values that appear within the composite items. So if for example you have a property X of type `int[]` and you want to efficiently query for all instances where X contains some value Y, you can create an inverted index on X. "
          }
        }
      },
      "ViewPropertyDefinition": {
        "description": "Property definition",
        "allOf": [
          {
            "$ref": "#/components/schemas/ViewCorePropertyDefinition"
          },
          {
            "type": "object",
            "required": [
              "container",
              "containerPropertyIdentifier"
            ],
            "properties": {
              "name": {
                "type": "string",
                "description": "Readable property name.",
                "maxLength": 255
              },
              "description": {
                "type": "string",
                "description": "Description of the content and suggested use for this property.",
                "maxLength": 1024
              },
              "container": {
                "$ref": "#/components/schemas/ContainerReference"
              },
              "containerPropertyIdentifier": {
                "description": "The unique identifier for the mapped property in the referenced container.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DMSExternalId"
                  }
                ]
              }
            }
          }
        ]
      },
      "ContainerPropertyDefinition": {
        "description": "Defines a property of a container.  You can reference this property in views.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ContainerCorePropertyDefinition"
          }
        ]
      },
      "TypePropertyDefinition": {
        "description": "Describes the type and configuration of a property included in the result.",
        "allOf": [
          {
            "$ref": "#/components/schemas/ViewCorePropertyDefinition"
          }
        ]
      },
      "ViewCorePropertyDefinition": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CorePropertyDefinition"
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "description": "The type of data you can store in this property. Most properties can also hold a list of values, for example, a list of integers or a list of timestamps. The supported storage types are:\n\n\n* text (allows user control of collation),\n * boolean,\n * 32-bit, and 64-bit float,\n * 32-bit, and 64-bit integer,\n * timestamp,\n * date,\n * JSON fragment,\n * direct relation to an existing node,\n * time series external-id reference,\n * file external-id reference,\n * sequence external-id reference,\n * enum (list of enums is not supported).\n\n\nThe JSON fragments have to be valid JSON objects. If JSON arrays are to be stored, these must be wrapped in a JSON object. JSON values (such as string, number, boolean) should use their respective primitive form instead. The maximum allowed size for a JSON object is 40960 bytes. For lists of json values, the size of the entire list must be within this limit. The maximum allowed length of a key is 128, while the maximum allowed size of a value is 10240 bytes and you can have up to 256 key-value pairs. The  byte sizes are computed by representing the data as a UTF-8 encoded JSON string.\nDirect relations use a space external-id, the external-id for an existing node, and the external-id for the data container. E.g. ```s-spaceExternalId.uniqueNodeExternalId.containerExternalId```. The ```view``` property on direct relation can optionally be set, and if it is set then this is a hint to the client on what kind of data is expected to exist.\nTimestamps must be a string in the format 'YYYY-MM-DDTHH:MM:SS[.millis][Z|time zone]' with optional milliseconds having precision of 1-3 decimal digits and optional timezone with format HH:MM, HHMM, HH or Z, where Z represents UTC, Year must be between 0001 and 9999.\nDates must be a date string in the format 'YYYY-MM-DD'. Year must be between 1 and 9999. ",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TextProperty"
                  },
                  {
                    "$ref": "#/components/schemas/PrimitiveProperty"
                  },
                  {
                    "$ref": "#/components/schemas/CDFExternalIdReference"
                  },
                  {
                    "$ref": "#/components/schemas/ViewDirectNodeRelation"
                  }
                ]
              }
            }
          }
        ]
      },
      "ContainerCorePropertyDefinition": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CorePropertyDefinition"
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "description": "The type of data you can store in this property. Most properties can also hold a list of values, for example, a list of integers or a list of timestamps. The supported storage types are:\n\n\n* text (allows user control of collation),\n * boolean,\n * 32-bit, and 64-bit float,\n * 32-bit, and 64-bit integer,\n * timestamp,\n * date,\n * JSON fragment,\n * direct relation to an existing node,\n * time series external-id reference,\n * file external-id reference,\n * sequence external-id reference,\n * enum (list of enums is not supported).\n\n\nThe JSON fragments have to be valid JSON objects. If JSON arrays are to be stored, these must be wrapped in a JSON object. JSON values (such as string, number, boolean) should use their respective primitive form instead. The maximum allowed size for a JSON object is 40960 bytes. For lists of json values, the size of the entire list must be within this limit. The maximum allowed length of a key is 128, while the maximum allowed size of a value is 10240 bytes and you can have up to 256 key-value pairs. The  byte sizes are computed by representing the data as a UTF-8 encoded JSON string.\nDirect relations use a space external-id, the external-id for an existing node, and the external-id for the data container. E.g. ```s-spaceExternalId.uniqueNodeExternalId.containerExternalId```\nTimestamps must be a string in the format 'YYYY-MM-DDTHH:MM:SS[.millis][Z|time zone]' with optional milliseconds having precision of 1-3 decimal digits and optional timezone with format HH:MM, HHMM, HH or Z, where Z represents UTC, Year must be between 0001 and 9999.\nDates must be a date string in the format 'YYYY-MM-DD'. Year must be between 1 and 9999. ",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/TextProperty"
                  },
                  {
                    "$ref": "#/components/schemas/PrimitiveProperty"
                  },
                  {
                    "$ref": "#/components/schemas/CDFExternalIdReference"
                  },
                  {
                    "$ref": "#/components/schemas/DirectNodeRelation"
                  },
                  {
                    "$ref": "#/components/schemas/EnumProperty"
                  }
                ]
              }
            }
          }
        ]
      },
      "CorePropertyDefinition": {
        "type": "object",
        "properties": {
          "immutable": {
            "type": "boolean",
            "description": "Should updates to this property be rejected after the initial population?",
            "default": false
          },
          "nullable": {
            "type": "boolean",
            "description": "Does this property need to be set to a value, or not?",
            "default": true
          },
          "autoIncrement": {
            "type": "boolean",
            "description": "When set to ```true```, the API will increment the property based on its highest current value (max value).  You can only use this functionality to increment properties of type `int32` or `int64`. If the property has a different data type, the API will return an error.",
            "default": false
          },
          "defaultValue": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "type": "object"
              }
            ],
            "description": "Default value to use when you do not specify a value for the property.  The default value must be of the same type as what you defined for the property itself. \n\n\nWe do not currently support using default values for array/list types. "
          },
          "description": {
            "type": "string",
            "description": "Description of the content and suggested use for this property.",
            "maxLength": 1024
          },
          "name": {
            "type": "string",
            "description": "Readable property name.",
            "maxLength": 255
          }
        }
      },
      "IncludeTyping": {
        "type": "boolean",
        "description": "Should we return property type information as part of the result?",
        "default": false
      },
      "RawPropertyValueV3": {
        "title": "raw value",
        "description": "A value matching the data type of the defined property",
        "oneOf": [
          {
            "type": "string",
            "title": "string",
            "description": "A string value without `null` characters and 128KB maximum size.\nOr a date string in the format `YYYY-MM-DD`.\nOr a timestamp string in the format: `YYYY-MM-DDTHH:MM:SS[.millis][Z|time zone]`.\n",
            "maxLength": 128000
          },
          {
            "type": "number",
            "title": "number",
            "description": "A number value matching the data type (integer(32/64), float, doable, etc) of the defined property."
          },
          {
            "type": "boolean",
            "title": "boolean",
            "description": "A boolean value - `true` or `false`."
          },
          {
            "type": "object",
            "title": "object",
            "description": "A JSON value. General limits for the JSON object are the next. The max key length is 128. The max number of keys 256. The max object total size is 40,960B. The max value size is 10,240B."
          },
          {
            "type": "object",
            "title": "direct relation",
            "description": "A JSON value matching the direct relation type. Direct relation json object requires and allows only `space` and `externalId` attributes of the related instance."
          },
          {
            "type": "array",
            "title": "array of strings",
            "description": "An array of string values without `null` characters in each item and sum of individual elements is no more than 128KB.\nEach item can be a date string in the format `YYYY-MM-DD` or a timestamp string in the format: `YYYY-MM-DDTHH:MM:SS[.millis][Z|time zone]`.\n",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "string"
            }
          },
          {
            "type": "array",
            "title": "array of booleans",
            "description": "An array of boolean values.",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "boolean"
            }
          },
          {
            "type": "array",
            "title": "array of numbers",
            "description": "An array of number values.",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "number"
            }
          },
          {
            "type": "array",
            "title": "array of direct relations",
            "description": "An array of direct relations.",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object"
            }
          },
          {
            "type": "array",
            "title": "array of objects",
            "description": "An array of JSON objects. General limits for the JSON array are the next. The max JSON total size is 40,960B. Other JSON objects constraints are applicable to each item in the array (see object).",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object"
            }
          }
        ]
      },
      "RawPropertyValueListV3": {
        "description": "A list of values",
        "type": "array",
        "items": {
          "description": "A value describing the type of the defined property",
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "type": "boolean"
            },
            {
              "type": "object"
            }
          ]
        }
      },
      "ParameterizedPropertyValueV3": {
        "title": "parameter",
        "description": "A parameterized value",
        "type": "object",
        "required": [
          "parameter"
        ],
        "properties": {
          "parameter": {
            "type": "string"
          }
        }
      },
      "ReferencedPropertyValueV3": {
        "title": "property reference",
        "description": "A property reference value",
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minItems": 2,
            "maxItems": 4
          }
        }
      },
      "PropertyValueGroupV3": {
        "type": "object",
        "description": "Group of property values indexed by a local unique identifier. The identifier has to have a length of between 1 and 255 characters.  It must also match the pattern ```^[a-zA-Z0-9][a-zA-Z0-9_-]{0,253}[a-zA-Z0-9]?$``` , and it cannot be any of the following reserved identifiers: ```space```, ```externalId```, ```createdTime```, ```lastUpdatedTime```, ```deletedTime```, and ```extensions```. The maximum number of properties depends on your subscription, and is by default 100.",
        "minProperties": 1,
        "additionalProperties": {
          "x-additionalPropertiesName": "property-identifier",
          "allOf": [
            {
              "$ref": "#/components/schemas/RawPropertyValueV3"
            }
          ]
        },
        "example": {
          "someStringProperty": "someStringValue",
          "someDirectRelation": {
            "space": "mySpace",
            "externalId": "someNode"
          },
          "someIntArrayProperty": [
            1,
            2,
            3,
            4
          ]
        }
      },
      "NodeDefinition": {
        "type": "object",
        "description": "Node",
        "required": [
          "instanceType",
          "space",
          "externalId",
          "createdTime",
          "lastUpdatedTime",
          "version"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "enum": [
              "node"
            ]
          },
          "version": {
            "description": "Current version of the node",
            "type": "integer"
          },
          "space": {
            "description": "Id of the space that the node belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "Unique identifier for the node",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "type": {
            "description": "Node type",
            "allOf": [
              {
                "$ref": "#/components/schemas/DirectRelationReference"
              }
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "deletedTime": {
            "description": "Timestamp when the node was soft deleted. Note that deleted nodes are filtered out of query results, but present in sync results. This means that this value will only be present in sync results.",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "properties": {
            "type": "object",
            "description": "Spaces for the requested view and its containers",
            "additionalProperties": {
              "x-additionalPropertiesName": "space-name",
              "allOf": [
                {
                  "$ref": "#/components/schemas/ViewOrContainer"
                }
              ]
            }
          }
        }
      },
      "SlimNodeDefinition": {
        "type": "object",
        "description": "Node",
        "required": [
          "instanceType",
          "space",
          "externalId",
          "wasModified",
          "version",
          "createdTime",
          "lastUpdatedTime"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "enum": [
              "node"
            ]
          },
          "version": {
            "description": "Current version of the node",
            "type": "integer"
          },
          "wasModified": {
            "description": "Whether or not the node was modified by this ingestion. We only update the nodes if the input differs from the existing state.",
            "type": "boolean"
          },
          "space": {
            "description": "Id of the space that the node belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "Unique identifier for the node",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "NodeWrite": {
        "description": "Node to create or update",
        "type": "object",
        "required": [
          "instanceType",
          "space",
          "externalId"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "enum": [
              "node"
            ],
            "default": "node"
          },
          "existingVersion": {
            "description": "Fail the ingestion request if the node's version is greater than this value. If no existingVersion is specified, the ingestion will always overwrite any existing data for the node (for the specified container or view). If existingVersion is set to 0, the upsert will behave as an insert, so it will fail the bulk if the item already exists. If skipOnVersionConflict is set on the ingestion request, then the item will be skipped instead of failing the ingestion request.",
            "type": "integer"
          },
          "space": {
            "description": "Id of the space that the node belongs to. This space-id cannot be updated.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "Unique identifier for the node",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "type": {
            "description": "Node type (direct relation)",
            "allOf": [
              {
                "$ref": "#/components/schemas/DirectRelationReference"
              }
            ]
          },
          "sources": {
            "type": "array",
            "description": "List of source properties to write. The properties are from the view and/or the container(s) making up this node.",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/EdgeOrNodeData"
            }
          }
        }
      },
      "EdgeOrNodeData": {
        "type": "object",
        "description": "Property values for the identified/specified view or container",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/SourceReference"
          },
          "properties": {
            "$ref": "#/components/schemas/PropertyValueGroupV3"
          }
        },
        "required": [
          "source"
        ]
      },
      "EdgeDefinition": {
        "type": "object",
        "description": "Edge",
        "required": [
          "instanceType",
          "type",
          "space",
          "externalId",
          "createdTime",
          "lastUpdatedTime",
          "startNode",
          "endNode",
          "version"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "enum": [
              "edge"
            ]
          },
          "version": {
            "description": "Current version of the edge",
            "type": "integer"
          },
          "type": {
            "description": "Edge type",
            "allOf": [
              {
                "$ref": "#/components/schemas/DirectRelationReference"
              }
            ]
          },
          "space": {
            "description": "Id of the space the edge belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "Unique identifier for the edge. Can also be a null character.",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "deletedTime": {
            "description": "Timestamp when the edge was soft deleted. Note that deleted edges are filtered out of query results, but present in sync results. This means that this value will only be present in sync results.",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "properties": {
            "type": "object",
            "description": "Spaces for the requested view and its containers",
            "additionalProperties": {
              "$ref": "#/components/schemas/ViewOrContainer"
            }
          },
          "startNode": {
            "$ref": "#/components/schemas/DirectRelationReference"
          },
          "endNode": {
            "$ref": "#/components/schemas/DirectRelationReference"
          }
        }
      },
      "SlimEdgeDefinition": {
        "type": "object",
        "description": "Edge",
        "required": [
          "instanceType",
          "space",
          "externalId",
          "wasModified",
          "version",
          "createdTime",
          "lastUpdatedTime"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "enum": [
              "edge"
            ]
          },
          "version": {
            "description": "Current version of the edge",
            "type": "integer"
          },
          "wasModified": {
            "description": "Whether or not the edge was modified by this ingestion. We only update the edges if the input differs from the existing state.",
            "type": "boolean"
          },
          "space": {
            "description": "Id of the space that the edge belongs to",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "Unique alphanumeric identifier for the edge",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "EdgeWrite": {
        "description": "Edge to create or update",
        "type": "object",
        "required": [
          "instanceType",
          "space",
          "externalId",
          "startNode",
          "endNode",
          "type"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "enum": [
              "edge"
            ],
            "default": "edge"
          },
          "existingVersion": {
            "description": "Fail the ingestion request if the edge's version is greater than this value. If no existingVersion is specified, the ingestion will always overwrite any existing data for the edge (for the specified container or view). If existingVersion is set to 0, the upsert will behave as an insert, so it will fail the bulk if the item already exists. If skipOnVersionConflict is set on the ingestion request, then the item will be skipped instead of failing the ingestion request.",
            "type": "integer"
          },
          "type": {
            "description": "Edge type (direct relation)",
            "allOf": [
              {
                "$ref": "#/components/schemas/DirectRelationReference"
              }
            ]
          },
          "space": {
            "description": "Id of the space that the edge belongs to. This id cannot be updated.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "description": "Unique alphanumeric identifier for the edge",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "startNode": {
            "$ref": "#/components/schemas/DirectRelationReference"
          },
          "endNode": {
            "$ref": "#/components/schemas/DirectRelationReference"
          },
          "sources": {
            "type": "array",
            "description": "Properties to write to in a view or container, for the edge.",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/EdgeOrNodeData"
            }
          }
        }
      },
      "FilterDefinition": {
        "type": "object",
        "description": "A filter Domain Specific Language (DSL) used to create advanced filter queries.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DataModelsBoolFilter"
          },
          {
            "$ref": "#/components/schemas/DataModelsLeafFilter"
          }
        ],
        "example": {
          "and": [
            {
              "in": {
                "property": [
                  "tag"
                ],
                "values": [
                  10011,
                  10011
                ]
              }
            },
            {
              "range": {
                "property": [
                  "weight"
                ],
                "gte": 0
              }
            }
          ]
        }
      },
      "TableExpressionFilterDefinition": {
        "type": "object",
        "description": "A filter Domain Specific Language (DSL) used to create advanced filter queries.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TableExpressionDataModelsBoolFilter"
          },
          {
            "$ref": "#/components/schemas/TableExpressionLeafFilter"
          }
        ],
        "example": {
          "and": [
            {
              "in": {
                "property": [
                  "tag"
                ],
                "values": [
                  10011,
                  10011
                ]
              }
            },
            {
              "range": {
                "property": [
                  "weight"
                ],
                "gte": 0
              }
            }
          ]
        }
      },
      "TableExpressionChainToDefinition": {
        "type": "string",
        "default": "destination",
        "enum": [
          "source",
          "destination"
        ],
        "description": "Default: `\"destination\"`. Applicable when `from` is an edge result expression. Control which side of the edges in `from` to chain to. The behavior depends on the `direction` setting in the `from` result expression:\n  - If `from` follows edges outwards, `direction=\"outwards\"` (default), then `\"source\"` selects `startNode` and `\"destination\"` selects `endNode`.\n  - If `from` follows edges inwards, `direction=\"inwards\"`, then `\"source\"` selects `endNode` and `\"destination\"` selects `startNode`."
      },
      "DataModelsBoolFilter": {
        "title": "BoolFilter",
        "description": "Build a new query by combining other queries, using boolean operators. We support the `and`, `or`, and\n`not` boolean operators.\n",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All the sub-clauses in the query must return a matching item.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/FilterDefinition"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "One or more of the sub-clauses in the query must return a matching item.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/FilterDefinition"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "None of the sub-clauses in the query can return a matching item.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterDefinition"
                  }
                ]
              }
            }
          }
        ]
      },
      "TableExpressionDataModelsBoolFilter": {
        "title": "BoolFilter",
        "description": "Build a new query by combining other queries, using boolean operators. We support the `and`, `or`, and\n`not` boolean operators.\n",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All the sub-clauses in the query must return a matching item.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/TableExpressionFilterDefinition"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "One or more of the sub-clauses in the query must return a matching item.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/TableExpressionFilterDefinition"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "None of the sub-clauses in the query can return a matching item.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TableExpressionFilterDefinition"
                  }
                ]
              }
            }
          }
        ]
      },
      "DataModelsLeafFilter": {
        "description": "Leaf filter",
        "title": "LeafFilter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EqualsFilterV3"
          },
          {
            "$ref": "#/components/schemas/InFilterV3"
          },
          {
            "$ref": "#/components/schemas/RangeFilterV3"
          },
          {
            "$ref": "#/components/schemas/PrefixFilterV3"
          },
          {
            "$ref": "#/components/schemas/DMSExistsFilter"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyFilterV3"
          },
          {
            "$ref": "#/components/schemas/ContainsAllFilterV3"
          },
          {
            "$ref": "#/components/schemas/MatchAllFilter"
          },
          {
            "$ref": "#/components/schemas/DataModelsNestedFilter"
          },
          {
            "$ref": "#/components/schemas/OverlapsFilterV3"
          },
          {
            "$ref": "#/components/schemas/HasExistingDataFilterV3"
          },
          {
            "$ref": "#/components/schemas/InstanceReferenceFilterV3"
          }
        ]
      },
      "TableExpressionLeafFilter": {
        "description": "Leaf filter",
        "title": "LeafFilter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TableExpressionEqualsFilterV3"
          },
          {
            "$ref": "#/components/schemas/TableExpressionInFilterV3"
          },
          {
            "$ref": "#/components/schemas/TableExpressionRangeFilterV3"
          },
          {
            "$ref": "#/components/schemas/TableExpressionPrefixFilterV3"
          },
          {
            "$ref": "#/components/schemas/DMSExistsFilter"
          },
          {
            "$ref": "#/components/schemas/TableExpressionContainsAnyFilterV3"
          },
          {
            "$ref": "#/components/schemas/TableExpressionContainsAllFilterV3"
          },
          {
            "$ref": "#/components/schemas/MatchAllFilter"
          },
          {
            "$ref": "#/components/schemas/DataModelsNestedFilter"
          },
          {
            "$ref": "#/components/schemas/TableExpressionOverlapsFilterV3"
          },
          {
            "$ref": "#/components/schemas/HasExistingDataFilterV3"
          },
          {
            "$ref": "#/components/schemas/InstanceReferenceFilterV3"
          }
        ]
      },
      "NodeOrEdgeDeleteRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "required": [
                "instanceType",
                "space",
                "externalId"
              ],
              "properties": {
                "instanceType": {
                  "description": "Is the item to delete a node, or an edge",
                  "type": "string",
                  "enum": [
                    "node",
                    "edge"
                  ]
                },
                "externalId": {
                  "description": "External id for the node or edge (item) you want to delete.",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/NodeOrEdgeExternalId"
                    }
                  ]
                },
                "space": {
                  "description": "Space that the described node or edge (item) belongs to.",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SpaceSpecification"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "NodeOrEdgeListRequestV3": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "includeTyping": {
                "$ref": "#/components/schemas/IncludeTyping"
              },
              "sources": {
                "$ref": "#/components/schemas/SourceSelectorWithoutPropertiesV3"
              },
              "instanceType": {
                "description": "The type of instance you are querying for; an edge or a node.  If the instance type isn't specified, we list nodes. When instanceType is `edge`, `property` can refer to any container and is defined as [\"edge\", \"type\"], and `value` contains the value of the property.\n\n  <u>Example:</u>\n\n  ```\n  {\n      includeTyping: true,\n      instanceType: \"edge\",\n      filter: {\n                  equals: {\n                      \"property\": [\n                        \"edge\",\n                        \"type\" // VALID VALUES:[space, externalId, createdTime, lastUpdatedTime, startNode, endNode, type ]\n                      ],\n                      \"value\": {\n                      \"space\": \"apm_simple\",\n                      \"externalId\": \"WMT:23-FO-96187\"\n                      }\n                    }\n                }\n  }\n  ```",
                "default": "node",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InstanceType"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/LimitWithDefault1000"
          },
          {
            "$ref": "#/components/schemas/SortV3"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/FilterDefinition"
              }
            }
          }
        ]
      },
      "DataModelsListRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/ReducedLimit"
          },
          {
            "type": "object",
            "properties": {
              "spaces": {
                "type": "array",
                "description": "List of spaces you want to use to limit the returned matches by",
                "items": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                }
              },
              "allVersions": {
                "$ref": "#/components/schemas/AllVersionsFlag"
              },
              "includeGlobal": {
                "$ref": "#/components/schemas/IncludeGlobalFlag"
              }
            }
          }
        ]
      },
      "DataModelsSort": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "description": "The property we should base sorting on when we return ordered data",
            "type": "string",
            "enum": [
              "space",
              "externalId",
              "name",
              "description",
              "version",
              "createdTime",
              "lastUpdatedTime"
            ]
          },
          "direction": {
            "description": "The sort order for the returned information",
            "type": "string",
            "default": "ascending",
            "enum": [
              "ascending",
              "descending"
            ]
          },
          "nullsFirst": {
            "description": "Should we list nulls first, or last (default) in the returned dataset",
            "type": "boolean",
            "default": false
          }
        }
      },
      "QueryRequest": {
        "type": "object",
        "required": [
          "with",
          "select"
        ],
        "properties": {
          "with": {
            "type": "object",
            "minProperties": 1,
            "maxProperties": 50,
            "additionalProperties": {
              "x-additionalPropertiesName": "result-expression-name",
              "allOf": [
                {
                  "$ref": "#/components/schemas/QueryTableExpressionV3"
                }
              ]
            }
          },
          "cursors": {
            "description": "Cursors returned from the previous query request. These cursors match the result set expressions you specified in the ```with``` clause for the query.",
            "type": "object",
            "maxProperties": 50,
            "additionalProperties": {
              "x-additionalPropertiesName": "pagination cursor reference",
              "allOf": [
                {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              ]
            }
          },
          "select": {
            "type": "object",
            "description": "Select properties for each result set.",
            "minProperties": 1,
            "maxProperties": 50,
            "additionalProperties": {
              "x-additionalPropertiesName": "result-expression-name",
              "allOf": [
                {
                  "$ref": "#/components/schemas/QuerySelectV3"
                }
              ]
            }
          },
          "parameters": {
            "type": "object",
            "description": "Values in filters can be parameterised. Parameters are provided as part of the query object, and referenced in the filter itself.",
            "additionalProperties": {
              "x-additionalPropertiesName": "parameter-identifier",
              "allOf": [
                {
                  "$ref": "#/components/schemas/RawPropertyValueV3"
                }
              ]
            }
          },
          "includeTyping": {
            "$ref": "#/components/schemas/IncludeTyping"
          }
        }
      },
      "SyncRequest": {
        "type": "object",
        "required": [
          "with",
          "select"
        ],
        "properties": {
          "with": {
            "type": "object",
            "minProperties": 1,
            "maxProperties": 50,
            "additionalProperties": {
              "$ref": "#/components/schemas/SyncTableExpressionV3"
            }
          },
          "cursors": {
            "description": "Cursors returned from the previous sync request. These cursors match the result set expressions you specified in the ```with``` clause for the sync.",
            "type": "object",
            "maxProperties": 50,
            "additionalProperties": {
              "x-additionalPropertiesName": "sync cursor reference",
              "allOf": [
                {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              ]
            }
          },
          "select": {
            "minProperties": 1,
            "maxProperties": 50,
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SyncSelectV3"
            }
          },
          "parameters": {
            "type": "object",
            "description": "Parameters to return",
            "additionalProperties": {
              "x-additionalPropertiesName": "parameter-identifier",
              "allOf": [
                {
                  "$ref": "#/components/schemas/RawPropertyValueV3"
                }
              ]
            }
          },
          "includeTyping": {
            "$ref": "#/components/schemas/IncludeTyping"
          }
        }
      },
      "AggregationRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CommonAggregationRequest"
          },
          {
            "type": "object",
            "required": [
              "view"
            ],
            "properties": {
              "instanceType": {
                "$ref": "#/components/schemas/InstanceType"
              },
              "view": {
                "$ref": "#/components/schemas/ViewReference"
              },
              "targetUnits": {
                "$ref": "#/components/schemas/TargetUnits"
              },
              "includeTyping": {
                "$ref": "#/components/schemas/IncludeTyping"
              }
            }
          }
        ]
      },
      "AggregationRequestV2": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CommonAggregationRequestV2"
          },
          {
            "type": "object",
            "required": [
              "view"
            ],
            "properties": {
              "view": {
                "$ref": "#/components/schemas/ViewReference"
              },
              "targetUnits": {
                "$ref": "#/components/schemas/TargetUnits"
              },
              "includeTyping": {
                "$ref": "#/components/schemas/IncludeTyping"
              }
            }
          }
        ]
      },
      "CommonAggregationRequest": {
        "description": "Defines an aggregation request. This will let you group, and aggregate supported data types. The request supports filters, and allows optional search matching.",
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Optional query string.  The API will parse the query string, and use it to match the text properties on elements to use for the aggregate(s)."
          },
          "properties": {
            "type": "array",
            "minItems": 1,
            "maxItems": 200,
            "description": "Optional list (array) of properties you want to apply the query above to. If you do not list any properties, you search through text fields by default.",
            "items": {
              "type": "string"
            }
          },
          "limit": {
            "type": "integer",
            "description": "Limit the number of results returned. The default limit is currently at 100 items.",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          },
          "aggregates": {
            "type": "array",
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/AggregationDefinition"
            }
          },
          "groupBy": {
            "type": "array",
            "description": "The selection of fields to group the results by when doing aggregations. You can specify up to 5 items\nto group by.\n\nWhen you do not specify any aggregates, the fields listed in the `groupBy` clause will return the unique\nvalues stored for each field. The property types supported for `groupBy` are `text`, `direct`, `int32`, `int64`, `float32`, `float64`, `boolean`, and `enum`.\n",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "type": "string"
            }
          },
          "filter": {
            "$ref": "#/components/schemas/FilterDefinition"
          }
        }
      },
      "CommonAggregationRequestV2": {
        "description": "Defines an aggregation request. This will let you aggregate supported data types. The request supports filters, and allows optional search matching.",
        "type": "object",
        "required": [
          "aggregates"
        ],
        "properties": {
          "query": {
            "type": "string",
            "description": "Optional query string. The API will parse the query string, and use it to match the text properties on elements to use for the aggregate(s)."
          },
          "properties": {
            "type": "array",
            "minItems": 1,
            "maxItems": 200,
            "description": "Optional list (array) of properties you want to apply the query above to. If you do not list any properties, you search through text fields by default.",
            "items": {
              "type": "string"
            }
          },
          "aggregates": {
            "$ref": "#/components/schemas/AggregatesDefinition"
          },
          "filter": {
            "$ref": "#/components/schemas/FilterDefinition"
          }
        }
      },
      "AggregatesDefinition": {
        "type": "object",
        "title": "aggregatesDictionary",
        "description": "A dictionary of requested aggregates with client defined names/identifiers.\n\n<u>Example:</u>\n\n```\n{\n  \"my_aggr_1\": {\n    \"min\": {\"property\": [\"room\", \"size\"]}\n  },\n  \"my_aggr_2\": {\n    \"max\": {\"property\": [\"room\", \"size\"]}\n  },\n}\n```",
        "minProperties": 1,
        "maxProperties": 5,
        "uniqueItems": true,
        "additionalProperties": {
          "x-additionalPropertiesName": "aggregate-id",
          "title": "aggregateDictionary",
          "type": "object",
          "description": "An aggregate. It's an aggregate identifier which map to an aggregator function, and some fields to use for the aggregator function.\nThe identifiers should match the next constraints:\n  pattern: \"^[A-Za-z_][A-Za-z0-9_]*$\"\n  maxLength: 1000\n  minLength: 1",
          "oneOf": [
            {
              "$ref": "#/components/schemas/AvgAggregate"
            },
            {
              "$ref": "#/components/schemas/CountAggregate"
            },
            {
              "$ref": "#/components/schemas/MinAggregate"
            },
            {
              "$ref": "#/components/schemas/MaxAggregate"
            },
            {
              "$ref": "#/components/schemas/SumAggregate"
            },
            {
              "$ref": "#/components/schemas/UniqueValuesAggregate"
            },
            {
              "$ref": "#/components/schemas/NumberHistogramAggregate"
            }
          ]
        },
        "propertyNames": {
          "pattern": "^[A-Za-z_][A-Za-z0-9_]*$",
          "maxLength": 1000,
          "minLength": 1
        },
        "example": {
          "my_avg_aggregate1": {
            "avg": {
              "property": [
                "mySpace",
                "myContainer",
                "manufacturer"
              ]
            }
          },
          "my_terms_aggregate2": {
            "uniqueValues": {
              "property": [
                "mySpace",
                "myContainer",
                "manufacturer"
              ],
              "aggregates": {
                "my_sub_aggregate1": {
                  "min": {
                    "property": [
                      "mySpace",
                      "myContainer",
                      "price"
                    ]
                  }
                },
                "my_sub_aggregate2": {
                  "max": {
                    "property": [
                      "mySpace",
                      "myContainer",
                      "price"
                    ]
                  }
                },
                "my_sub_aggregate3": {
                  "uniqueValues": {
                    "property": [
                      "mySpace",
                      "myContainer",
                      "region"
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "AvgAggregate": {
        "type": "object",
        "title": "avg",
        "required": [
          "avg"
        ],
        "properties": {
          "avg": {
            "type": "object",
            "description": "Calculates the average from the data stored by the specified property. This aggregation uses an average mean calculation, and not an integral mean.",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "CountAggregate": {
        "title": "count",
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "object",
            "description": "Counts the number of items. When you specify a property, it returns the number of non-null values for that property.",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "MinAggregate": {
        "type": "object",
        "title": "min",
        "required": [
          "min"
        ],
        "properties": {
          "min": {
            "type": "object",
            "description": "The function will calculate, and return, the lowest - min - value for a property.",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "MaxAggregate": {
        "type": "object",
        "title": "max",
        "required": [
          "max"
        ],
        "properties": {
          "max": {
            "type": "object",
            "description": "The function will calculate, and return, the highest - max - value for the property.",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "SumAggregate": {
        "type": "object",
        "title": "sum",
        "required": [
          "sum"
        ],
        "properties": {
          "sum": {
            "type": "object",
            "description": "Calculates the sum from the values of the specified property.",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "UniqueValuesAggregate": {
        "type": "object",
        "title": "uniqueValues",
        "required": [
          "uniqueValues"
        ],
        "properties": {
          "uniqueValues": {
            "type": "object",
            "description": "Request unique value buckets aggregate on of the specified property.\nEach bucket is defined by `values` array and has the number of the `values` occurrences.",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              },
              "aggregates": {
                "$ref": "#/components/schemas/AggregatesDefinition"
              },
              "size": {
                "type": "integer",
                "description": "The number of top buckets returned. The default limit is 10 items.",
                "minimum": 1,
                "maximum": 2000,
                "default": 10
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "NumberHistogramAggregate": {
        "type": "object",
        "title": "numberHistogram",
        "required": [
          "numberHistogram"
        ],
        "properties": {
          "numberHistogram": {
            "type": "object",
            "description": "A histogram aggregator function. This function will generate a histogram from the values of the specified\nproperty. It uses the specified interval as defined in your `interval` argument.",
            "required": [
              "property",
              "interval"
            ],
            "properties": {
              "interval": {
                "type": "number",
                "description": "The interval between each bucket."
              },
              "property": {
                "$ref": "#/components/schemas/AggregatePropertyDms"
              },
              "aggregates": {
                "$ref": "#/components/schemas/AggregatesDefinition"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "AggregatePropertyDms": {
        "title": "property",
        "description": "Property you want to aggregate. Use a list of strings to specify nested properties.\n\n<u>Example:</u>\n\nYou have the object\n```\n{\n  \"room\": {\n    \"id\": \"b53\"\n  },\n  \"roomId\": \"a23\"\n}\n```\n\nUse `[\"room\", \"id\"]` to return the value in the nested `id` property, which is a part of the `room` object.\n\nYou can also read the value(s) in the standalone property `roomId` with `[\"roomId\"]`.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 3,
        "items": {
          "type": "string",
          "minLength": 1,
          "maxLength": 1000
        },
        "example": [
          "room",
          "id"
        ]
      },
      "AggregatesResultDefinition": {
        "type": "object",
        "title": "aggregatesResultDictionary",
        "description": "A dictionary of the results for the requested aggregates mapped by the aggregates identifiers.\n\n<u>Example:</u>\n\n```\n{\n  \"my_aggr_1\": {\n    \"avg\": 42\n  },\n  \"my_aggr_2\": {\n    \"max\": 69\n  },\n}\n```",
        "additionalProperties": {
          "x-additionalPropertiesName": "aggregate-id",
          "type": "object",
          "title": "aggregateResultDictionary",
          "description": "Requested aggregate result. It's the aggregate identifier from the request and a set of fields to represent aggregated data.",
          "oneOf": [
            {
              "$ref": "#/components/schemas/AvgAggregateResult"
            },
            {
              "$ref": "#/components/schemas/CountAggregateResultDms"
            },
            {
              "$ref": "#/components/schemas/MinAggregateResult"
            },
            {
              "$ref": "#/components/schemas/MaxAggregateResult"
            },
            {
              "$ref": "#/components/schemas/SumAggregateResult"
            },
            {
              "$ref": "#/components/schemas/UniqueValuesAggregateResult"
            },
            {
              "$ref": "#/components/schemas/NumberHistogramAggregateResult"
            }
          ]
        },
        "example": {
          "my_avg_aggregate1": {
            "avg": 42
          },
          "my_terms_aggregate2": {
            "buckets": [
              {
                "value": "Cognite",
                "count": 42,
                "aggregates": {
                  "my_sub_aggregate1": {
                    "min": 13
                  },
                  "my_sub_aggregate2": {
                    "max": 69
                  },
                  "my_sub_aggregate3": {
                    "buckets": [
                      {
                        "value": "us1",
                        "count": 42
                      },
                      {
                        "value": "ie1",
                        "count": 7
                      }
                    ]
                  }
                }
              },
              {
                "value": "AkerBP",
                "count": 21,
                "aggregates": {
                  "my_sub_aggregate1": {
                    "min": 99
                  },
                  "my_sub_aggregate2": {
                    "max": 999
                  },
                  "my_sub_aggregate3": {
                    "buckets": [
                      {
                        "value": "us1",
                        "count": 11
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      "AvgAggregateResult": {
        "type": "object",
        "title": "avgResult",
        "required": [
          "avg"
        ],
        "properties": {
          "avg": {
            "type": "number",
            "description": "The average value from the data stored by the specified in the request property.",
            "example": 42.7
          }
        }
      },
      "CountAggregateResultDms": {
        "type": "object",
        "title": "countResult",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64",
            "description": "The number of non-null values for specified in the request property.",
            "example": 42
          }
        }
      },
      "MinAggregateResult": {
        "type": "object",
        "title": "minResult",
        "required": [
          "min"
        ],
        "properties": {
          "min": {
            "type": "number",
            "description": "The lowest - min - value for the specified in the request property.",
            "example": 42.7
          }
        }
      },
      "MaxAggregateResult": {
        "type": "object",
        "title": "maxResult",
        "required": [
          "max"
        ],
        "properties": {
          "max": {
            "type": "number",
            "description": "The highest - max - value for the specified in the request property.",
            "example": 42.7
          }
        }
      },
      "SumAggregateResult": {
        "type": "object",
        "title": "sumResult",
        "required": [
          "sum"
        ],
        "properties": {
          "sum": {
            "type": "number",
            "description": "The sum from the values of the specified in the request property.",
            "example": 42.7
          }
        }
      },
      "UniqueValuesAggregateResult": {
        "type": "object",
        "title": "uniqueValuesResult",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "Unique value buckets on of the specified in the request property.",
            "items": {
              "type": "object",
              "required": [
                "count",
                "value"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The count of items with the value in the property.",
                  "example": 42
                },
                "value": {
                  "$ref": "#/components/schemas/AggregateValue"
                },
                "aggregates": {
                  "$ref": "#/components/schemas/AggregatesResultDefinition"
                }
              }
            }
          }
        }
      },
      "NumberHistogramAggregateResult": {
        "type": "object",
        "title": "numberHistogramResult",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "The histogram from the values of the specified in the request property.",
            "items": {
              "type": "object",
              "required": [
                "count",
                "intervalStart"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The count of items with the value from the bucket interval in the property.",
                  "example": 100
                },
                "intervalStart": {
                  "type": "number",
                  "description": "The number which represent the start of the bucket interval (the next bucket start point is the end point for this bucket).",
                  "example": 42.7
                },
                "aggregates": {
                  "$ref": "#/components/schemas/AggregatesResultDefinition"
                }
              }
            }
          }
        }
      },
      "AggregateValue": {
        "oneOf": [
          {
            "type": "string",
            "description": "A string which find in the provided property."
          },
          {
            "type": "number",
            "description": "A number which find in the provided property."
          },
          {
            "type": "integer",
            "format": "int64",
            "description": "An integer number which find in the provided property."
          },
          {
            "type": "boolean",
            "description": "A boolean value which find in the provided property."
          }
        ]
      },
      "AggregatedResultItemCollection": {
        "required": [
          "items",
          "properties"
        ],
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AggregatedResultItem"
            }
          }
        }
      },
      "AggregatedResultItem": {
        "type": "object",
        "required": [
          "instanceType",
          "aggregates"
        ],
        "properties": {
          "instanceType": {
            "$ref": "#/components/schemas/InstanceType"
          },
          "group": {
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                },
                {
                  "$ref": "#/components/schemas/DirectRelationReference"
                }
              ]
            },
            "example": {
              "name": "PumpName1",
              "tag": "tag01"
            }
          },
          "aggregates": {
            "type": "array",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/AggregatedValueItem"
            }
          }
        }
      },
      "AggregatedValueItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/AggregatedNumberValue"
          },
          {
            "$ref": "#/components/schemas/AggregatedHistogramValue"
          }
        ]
      },
      "AggregatedNumberValue": {
        "type": "object",
        "required": [
          "aggregate"
        ],
        "properties": {
          "aggregate": {
            "type": "string",
            "example": "avg",
            "enum": [
              "avg",
              "min",
              "max",
              "count",
              "sum"
            ]
          },
          "property": {
            "description": "The property the aggregate was calculated from",
            "type": "string",
            "example": "duration"
          },
          "value": {
            "type": "number",
            "description": "Value returned by the aggregate function",
            "example": 0.2
          }
        }
      },
      "AggregatedHistogramValue": {
        "type": "object",
        "required": [
          "aggregate",
          "interval",
          "property",
          "buckets"
        ],
        "properties": {
          "aggregate": {
            "type": "string",
            "enum": [
              "histogram"
            ]
          },
          "interval": {
            "type": "number",
            "example": 50
          },
          "property": {
            "type": "string",
            "example": "duration"
          },
          "buckets": {
            "type": "array",
            "description": "List (array) of buckets to use for histogram aggregates.",
            "items": {
              "type": "object",
              "required": [
                "start",
                "count"
              ],
              "properties": {
                "start": {
                  "description": "Start value for a histogram bucket",
                  "type": "number",
                  "example": 1050
                },
                "count": {
                  "description": "Number of items in the histogram bucket",
                  "type": "integer",
                  "example": 7
                }
              }
            }
          }
        }
      },
      "NodeOrEdgeSearchRequest": {
        "description": "Searching nodes or edges using properties from a view",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/SearchRequestV3"
          }
        ]
      },
      "SearchRequestV3": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "view"
            ],
            "properties": {
              "view": {
                "$ref": "#/components/schemas/ViewReference"
              },
              "query": {
                "type": "string",
                "description": "Query string that will be parsed and used for search."
              },
              "instanceType": {
                "description": "Limit the search query to searching nodes or edges. Unless you set the item type to apply the search to, the service will default to searching nodes within the view.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/InstanceType"
                  }
                ]
              },
              "properties": {
                "type": "array",
                "description": "Optional array of properties you want to search through.  If you do not specify one or more properties, the service will search all text fields within the view.",
                "items": {
                  "type": "string"
                }
              },
              "targetUnits": {
                "$ref": "#/components/schemas/TargetUnits"
              },
              "filter": {
                "$ref": "#/components/schemas/FilterDefinition"
              },
              "includeTyping": {
                "$ref": "#/components/schemas/IncludeTyping"
              },
              "sort": {
                "type": "array",
                "maxItems": 5,
                "items": {
                  "$ref": "#/components/schemas/SearchSort"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/LimitWithDefault1000"
          }
        ]
      },
      "ViewCreateCollection": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "List of views to create/update",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/ViewCreateDefinition"
            }
          }
        }
      },
      "ContainerCreateCollection": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "List of containers to create/update",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/ContainerCreateDefinition"
            }
          }
        }
      },
      "DataModelCreateCollection": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "List of data models to create/update",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/DataModelCreate"
            }
          }
        }
      },
      "NodeAndEdgeCreateCollection": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "List of nodes and edges to create/update",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/NodeOrEdgeCreate"
            }
          },
          "autoCreateDirectRelations": {
            "type": "boolean",
            "description": "Should we create missing target nodes of direct relations? If the target-container constraint has been specified for a direct relation, the target node cannot be auto-created. If you want to point direct relations to a space where you have only read access, this option must be set to false.",
            "default": true
          },
          "autoCreateStartNodes": {
            "type": "boolean",
            "description": "Should we create missing start nodes for edges when ingesting?  By default, the start node of an edge must exist before we can ingest the edge.",
            "default": false
          },
          "autoCreateEndNodes": {
            "type": "boolean",
            "default": false,
            "description": "Should we create missing end nodes for edges when ingesting?  By default, the end node of an edge must exist before we can ingest the edge."
          },
          "skipOnVersionConflict": {
            "type": "boolean",
            "default": false,
            "description": "If existingVersion is specified on any of the nodes/edges in the input, the default behaviour is that the entire ingestion will fail when version conflicts occur. If skipOnVersionConflict is set to true, items with version conflicts will be skipped instead. If no version is specified for nodes/edges, it will do the write directly."
          },
          "replace": {
            "type": "boolean",
            "description": "How do we behave when a property value exists? Do we replace all matching and existing values with the supplied values (`true`)?  Or should we merge in new values for properties together with the existing values (`false`)?  Note: This setting applies for all nodes or edges specified in the ingestion call.",
            "default": false
          }
        }
      },
      "NodeOrEdgeCreate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/NodeWrite"
          },
          {
            "$ref": "#/components/schemas/EdgeWrite"
          }
        ]
      },
      "SpaceCreateCollection": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "List of spaces to create/update",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/SpaceCreateDefinition"
            }
          }
        }
      },
      "SpaceCreateDefinition": {
        "type": "object",
        "required": [
          "space"
        ],
        "properties": {
          "space": {
            "type": "string",
            "description": "The Space identifier (id).\n\n\nNote that we have reserved the use of certain space ids.  These reserved spaces are:\n * `space`\n * `cdf`\n * `dms`\n * `pg3`\n * `shared`\n * `system`\n * `node`\n * `edge`\n ",
            "pattern": "(?!^(space|cdf|dms|pg3|shared|system|node|edge)$)(^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$)",
            "minLength": 1,
            "maxLength": 43
          },
          "description": {
            "type": "string",
            "description": "Used to describe the space you're defining.",
            "maxLength": 1024
          },
          "name": {
            "type": "string",
            "description": "Human-readable name for the space.",
            "maxLength": 255
          }
        }
      },
      "SpaceDefinition": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SpaceCreateDefinition"
          },
          {
            "type": "object",
            "required": [
              "createdTime",
              "lastUpdatedTime",
              "isGlobal"
            ],
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "isGlobal": {
                "type": "boolean",
                "description": "Is this a global space."
              }
            }
          }
        ]
      },
      "UpsertConflict": {
        "type": "object",
        "required": [
          "error"
        ],
        "properties": {
          "error": {
            "type": "object",
            "description": "Details about the error caused by the upsert/update.",
            "required": [
              "code",
              "message"
            ],
            "properties": {
              "code": {
                "type": "integer",
                "description": "The HTTP status code returned",
                "format": "int32",
                "example": 409
              },
              "message": {
                "type": "string",
                "description": "The error message returned from the service."
              }
            }
          }
        }
      },
      "ListOfSpaceIdsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "required": [
                "space"
              ],
              "properties": {
                "space": {
                  "description": "Ids for the spaces to perform operations on",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SpaceSpecification"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "ListOfContainerSubObjectIdentifierRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "type": "object",
              "required": [
                "space",
                "containerExternalId",
                "identifier"
              ],
              "properties": {
                "space": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                },
                "containerExternalId": {
                  "description": "External ids for the requested items",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DMSExternalId"
                    }
                  ]
                },
                "identifier": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "ListOfSpaceExternalIdsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "required": [
                "space",
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "description": "External ids for the requested items",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DMSExternalId"
                    }
                  ]
                },
                "space": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                }
              }
            }
          }
        }
      },
      "ListOfSpaceExternalIdsRequestWithTyping": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "sources": {
            "description": "The node/edge must have data in all the sources defined in the list",
            "allOf": [
              {
                "$ref": "#/components/schemas/SourceSelectorWithoutPropertiesV3"
              }
            ]
          },
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "required": [
                "instanceType",
                "space",
                "externalId"
              ],
              "properties": {
                "instanceType": {
                  "description": "The type of instance being returned, an edge or a node.",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/InstanceType"
                    }
                  ]
                },
                "externalId": {
                  "description": "External ids for the requested items",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/NodeOrEdgeExternalId"
                    }
                  ]
                },
                "space": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                }
              }
            }
          },
          "includeTyping": {
            "$ref": "#/components/schemas/IncludeTyping"
          }
        }
      },
      "InstanceInspectRequest": {
        "type": "object",
        "required": [
          "inspectionOperations",
          "items"
        ],
        "properties": {
          "inspectionOperations": {
            "type": "object",
            "properties": {
              "involvedViews": {
                "type": "object",
                "properties": {
                  "allVersions": {
                    "type": "boolean",
                    "default": false
                  }
                }
              },
              "involvedContainers": {
                "type": "object",
                "properties": {
                  "allVersions": {
                    "type": "boolean",
                    "default": false
                  }
                }
              }
            }
          },
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "required": [
                "instanceType",
                "space",
                "externalId"
              ],
              "properties": {
                "instanceType": {
                  "description": "The type of instance being returned, an edge or a node.",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/InstanceType"
                    }
                  ]
                },
                "externalId": {
                  "description": "External ids for the requested items",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/NodeOrEdgeExternalId"
                    }
                  ]
                },
                "space": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                }
              }
            }
          }
        }
      },
      "InstanceInspectResultItem": {
        "type": "object",
        "required": [
          "instanceType",
          "externalId",
          "space",
          "inspectionResults"
        ],
        "properties": {
          "instanceType": {
            "description": "The type of instance being returned, an edge or a node.",
            "allOf": [
              {
                "$ref": "#/components/schemas/InstanceType"
              }
            ]
          },
          "externalId": {
            "description": "External ids for the requested items",
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "inspectionResults": {
            "type": "object",
            "properties": {
              "involvedViews": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ViewReference"
                }
              },
              "involvedContainers": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ContainerReference"
                }
              }
            }
          }
        }
      },
      "ContainerInspectRequest": {
        "type": "object",
        "required": [
          "inspectionOperations",
          "items"
        ],
        "properties": {
          "inspectionOperations": {
            "type": "object",
            "properties": {
              "involvedViews": {
                "type": "object",
                "properties": {
                  "allVersions": {
                    "type": "boolean",
                    "default": false
                  }
                }
              },
              "totalInvolvedViewCount": {
                "type": "object",
                "properties": {
                  "allVersions": {
                    "type": "boolean",
                    "default": false
                  },
                  "includeUnavailableViews": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether or not to also count views which aren't available to the user. This is useful for understanding whether or not views/datamodels you don't have to access to will be affected by deleting/changing this container."
                  }
                }
              }
            }
          },
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10,
            "items": {
              "type": "object",
              "required": [
                "space",
                "externalId"
              ],
              "properties": {
                "space": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                },
                "externalId": {
                  "description": "External id for the requested container",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DMSExternalId"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "ContainerInspectResultItem": {
        "type": "object",
        "required": [
          "externalId",
          "space",
          "inspectionResults"
        ],
        "properties": {
          "externalId": {
            "description": "External ids for the requested items",
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "inspectionResults": {
            "type": "object",
            "properties": {
              "involvedViewCount": {
                "description": "The total number of views mapping this container (including views you don't have access to)",
                "type": "integer"
              },
              "involvedViews": {
                "type": "array",
                "description": "The views you have access to which map this container.",
                "items": {
                  "$ref": "#/components/schemas/ViewReference"
                }
              }
            }
          }
        }
      },
      "ListOfVersionReferences": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "required": [
                "space",
                "externalId",
                "version"
              ],
              "properties": {
                "externalId": {
                  "description": "External id for the requested item",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DMSExternalId"
                    }
                  ]
                },
                "space": {
                  "description": "Space id for the requested item",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SpaceSpecification"
                    }
                  ]
                },
                "version": {
                  "description": "Version of the requested item",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DMSVersion"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "ListOfAllVersionsReferences": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "required": [
                "space",
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "description": "External id for the requested item",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/DMSExternalId"
                    }
                  ]
                },
                "space": {
                  "description": "Space id for the requested item",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/SpaceSpecification"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "MultiNextCursorV3": {
        "description": "Cursors to paginate to the next page of results.  The cursor applies to each result set expression.  We only provide a cursor when more data is available.",
        "type": "object",
        "properties": {
          "additionalProperties": {
            "x-additionalPropertiesName": "cursor-name",
            "allOf": [
              {
                "$ref": "#/components/schemas/NextCursorV3"
              }
            ]
          }
        }
      },
      "AggregationDefinition": {
        "type": "object",
        "description": "An aggregate.  It consists of a name, an aggregator function, and the field to use for the function.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/AvgAggregateFunctionV3"
          },
          {
            "$ref": "#/components/schemas/CountAggregateFunctionV3"
          },
          {
            "$ref": "#/components/schemas/MinAggregateFunctionV3"
          },
          {
            "$ref": "#/components/schemas/MaxAggregateFunctionV3"
          },
          {
            "$ref": "#/components/schemas/SumAggregateFunctionV3"
          },
          {
            "$ref": "#/components/schemas/HistogramAggregateFunctionV3"
          }
        ]
      },
      "CountAggregateFunctionV3": {
        "title": "count",
        "type": "object",
        "description": "Counts the number of items.  When you specify a property, it returns the number of non-null values for that property.",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "object",
            "properties": {
              "property": {
                "type": "string",
                "description": "The property to count. If specified, counts all non-null values for the specified property."
              }
            }
          }
        }
      },
      "AvgAggregateFunctionV3": {
        "type": "object",
        "title": "avg",
        "description": "Calculates the average from the data stored by the specified property. This aggregation uses an average mean calculation, and not an integral mean.",
        "required": [
          "avg"
        ],
        "properties": {
          "avg": {
            "type": "object",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "type": "string",
                "description": "The property who's data we use to calculate the average from.  This property needs to be a defined-as-numerical property."
              }
            }
          }
        }
      },
      "MaxAggregateFunctionV3": {
        "type": "object",
        "title": "max",
        "description": "The function will calculate, and return, the highest - max - value for the property.",
        "required": [
          "max"
        ],
        "properties": {
          "max": {
            "type": "object",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "type": "string",
                "description": "The property who's data we use to generate the max value from.  This property needs to be a defined-as-numerical property."
              }
            }
          }
        }
      },
      "MinAggregateFunctionV3": {
        "type": "object",
        "title": "min",
        "description": "The function will calculate, and return, the lowest - min - value for a property.",
        "required": [
          "min"
        ],
        "properties": {
          "min": {
            "type": "object",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "type": "string",
                "description": "The property who's data we use to generate the min value from.  This property needs to be a defined-as-numerical property."
              }
            }
          }
        }
      },
      "HistogramAggregateFunctionV3": {
        "type": "object",
        "title": "histogram",
        "description": "A histogram aggregator function.  This function will generate a histogram from the values of the specified property.  It uses the specified interval as defined in your `interval` argument.",
        "required": [
          "histogram"
        ],
        "properties": {
          "histogram": {
            "type": "object",
            "required": [
              "property",
              "interval"
            ],
            "properties": {
              "property": {
                "type": "string",
                "description": "The property who's data we use to generate the histogram.  This property needs to be a defined-as-numerical property."
              },
              "interval": {
                "type": "number",
                "description": "The interval between each bucket."
              }
            }
          }
        }
      },
      "SumAggregateFunctionV3": {
        "type": "object",
        "title": "sum",
        "description": "Calculates the sum from the values of the specified property.",
        "required": [
          "sum"
        ],
        "properties": {
          "sum": {
            "type": "object",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "type": "string",
                "description": "The property who's data we use to calculate the sum of.  This property needs to be a defined-as-numerical property."
              }
            }
          }
        }
      },
      "SyncTableExpressionV3": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SyncNodeTableExpressionV3"
          },
          {
            "$ref": "#/components/schemas/SyncEdgeTableExpressionV3"
          }
        ]
      },
      "SyncNodeTableExpressionV3": {
        "type": "object",
        "required": [
          "nodes"
        ],
        "description": "The synchronization query to use when we listen for changes to nodes.  The nodes must also match the specified filter.",
        "properties": {
          "limit": {
            "$ref": "#/components/schemas/TableExpressionSyncLimit"
          },
          "nodes": {
            "type": "object",
            "properties": {
              "from": {
                "description": "Chain your result expression from the specified view, or container.",
                "type": "string"
              },
              "chainTo": {
                "$ref": "#/components/schemas/TableExpressionChainToDefinition"
              },
              "through": {
                "$ref": "#/components/schemas/NodeTableExpressionThrough"
              },
              "direction": {
                "description": "The direction to use when traversing direct relations. Only applicable when `through` is specified.",
                "type": "string",
                "default": "inwards",
                "enum": [
                  "outwards",
                  "inwards"
                ]
              },
              "filter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              }
            }
          }
        }
      },
      "NodeTableExpressionThrough": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ViewPropertyReference"
          },
          {
            "$ref": "#/components/schemas/ThroughReference"
          }
        ]
      },
      "SyncEdgeTableExpressionV3": {
        "type": "object",
        "required": [
          "edges"
        ],
        "description": "The synchronization query to use when we listen for changes to edges.  The edges must also match the specified filter.",
        "properties": {
          "limit": {
            "$ref": "#/components/schemas/TableExpressionSyncLimit"
          },
          "edges": {
            "type": "object",
            "properties": {
              "from": {
                "description": "Chain your result expression from this query.",
                "type": "string"
              },
              "chainTo": {
                "$ref": "#/components/schemas/TableExpressionChainToDefinition"
              },
              "maxDistance": {
                "description": "The largest - max - number of levels to traverse when resolving the query.",
                "type": "integer"
              },
              "direction": {
                "description": "The direction to use when traversing.",
                "type": "string",
                "enum": [
                  "outwards",
                  "inwards"
                ]
              },
              "filter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              },
              "nodeFilter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              },
              "terminationFilter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              }
            }
          }
        }
      },
      "QueryTableExpressionV3": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/QueryNodeTableExpressionV3"
          },
          {
            "$ref": "#/components/schemas/QueryEdgeTableExpressionV3"
          },
          {
            "$ref": "#/components/schemas/QuerySetOperationTableExpressionV3"
          }
        ],
        "type": "object"
      },
      "QueryNodeTableExpressionV3": {
        "title": "node result expression",
        "description": "Specifies a result set of nodes.",
        "type": "object",
        "required": [
          "nodes"
        ],
        "properties": {
          "sort": {
            "type": "array",
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/PropertySortV3"
            }
          },
          "limit": {
            "$ref": "#/components/schemas/TableExpressionQueryLimit"
          },
          "nodes": {
            "type": "object",
            "properties": {
              "from": {
                "description": "The name of a result expression to chain from.",
                "type": "string"
              },
              "chainTo": {
                "$ref": "#/components/schemas/TableExpressionChainToDefinition"
              },
              "through": {
                "$ref": "#/components/schemas/NodeTableExpressionThrough"
              },
              "direction": {
                "description": "The direction to use when traversing direct relations. Only applicable when `through` is specified.",
                "type": "string",
                "default": "inwards",
                "enum": [
                  "outwards",
                  "inwards"
                ]
              },
              "filter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              }
            }
          }
        }
      },
      "QueryEdgeTableExpressionV3": {
        "title": "edge result expression",
        "description": "Specifies a result set of edges.",
        "type": "object",
        "required": [
          "edges"
        ],
        "properties": {
          "sort": {
            "type": "array",
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/PropertySortV3"
            }
          },
          "postSort": {
            "type": "array",
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/PropertySortV3"
            }
          },
          "limit": {
            "$ref": "#/components/schemas/TableExpressionQueryLimit"
          },
          "edges": {
            "type": "object",
            "properties": {
              "from": {
                "description": "The name of a result expression to chain from.",
                "type": "string"
              },
              "chainTo": {
                "$ref": "#/components/schemas/TableExpressionChainToDefinition"
              },
              "maxDistance": {
                "description": "The largest - max - number of levels to traverse.",
                "type": "integer"
              },
              "direction": {
                "description": "The direction to use when traversing.",
                "type": "string",
                "default": "outwards",
                "enum": [
                  "outwards",
                  "inwards"
                ]
              },
              "filter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              },
              "nodeFilter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              },
              "terminationFilter": {
                "$ref": "#/components/schemas/TableExpressionFilterDefinition"
              },
              "limitEach": {
                "type": "integer",
                "description": "Limit the number of returned edges for each of the source nodes in the result set.  The indicated uniform limit applies to the result set from the referenced `from`.  `limitEach` only has meaning when you also specify `maxDistance=1` and `from`.",
                "minimum": 1,
                "maximum": 2000
              }
            }
          }
        }
      },
      "QuerySetOperationTableExpressionV3": {
        "title": "set operation result expression",
        "oneOf": [
          {
            "$ref": "#/components/schemas/QueryUnionAllTableExpressionV3"
          },
          {
            "$ref": "#/components/schemas/QueryUnionTableExpressionV3"
          },
          {
            "$ref": "#/components/schemas/QueryIntersectionTableExpressionV3"
          }
        ],
        "type": "object"
      },
      "QueryUnionAllTableExpressionV3": {
        "title": "union all",
        "type": "object",
        "description": "Return the union of the specified result sets.  We will remove the results that match the optional exception\nresult sets.  Note: The operation may return duplicate results since we do not perform deduplication.\n",
        "required": [
          "unionAll"
        ],
        "properties": {
          "unionAll": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/QuerySetOperationTableExpressionV3"
                },
                {
                  "type": "string"
                }
              ]
            }
          },
          "except": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "limit": {
            "$ref": "#/components/schemas/TableExpressionQueryLimit"
          }
        }
      },
      "QueryUnionTableExpressionV3": {
        "title": "union",
        "description": "Return the union of the specified result sets. We will remove the results that match the optional\nexception result sets.  But this operation does not result in duplicate results as it performs\ndeduplication.\n\nNote: You should use the `unionAll` operation whenever possible. Using it enables a built-in optimization.\nI.e. `A unionAll B` with `limit: n` will execute set operation B, if and only if, A returns less than\nn records.\n",
        "type": "object",
        "required": [
          "union"
        ],
        "properties": {
          "union": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/QuerySetOperationTableExpressionV3"
                },
                {
                  "type": "string"
                }
              ]
            }
          },
          "except": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "limit": {
            "$ref": "#/components/schemas/TableExpressionQueryLimit"
          }
        }
      },
      "QueryIntersectionTableExpressionV3": {
        "title": "intersection",
        "type": "object",
        "description": "Find the common elements in the returned result set. Excludes the elements from the optional `except` result set.",
        "required": [
          "intersection"
        ],
        "properties": {
          "intersection": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/QuerySetOperationTableExpressionV3"
                },
                {
                  "type": "string"
                }
              ]
            }
          },
          "except": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "limit": {
            "$ref": "#/components/schemas/TableExpressionQueryLimit"
          }
        }
      },
      "SortV3": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "array",
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/PropertySortV3"
            }
          }
        }
      },
      "PropertySortV3": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "$ref": "#/components/schemas/DMSFilterProperty"
          },
          "direction": {
            "type": "string",
            "default": "ascending",
            "enum": [
              "ascending",
              "descending"
            ]
          },
          "nullsFirst": {
            "type": "boolean",
            "default": false
          }
        }
      },
      "SearchSort": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "$ref": "#/components/schemas/DMSFilterProperty"
          },
          "direction": {
            "type": "string",
            "default": "ascending",
            "enum": [
              "ascending",
              "descending"
            ]
          }
        }
      },
      "SourceSelectorWithoutPropertiesV3": {
        "type": "array",
        "description": "Retrieve properties from the listed - by reference - views. The node/edge must have data in all the sources defined in the list.",
        "maxItems": 10,
        "items": {
          "type": "object",
          "required": [
            "source"
          ],
          "properties": {
            "source": {
              "$ref": "#/components/schemas/ViewReference"
            },
            "targetUnits": {
              "$ref": "#/components/schemas/TargetUnits"
            }
          }
        }
      },
      "SourceSelectorV3": {
        "type": "array",
        "maxItems": 10,
        "items": {
          "type": "object",
          "required": [
            "source",
            "properties"
          ],
          "properties": {
            "source": {
              "$ref": "#/components/schemas/ViewReference"
            },
            "properties": {
              "type": "array",
              "description": "Properties to return for the specified view. Use \"*\" to return all properties.",
              "items": {
                "type": "string"
              }
            },
            "targetUnits": {
              "$ref": "#/components/schemas/TargetUnits"
            }
          }
        }
      },
      "TargetUnits": {
        "type": "array",
        "description": "Properties to convert to another unit. The API can only convert to another unit, if a unit has been defined as part of the type on the underlying container being queried.",
        "maxItems": 10,
        "minItems": 1,
        "items": {
          "$ref": "#/components/schemas/TargetUnit"
        }
      },
      "TargetUnit": {
        "type": "object",
        "description": "Describes a target unit for a property.",
        "required": [
          "property",
          "unit"
        ],
        "properties": {
          "property": {
            "type": "string"
          },
          "unit": {
            "description": "The external id of the target unit or unit system to convert to.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/UnitReference"
              },
              {
                "$ref": "#/components/schemas/UnitSystemReference"
              }
            ]
          }
        }
      },
      "UnitReference": {
        "type": "object",
        "description": "Target unit reference.",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/NodeOrEdgeExternalId"
          }
        }
      },
      "UnitSystemReference": {
        "type": "object",
        "description": "Target system to convert data to. Can be used instead of targetUnit to identify the unit to convert to.\n",
        "required": [
          "unitSystemName"
        ],
        "example": "Default, SI, Imperial\n",
        "properties": {
          "unitSystemName": {
            "type": "string"
          }
        }
      },
      "QuerySelectV3": {
        "type": "object",
        "description": "Define which view to return properties for, and the properties to return. Up to 10 views can be specified per query.",
        "properties": {
          "sources": {
            "$ref": "#/components/schemas/SourceSelectorV3"
          },
          "sort": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PropertySortV3"
            }
          },
          "limit": {
            "type": "integer"
          }
        }
      },
      "SyncSelectV3": {
        "type": "object",
        "description": "Specify the container or view to return properties for. Also specify the properties for those containers/views to return. Up to 10 views can be specified.",
        "properties": {
          "sources": {
            "$ref": "#/components/schemas/SourceSelectorV3"
          }
        }
      },
      "SourceReference": {
        "description": "Reference to a view, or a container",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ViewReference"
          },
          {
            "$ref": "#/components/schemas/ContainerReference"
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "FilterValue": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawPropertyValueV3"
          },
          {
            "$ref": "#/components/schemas/ReferencedPropertyValueV3"
          }
        ]
      },
      "TableExpressionFilterValue": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawPropertyValueV3"
          },
          {
            "$ref": "#/components/schemas/ParameterizedPropertyValueV3"
          },
          {
            "$ref": "#/components/schemas/ReferencedPropertyValueV3"
          }
        ]
      },
      "FilterValueList": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawPropertyValueListV3"
          },
          {
            "$ref": "#/components/schemas/ReferencedPropertyValueV3"
          }
        ]
      },
      "TableExpressionFilterValueList": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawPropertyValueListV3"
          },
          {
            "$ref": "#/components/schemas/ParameterizedPropertyValueV3"
          },
          {
            "$ref": "#/components/schemas/ReferencedPropertyValueV3"
          }
        ]
      },
      "FilterValueRange": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RangeValue"
          },
          {
            "$ref": "#/components/schemas/ReferencedPropertyValueV3"
          }
        ]
      },
      "TableExpressionFilterValueRange": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/RangeValue"
          },
          {
            "$ref": "#/components/schemas/ParameterizedPropertyValueV3"
          },
          {
            "$ref": "#/components/schemas/ReferencedPropertyValueV3"
          }
        ]
      },
      "DataModelsNestedFilter": {
        "type": "object",
        "title": "nested",
        "required": [
          "nested"
        ],
        "properties": {
          "nested": {
            "required": [
              "scope",
              "filter"
            ],
            "description": "Use `nested` to apply the properties of the direct relation as the filter.  `scope` specifies the direct\nrelation property you want use as the filtering property.\n\nExample:\n```\n  {\n    \"nested\": {\n      \"scope\": [\"some\", \"direct_relation\", \"property\"],\n      \"filter\": {\n        \"equals\": {\n          \"property\": [\"node\", \"name\"],\n          \"value\": \"ACME\"\n        }\n      }\n    }\n  }\n```\n",
            "type": "object",
            "properties": {
              "scope": {
                "type": "array",
                "minItems": 1,
                "maxItems": 3,
                "items": {
                  "type": "string"
                }
              },
              "filter": {
                "$ref": "#/components/schemas/FilterDefinition"
              }
            }
          }
        }
      },
      "HasExistingDataFilterV3": {
        "type": "object",
        "title": "hasData",
        "required": [
          "hasData"
        ],
        "properties": {
          "hasData": {
            "type": "array",
            "description": "Matches instances that have data in the referenced views or containers.",
            "items": {
              "$ref": "#/components/schemas/SourceReference"
            }
          }
        }
      },
      "InstanceReferenceFilterV3": {
        "type": "object",
        "title": "instanceReferences",
        "required": [
          "instanceReferences"
        ],
        "properties": {
          "instanceReferences": {
            "type": "array",
            "description": "Matches instances with any of the specified space/externalId pairs.",
            "items": {
              "type": "object",
              "required": [
                "space",
                "externalId"
              ],
              "properties": {
                "space": {
                  "$ref": "#/components/schemas/SpaceSpecification"
                },
                "externalId": {
                  "$ref": "#/components/schemas/NodeOrEdgeExternalId"
                }
              }
            }
          }
        }
      },
      "OverlapsFilterV3": {
        "type": "object",
        "title": "overlaps",
        "required": [
          "overlaps"
        ],
        "properties": {
          "overlaps": {
            "type": "object",
            "description": "Matches items where the range made up of the two properties overlap with the provided range.\nNot available for search queries.",
            "required": [
              "startProperty",
              "endProperty"
            ],
            "properties": {
              "startProperty": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "endProperty": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/FilterValueRange"
              },
              "gt": {
                "$ref": "#/components/schemas/FilterValueRange"
              },
              "lte": {
                "$ref": "#/components/schemas/FilterValueRange"
              },
              "lt": {
                "$ref": "#/components/schemas/FilterValueRange"
              }
            }
          }
        }
      },
      "TableExpressionOverlapsFilterV3": {
        "type": "object",
        "title": "overlaps",
        "required": [
          "overlaps"
        ],
        "properties": {
          "overlaps": {
            "type": "object",
            "description": "Matches items where the range made up of the two properties overlap with the provided range.",
            "required": [
              "startProperty",
              "endProperty"
            ],
            "properties": {
              "startProperty": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "endProperty": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              },
              "gt": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              },
              "lte": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              },
              "lt": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              }
            }
          }
        }
      },
      "EqualsFilterV3": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contain the exact value in the provided property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/FilterValue"
              }
            }
          }
        }
      },
      "TableExpressionEqualsFilterV3": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contain the exact value in the provided property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/TableExpressionFilterValue"
              }
            }
          }
        }
      },
      "InFilterV3": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property **exactly** matches one of the given values.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/FilterValueList"
              }
            }
          }
        }
      },
      "TableExpressionInFilterV3": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property **exactly** matches one of the given values.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/TableExpressionFilterValueList"
              }
            }
          }
        }
      },
      "RangeFilterV3": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain terms within the provided range.\n\nThe range must include both an upper and a lower bound. It is not permitted to specify both inclusive\nand exclusive bounds together.  E.g. `gte` and `gt`.\n\n  `gte`: Greater than or equal to.\n  `gt`: Greater than.\n  `lte`: Less than or equal to.\n  `lt`: Less than.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/FilterValueRange"
              },
              "gt": {
                "$ref": "#/components/schemas/FilterValueRange"
              },
              "lte": {
                "$ref": "#/components/schemas/FilterValueRange"
              },
              "lt": {
                "$ref": "#/components/schemas/FilterValueRange"
              }
            }
          }
        }
      },
      "TableExpressionRangeFilterV3": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain terms within the provided range.\n\nThe range must include both an upper and a lower bound. It is not permitted to specify both inclusive\nand exclusive bounds together.  E.g. `gte` and `gt`.\n\n  `gte`: Greater than or equal to.\n  `gt`: Greater than.\n  `lte`: Less than or equal to.\n  `lt`: Less than.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              },
              "gt": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              },
              "lte": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              },
              "lt": {
                "$ref": "#/components/schemas/TableExpressionFilterValueRange"
              }
            }
          }
        }
      },
      "PrefixFilterV3": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that have the prefix in the identified property. This filter is only supported for single value text properties.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "value": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/components/schemas/ParameterizedPropertyValueV3"
                  }
                ]
              }
            }
          }
        }
      },
      "TableExpressionPrefixFilterV3": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that have the prefix in the identified property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/TableExpressionFilterValue"
              }
            }
          }
        }
      },
      "ContainsAnyFilterV3": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more of the given values. Only apply this filter to multivalued properties.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/FilterValueList"
              }
            }
          }
        }
      },
      "TableExpressionContainsAnyFilterV3": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more of the given values. Only apply this filter to multivalued properties.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/TableExpressionFilterValueList"
              }
            }
          }
        }
      },
      "ContainsAllFilterV3": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains all the given values. Only apply this filter to multivalued properties.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/FilterValueList"
              }
            }
          }
        }
      },
      "TableExpressionContainsAllFilterV3": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains all the given values. Only apply this filter to multivalued properties.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/TableExpressionFilterValueList"
              }
            }
          }
        }
      },
      "TypeInformationOuter": {
        "type": "object",
        "description": "Spaces for the requested view and containers",
        "additionalProperties": {
          "x-additionalPropertiesName": "space-name",
          "allOf": [
            {
              "$ref": "#/components/schemas/TypingViewOrContainer"
            }
          ]
        }
      },
      "TypingViewOrContainer": {
        "type": "object",
        "description": "View or container holding properties",
        "additionalProperties": {
          "x-additionalPropertiesName": "view-or-container-external-id",
          "allOf": [
            {
              "$ref": "#/components/schemas/TypeInformation"
            }
          ]
        }
      },
      "TypeInformation": {
        "type": "object",
        "description": "Type information for the returned properties (if requested)",
        "additionalProperties": {
          "x-additionalPropertiesName": "property-identifier",
          "allOf": [
            {
              "$ref": "#/components/schemas/TypePropertyDefinition"
            }
          ]
        }
      },
      "DMSExternalId": {
        "type": "string",
        "pattern": "^[a-zA-Z]([a-zA-Z0-9_]{0,253}[a-zA-Z0-9])?$",
        "minLength": 1,
        "maxLength": 255
      },
      "NodeOrEdgeExternalId": {
        "type": "string",
        "pattern": "^[^\\\\x00]{1,256}$",
        "minLength": 1,
        "maxLength": 256
      },
      "DMSVersion": {
        "type": "string",
        "pattern": "^[a-zA-Z0-9]([.a-zA-Z0-9_-]{0,41}[a-zA-Z0-9])?$",
        "minLength": 1,
        "maxLength": 43
      },
      "PropertyIdentifierV3": {
        "type": "string",
        "pattern": "^[a-zA-Z]([a-zA-Z0-9_]{0,253}[a-zA-Z0-9])?$",
        "minLength": 1,
        "maxLength": 255
      },
      "DirectRelationReference": {
        "type": "object",
        "description": "Reference to the node pointed to by the direct relation. The reference consists of a space and an external-id.",
        "required": [
          "space",
          "externalId"
        ],
        "properties": {
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "externalId": {
            "$ref": "#/components/schemas/NodeOrEdgeExternalId"
          }
        }
      },
      "LimitWithDefault1000": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to return.",
            "type": "integer",
            "default": 1000,
            "minimum": 1,
            "maximum": 1000
          }
        }
      },
      "ReducedLimit": {
        "type": "object",
        "description": "Limits the number of results returned. The greatest number of results returned by the server is 1000. This is true even when you specify a higher limit.",
        "properties": {
          "limit": {
            "type": "integer",
            "default": 10,
            "minimum": 1,
            "maximum": 1000
          }
        }
      },
      "TableExpressionQueryLimit": {
        "type": "integer",
        "default": 100,
        "minimum": 1,
        "maximum": 10000,
        "description": "Limits the number of instances in the result set generated by this result expression."
      },
      "TableExpressionSyncLimit": {
        "type": "integer",
        "default": 100,
        "minimum": 100,
        "maximum": 2000,
        "description": "Limits the number of instances in the result set generated by this table expression."
      },
      "SpaceSpecification": {
        "type": "string",
        "pattern": "^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$",
        "minLength": 1,
        "maxLength": 43
      },
      "AllVersionsFlag": {
        "type": "boolean",
        "default": false,
        "description": "If all versions of the entity should be returned. Defaults to false which returns the latest version, attributed to the newest 'createdTime' field"
      },
      "IncludeGlobalFlag": {
        "type": "boolean",
        "default": false,
        "description": "If the global items of the entity should be returned. Defaults to false which excludes global items."
      },
      "TextProperty": {
        "type": "object",
        "description": "Text type",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "text"
            ]
          },
          "list": {
            "type": "boolean",
            "description": "Specifies that the data type is a list of values. The ordering of values is preserved.\n",
            "default": false
          },
          "maxListSize": {
            "type": "integer",
            "description": "Specifies the maximum number of values in the list"
          },
          "collation": {
            "type": "string",
            "description": "Collation - the set of language specific rules - used when sorting text fields",
            "enum": [
              "ucs_basic",
              "und",
              "af",
              "af-NA",
              "af-ZA",
              "agq",
              "agq-CM",
              "ak",
              "ak-GH",
              "am",
              "am-ET",
              "ar",
              "ar-001",
              "ar-AE",
              "ar-BH",
              "ar-DJ",
              "ar-DZ",
              "ar-EG",
              "ar-EH",
              "ar-ER",
              "ar-IL",
              "ar-IQ",
              "ar-JO",
              "ar-KM",
              "ar-KW",
              "ar-LB",
              "ar-LY",
              "ar-MA",
              "ar-MR",
              "ar-OM",
              "ar-PS",
              "ar-QA",
              "ar-SA",
              "ar-SD",
              "ar-SO",
              "ar-SS",
              "ar-SY",
              "ar-TD",
              "ar-TN",
              "ar-YE",
              "as",
              "as-IN",
              "asa",
              "asa-TZ",
              "ast",
              "ast-ES",
              "az",
              "az-Cyrl",
              "az-Cyrl-AZ",
              "az-Latn",
              "az-Latn-AZ",
              "bas",
              "bas-CM",
              "be",
              "be-BY",
              "bem",
              "bem-ZM",
              "bez",
              "bez-TZ",
              "bg",
              "bg-BG",
              "bm",
              "bm-ML",
              "bn",
              "bn-BD",
              "bn-IN",
              "bo",
              "bo-CN",
              "bo-IN",
              "br",
              "br-FR",
              "brx",
              "brx-IN",
              "bs",
              "bs-Cyrl",
              "bs-Cyrl-BA",
              "bs-Latn",
              "bs-Latn-BA",
              "ca",
              "ca-AD",
              "ca-ES",
              "ca-FR",
              "ca-IT",
              "ccp",
              "ccp-BD",
              "ccp-IN",
              "ce",
              "ce-RU",
              "ceb",
              "ceb-PH",
              "cgg",
              "cgg-UG",
              "chr",
              "chr-US",
              "ckb",
              "ckb-IQ",
              "ckb-IR",
              "cs",
              "cs-CZ",
              "cy",
              "cy-GB",
              "da",
              "da-DK",
              "da-GL",
              "dav",
              "dav-KE",
              "de",
              "de-AT",
              "de-BE",
              "de-CH",
              "de-DE",
              "de-IT",
              "de-LI",
              "de-LU",
              "dje",
              "dje-NE",
              "dsb",
              "dsb-DE",
              "dua",
              "dua-CM",
              "dyo",
              "dyo-SN",
              "dz",
              "dz-BT",
              "ebu",
              "ebu-KE",
              "ee",
              "ee-GH",
              "ee-TG",
              "el",
              "el-CY",
              "el-GR",
              "en",
              "en-001",
              "en-150",
              "en-AE",
              "en-AG",
              "en-AI",
              "en-AS",
              "en-AT",
              "en-AU",
              "en-BB",
              "en-BE",
              "en-BI",
              "en-BM",
              "en-BS",
              "en-BW",
              "en-BZ",
              "en-CA",
              "en-CC",
              "en-CH",
              "en-CK",
              "en-CM",
              "en-CX",
              "en-CY",
              "en-DE",
              "en-DG",
              "en-DK",
              "en-DM",
              "en-ER",
              "en-FI",
              "en-FJ",
              "en-FK",
              "en-FM",
              "en-GB",
              "en-GD",
              "en-GG",
              "en-GH",
              "en-GI",
              "en-GM",
              "en-GU",
              "en-GY",
              "en-HK",
              "en-IE",
              "en-IL",
              "en-IM",
              "en-IN",
              "en-IO",
              "en-JE",
              "en-JM",
              "en-KE",
              "en-KI",
              "en-KN",
              "en-KY",
              "en-LC",
              "en-LR",
              "en-LS",
              "en-MG",
              "en-MH",
              "en-MO",
              "en-MP",
              "en-MS",
              "en-MT",
              "en-MU",
              "en-MW",
              "en-MY",
              "en-NA",
              "en-NF",
              "en-NG",
              "en-NL",
              "en-NR",
              "en-NU",
              "en-NZ",
              "en-PG",
              "en-PH",
              "en-PK",
              "en-PN",
              "en-PR",
              "en-PW",
              "en-RW",
              "en-SB",
              "en-SC",
              "en-SD",
              "en-SE",
              "en-SG",
              "en-SH",
              "en-SI",
              "en-SL",
              "en-SS",
              "en-SX",
              "en-SZ",
              "en-TC",
              "en-TK",
              "en-TO",
              "en-TT",
              "en-TV",
              "en-TZ",
              "en-UG",
              "en-UM",
              "en-US",
              "en-US-u-va-posix",
              "en-VC",
              "en-VG",
              "en-VI",
              "en-VU",
              "en-WS",
              "en-ZA",
              "en-ZM",
              "en-ZW",
              "eo",
              "eo-001",
              "es",
              "es-419",
              "es-AR",
              "es-BO",
              "es-BR",
              "es-BZ",
              "es-CL",
              "es-CO",
              "es-CR",
              "es-CU",
              "es-DO",
              "es-EA",
              "es-EC",
              "es-ES",
              "es-GQ",
              "es-GT",
              "es-HN",
              "es-IC",
              "es-MX",
              "es-NI",
              "es-PA",
              "es-PE",
              "es-PH",
              "es-PR",
              "es-PY",
              "es-SV",
              "es-US",
              "es-UY",
              "es-VE",
              "et",
              "et-EE",
              "eu",
              "eu-ES",
              "ewo",
              "ewo-CM",
              "fa",
              "fa-AF",
              "fa-IR",
              "ff",
              "ff-Adlm",
              "ff-Adlm-BF",
              "ff-Adlm-CM",
              "ff-Adlm-GH",
              "ff-Adlm-GM",
              "ff-Adlm-GN",
              "ff-Adlm-GW",
              "ff-Adlm-LR",
              "ff-Adlm-MR",
              "ff-Adlm-NE",
              "ff-Adlm-NG",
              "ff-Adlm-SL",
              "ff-Adlm-SN",
              "ff-Latn",
              "ff-Latn-BF",
              "ff-Latn-CM",
              "ff-Latn-GH",
              "ff-Latn-GM",
              "ff-Latn-GN",
              "ff-Latn-GW",
              "ff-Latn-LR",
              "ff-Latn-MR",
              "ff-Latn-NE",
              "ff-Latn-NG",
              "ff-Latn-SL",
              "ff-Latn-SN",
              "fi",
              "fi-FI",
              "fil",
              "fil-PH",
              "fo",
              "fo-DK",
              "fo-FO",
              "fr",
              "fr-BE",
              "fr-BF",
              "fr-BI",
              "fr-BJ",
              "fr-BL",
              "fr-CA",
              "fr-CD",
              "fr-CF",
              "fr-CG",
              "fr-CH",
              "fr-CI",
              "fr-CM",
              "fr-DJ",
              "fr-DZ",
              "fr-FR",
              "fr-GA",
              "fr-GF",
              "fr-GN",
              "fr-GP",
              "fr-GQ",
              "fr-HT",
              "fr-KM",
              "fr-LU",
              "fr-MA",
              "fr-MC",
              "fr-MF",
              "fr-MG",
              "fr-ML",
              "fr-MQ",
              "fr-MR",
              "fr-MU",
              "fr-NC",
              "fr-NE",
              "fr-PF",
              "fr-PM",
              "fr-RE",
              "fr-RW",
              "fr-SC",
              "fr-SN",
              "fr-SY",
              "fr-TD",
              "fr-TG",
              "fr-TN",
              "fr-VU",
              "fr-WF",
              "fr-YT",
              "fur",
              "fur-IT",
              "fy",
              "fy-NL",
              "ga",
              "ga-GB",
              "ga-IE",
              "gd",
              "gd-GB",
              "gl",
              "gl-ES",
              "gsw",
              "gsw-CH",
              "gsw-FR",
              "gsw-LI",
              "gu",
              "gu-IN",
              "guz",
              "guz-KE",
              "gv",
              "gv-IM",
              "ha",
              "ha-GH",
              "ha-NE",
              "ha-NG",
              "haw",
              "haw-US",
              "he",
              "he-IL",
              "hi",
              "hi-IN",
              "hr",
              "hr-BA",
              "hr-HR",
              "hsb",
              "hsb-DE",
              "hu",
              "hu-HU",
              "hy",
              "hy-AM",
              "ia",
              "ia-001",
              "id",
              "id-ID",
              "ig",
              "ig-NG",
              "ii",
              "ii-CN",
              "is",
              "is-IS",
              "it",
              "it-CH",
              "it-IT",
              "it-SM",
              "it-VA",
              "ja",
              "ja-JP",
              "jgo",
              "jgo-CM",
              "jmc",
              "jmc-TZ",
              "jv",
              "jv-ID",
              "ka",
              "ka-GE",
              "kab",
              "kab-DZ",
              "kam",
              "kam-KE",
              "kde",
              "kde-TZ",
              "kea",
              "kea-CV",
              "khq",
              "khq-ML",
              "ki",
              "ki-KE",
              "kk",
              "kk-KZ",
              "kkj",
              "kkj-CM",
              "kl",
              "kl-GL",
              "kln",
              "kln-KE",
              "km",
              "km-KH",
              "kn",
              "kn-IN",
              "ko",
              "ko-KP",
              "ko-KR",
              "kok",
              "kok-IN",
              "ks",
              "ks-Arab",
              "ks-Arab-IN",
              "ksb",
              "ksb-TZ",
              "ksf",
              "ksf-CM",
              "ksh",
              "ksh-DE",
              "ku",
              "ku-TR",
              "kw",
              "kw-GB",
              "ky",
              "ky-KG",
              "lag",
              "lag-TZ",
              "lb",
              "lb-LU",
              "lg",
              "lg-UG",
              "lkt",
              "lkt-US",
              "ln",
              "ln-AO",
              "ln-CD",
              "ln-CF",
              "ln-CG",
              "lo",
              "lo-LA",
              "lrc",
              "lrc-IQ",
              "lrc-IR",
              "lt",
              "lt-LT",
              "lu",
              "lu-CD",
              "luo",
              "luo-KE",
              "luy",
              "luy-KE",
              "lv",
              "lv-LV",
              "mai",
              "mai-IN",
              "mas",
              "mas-KE",
              "mas-TZ",
              "mer",
              "mer-KE",
              "mfe",
              "mfe-MU",
              "mg",
              "mg-MG",
              "mgh",
              "mgh-MZ",
              "mgo",
              "mgo-CM",
              "mi",
              "mi-NZ",
              "mk",
              "mk-MK",
              "ml",
              "ml-IN",
              "mn",
              "mn-MN",
              "mni",
              "mni-Beng",
              "mni-Beng-IN",
              "mr",
              "mr-IN",
              "ms",
              "ms-BN",
              "ms-ID",
              "ms-MY",
              "ms-SG",
              "mt",
              "mt-MT",
              "mua",
              "mua-CM",
              "my",
              "my-MM",
              "mzn",
              "mzn-IR",
              "naq",
              "naq-NA",
              "nb",
              "nb-NO",
              "nb-SJ",
              "nd",
              "nd-ZW",
              "nds",
              "nds-DE",
              "nds-NL",
              "ne",
              "ne-IN",
              "ne-NP",
              "nl",
              "nl-AW",
              "nl-BE",
              "nl-BQ",
              "nl-CW",
              "nl-NL",
              "nl-SR",
              "nl-SX",
              "nmg",
              "nmg-CM",
              "nn",
              "nn-NO",
              "nnh",
              "nnh-CM",
              "nus",
              "nus-SS",
              "nyn",
              "nyn-UG",
              "om",
              "om-ET",
              "om-KE",
              "or",
              "or-IN",
              "os",
              "os-GE",
              "os-RU",
              "pa",
              "pa-Arab",
              "pa-Arab-PK",
              "pa-Guru",
              "pa-Guru-IN",
              "pcm",
              "pcm-NG",
              "pl",
              "pl-PL",
              "ps",
              "ps-AF",
              "ps-PK",
              "pt",
              "pt-AO",
              "pt-BR",
              "pt-CH",
              "pt-CV",
              "pt-GQ",
              "pt-GW",
              "pt-LU",
              "pt-MO",
              "pt-MZ",
              "pt-PT",
              "pt-ST",
              "pt-TL",
              "qu",
              "qu-BO",
              "qu-EC",
              "qu-PE",
              "rm",
              "rm-CH",
              "rn",
              "rn-BI",
              "ro",
              "ro-MD",
              "ro-RO",
              "rof",
              "rof-TZ",
              "ru",
              "ru-BY",
              "ru-KG",
              "ru-KZ",
              "ru-MD",
              "ru-RU",
              "ru-UA",
              "rw",
              "rw-RW",
              "rwk",
              "rwk-TZ",
              "sah",
              "sah-RU",
              "saq",
              "saq-KE",
              "sat",
              "sat-Olck",
              "sat-Olck-IN",
              "sbp",
              "sbp-TZ",
              "sd",
              "sd-Arab",
              "sd-Arab-PK",
              "sd-Deva",
              "sd-Deva-IN",
              "se",
              "se-FI",
              "se-NO",
              "se-SE",
              "seh",
              "seh-MZ",
              "ses",
              "ses-ML",
              "sg",
              "sg-CF",
              "shi",
              "shi-Latn",
              "shi-Latn-MA",
              "shi-Tfng",
              "shi-Tfng-MA",
              "si",
              "si-LK",
              "sk",
              "sk-SK",
              "sl",
              "sl-SI",
              "smn",
              "smn-FI",
              "sn",
              "sn-ZW",
              "so",
              "so-DJ",
              "so-ET",
              "so-KE",
              "so-SO",
              "sq",
              "sq-AL",
              "sq-MK",
              "sq-XK",
              "sr",
              "sr-Cyrl",
              "sr-Cyrl-BA",
              "sr-Cyrl-ME",
              "sr-Cyrl-RS",
              "sr-Cyrl-XK",
              "sr-Latn",
              "sr-Latn-BA",
              "sr-Latn-ME",
              "sr-Latn-RS",
              "sr-Latn-XK",
              "su",
              "su-Latn",
              "su-Latn-ID",
              "sv",
              "sv-AX",
              "sv-FI",
              "sv-SE",
              "sw",
              "sw-CD",
              "sw-KE",
              "sw-TZ",
              "sw-UG",
              "ta",
              "ta-IN",
              "ta-LK",
              "ta-MY",
              "ta-SG",
              "te",
              "te-IN",
              "teo",
              "teo-KE",
              "teo-UG",
              "tg",
              "tg-TJ",
              "th",
              "th-TH",
              "ti",
              "ti-ER",
              "ti-ET",
              "tk",
              "tk-TM",
              "to",
              "to-TO",
              "tr",
              "tr-CY",
              "tr-TR",
              "tt",
              "tt-RU",
              "twq",
              "twq-NE",
              "tzm",
              "tzm-MA",
              "ug",
              "ug-CN",
              "uk",
              "uk-UA",
              "ur",
              "ur-IN",
              "ur-PK",
              "uz",
              "uz-Arab",
              "uz-Arab-AF",
              "uz-Cyrl",
              "uz-Cyrl-UZ",
              "uz-Latn",
              "uz-Latn-UZ",
              "vai",
              "vai-Latn",
              "vai-Latn-LR",
              "vai-Vaii",
              "vai-Vaii-LR",
              "vi",
              "vi-VN",
              "vun",
              "vun-TZ",
              "wae",
              "wae-CH",
              "wo",
              "wo-SN",
              "xh",
              "xh-ZA",
              "xog",
              "xog-UG",
              "yav",
              "yav-CM",
              "yi",
              "yi-001",
              "yo",
              "yo-BJ",
              "yo-NG",
              "yue",
              "yue-Hans",
              "yue-Hans-CN",
              "yue-Hant",
              "yue-Hant-HK",
              "zgh",
              "zgh-MA",
              "zh",
              "zh-Hans",
              "zh-Hans-CN",
              "zh-Hans-HK",
              "zh-Hans-MO",
              "zh-Hans-SG",
              "zh-Hant",
              "zh-Hant-HK",
              "zh-Hant-MO",
              "zh-Hant-TW",
              "zu",
              "zu-ZA"
            ],
            "default": "ucs_basic"
          }
        }
      },
      "PrimitiveProperty": {
        "type": "object",
        "description": "Primitive types for the property.\n\nWe expect dates to be in the ISO-8601 format, while timestamps are expected to be an epoch value with\nmillisecond precision. JSON values have to be valid JSON fragments. The maximum allowed size for a JSON\nobject is 40960 bytes. For list of json values, the size of the entire list must be within this limit.\nThe maximum allowed length of a key is 128, while the maximum allowed size of a value is 10240 bytes\nand you can have up to 256 key-value pairs.\n",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "boolean",
              "float32",
              "float64",
              "int32",
              "int64",
              "timestamp",
              "date",
              "json"
            ]
          },
          "unit": {
            "type": "object",
            "description": "The unit of the data stored in this property, can only be assign to type float32 or float64.\nExternalId needs to match with a unit in the Cognite unit catalog.\n",
            "required": [
              "externalId"
            ],
            "example": "externalId: temperature:deg_c, sourceUnit: Celsius\n",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              },
              "sourceUnit": {
                "type": "string"
              }
            }
          },
          "list": {
            "description": "Specifies that the data type is a list of values. The ordering of values is preserved.\n",
            "type": "boolean",
            "default": false
          },
          "maxListSize": {
            "type": "integer",
            "description": "Specifies the maximum number of values in the list"
          }
        }
      },
      "CDFExternalIdReference": {
        "type": "object",
        "description": "An external-id reference to an existing CDF resource type item, such as a time series.\n\nAn example could be that for an existing time series stored in the CDF time series resource type with the\nexternal-id 21PT0293, then the value would be set to \"21PT029\", and the type would be set to \"timeseries\". There\nare no referential integrity guarantees for this, and the client should handle if the time series has been removed\nor the client may not have access to it.\n\nCurrently, time series, sequence and file references are supported.\n",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "timeseries",
              "file",
              "sequence"
            ]
          },
          "list": {
            "description": "Specifies that the data type is a list of values. The ordering of values is preserved.\n",
            "type": "boolean",
            "default": false
          },
          "maxListSize": {
            "type": "integer",
            "description": "Specifies the maximum number of values in the list"
          }
        }
      },
      "ViewDirectNodeRelation": {
        "description": "Direct node relation. Can include a hint to specify the view that this direct relation points to. This hint is optional.",
        "allOf": [
          {
            "$ref": "#/components/schemas/DirectNodeRelation"
          },
          {
            "type": "object",
            "properties": {
              "source": {
                "description": "The hint showing the view what the direct relation points to.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ViewReference"
                  }
                ]
              }
            }
          }
        ]
      },
      "DirectNodeRelation": {
        "type": "object",
        "description": "Direct node relation",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "direct"
            ]
          },
          "container": {
            "description": "The (optional) required type for the node the direct relation points to. If specified, the node must exist before the direct relation is referenced and of the specified type. If no container specification is used, the node will be auto created with the built-in ```node``` container type, and it does not explicitly have to be created before the node that references it.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ContainerReference"
              }
            ]
          },
          "list": {
            "description": "Specifies that the data type is a list of values. The ordering of values is preserved.\n",
            "type": "boolean",
            "default": false
          },
          "maxListSize": {
            "type": "integer",
            "description": "Specifies the maximum number of values in the list"
          }
        }
      },
      "EnumProperty": {
        "type": "object",
        "description": "An enum type property.\n\nAn enum property can only consist for predefined values.\n",
        "required": [
          "type",
          "values"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "enum"
            ]
          },
          "unknownValue": {
            "type": "string",
            "description": "The value to use when the enum value is unknown.\nThis can optionally be used to provide forward-compatibility, Specifying what value to use if the client does not recognize the returned value. It is not possible to ingest the unknown value, but it must be part of the allowed values."
          },
          "values": {
            "type": "object",
            "description": "A set of all possible values for the enum property.  The enum value identifier has to have a length of between 1 and 127 characters.  It must also match the pattern ```^[_A-Za-z][_0-9A-Za-z]{0,127}$```.\n\nExample: ```{ \"value1\": { \"name\": \"Value 1\", \"description\": \"This is value 1\" }, \"value2\": { } }```",
            "additionalProperties": {
              "x-additionalPropertiesName": "enumValueIdentifier",
              "minProperties": 1,
              "maxProperties": 32,
              "allOf": [
                {
                  "$ref": "#/components/schemas/EnumValueProperties"
                }
              ]
            }
          }
        },
        "example": {
          "unknownValue": "unknown",
          "values": {
            "value1": {
              "name": "Value 1",
              "description": "This is value 1"
            },
            "value2": {},
            "unknown": {
              "name": "Unknown",
              "description": "Used if the client does not recognize the returned value."
            }
          }
        }
      },
      "EnumValueProperties": {
        "type": "object",
        "description": "Metadata of the enum value.",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the enum value.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "description": "Description of the enum value.",
            "maxLength": 1024
          }
        }
      },
      "InstanceType": {
        "description": "The type of instance",
        "type": "string",
        "default": "node",
        "enum": [
          "node",
          "edge"
        ]
      },
      "ViewOrContainer": {
        "type": "object",
        "description": "View or container holding properties",
        "additionalProperties": {
          "description": "Properties in the view/container of the instance",
          "x-additionalPropertiesName": "view-or-container-identifier",
          "allOf": [
            {
              "$ref": "#/components/schemas/PropertyValueGroupV3"
            }
          ]
        }
      },
      "UsedFor": {
        "type": "string",
        "description": "Should this operation apply to nodes, edges or both.",
        "enum": [
          "node",
          "edge",
          "all"
        ],
        "default": "node"
      },
      "DMSFilterProperty": {
        "title": "property",
        "description": "A reference to either a DMS base property or a container property.\nFor nodes the DMS base properties are `instanceType`, `version`,\n`space`, `externalId`, `type`, `createdTime`, `lastUpdatedTime`,\nand `deletedTime`. For edges the DMS base properties\nare all of the node base properties with the addition of\n`startNode` and `endNode`.\n\nReferences to DMS base properties are on the form\n`[\"node\", \"identifier\"]` or `[\"edge\", \"identifier\"]` where\n`identifier` is a DMS base property.\n\nContainer properties can be referenced either through a view\n or through the container where it is defined.\n- To reference a property through the container where it\n    is defined the format is\n    `[\"space\", \"externalId\", \"identifier\"]` where `space`,\n    `externalId` is the space and\n    externalId of the container and `identifier` is one of the\n    property identifiers defined in the container.\n- To reference a property through one of the views mapping it the format\n  is `[\"space\", \"externalId/version\", \"identifier\"]`\n  where `space`, `externalId`, `version` is the space, externalId,\n  and version of the view respectively, and `identifier` is one of the\n  property identifiers defined in the view.\n",
        "type": "array",
        "minItems": 1,
        "items": {
          "type": "string"
        }
      },
      "DMSExistsFilter": {
        "type": "object",
        "title": "exists",
        "required": [
          "exists"
        ],
        "properties": {
          "exists": {
            "required": [
              "property"
            ],
            "description": "Will match items that have a value in the specified property.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DMSFilterProperty"
              }
            }
          }
        }
      },
      "StreamResponse": {
        "type": "object",
        "title": "streamResponse",
        "description": "Stream response.\n",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "title": "streamItems",
            "description": "List of streams.\n",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/StreamResponseItem"
                }
              ]
            }
          }
        }
      },
      "StreamCreateConflict": {
        "type": "object",
        "required": [
          "error"
        ],
        "properties": {
          "error": {
            "type": "object",
            "description": "Details about the duplicated stream id.\n",
            "required": [
              "code",
              "message"
            ],
            "properties": {
              "code": {
                "type": "integer",
                "description": "The HTTP status code returned.\n",
                "format": "int32",
                "example": 409,
                "enum": [
                  409
                ]
              },
              "message": {
                "type": "string",
                "description": "The error which describes the issue.\n"
              },
              "duplicated": {
                "type": "array",
                "description": "Single stream item in the list that is not unique.\n",
                "items": {
                  "$ref": "#/components/schemas/StreamResponseItem"
                },
                "minItems": 1,
                "maxItems": 1
              }
            }
          }
        }
      },
      "StreamRequestItem": {
        "type": "object",
        "title": "stream request item",
        "description": "Stream object.\n",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "type": "string",
            "title": "streamId",
            "description": "Stream identifier. The identifier must be unique within the project and must be a valid stream identifier.\nStream identifiers can only consist of alphanumeric characters, hyphens, and underscores. It must not start with cdf_ or cognite_, as those are reserved for future use.\nStream id cannot be logs or records. Max length is 100 characters.\n",
            "pattern": "^[a-z]([a-z0-9_-]{0,98}[a-z0-9])?$",
            "minLength": 1,
            "maxLength": 100,
            "example": "test_stream_1"
          }
        }
      },
      "StreamResponseItem": {
        "type": "object",
        "title": "streamItem",
        "description": "Stream object.\n",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "type": "string",
            "title": "streamId",
            "description": "Stream identifier.\n",
            "example": "test1"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "IngestRecordsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "title": "recordItems",
            "description": "List of records to ingest.\n",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecordIngest"
                }
              ]
            }
          }
        }
      },
      "FilterRecordsRequest": {
        "allOf": [
          {
            "type": "object",
            "description": "Defines a filter request. This will let you fetch records with some necessary properties filtered by different criteria.\n",
            "required": [
              "createdTime"
            ],
            "properties": {
              "createdTime": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CreatedTimeFilter"
                  }
                ]
              },
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterDefinitionIla"
                  }
                ]
              },
              "sources": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SourceSelector"
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/LimitWithDefault10"
          },
          {
            "$ref": "#/components/schemas/Sort"
          }
        ]
      },
      "SyncRecordsRequest": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "sources": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SourceSelector"
                  }
                ]
              },
              "filter": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterDefinitionIla"
                  }
                ]
              },
              "cursor": {
                "type": "string",
                "description": "A cursor returned from the previous sync request.\n",
                "minLength": 1,
                "maxLength": 100500,
                "example": "c29tZSBjdXJzb3I="
              },
              "initializeCursor": {
                "type": "string",
                "description": "The format is \"`duration`-ago\", where duration is a correct duration representation: 3m, 400h, 25d, etc.\nFor instance, \"2d-ago\" will give a stream of changes ingested up to 2 days ago.\n\nIf ```cursor``` is not set, ```initializeCursor``` is used to choose a shift where to start the stream reading.\nIf ```initializeCursor``` is not set, the ```cursor``` is required. If the ```cursor``` is provided, ```initializeCursor``` is ignored.\n\nNote that ```initializeCursor``` is not exact; a deviation up to few seconds can occur.\n",
                "minLength": 6,
                "maxLength": 500,
                "example": "42d-ago"
              }
            }
          },
          {
            "$ref": "#/components/schemas/LimitWithDefault10"
          }
        ]
      },
      "AggregateRecordsRequest": {
        "description": "Defines an aggregation request. This will let you aggregate supported data types. The request\nsupports filters, and allows optional search matching.\n",
        "type": "object",
        "required": [
          "aggregates",
          "createdTime"
        ],
        "properties": {
          "createdTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CreatedTimeFilter"
              }
            ]
          },
          "filter": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FilterDefinitionIla"
              }
            ]
          },
          "aggregates": {
            "description": "A dictionary of requested aggregates with client defined names/identifiers.\n\n<u>Example:</u>\n\n```\n{\n  \"my_aggr_1\": {\n    \"min\": {\"property\": [\"space1\", \"container1\", \"property1\"]}\n  },\n  \"my_aggr_2\": {\n    \"uniqueValues\": {\n      \"property\": [\"space1\", \"container2\", \"property1\"],\n      \"aggregates\": {\n        \"my_sub_aggr\": {\n          \"avg\": {\"property\": [\"space2\", \"container1\", \"property3\"]}\n        }\n      }\n    }\n  },\n}\n```\n\nMax number of (sub-)aggregate trees on a level is 5, Max aggregate tree depth is 5. Max number of aggregates in the forest is 16.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/AggregatesDefinitionIla"
              }
            ]
          }
        }
      },
      "RecordIngest": {
        "type": "object",
        "title": "recordItem",
        "description": "Record to ingest.\n",
        "required": [
          "space",
          "sources"
        ],
        "properties": {
          "space": {
            "description": "Id of the space that the ```record``` belongs to.\n",
            "example": "mySpace",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "sources": {
            "type": "array",
            "title": "propertiesPerContainer",
            "description": "List of source properties to write. The properties are from the container(s) making up this ```record```.\n",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/RecordData"
                }
              ]
            }
          }
        }
      },
      "RecordData": {
        "type": "object",
        "description": "Property values for the identified/specified container.\n",
        "required": [
          "source",
          "properties"
        ],
        "properties": {
          "source": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ContainerReferenceIla"
              }
            ]
          },
          "properties": {
            "title": "containerProperties",
            "allOf": [
              {
                "$ref": "#/components/schemas/PropertyValueGroupV3"
              }
            ]
          }
        }
      },
      "SourceSelector": {
        "type": "array",
        "title": "propertiesPerContainer",
        "description": "List of containers and their properties which values should be selected for the response.\n",
        "minItems": 1,
        "maxItems": 10,
        "items": {
          "type": "object",
          "title": "propertiesForContainer",
          "required": [
            "source",
            "properties"
          ],
          "properties": {
            "source": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ContainerReferenceIla"
                }
              ]
            },
            "properties": {
              "type": "array",
              "title": "containerProperties",
              "description": "Properties to return for the specified container. Use \"*\" to return all properties.\n",
              "minItems": 1,
              "maxItems": 1000,
              "items": {
                "type": "string",
                "minLength": 1,
                "maxLength": 255,
                "example": "someProperty"
              }
            }
          }
        }
      },
      "ContainerReferenceIla": {
        "type": "object",
        "title": "containerReference",
        "description": "Reference to a container.\n",
        "example": {
          "type": "container,",
          "space": "mySpace,",
          "externalId": "myContainer"
        },
        "allOf": [
          {
            "$ref": "#/components/schemas/ContainerReference"
          }
        ]
      },
      "FilterDefinitionIla": {
        "type": "object",
        "title": "filter",
        "description": "A filter Domain Specific Language (DSL) used to create advanced filter queries.\n\nNote: the max number of nodes in the filter tree is 100 and the max tree depth is 10.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/BoolFilterIla"
          },
          {
            "$ref": "#/components/schemas/LeafFilterIla"
          }
        ],
        "example": {
          "and": [
            {
              "containsAll": {
                "property": [
                  "mySpace",
                  "myContainer",
                  "myProperty"
                ],
                "values": [
                  10011,
                  10012
                ]
              }
            },
            {
              "range": {
                "property": [
                  "my_space",
                  "my_container",
                  "my_weight"
                ],
                "gte": 0
              }
            }
          ]
        }
      },
      "BoolFilterIla": {
        "type": "object",
        "title": "boolFilter",
        "description": "Build a new query by combining other queries, using boolean operators. We support the `and`, `or`, and\n`not` boolean operators.\n",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "type": "array",
                "description": "All the sub-clauses in the query must return a matching record.\n",
                "minItems": 1,
                "maxItems": 99,
                "items": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/FilterDefinitionIla"
                    }
                  ]
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "type": "array",
                "description": "One or more of the sub-clauses in the query must return a matching record.\n",
                "minItems": 1,
                "maxItems": 99,
                "items": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/FilterDefinitionIla"
                    }
                  ]
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "type": "object",
                "title": "not",
                "description": "None of the sub-clauses in the query can return a matching record.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterDefinitionIla"
                  }
                ]
              }
            }
          }
        ]
      },
      "LeafFilterIla": {
        "type": "object",
        "title": "leafFilter",
        "description": "Leaf filter which is used in boolean filters to build advanced queries to filter out some records.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/MatchAllFilter"
          },
          {
            "$ref": "#/components/schemas/ExistsFilterIla"
          },
          {
            "$ref": "#/components/schemas/EqualsFilterIla"
          },
          {
            "$ref": "#/components/schemas/HasDataFilterIla"
          },
          {
            "$ref": "#/components/schemas/PrefixFilterIla"
          },
          {
            "$ref": "#/components/schemas/RangeFilterIla"
          },
          {
            "$ref": "#/components/schemas/InFilterIla"
          },
          {
            "$ref": "#/components/schemas/ContainsAllFilterIla"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyFilterIla"
          }
        ]
      },
      "ExistsFilterIla": {
        "type": "object",
        "title": "exists",
        "required": [
          "exists"
        ],
        "properties": {
          "exists": {
            "type": "object",
            "description": "Will match records that have a value in the specified property.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertyNoTopLevelIla"
                  }
                ]
              }
            }
          }
        }
      },
      "EqualsFilterIla": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "type": "object",
            "description": "Matches records that contain the exact value in the provided property.\nOnly apply this filter to properties containing a single value.\n",
            "required": [
              "property",
              "value"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertyAllTopLevelIla"
                  }
                ]
              },
              "value": {
                "title": "value",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RawPropertyValueV3"
                  }
                ]
              }
            }
          }
        }
      },
      "HasDataFilterIla": {
        "type": "object",
        "title": "hasData",
        "required": [
          "hasData"
        ],
        "properties": {
          "hasData": {
            "type": "array",
            "title": "containerItems",
            "minItems": 1,
            "maxItems": 10,
            "description": "Matches records where data is present in the referenced containers.\n",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ContainerReferenceIla"
                }
              ]
            }
          }
        }
      },
      "PrefixFilterIla": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "type": "object",
            "description": "Matches records that have the prefix in the identified property. This filter is only supported for\nsingle value text properties.\n",
            "required": [
              "property",
              "value"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertySpaceTopLevelIla"
                  }
                ]
              },
              "value": {
                "type": "string",
                "title": "prefixValue",
                "minLength": 1,
                "maxLength": 500
              }
            }
          }
        }
      },
      "RangeFilterIla": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "type": "object",
            "description": "Matches records that contain terms within the provided range.\n\nThe range must include an upper and/or a lower bound. It is not allowed to specify two upper or lower bounds, e.g. `gte` and `gt`, in the same filter.\n\n  `gte`: Greater than or equal to.\n  `gt`: Greater than.\n  `lte`: Less than or equal to.\n  `lt`: Less than.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertyCreatedTimeTopLevelIla"
                  }
                ]
              },
              "gte": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RangeValue"
                  }
                ]
              },
              "gt": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RangeValue"
                  }
                ]
              },
              "lte": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RangeValue"
                  }
                ]
              },
              "lt": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RangeValue"
                  }
                ]
              }
            }
          }
        }
      },
      "InFilterIla": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "type": "object",
            "description": "Matches records where the property **exactly** matches one of the given values.\nOnly apply this filter to properties containing a single value.\n",
            "required": [
              "property",
              "values"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertyAllTopLevelIla"
                  }
                ]
              },
              "values": {
                "title": "values",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RawPropertyValueListIla"
                  }
                ]
              }
            }
          }
        }
      },
      "ContainsAllFilterIla": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "type": "object",
            "description": "Matches records where the property contains all the given values.\nOnly apply this filter to multivalued properties.\n",
            "required": [
              "property",
              "values"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertyNoTopLevelIla"
                  }
                ]
              },
              "values": {
                "title": "values",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RawPropertyValueListIla"
                  }
                ]
              }
            }
          }
        }
      },
      "ContainsAnyFilterIla": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "type": "object",
            "description": "Matches records where the property contains one or more of the given values.\nOnly apply this filter to multivalued properties.\n",
            "required": [
              "property",
              "values"
            ],
            "properties": {
              "property": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FilterPropertyNoTopLevelIla"
                  }
                ]
              },
              "values": {
                "title": "values",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/RawPropertyValueListIla"
                  }
                ]
              }
            }
          }
        }
      },
      "RawPropertyValueListIla": {
        "description": "A list of values describing the type of the defined property",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "allOf": [
            {
              "$ref": "#/components/schemas/RawPropertyValueV3"
            }
          ]
        }
      },
      "CreatedTimeFilter": {
        "type": "object",
        "title": "createdTime",
        "description": "Matches records with the created time within the provided range.\nThis attribute is mandatory, and maximum time interval that can be defined by it\nis limited by the stream configuration. If more data needs to be queried than allowed by the stream\nconfiguration, it should be done with multiple requests. For example, if stream allows querying\nup to 1 month of data, but a quarterly report is needed, the solution is to make 3 requests, one for\neach month, and then aggregate the responses.\n\nThe range must include at least a left (`gt` or `gte`) bound.\nIt is not allowed to specify two upper or lower bounds, e.g. `gte` and `gt`, in the same filter.\n\n  `gte`: Greater than or equal to.\n  `gt`: Greater than.\n  `lte`: Less than or equal to.\n  `lt`: Less than.\n\nNote: `createdTime` is a CDF generated timestamp that marks the moment a record is stored in the API\n",
        "properties": {
          "gte": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CreatedTimeRangeValue"
              }
            ]
          },
          "gt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CreatedTimeRangeValue"
              }
            ]
          },
          "lte": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CreatedTimeRangeValue"
              }
            ]
          },
          "lt": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CreatedTimeRangeValue"
              }
            ]
          }
        },
        "example": {
          "gt": 1705341600000,
          "lt": "2030-05-15T18:00:00.00Z"
        }
      },
      "CreatedTimeRangeValue": {
        "oneOf": [
          {
            "type": "string",
            "minLength": 1,
            "maxLength": 100
          },
          {
            "type": "integer"
          }
        ],
        "title": "createdTimeRangeBound",
        "description": "Timestamp value you wish to find in the ```record``` created time using a range clause.\n"
      },
      "LimitWithDefault10": {
        "type": "object",
        "title": "limit",
        "properties": {
          "limit": {
            "type": "integer",
            "description": "Limits the number of results to return.\n",
            "default": 10,
            "minimum": 1,
            "maximum": 1000,
            "example": 42
          }
        }
      },
      "Sort": {
        "type": "object",
        "title": "sortsSpecification",
        "properties": {
          "sort": {
            "type": "array",
            "title": "orderedSortSpecList",
            "description": "Ordered list of sorting specifications (property, direction, etc) to sort on.\n",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/PropertySort"
                }
              ]
            }
          }
        }
      },
      "PropertySort": {
        "type": "object",
        "title": "sortSpecification",
        "description": "Sorting spec for a property.\n",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SortPropertyIla"
              }
            ]
          },
          "direction": {
            "type": "string",
            "default": "ascending",
            "enum": [
              "ascending",
              "descending"
            ],
            "example": "descending"
          }
        }
      },
      "AggregatesDefinitionIla": {
        "type": "object",
        "title": "aggregatesDictionary",
        "minProperties": 1,
        "maxProperties": 5,
        "uniqueItems": true,
        "additionalProperties": {
          "x-additionalPropertiesName": "aggregate-id",
          "title": "aggregateDictionary",
          "type": "object",
          "description": "An aggregate. It's an aggregate identifier which map to an aggregator function, and some fields to use for the aggregator function.\nThe identifiers should match the next constraints:\n  pattern: \"^[A-Za-z_][A-Za-z0-9_]*$\"\n  maxLength: 255\n  minLength: 1\n",
          "oneOf": [
            {
              "$ref": "#/components/schemas/AvgAggregateIla"
            },
            {
              "$ref": "#/components/schemas/CountAggregateIla"
            },
            {
              "$ref": "#/components/schemas/MinAggregateIla"
            },
            {
              "$ref": "#/components/schemas/MaxAggregateIla"
            },
            {
              "$ref": "#/components/schemas/SumAggregateIla"
            },
            {
              "$ref": "#/components/schemas/UniqueValuesAggregateIla"
            },
            {
              "$ref": "#/components/schemas/NumberHistogramAggregateIla"
            },
            {
              "$ref": "#/components/schemas/TimeHistogramAggregateIla"
            },
            {
              "$ref": "#/components/schemas/MovingFunctionAggregateIla"
            },
            {
              "$ref": "#/components/schemas/FiltersAggregateIla"
            }
          ]
        },
        "propertyNames": {
          "maxLength": 255,
          "minLength": 1
        },
        "example": {
          "my_avg_aggregate1": {
            "avg": {
              "property": [
                "mySpace",
                "myContainer",
                "manufacturer"
              ]
            }
          },
          "my_terms_aggregate2": {
            "uniqueValues": {
              "property": [
                "mySpace",
                "myContainer",
                "manufacturer"
              ],
              "aggregates": {
                "my_sub_aggregate1": {
                  "min": {
                    "property": [
                      "mySpace",
                      "myContainer",
                      "price"
                    ]
                  }
                },
                "my_sub_aggregate2": {
                  "max": {
                    "property": [
                      "mySpace",
                      "myContainer",
                      "price"
                    ]
                  }
                },
                "my_sub_aggregate3": {
                  "uniqueValues": {
                    "property": [
                      "mySpace",
                      "myContainer",
                      "region"
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "MovingFunctionAggregateIla": {
        "type": "object",
        "title": "movingFunction",
        "required": [
          "movingFunction"
        ],
        "properties": {
          "movingFunction": {
            "type": "object",
            "description": "Given an ordered series of data, the Moving Function aggregation will slide a window across the data and allow the user to specify a function that is executed on each window of data.\nA number of common functions are predefined such as min/max, moving averages, etc. Customer defined functions are not allowed now.\nThe aggregate must be embedded inside of a numberHistogram or timeHistogram aggregate. It can be embedded like any other metric aggregate.\n",
            "required": [
              "bucketsPath",
              "window",
              "function"
            ],
            "properties": {
              "bucketsPath": {
                "type": "string",
                "description": "Path to the metric of interest from other aggregation.\n\n<u>`buckets_path` syntax:</u>\n\n```\nAGG_SEPARATOR       =  `>` ;\nAGG_NAME            =  <the name of the aggregation> ;\nMULTIBUCKET_KEY     =  `[<KEY_NAME>]`\nKEY_NAME            =  <the name of the bucket key in the multi-bucket aggregate result> ;\nPATH                =  <AGG_NAME><MULTIBUCKET_KEY>?(<AGG_SEPARATOR><AGG_NAME>)* ;\n```\n",
                "maxLength": 1280,
                "minLength": 1,
                "example": "multi_bucket_aggr[\"top_bucket\"]>sub_aggr>sub_sub_aggr"
              },
              "window": {
                "type": "integer",
                "minimum": 1,
                "description": "The size of window to \"slide\" across the histogram.\n",
                "example": 42
              },
              "function": {
                "type": "string",
                "enum": [
                  "MovingFunctions.max",
                  "MovingFunctions.min",
                  "MovingFunctions.sum",
                  "MovingFunctions.unweightedAvg",
                  "MovingFunctions.linearWeightedAvg"
                ],
                "description": "The function that should be executed on each window of data.\n",
                "example": "MovingFunctions.sum"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "AvgAggregateIla": {
        "type": "object",
        "title": "avg",
        "required": [
          "avg"
        ],
        "properties": {
          "avg": {
            "type": "object",
            "description": "Calculates the average from the data stored by the specified property. This aggregation uses an average mean\ncalculation, and not an integral mean.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "CountAggregateIla": {
        "title": "count",
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "object",
            "description": "Counts the number of items. When you specify a property, it returns the number of non-null values for that property.\n",
            "properties": {
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "MinAggregateIla": {
        "type": "object",
        "title": "min",
        "required": [
          "min"
        ],
        "properties": {
          "min": {
            "type": "object",
            "description": "The function will calculate, and return, the lowest - min - value for a property.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "MaxAggregateIla": {
        "type": "object",
        "title": "max",
        "required": [
          "max"
        ],
        "properties": {
          "max": {
            "type": "object",
            "description": "The function will calculate, and return, the highest - max - value for the property.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "SumAggregateIla": {
        "type": "object",
        "title": "sum",
        "required": [
          "sum"
        ],
        "properties": {
          "sum": {
            "type": "object",
            "description": "Calculates the sum from the values of the specified property.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "FiltersAggregateIla": {
        "type": "object",
        "title": "filters",
        "required": [
          "filters"
        ],
        "properties": {
          "filters": {
            "type": "object",
            "description": "A multi-bucket aggregation where each bucket contains the records that match a filter from `filters list`.\n\nNote: The only 30 such buckets (filter defined) are allowed across all Filters aggregates in a single request.\n",
            "required": [
              "filters"
            ],
            "properties": {
              "filters": {
                "type": "array",
                "description": "List of filters from which to build buckets.\n",
                "minItems": 1,
                "maxItems": 10,
                "items": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/FilterDefinitionIla"
                    }
                  ]
                }
              },
              "aggregates": {
                "description": "A dictionary of requested aggregates with client defined names/identifiers.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatesDefinitionIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "UniqueValuesAggregateIla": {
        "type": "object",
        "title": "uniqueValues",
        "required": [
          "uniqueValues"
        ],
        "properties": {
          "uniqueValues": {
            "type": "object",
            "description": "Request unique value buckets aggregate on of the specified property.\nEach bucket is defined by `values` array and has the number of the `values` occurrences.\n",
            "required": [
              "property"
            ],
            "properties": {
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              },
              "aggregates": {
                "description": "A dictionary of requested aggregates with client defined names/identifiers.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatesDefinitionIla"
                  }
                ]
              },
              "size": {
                "type": "integer",
                "description": "The number of top buckets returned. The default limit is 10 items.\n",
                "minimum": 1,
                "maximum": 2000,
                "default": 10
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "NumberHistogramAggregateIla": {
        "type": "object",
        "title": "numberHistogram",
        "required": [
          "numberHistogram"
        ],
        "properties": {
          "numberHistogram": {
            "type": "object",
            "description": "A histogram aggregator function. This function will generate a histogram from the values of the specified\nproperty. It uses the specified interval as defined in your `interval` argument.\n",
            "required": [
              "property",
              "interval"
            ],
            "properties": {
              "interval": {
                "type": "number",
                "description": "The interval between each bucket.\n"
              },
              "hardBounds": {
                "type": "object",
                "description": "To limit the range of buckets in the histogram.\nIt is particularly useful in the case of open data ranges that can result in a very large number of buckets.\nOne or both bounds must be specified.\n",
                "properties": {
                  "min": {
                    "type": "number",
                    "description": "The lowest number for the histogram bucket should appear in the response.\n",
                    "example": 42
                  },
                  "max": {
                    "type": "number",
                    "description": "The highest number for the histogram bucket should appear in the response.\n",
                    "example": 777
                  }
                }
              },
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              },
              "aggregates": {
                "description": "A dictionary of requested aggregates with client defined names/identifiers.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatesDefinitionIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "TimeHistogramAggregateIla": {
        "type": "object",
        "title": "timeHistogram",
        "required": [
          "timeHistogram"
        ],
        "properties": {
          "timeHistogram": {
            "type": "object",
            "description": "A time histogram aggregator function. This function will generate a histogram from the values of the specified\nproperty. It uses the specified calendar or fixed interval as defined in the request arguments.\nThe request attribute calendarInterval or fixedInterval must be specified but not both.\n",
            "required": [
              "property"
            ],
            "properties": {
              "calendarInterval": {
                "type": "string",
                "enum": [
                  "1s",
                  "1m",
                  "1h",
                  "1d",
                  "1w",
                  "1M",
                  "1q",
                  "1y"
                ],
                "description": "The calendar interval between each bucket.\n",
                "example": "1q"
              },
              "fixedInterval": {
                "type": "string",
                "description": "The interval between each bucket. It must be a correct duration representation: 3m, 400h, 25d, etc.\n",
                "example": "42m",
                "minLength": 1,
                "maxLength": 100
              },
              "hardBounds": {
                "type": "object",
                "description": "To limit the range of buckets in the histogram.\nIt is particularly useful in the case of open data ranges that can result in a very large number of buckets.\nOne or both bounds must be specified.\n",
                "properties": {
                  "min": {
                    "type": "string",
                    "description": "The lowest time point for the histogram bucket should appear in the response. It must be correct instant time representation.\n",
                    "example": "2024-05-15T20:00:00Z",
                    "minLength": 1,
                    "maxLength": 100
                  },
                  "max": {
                    "type": "string",
                    "description": "The highest time point for the histogram bucket should appear in the response. It must be correct instant time representation.\n",
                    "example": "2024-05-16T20:00:00Z",
                    "minLength": 1,
                    "maxLength": 100
                  }
                }
              },
              "property": {
                "title": "aggregateProperty",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatePropertyIla"
                  }
                ]
              },
              "aggregates": {
                "description": "A dictionary of requested aggregates with client defined names/identifiers.\n",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/AggregatesDefinitionIla"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      "BasePropertyIla": {
        "type": "array",
        "maxItems": 3,
        "items": {
          "type": "string",
          "minLength": 1,
          "maxLength": 255
        }
      },
      "AggregatePropertyIla": {
        "title": "aggregateProperty",
        "description": "Property a client wants to aggregate.\nTo represent fully qualified properties, Records use arrays of strings.\n\nThe aggregate supports only container level properties.\nSo the property array always has 3 segments:\n  - the first segment is the space that the container belongs to,\n  - the second segment is the container external id,\n  - the third segment is the property id inside the container.\n\n<u>Example:</u>\n\nYou have the schema\n```\n{\n  \"mySpace\": {\n    \"myContainer\": {\n      \"myProperty\": {...}\n    }\n  }\n}\n```\n\nUse `[\"mySpace\", \"myContainer\", \"myProperty\"]` array to aggregate the values for `myProperty` property.\n",
        "minItems": 3,
        "example": [
          "mySpace",
          "myContainer",
          "myProperty"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePropertyIla"
          }
        ]
      },
      "SortPropertyIla": {
        "title": "sortProperty",
        "description": "Property a client wants to sort on.\nTo represent fully qualified properties, Records use arrays of strings.\nThe Records sorting supports container level properties and one top level property (`[\"space\"]`).\n\nSo the property array has 1 or 3 segments.\n1 segment property is top level property. And currently, only `space` top level property is supported to sort on.\n3 segment property is container level property.\nThe property array for container level property always has 3 segments:\n- the first segment is the space that the container belongs to,\n- the second segment is the container external id,\n- the third segment is the property id inside the container.\n\n<u>Example:</u>\n\nYou have the schema\n```\n{\n  \"mySpace\": {\n    \"myContainer\": {\n      \"myProperty\": {...}\n    }\n  }\n}\n```\n\nUse `[\"mySpace\", \"myContainer\", \"myProperty\"]` array to sort the records on `myProperty` property.\n",
        "minItems": 1,
        "example": [
          "space"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePropertyIla"
          }
        ]
      },
      "FilterPropertySpaceTopLevelIla": {
        "title": "filterPropertyWithSpaceTopLevel",
        "description": "Property a client wants to use in the filter.\nTo represent fully qualified properties, Records use arrays of strings.\nThe filter supports container level properties and one top level property (`[\"space\"]`).\n\nSo the property array has 1 or 3 segments.\n1 segment property is top level property. And currently, only `space` top level property is supported in the filter.\n3 segment property is container level property.\nThe property array for container level property has always 3 segments:\n- the first segment is the space that the container belongs to,\n- the second segment is the container external id,\n- the third segment is the property id inside the container.\n\n<u>Example:</u>\n\nYou have the schema\n```\n{\n  \"mySpace\": {\n    \"myContainer\": {\n      \"myProperty\": {...}\n    }\n  }\n}\n```\n\nUse `[\"mySpace\", \"myContainer\", \"myProperty\"]` array to filter the records based on `myProperty` property.\n",
        "minItems": 1,
        "example": [
          "space"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePropertyIla"
          }
        ]
      },
      "FilterPropertyCreatedTimeTopLevelIla": {
        "title": "filterPropertyWithCreatedTimeTopLevel",
        "description": "Property a client wants to use in the filter.\nTo represent fully qualified properties, Records use arrays of strings.\nThe filter supports container level properties and one top level property (`[\"createdTime\"]`).\n\nSo the property array has 1 or 3 segments.\n1 segment property is top level property. And currently, only `createdTime` top level property is supported in the filter.\n3 segment property is container level property.\nThe property array for container level property has always 3 segments:\n- the first segment is the space that the container belongs to,\n- the second segment is the container external id,\n- the third segment is the property id inside the container.\n\n<u>Example:</u>\n\nYou have the schema\n```\n{\n  \"mySpace\": {\n    \"myContainer\": {\n      \"myProperty\": {...}\n    }\n  }\n}\n```\n\nUse `[\"mySpace\", \"myContainer\", \"myProperty\"]` array to filter the records based on `myProperty` property.\n",
        "minItems": 1,
        "example": [
          "createdTime"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePropertyIla"
          }
        ]
      },
      "FilterPropertyAllTopLevelIla": {
        "title": "filterPropertyWithAllTopLevel",
        "description": "Property a client wants to use in the filter.\nTo represent fully qualified properties, Records use arrays of strings.\nThe filter supports container level properties and two top level properties (`[\"space\"]` and `[\"createdTime\"]`).\n\nSo the property array has 1 or 3 segments.\n1 segment property is top level property. And currently, only `space` and `createdTime` top level properties are supported in the filter.\n3 segment property is container level property.\nThe property array for container level property has always 3 segments:\n- the first segment is the space that the container belongs to,\n- the second segment is the container external id,\n- the third segment is the property id inside the container.\n\n<u>Example:</u>\n\nYou have the schema\n```\n{\n  \"mySpace\": {\n    \"myContainer\": {\n      \"myProperty\": {...}\n    }\n  }\n}\n```\n\nUse `[\"mySpace\", \"myContainer\", \"myProperty\"]` array to filter the records based on `myProperty` property.\n",
        "minItems": 1,
        "example": [
          "createdTime"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePropertyIla"
          }
        ]
      },
      "FilterPropertyNoTopLevelIla": {
        "title": "filterPropertyNoTopLevel",
        "description": "Property a client wants to use in the filter.\nTo represent fully qualified properties, Records use arrays of strings.\nThe filter supports container level properties only.\n\nSo the property array always has 3 segments:\n - the first segment is the space that the container belongs to,\n - the second segment is the container external id,\n - the third segment is the property id inside the container.\n\n<u>Example:</u>\n\nYou have the schema\n```\n{\n  \"mySpace\": {\n    \"myContainer\": {\n      \"myProperty\": {...}\n    }\n  }\n}\n```\n\nUse `[\"mySpace\", \"myContainer\", \"myProperty\"]` array to filter the records based on `myProperty` property.\n",
        "minItems": 3,
        "example": [
          "mySpace",
          "myContainer",
          "myProperty"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/BasePropertyIla"
          }
        ]
      },
      "AggregatesResultDefinitionIla": {
        "type": "object",
        "title": "aggregatesResultDictionary",
        "description": "A dictionary of the results for the requested aggregates mapped by the aggregates identifiers.\n\n<u>Example:</u>\n\n```\n{\n  \"my_aggr_1\": {\n    \"avg\": 42\n  },\n  \"my_aggr_2\": {\n    \"max\": 69\n  },\n}\n```\n",
        "uniqueItems": true,
        "additionalProperties": {
          "x-additionalPropertiesName": "aggregate-id",
          "type": "object",
          "title": "aggregateResultDictionary",
          "description": "Requested aggregate result. It's the aggregate identifier from the request and a set of fields to represent aggregated data.\n",
          "oneOf": [
            {
              "$ref": "#/components/schemas/AvgAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/CountAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/MinAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/MaxAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/SumAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/UniqueValuesAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/NumberHistogramAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/TimeHistogramAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/MovingFunctionAggregateResultIla"
            },
            {
              "$ref": "#/components/schemas/FiltersAggregateResultIla"
            }
          ]
        },
        "example": {
          "my_avg_aggregate1": {
            "avg": 42
          },
          "my_terms_aggregate2": {
            "buckets": [
              {
                "value": "Cognite",
                "count": 42,
                "aggregates": {
                  "my_sub_aggregate1": {
                    "min": 13
                  },
                  "my_sub_aggregate2": {
                    "max": 69
                  },
                  "my_sub_aggregate3": {
                    "buckets": [
                      {
                        "value": "us1",
                        "count": 42
                      },
                      {
                        "value": "ie1",
                        "count": 7
                      }
                    ]
                  }
                }
              },
              {
                "value": "AkerBP",
                "count": 21,
                "aggregates": {
                  "my_sub_aggregate1": {
                    "min": 99
                  },
                  "my_sub_aggregate2": {
                    "max": 999
                  },
                  "my_sub_aggregate3": {
                    "buckets": [
                      {
                        "value": "us1",
                        "count": 11
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      "MovingFunctionAggregateResultIla": {
        "type": "object",
        "title": "movingFunctionResult",
        "required": [
          "fnValue"
        ],
        "properties": {
          "fnValue": {
            "type": "number",
            "description": "The moving function value from the parent histogram aggregate buckets data located by the specified in the request buckets path.\n",
            "example": 42.7
          }
        }
      },
      "AvgAggregateResultIla": {
        "type": "object",
        "title": "avgResult",
        "required": [
          "avg"
        ],
        "properties": {
          "avg": {
            "type": "number",
            "description": "The average value from the data stored by the specified in the request property.\n",
            "example": 42.7
          }
        }
      },
      "CountAggregateResultIla": {
        "type": "object",
        "title": "countResult",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "format": "int64",
            "description": "The number of non-null values for specified in the request property.\n",
            "example": 42
          }
        }
      },
      "MinAggregateResultIla": {
        "type": "object",
        "title": "minResult",
        "required": [
          "min"
        ],
        "properties": {
          "min": {
            "type": "number",
            "description": "The lowest - min - value for the specified in the request property.\n",
            "example": 13.42
          }
        }
      },
      "MaxAggregateResultIla": {
        "type": "object",
        "title": "maxResult",
        "required": [
          "max"
        ],
        "properties": {
          "max": {
            "type": "number",
            "description": "The highest - max - value for the specified in the request property.\n",
            "example": 77.7
          }
        }
      },
      "SumAggregateResultIla": {
        "type": "object",
        "title": "sumResult",
        "required": [
          "sum"
        ],
        "properties": {
          "sum": {
            "type": "number",
            "description": "The sum from the values of the specified in the request property.\n",
            "example": 777
          }
        }
      },
      "FiltersAggregateResultIla": {
        "type": "object",
        "title": "filtersResult",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "Filter buckets of the specified in the request filters.\n",
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The count of items matching the filter for the bucket.\n",
                  "example": 42
                },
                "aggregates": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/AggregatesResultDefinitionIla"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "UniqueValuesAggregateResultIla": {
        "type": "object",
        "title": "uniqueValuesResult",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "Unique value buckets on of the specified in the request property.\n",
            "items": {
              "type": "object",
              "required": [
                "count",
                "value"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The count of items with the value in the property.\n",
                  "example": 42
                },
                "value": {
                  "title": "aggregateValue",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/AggregateValue"
                    }
                  ]
                },
                "aggregates": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/AggregatesResultDefinitionIla"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "NumberHistogramAggregateResultIla": {
        "type": "object",
        "title": "numberHistogramResult",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "The histogram from the values of the specified in the request property.\n",
            "items": {
              "type": "object",
              "required": [
                "count",
                "intervalStart"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The count of items with the value from the bucket interval in the property.\n",
                  "example": 100
                },
                "intervalStart": {
                  "type": "number",
                  "description": "The number which represents the start of the bucket interval (the next bucket start point is the end point for this bucket).\n",
                  "example": 42.7
                },
                "aggregates": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/AggregatesResultDefinitionIla"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "TimeHistogramAggregateResultIla": {
        "type": "object",
        "title": "timeHistogramResult",
        "properties": {
          "buckets": {
            "type": "array",
            "description": "The histogram from the values of the specified in the request property.\n",
            "items": {
              "type": "object",
              "required": [
                "count",
                "intervalStart"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The count of items with the value from the bucket interval in the property.\n",
                  "example": 100
                },
                "intervalStart": {
                  "type": "string",
                  "description": "The time point which represent the start of the bucket interval (the next bucket start point is the end point for this bucket).\n",
                  "example": "2024-05-16T00:00:00Z"
                },
                "aggregates": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/AggregatesResultDefinitionIla"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "Record": {
        "type": "object",
        "title": "recordItem",
        "description": "Record item.\n",
        "required": [
          "space",
          "createdTime",
          "properties"
        ],
        "properties": {
          "space": {
            "description": "Id of the space that the ```record``` belongs to.\n",
            "example": "mySpace",
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "createdTime": {
            "title": "createdTime",
            "example": 1720616232,
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "properties": {
            "type": "object",
            "title": "spaceToContainers",
            "description": "Spaces to containers to properties and their values for the requested containers.\n",
            "uniqueItems": true,
            "additionalProperties": {
              "x-additionalPropertiesName": "space-name",
              "allOf": [
                {
                  "$ref": "#/components/schemas/ContainerWithData"
                }
              ]
            }
          }
        }
      },
      "ContainerWithData": {
        "type": "object",
        "title": "containerToProperties",
        "description": "Container holding properties.\n",
        "uniqueItems": true,
        "additionalProperties": {
          "description": "Properties in the container of the ```record```.\n",
          "x-additionalPropertiesName": "container-identifier",
          "title": "propertyToValues",
          "allOf": [
            {
              "$ref": "#/components/schemas/PropertyValueGroupV3"
            }
          ]
        }
      },
      "RecordStatus": {
        "type": "object",
        "title": "statusItem",
        "description": "Record ingestion status item.\n",
        "required": [
          "status"
        ],
        "oneOf": [
          {
            "type": "object",
            "title": "success",
            "required": [
              "status"
            ],
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "success"
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "fail",
            "required": [
              "status",
              "code",
              "message"
            ],
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "fail"
                ]
              },
              "code": {
                "type": "integer",
                "description": "HTTP status code.",
                "format": "int32",
                "example": 401
              },
              "message": {
                "type": "string",
                "description": "Error message.",
                "example": "Could not authenticate."
              },
              "parameters": {
                "type": "object",
                "title": "errorContext",
                "description": "A map of parameters to handle the error better.\n",
                "uniqueItems": true,
                "additionalProperties": {
                  "description": "Properties in the container of the ```record```.\n",
                  "x-additionalPropertiesName": "parameter-name",
                  "title": "parameterToValues"
                },
                "example": {
                  "defaultLimit": 100,
                  "overrideLimit": 1000,
                  "reachedValue": 1042,
                  "type": "rate"
                }
              }
            }
          }
        ]
      },
      "EventType": {
        "maxLength": 64,
        "type": "string",
        "description": "Type of the event, e.g 'failure'."
      },
      "SetEventType": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/EventType"
          }
        }
      },
      "EventSubType": {
        "maxLength": 64,
        "type": "string",
        "description": "SubType of the event, e.g 'electrical'."
      },
      "SetEventSubType": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/EventSubType"
          }
        }
      },
      "InternalId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "ExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "EventSource": {
        "maxLength": 128,
        "type": "string",
        "description": "The source of this event."
      },
      "SetEventSource": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/EventSource"
          }
        }
      },
      "EventDescription": {
        "maxLength": 500,
        "type": "string",
        "description": "Textual description of the event."
      },
      "DataEvent": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Event"
            }
          }
        }
      },
      "DataExternalEvent": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalEvent"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "DataEventChange": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EventChange"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "EitherId": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/InternalId"
          },
          {
            "$ref": "#/components/schemas/ExternalId"
          }
        ]
      },
      "EventDataIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/EitherId"
                },
                "maxItems": 1000,
                "minItems": 1
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DataWithCursorEvent": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Event"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next or previous page of results."
      },
      "EventMetadata": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 128 bytes, value 128000 bytes, up to 256 key-value pairs, of total size at most 200000.",
        "additionalProperties": {
          "type": "string",
          "maxLength": 128000
        },
        "x-maxKeyLength": 128,
        "x-maxTotalSize": 200000,
        "maxProperties": 256
      },
      "Event": {
        "allOf": [
          {
            "$ref": "#/components/schemas/InternalEvent"
          },
          {
            "$ref": "#/components/schemas/InternalId"
          },
          {
            "type": "object",
            "required": [
              "createdTime",
              "lastUpdatedTime"
            ],
            "properties": {
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        ]
      },
      "InternalEvent": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "dataSetId": {
            "description": "The id of the dataset this event belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "type": {
            "$ref": "#/components/schemas/EventType"
          },
          "subtype": {
            "$ref": "#/components/schemas/EventSubType"
          },
          "description": {
            "maxLength": 500,
            "type": "string",
            "description": "Textual description of the event."
          },
          "metadata": {
            "$ref": "#/components/schemas/EventMetadata"
          },
          "assetIds": {
            "type": "array",
            "uniqueItems": true,
            "description": "Asset IDs of equipment that this event relates to.",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "source": {
            "maxLength": 128,
            "type": "string",
            "description": "The source of this event."
          }
        },
        "description": "An event represents something that happened at a given interval in time, for example, a failure, a work order, etc."
      },
      "ExternalEvent": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "dataSetId": {
            "description": "The id of the dataset this event belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "type": {
            "$ref": "#/components/schemas/EventType"
          },
          "subtype": {
            "$ref": "#/components/schemas/EventSubType"
          },
          "description": {
            "$ref": "#/components/schemas/EventDescription"
          },
          "metadata": {
            "$ref": "#/components/schemas/EventMetadata"
          },
          "assetIds": {
            "type": "array",
            "minItems": 0,
            "maxItems": 10000,
            "uniqueItems": true,
            "description": "Asset IDs of equipment that this event relates to.",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "source": {
            "$ref": "#/components/schemas/EventSource"
          }
        },
        "description": "An event represents something that happened at a given interval in time, e.g a failure, a work order, etc."
      },
      "EventAggregateRequest": {
        "description": "Aggregation request of events. Filters behave the same way as for the `filter` endpoint. Default aggregation is `count`.",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EventCountAggregate"
          },
          {
            "$ref": "#/components/schemas/EventWithPropertyCountAggregate"
          },
          {
            "$ref": "#/components/schemas/EventCardinalityValuesAggregate"
          },
          {
            "$ref": "#/components/schemas/EventCardinalityPropertiesAggregate"
          },
          {
            "$ref": "#/components/schemas/UniqueValues"
          },
          {
            "$ref": "#/components/schemas/EventUniquePropertiesAggregate"
          }
        ]
      },
      "EventCardinalityValuesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "ApproximateCardinalityForValues",
            "description": "Request values approximate cardinality aggregate on a specific property.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`cardinalityValues`: Get an approximate number of unique values for the specified property.\n",
                "type": "string",
                "enum": [
                  "cardinalityValues"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/EventAggregateFilter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/EventAdvancedFilter"
              },
              "filter": {
                "$ref": "#/components/schemas/EventFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/EventAggregateProperties"
          }
        ]
      },
      "EventCardinalityPropertiesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "ApproximateCardinalityForProperties",
            "description": "Request resource properties approximate cardinality aggregate.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`cardinalityProperties`: Get an approximate number of unique properties.\n",
                "type": "string",
                "enum": [
                  "cardinalityProperties"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/EventAggregateFilter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/EventAdvancedFilter"
              },
              "filter": {
                "$ref": "#/components/schemas/EventFilter"
              },
              "path": {
                "description": "The scope in every document to aggregate properties.\nThe only value allowed now is [\"metadata\"].\nIt means to aggregate only metadata properties (aka keys).\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "string",
                  "enum": [
                    "metadata"
                  ]
                },
                "default": [
                  "metadata"
                ]
              }
            }
          }
        ]
      },
      "EventUniquePropertiesAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "UniqueProperties",
            "description": "Request unique non null property buckets aggregate.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`uniqueProperties`: Get unique properties (up to max 1000) in the specified document path (default path is [\"metadata\"] - metadata keys only).\nOrdered by frequency.\n",
                "type": "string",
                "enum": [
                  "uniqueProperties"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/EventAggregateFilter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/EventAdvancedFilter"
              },
              "filter": {
                "$ref": "#/components/schemas/EventFilter"
              },
              "path": {
                "description": "The scope in every document to aggregate properties.\nThe only value allowed now is [\"metadata\"].\nIt means to aggregate only metadata properties (aka keys).\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "string",
                  "enum": [
                    "metadata"
                  ]
                },
                "default": [
                  "metadata"
                ]
              }
            }
          }
        ]
      },
      "EventCountAggregate": {
        "type": "object",
        "title": "EventCount",
        "description": "Request aggregate to count the number of Events matching the filters. Default aggregate for the endpoint.",
        "properties": {
          "aggregate": {
            "description": "Type of aggregation to apply.\n`count`: Get an approximate number of Events matching the filters.",
            "type": "string",
            "enum": [
              "count"
            ]
          },
          "advancedFilter": {
            "$ref": "#/components/schemas/EventAdvancedFilter"
          },
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          }
        }
      },
      "EventWithPropertyCountAggregate": {
        "allOf": [
          {
            "type": "object",
            "title": "EventWithPropertyCount",
            "description": "Request aggregate to count the number of Events with a specific property (property is not null) and matching the filters.",
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`count`: Get an approximate number of Events with a specific property (property is not null) and matching the filters.",
                "type": "string",
                "enum": [
                  "count"
                ]
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/EventAdvancedFilter"
              },
              "filter": {
                "$ref": "#/components/schemas/EventFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/EventAggregateProperties"
          }
        ]
      },
      "UniqueValues": {
        "allOf": [
          {
            "type": "object",
            "description": "Request unique value buckets aggregate on a specific Event property. Each bucket is defined by `values` array and has the number of the `values` occurrences.",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "Type of aggregation to apply.\n`uniqueValues`: Get unique values (up to max 1000) in the specified property ordered by the frequency.\nNote: When aggregate on the `[\"metadata\"]` property, a value may occur multiple times in one Event for different metadata keys.\nEach occurrence is counted.\n",
                "type": "string",
                "enum": [
                  "uniqueValues"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/EventAggregateFilter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/EventAdvancedFilter"
              },
              "filter": {
                "$ref": "#/components/schemas/EventFilter"
              }
            }
          },
          {
            "oneOf": [
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EventAggregateProperties"
                  },
                  {
                    "title": "WithProperties"
                  }
                ]
              },
              {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/LegacyAggregationFields"
                  },
                  {
                    "title": "WithFields"
                  },
                  {
                    "deprecated": true
                  }
                ]
              }
            ]
          }
        ]
      },
      "EventAggregateProperties": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "description": "The property name(s) to apply the aggregation on. Currently, limited to one property per request.\n",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "property"
              ],
              "properties": {
                "property": {
                  "type": "array",
                  "description": "It's an array of strings to allow specifying nested properties.\n\nSupported properties:\\\n| Property                        | Type                         |\n|---------------------------------|------------------------------|\n| `[\"assetIds\"]`                  | array of [number]            |\n| `[\"dataSetId\"]`                 | number                       |\n| `[\"description\"]`               | string                       |\n| `[\"source\"]`                    | string                       |\n| `[\"subtype\"]`                   | string                       |\n| `[\"type\"]`                      | string                       |\n| `[\"metadata\"]`                  | string                       |\n| `[\"metadata\", <key>]`           | string                       |\n",
                  "minItems": 1,
                  "maxItems": 2,
                  "items": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 128
                  },
                  "example": [
                    "dataSetId"
                  ]
                },
                "filter": {
                  "$ref": "#/components/schemas/EventAggregateFilter"
                }
              }
            }
          }
        }
      },
      "LegacyAggregationFields": {
        "type": "object",
        "required": [
          "fields"
        ],
        "properties": {
          "fields": {
            "description": "This field is deprecated. Use the `properties` field instead.\\\nThe field name(s) to apply the aggregation on. Currently limited to one field.\nAccepts the following field names: `type`, `subtype`, `dataSetId` and metadata fields, for example, `metadata.FooBar`.\n",
            "deprecated": true,
            "type": "array",
            "maxItems": 1,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "EventFilterRequest": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/EventFilter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/EventAdvancedFilter"
              },
              "limit": {
                "description": "Limits the maximum number of results to be returned by a single request.\nIn case there are more results to the request, the 'nextCursor' attribute will be provided as part of the response.\nRequest may contain less results than the request limit.\n",
                "type": "integer",
                "format": "int32",
                "minimum": 1,
                "maximum": 1000,
                "default": 100
              },
              "sort": {
                "oneOf": [
                  {
                    "title": "modern",
                    "description": "Sort by array of selected properties.\n",
                    "type": "array",
                    "maxItems": 2,
                    "items": {
                      "$ref": "#/components/schemas/SortProperty"
                    },
                    "example": [
                      {
                        "property": [
                          "createdTime"
                        ],
                        "order": "desc"
                      },
                      {
                        "property": [
                          "metadata",
                          "FooBar"
                        ],
                        "nulls": "first"
                      }
                    ]
                  },
                  {
                    "title": "deprecated",
                    "deprecated": true,
                    "type": "array",
                    "maxItems": 2,
                    "items": {
                      "type": "string",
                      "description": "Sort by selected field. Syntax: `\"<fieldname>:asc|desc\"`. Default sort order is `asc` with short syntax: `\"<fieldname>\"`.\nFilter accepts the following field names:\n  `dataSetId`,\n  `externalId`,\n  `type`,\n  `subtype`,\n  `startTime`,\n  `endTime`,\n  `createdTime`,\n  `lastUpdatedTime`,\n  `source`,\n  `description`,\n  `metadata`.\nPartitions are done independently of sorting, there is no guarantee on sort order between elements from different partitions."
                    },
                    "example": [
                      "endTime:desc"
                    ]
                  }
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/PartitionObjectLimited10"
          }
        ]
      },
      "EventAdvancedFilter": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define advanced filter queries.\n\nSee more information about filtering DSL [here](https://docs.cognite.com/dev/concepts/resource_filtering_dsl/ \"filtering DSL\").\n\nSupported properties:\n\n  | Property                        | Type                                    |\n  |---------------------------------|-----------------------------------------|\n  | `[\"assetIds\"]`                  | array of [number]                       |\n  | `[\"createdTime\"]`               | number                                  |\n  | `[\"dataSetId\"]`                 | number                                  |\n  | `[\"endTime\"]`                   | number                                  |\n  | `[\"id\"]`                        | number                                  |\n  | `[\"lastUpdatedTime\"]`           | number                                  |\n  | `[\"startTime\"]`                 | number                                  |\n  | `[\"description\"]`               | string                                  |\n  | `[\"externalId\"]`                | string                                  |\n  | `[\"metadata\"]`                  | string                                  |\n  | `[\"metadata\", \"someCustomKey\"]` | string                                  |\n  | `[\"source\"]`                    | string                                  |\n  | `[\"subtype\"]`                   | string                                  |\n  | `[\"type\"]`                      | string                                  |\n\n  Note: Filtering on the `[\"metadata\"]` property has the following logic:\n  If a value of any metadata keys in an event matches the filter, the event matches the filter.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EventBoolFilter"
          },
          {
            "$ref": "#/components/schemas/EventLeafFilter"
          }
        ],
        "example": {
          "or": [
            {
              "not": {
                "and": [
                  {
                    "equals": {
                      "property": [
                        "metadata",
                        "severity"
                      ],
                      "value": "medium"
                    }
                  },
                  {
                    "in": {
                      "property": [
                        "source"
                      ],
                      "values": [
                        "inspection protocol",
                        "incident report"
                      ]
                    }
                  },
                  {
                    "range": {
                      "property": [
                        "dataSetId"
                      ],
                      "gte": 1,
                      "lt": 10
                    }
                  }
                ]
              }
            },
            {
              "and": [
                {
                  "equals": {
                    "property": [
                      "type"
                    ],
                    "value": "equipment malfunction"
                  }
                },
                {
                  "equals": {
                    "property": [
                      "subtype"
                    ],
                    "value": "mechanical failure"
                  }
                }
              ]
            },
            {
              "search": {
                "property": [
                  "description"
                ],
                "value": "outage"
              }
            }
          ]
        }
      },
      "EventLeafFilter": {
        "description": "Leaf filter.",
        "title": "LeafFilter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EqualsFilter"
          },
          {
            "$ref": "#/components/schemas/InFilter"
          },
          {
            "$ref": "#/components/schemas/GenericRangeFilter"
          },
          {
            "$ref": "#/components/schemas/PrefixFilter"
          },
          {
            "$ref": "#/components/schemas/ExistsFilter"
          },
          {
            "$ref": "#/components/schemas/ContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/ContainsAllFilter"
          },
          {
            "$ref": "#/components/schemas/SearchFilter"
          }
        ]
      },
      "EventBoolFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt's built using one or more boolean clauses of the following types: `and`, `or`, or `not`\n",
        "title": "BoolFilter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/EventAdvancedFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/EventAdvancedFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EventAdvancedFilter"
                  }
                ]
              }
            }
          }
        ]
      },
      "EventAggregateFilter": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define aggregate filter queries.\n\nSee more information about filtering DSL [here](https://docs.cognite.com/dev/concepts/resource_filtering_dsl/ \"filtering DSL\").\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EventAggregateBoolFilter"
          },
          {
            "$ref": "#/components/schemas/EventAggregateLeafFilter"
          }
        ],
        "example": {
          "or": [
            {
              "not": {
                "and": [
                  {
                    "equals": {
                      "value": 10
                    }
                  },
                  {
                    "in": {
                      "values": [
                        11,
                        12
                      ]
                    }
                  },
                  {
                    "range": {
                      "gte": 13,
                      "lt": 15
                    }
                  }
                ]
              }
            },
            {
              "and": [
                {
                  "equals": {
                    "value": 42
                  }
                }
              ]
            }
          ]
        }
      },
      "EventAggregateLeafFilter": {
        "description": "Aggregate leaf filter.\n",
        "title": "AggregateLeafFilter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/AggregateInFilter"
          },
          {
            "$ref": "#/components/schemas/AggregatePrefixFilter"
          },
          {
            "$ref": "#/components/schemas/AggregateRangeFilter"
          }
        ]
      },
      "EventAggregateBoolFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt is built using one or more boolean clauses of the following types: `and`, `or`, or `not`.\n",
        "title": "AggregateBoolFilter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/EventAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/EventAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EventAggregateFilter"
                  }
                ]
              }
            }
          }
        ]
      },
      "SortProperty": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "type": "array",
            "description": "Property to sort on.\nSorting can be done on the following properties:\n| Property                        |\n|---------------------------------|\n| `[\"createdTime\"]`               |\n| `[\"dataSetId\"]`                 |\n| `[\"description\"]`               |\n| `[\"endTime\"]`                   |\n| `[\"externalId\"]`                |\n| `[\"lastUpdatedTime\"]`           |\n| `[\"metadata\", \"someCustomKey\"]` |\n| `[\"source\"]`                    |\n| `[\"startTime\"]`                 |\n| `[\"subtype\"]`                   |\n| `[\"type\"]`                      |\n| `[\"_score_\"]`                   |",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "type": "string"
            }
          },
          "order": {
            "type": "string",
            "description": "The `order` attribute is optional and defaults to `desc` for `_score_` and `asc` for all other properties.\n",
            "enum": [
              "asc",
              "desc"
            ]
          },
          "nulls": {
            "type": "string",
            "description": "The `nulls` attribute is optional and defaults to `auto`.\n`auto` is translated to `last` for the `asc` order and to `first` for the `desc` order by the service.",
            "enum": [
              "first",
              "last",
              "auto"
            ],
            "default": "auto"
          }
        }
      },
      "EventChange": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EventChangeById"
          },
          {
            "$ref": "#/components/schemas/EventChangeByExternalId"
          }
        ]
      },
      "EventChangeById": {
        "allOf": [
          {
            "$ref": "#/components/schemas/EventPatch"
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "EventChangeByExternalId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/EventPatch"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "EventPatch": {
        "type": "object",
        "description": "Changes will be applied to event.",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/SinglePatchExternalId"
              },
              "dataSetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "startTime": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "endTime": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchResourceDescription"
              },
              "metadata": {
                "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/ObjectPatchEvent"
                  }
                ]
              },
              "assetIds": {
                "$ref": "#/components/schemas/ArrayPatchLong"
              },
              "source": {
                "$ref": "#/components/schemas/SinglePatchEventSource"
              },
              "type": {
                "$ref": "#/components/schemas/SinglePatchEventType"
              },
              "subtype": {
                "$ref": "#/components/schemas/SinglePatchEventSubType"
              }
            }
          }
        }
      },
      "SinglePatchEventType": {
        "title": "Type",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetEventType"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchEventSubType": {
        "title": "SubType",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetEventSubType"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "SinglePatchEventSource": {
        "title": "Source",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetEventSource"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the source, or remove the value."
      },
      "ActiveAtTimeFilter": {
        "description": "Event is considered active from its startTime to endTime inclusive. If startTime is null, event is never active. If endTime is null, event is active from startTime onwards. activeAtTime filter will match all events that are active at some point from min to max, from min, or to max, depending on which of min and max parameters are specified.",
        "allOf": [
          {
            "$ref": "#/components/schemas/EpochTimestampRange"
          }
        ]
      },
      "EndTimeMinMax": {
        "$ref": "#/components/schemas/EpochTimestampRange"
      },
      "EndTimeIsNull": {
        "$ref": "#/components/schemas/IsNull"
      },
      "EndTimeFilter": {
        "description": "Either range between two timestamps or isNull filter condition.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          {
            "$ref": "#/components/schemas/IsNull"
          }
        ]
      },
      "EventFilter": {
        "description": "Filter on events filter with exact match",
        "type": "object",
        "properties": {
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "endTime": {
            "$ref": "#/components/schemas/EndTimeFilter"
          },
          "activeAtTime": {
            "$ref": "#/components/schemas/ActiveAtTimeFilter"
          },
          "metadata": {
            "$ref": "#/components/schemas/EventMetadata"
          },
          "assetIds": {
            "type": "array",
            "minItems": 1,
            "maxItems": 5000,
            "uniqueItems": true,
            "description": "Asset IDs of equipment that this event relates to.",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "assetExternalIds": {
            "type": "array",
            "uniqueItems": true,
            "minItems": 1,
            "maxItems": 5000,
            "description": "Asset External IDs of equipment that this event relates to.",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          },
          "assetSubtreeIds": {
            "type": "array",
            "uniqueItems": true,
            "minItems": 1,
            "maxItems": 100,
            "description": "Only include events that have a related asset in a subtree rooted at any of these assetIds (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "items": {
              "$ref": "#/components/schemas/AssetIdEither"
            }
          },
          "dataSetIds": {
            "type": "array",
            "maxItems": 100,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/DataSetIdEither"
            }
          },
          "source": {
            "$ref": "#/components/schemas/EventSource"
          },
          "type": {
            "$ref": "#/components/schemas/EventType"
          },
          "subtype": {
            "$ref": "#/components/schemas/EventSubType"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "externalIdPrefix": {
            "$ref": "#/components/schemas/CogniteExternalIdPrefix"
          }
        }
      },
      "EventSearch": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "maxLength": 500,
            "description": "text to search in description field across events"
          }
        }
      },
      "EventSearchRequest": {
        "description": "Filter on events filter with exact match",
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/EventFilter"
          },
          "search": {
            "$ref": "#/components/schemas/EventSearch"
          },
          "limit": {
            "description": "<- Limits the maximum number of results to be returned by single request. Request may contain less results than request limit.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DataEventAggregate": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/EventAggregate"
            }
          }
        }
      },
      "EventAggregate": {
        "description": "Aggregation group of events",
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Size of the aggregation group",
            "format": "int64"
          }
        }
      },
      "EventResponse": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DataEvent"
          }
        ]
      },
      "EventWithCursorResponse": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DataWithCursorEvent"
          }
        ]
      },
      "InstanceId": {
        "type": "object",
        "required": [
          "space",
          "externalId"
        ],
        "properties": {
          "space": {
            "$ref": "#/components/schemas/InstanceSpace"
          },
          "externalId": {
            "$ref": "#/components/schemas/InstanceExternalId"
          }
        }
      },
      "FileInstanceId": {
        "type": "object",
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "$ref": "#/components/schemas/InstanceId"
          }
        }
      },
      "FileInternalId": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "FileExternalId": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "FileExternalIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FileExternalId"
          },
          {
            "$ref": "#/components/schemas/FileInstanceId"
          }
        ]
      },
      "FileIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FileInternalId"
          },
          {
            "$ref": "#/components/schemas/FileExternalId"
          },
          {
            "$ref": "#/components/schemas/FileInstanceId"
          }
        ]
      },
      "FileDeleteByIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FileInternalId"
          },
          {
            "$ref": "#/components/schemas/FileExternalId"
          }
        ]
      },
      "FileName": {
        "type": "string",
        "description": "Name of the file.",
        "maxLength": 256
      },
      "FileDirectory": {
        "type": "string",
        "description": "Directory containing the file. Must be an absolute, unix-style path.",
        "maxLength": 512
      },
      "MimeType": {
        "maxLength": 256,
        "type": "string",
        "example": "image/jpeg",
        "description": "File type. E.g. text/plain, application/pdf, .."
      },
      "FileSource": {
        "maxLength": 128,
        "type": "string",
        "description": "The source of the file."
      },
      "ExternalFilesMetadata": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "$ref": "#/components/schemas/FileName"
          },
          "directory": {
            "$ref": "#/components/schemas/FileDirectory"
          },
          "source": {
            "$ref": "#/components/schemas/FileSource"
          },
          "mimeType": {
            "$ref": "#/components/schemas/MimeType"
          },
          "metadata": {
            "$ref": "#/components/schemas/FilesMetadataField"
          },
          "assetIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "maxItems": 1000,
            "minItems": 1
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          },
          "sourceCreatedTime": {
            "allOf": [
              {
                "description": "The timestamp for when the file was originally created in the source system, specified in milliseconds since the epoch."
              },
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "sourceModifiedTime": {
            "allOf": [
              {
                "description": "The timestamp for when the file was last modified in the source system, specified in milliseconds since the epoch."
              },
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "securityCategories": {
            "type": "array",
            "description": "The security category IDs required to access this file.",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "maxItems": 100,
            "minItems": 0
          },
          "labels": {
            "$ref": "#/components/schemas/LabelList"
          },
          "geoLocation": {
            "$ref": "#/components/schemas/GeoLocation"
          }
        }
      },
      "FilesMetadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExternalFilesMetadata"
          },
          {
            "type": "object",
            "required": [
              "id",
              "uploaded",
              "createdTime",
              "lastUpdatedTime"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "uploaded": {
                "type": "boolean",
                "description": "Whether or not the actual file is uploaded. This field is returned only by the API, it has no effect in a post body.",
                "example": true
              },
              "uploadedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "instanceId": {
                "$ref": "#/components/schemas/InstanceId"
              }
            }
          }
        ]
      },
      "UploadFileMetadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesMetadata"
          },
          {
            "type": "object",
            "required": [
              "uploadUrl"
            ],
            "properties": {
              "uploadUrl": {
                "description": "The URL where the file contents should be uploaded.",
                "type": "string"
              }
            }
          }
        ]
      },
      "CompleteMultiPartUpload": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FileIdEither"
          },
          {
            "type": "object",
            "required": [
              "uploadId"
            ],
            "properties": {
              "uploadId": {
                "type": "string",
                "description": "A server-generated identifier returned by 'files/initmultipartupload', used by 'files/completemultipartupload' for validation purposes."
              }
            }
          }
        ]
      },
      "MultiPartUploadFileMetadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FilesMetadata"
          },
          {
            "type": "object",
            "required": [
              "uploadId",
              "uploadUrls"
            ],
            "properties": {
              "uploadId": {
                "description": "Identifier for this multipart upload. To be used in 'files/completemultipartupload' request, in the 'uploadId' URL parameter. This data string is used by the files API for file validation purposes.",
                "type": "string"
              },
              "uploadUrls": {
                "description": "Upload URL for each part of the file. Clients must make sure that the file parts are uploaded in the same order as the order in the list of uploadUrls. The PUT requests to upload each file part can however be done in parallel.",
                "type": "array",
                "example": [
                  "uploadURL_for_part_1",
                  "uploadURL_for_part_2",
                  "uploadURL_for_part_3"
                ],
                "items": {
                  "type": "string"
                }
              }
            }
          }
        ]
      },
      "FilesSearchFilter": {
        "description": "Filter on files with exact match",
        "allOf": [
          {
            "$ref": "#/components/schemas/FileFilter"
          },
          {
            "type": "object",
            "properties": {
              "search": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/FileName"
                  }
                }
              }
            }
          }
        ]
      },
      "DataFileChange": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/FileChangeUpdate"
            }
          }
        }
      },
      "FileChangeUpdate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FileChangeUpdateById"
          },
          {
            "$ref": "#/components/schemas/FileChangeUpdateByExternalId"
          },
          {
            "$ref": "#/components/schemas/FileChangeUpdateByInstanceId"
          }
        ]
      },
      "FileChangeUpdateById": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/FileChange"
          }
        ]
      },
      "FileChangeUpdateByExternalId": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/FileChange"
          }
        ]
      },
      "FileChangeUpdateByInstanceId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FileInstanceId"
          },
          {
            "$ref": "#/components/schemas/DMSFileChange"
          }
        ]
      },
      "DataFileMetadata": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilesMetadata"
            }
          }
        }
      },
      "DataFileUploadFileMetadata": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UploadFileMetadata"
            }
          }
        }
      },
      "DataMultiPartUploadFileMetadata": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MultiPartUploadFileMetadata"
            }
          }
        }
      },
      "FileLink": {
        "type": "object",
        "properties": {
          "downloadUrl": {
            "type": "string"
          }
        }
      },
      "DataExternalFileMetadata": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExternalFilesMetadata"
            }
          }
        }
      },
      "FileDeleteByIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FileDeleteByIdEither"
                },
                "maxItems": 1000,
                "minItems": 1
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FileDataIds": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileIdEither"
            },
            "maxItems": 1000,
            "minItems": 1
          }
        }
      },
      "FileSelectById": {
        "type": "object",
        "title": "Select by Id",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "FileSelectByExternalId": {
        "type": "object",
        "title": "Select by ExternalId",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "FileSelectByInstanceId": {
        "type": "object",
        "title": "Select by InstanceId",
        "properties": {
          "instanceId": {
            "$ref": "#/components/schemas/InstanceId"
          }
        }
      },
      "FileSelectEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FileSelectById"
          },
          {
            "$ref": "#/components/schemas/FileSelectByExternalId"
          },
          {
            "$ref": "#/components/schemas/FileSelectByInstanceId"
          }
        ]
      },
      "FileDataIdsWithIgnoreUnknownIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FileSelectEither"
                },
                "minItems": 1,
                "maxItems": 1000
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FileDataUploadIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileExternalIdEither"
            },
            "minItems": 1,
            "maxItems": 1
          }
        }
      },
      "FileLinkIds": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FileIdEither"
            },
            "maxItems": 100,
            "minItems": 1
          }
        }
      },
      "FileChange": {
        "type": "object",
        "description": "Changes will be applied to file.",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "directory": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "source": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "mimeType": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "metadata": {
                "allOf": [
                  {
                    "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240."
                  },
                  {
                    "$ref": "#/components/schemas/ObjectPatch"
                  }
                ]
              },
              "assetIds": {
                "allOf": [
                  {
                    "description": "Edit the set of assetIds for the file. Minimum 0, maximum 1000. See examples in the description for the updateFiles operation."
                  },
                  {
                    "$ref": "#/components/schemas/ArrayPatchLong"
                  }
                ]
              },
              "sourceCreatedTime": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "sourceModifiedTime": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "dataSetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "securityCategories": {
                "allOf": [
                  {
                    "description": "Edit the set of securityCategories for the file. Minimum 0, maximum 100. See examples in the description for the updateFiles operation."
                  },
                  {
                    "$ref": "#/components/schemas/ArrayPatchLong"
                  }
                ]
              },
              "labels": {
                "$ref": "#/components/schemas/LabelsPatch"
              },
              "geoLocation": {
                "$ref": "#/components/schemas/SinglePatchGeoLocation"
              }
            }
          }
        }
      },
      "DMSFileChange": {
        "type": "object",
        "description": "Changes will be applied to file.",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "metadata": {
                "allOf": [
                  {
                    "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240."
                  },
                  {
                    "$ref": "#/components/schemas/ObjectPatch"
                  }
                ]
              },
              "assetIds": {
                "allOf": [
                  {
                    "description": "Edit the set of assetIds for the file. Minimum 0, maximum 1000. See examples in the description for the updateFiles operation."
                  },
                  {
                    "$ref": "#/components/schemas/ArrayPatchLong"
                  }
                ]
              },
              "dataSetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "labels": {
                "$ref": "#/components/schemas/LabelsPatch"
              },
              "geoLocation": {
                "$ref": "#/components/schemas/SinglePatchGeoLocation"
              }
            }
          }
        }
      },
      "DataWithCursor": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilesMetadata"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next page of results"
      },
      "FilesMetadataField": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "additionalProperties": {
          "type": "string"
        }
      },
      "FileFilterRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FileFilter"
          },
          {
            "$ref": "#/components/schemas/PartitionObjectLimited10"
          },
          {
            "$ref": "#/components/schemas/FileLimit"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "FileFilter": {
        "description": "Filter on files with exact match",
        "type": "object",
        "properties": {
          "filter": {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FileName"
              },
              "directoryPrefix": {
                "description": "Filter by this (case-sensitive) prefix for the directory.",
                "type": "string",
                "maxLength": 512,
                "example": "/my/known/directory"
              },
              "mimeType": {
                "$ref": "#/components/schemas/MimeType"
              },
              "metadata": {
                "$ref": "#/components/schemas/FilesMetadataField"
              },
              "assetIds": {
                "$ref": "#/components/schemas/AssetIds"
              },
              "assetExternalIds": {
                "$ref": "#/components/schemas/AssetExternalIds"
              },
              "rootAssetIds": {
                "$ref": "#/components/schemas/RootAssetIds"
              },
              "dataSetIds": {
                "type": "array",
                "maxItems": 100,
                "uniqueItems": true,
                "description": "Only include files that belong to these datasets.",
                "items": {
                  "$ref": "#/components/schemas/DataSetIdEither"
                }
              },
              "assetSubtreeIds": {
                "$ref": "#/components/schemas/AssetSubtreeIds"
              },
              "source": {
                "maxLength": 128,
                "type": "string",
                "description": "The source of this event."
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "uploadedTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "sourceCreatedTime": {
                "allOf": [
                  {
                    "description": "Filter for files where the sourceCreatedTime field has been set and is within the specified range."
                  },
                  {
                    "$ref": "#/components/schemas/EpochTimestampRange"
                  }
                ]
              },
              "sourceModifiedTime": {
                "allOf": [
                  {
                    "description": "Filter for files where the sourceModifiedTime field has been set and is within the specified range."
                  },
                  {
                    "$ref": "#/components/schemas/EpochTimestampRange"
                  }
                ]
              },
              "externalIdPrefix": {
                "$ref": "#/components/schemas/CogniteExternalIdPrefix"
              },
              "uploaded": {
                "description": "Whether or not the actual file is uploaded. This field is returned only by the API, it has no effect in a post body.",
                "type": "boolean",
                "example": true
              },
              "labels": {
                "$ref": "#/components/schemas/LabelFilter"
              },
              "geoLocation": {
                "$ref": "#/components/schemas/GeoLocationFilter"
              }
            }
          }
        }
      },
      "FileLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "<- Maximum number of items that the client want to get back.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "AssetIds": {
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "uniqueItems": true,
        "description": "Only include files that reference these specific asset IDs.",
        "example": [
          363848954441724,
          793045462540095,
          1261042166839739
        ],
        "items": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "AssetExternalIds": {
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "uniqueItems": true,
        "description": "Only include files that reference these specific asset external IDs.",
        "example": [
          "externalId1",
          "externalId2",
          "externalId3"
        ],
        "items": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "RootAssetIds": {
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "uniqueItems": true,
        "description": "Only include files that have a related asset in a tree rooted at any of these root assetIds.",
        "example": [
          {
            "id": 123456789
          },
          {
            "externalId": "system 99 external Id 1234"
          }
        ],
        "items": {
          "$ref": "#/components/schemas/AssetIdEither"
        }
      },
      "AssetSubtreeIds": {
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "uniqueItems": true,
        "description": "Only include files that have a related asset in a subtree rooted at any of these assetIds (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
        "example": [
          {
            "id": 123456789
          },
          {
            "externalId": "system 99 external Id 1234"
          }
        ],
        "items": {
          "$ref": "#/components/schemas/AssetIdEither"
        }
      },
      "FilesAggregate": {
        "description": "Aggregation results for files",
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of filtered items included in aggregation",
            "format": "int64",
            "minimum": 0
          }
        }
      },
      "DataFilesAggregate": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FilesAggregate"
            }
          }
        }
      },
      "CPURange": {
        "type": "object",
        "description": "The number of CPU cores per function exectuion (i.e. function call).",
        "required": [
          "min",
          "max",
          "default"
        ],
        "properties": {
          "min": {
            "type": "number",
            "example": 1,
            "description": "The minimum value you can request when creating a function."
          },
          "max": {
            "type": "number",
            "example": 1,
            "description": "The maximum value you can request when creating a function."
          },
          "default": {
            "type": "number",
            "example": 1,
            "description": "The default value when creating a function."
          }
        }
      },
      "MemoryRange": {
        "type": "object",
        "description": "The amount of available memory in GB per function execution (i.e. function call).",
        "required": [
          "min",
          "max",
          "default"
        ],
        "properties": {
          "min": {
            "type": "number",
            "example": 1.5,
            "description": "The minimum value you can request when creating a function."
          },
          "max": {
            "type": "number",
            "example": 1.5,
            "description": "The maximum value you can request when creating a function."
          },
          "default": {
            "type": "number",
            "example": 1.5,
            "description": "The default value when creating a function."
          }
        }
      },
      "FunctionBuildError": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite Function API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 400
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not build function."
          }
        }
      },
      "FunctionErrorBasic": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite Function API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 400
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          }
        }
      },
      "FunctionCallError": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Error occuring due to user's function code.",
        "properties": {
          "trace": {
            "type": "string",
            "description": "Stack trace of exception, useful for debugging.",
            "example": "Cannot assign foo to bar."
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          }
        }
      },
      "FunctionScheduleCronExpression": {
        "type": "string",
        "example": "* * * * *",
        "maxLength": 1024,
        "description": "Cron expression describes when the function should be called. Use http://www.cronmaker.com to create a cron expression."
      },
      "FunctionScheduleDescription": {
        "type": "string",
        "example": "This is a nice schedule",
        "maxLength": 500,
        "description": "Description of function schedule."
      },
      "FunctionScheduleName": {
        "type": "string",
        "description": "Name of function schedule.",
        "example": "My schedule",
        "minLength": 1,
        "maxLength": 140
      },
      "FunctionScheduleWhen": {
        "type": "string",
        "description": "When the schedule will trigger, in human readable text.",
        "example": "Every hour"
      },
      "SessionId": {
        "description": "Id of the session.",
        "type": "string"
      },
      "FunctionName": {
        "type": "string",
        "description": "The name of the function.",
        "example": "myfunction",
        "minLength": 1,
        "maxLength": 140
      },
      "FunctionOwner": {
        "type": "string",
        "example": "user@cognite.com",
        "maxLength": 128,
        "description": "Owner of this function. Typically used to know who created it."
      },
      "FunctionId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "The ID of the function."
      },
      "FunctionExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "description": "The external ID of the function. Should be unique for the project."
      },
      "FunctionCallId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "FunctionCallIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FunctionCallId"
                },
                "maxItems": 10000,
                "minItems": 1
              }
            }
          }
        ]
      },
      "FunctionScheduleId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        },
        "description": "The ID of the function schedule."
      },
      "FunctionIdEither": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/FunctionId"
          },
          {
            "$ref": "#/components/schemas/FunctionExternalId"
          }
        ]
      },
      "FunctionScheduleIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "type": "object",
                  "required": [
                    "id"
                  ],
                  "properties": {
                    "id": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      ]
                    }
                  }
                },
                "maxItems": 10000,
                "minItems": 1
              }
            }
          }
        ]
      },
      "FunctionCallStatus": {
        "type": "string",
        "description": "Status of the function call.",
        "enum": [
          "Running",
          "Completed",
          "Failed",
          "Timeout"
        ],
        "example": "Running"
      },
      "FunctionStatus": {
        "type": "string",
        "enum": [
          "Queued",
          "Deploying",
          "Ready",
          "Failed"
        ],
        "example": "Queued",
        "description": "Status of the function. It starts in a Queued state, is then Deploying before it is either Ready or Failed. If the function is Ready, it can be called."
      },
      "FunctionListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          }
        ]
      },
      "LimitList": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Limits the number of results to be returned.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "default": 100
          }
        }
      },
      "FunctionFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionFilter",
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FunctionName"
              },
              "owner": {
                "$ref": "#/components/schemas/FunctionOwner"
              },
              "fileId": {
                "$ref": "#/components/schemas/FunctionFileId"
              },
              "status": {
                "$ref": "#/components/schemas/FunctionStatus"
              },
              "externalIdPrefix": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "metadata": {
                "$ref": "#/components/schemas/MetaData"
              }
            }
          }
        }
      },
      "FunctionCallFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionCallFilter",
            "type": "object",
            "properties": {
              "scheduleId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "status": {
                "$ref": "#/components/schemas/FunctionCallStatus"
              },
              "startTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "endTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              }
            },
            "description": ""
          }
        }
      },
      "FunctionCallListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionCallFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "FunctionScheduleFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "title": "FunctionScheduleFilter",
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/FunctionScheduleName"
              },
              "FunctionId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "FunctionExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              "cronExpression": {
                "$ref": "#/components/schemas/FunctionScheduleCronExpression"
              }
            },
            "description": ""
          }
        }
      },
      "FunctionScheduleScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/FunctionScheduleFilter"
          },
          {
            "$ref": "#/components/schemas/LimitList"
          }
        ]
      },
      "FunctionScheduleIdArray": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 10000,
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/FunctionScheduleId"
            }
          }
        }
      },
      "FunctionIdEitherList": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "maxItems": 10,
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/FunctionIdEither"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FunctionSchedule": {
        "allOf": [
          {
            "title": "Funtion Schedule",
            "type": "object",
            "description": "",
            "properties": {
              "id": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                ],
                "readOnly": true
              },
              "name": {
                "$ref": "#/components/schemas/FunctionScheduleName"
              },
              "createdTime": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/EpochTimestamp"
                  }
                ],
                "readOnly": true
              },
              "description": {
                "$ref": "#/components/schemas/FunctionScheduleDescription"
              },
              "cronExpression": {
                "$ref": "#/components/schemas/FunctionScheduleCronExpression"
              },
              "when": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FunctionScheduleWhen"
                  }
                ],
                "readOnly": true
              },
              "functionId": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "functionExternalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "sessionId": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SessionId"
                  }
                ],
                "readOnly": true
              },
              "data": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/data"
                  }
                ],
                "writeOnly": true
              },
              "nonce": {
                "$ref": "#/components/schemas/nonce"
              }
            }
          }
        ],
        "required": [
          "id",
          "name",
          "createdTime",
          "cronExpression",
          "when",
          "sessionId",
          "nonce"
        ]
      },
      "FunctionCallLogEntry": {
        "title": "FunctionCallLogEntry",
        "type": "object",
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "message": {
            "type": "string",
            "description": "Single line from stdout / stderr.",
            "example": "Did something great"
          }
        }
      },
      "FunctionCall": {
        "title": "FunctionCall",
        "type": "object",
        "required": [
          "id",
          "status",
          "startTime",
          "functionId"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "status": {
            "$ref": "#/components/schemas/FunctionCallStatus"
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "error": {
            "$ref": "#/components/schemas/FunctionCallError"
          },
          "scheduleId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "functionId": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "scheduledTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "FunctionCalls": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          }
        }
      },
      "FunctionCallsWithCursor": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "FunctionDeleteRequest": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "maxItems": 10,
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/FunctionIdEither"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "FunctionCallRequest": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/data"
          },
          "nonce": {
            "$ref": "#/components/schemas/nonce"
          }
        },
        "required": [
          "nonce"
        ]
      },
      "FunctionFileId": {
        "description": "The file ID to a file uploaded to Cognite's Files API. This file must be a zip file and contain a file called `handler.py` in the root folder (unless otherwise specified in the `functionPath` argument). This file must contain a function named `handle` with any of the following arguments: `data`, `client`, `secrets` and `function_call_info`, which are passed into the function. The zip file can contain other files as well (model binary data, libraries etc).\n\nCustom packages can be pip installed by providing a requirements.txt file in the root of the zip file. The latest version of the Cognite Python SDK is automatically installed. If a specific version is needed, please specify this in the requirements.txt file.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "MetaData": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32, value 512 characters, up to 16 key-value pairs. Maximum size of entire metadata is 4096 bytes."
      },
      "Function": {
        "type": "object",
        "required": [
          "id",
          "createdTime",
          "status",
          "name",
          "fileId"
        ],
        "properties": {
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "readOnly": true
          },
          "createdTime": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ],
            "readOnly": true,
            "example": 123455234
          },
          "status": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionStatus"
              }
            ],
            "readOnly": true
          },
          "name": {
            "$ref": "#/components/schemas/FunctionName"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "fileId": {
            "$ref": "#/components/schemas/FunctionFileId"
          },
          "owner": {
            "$ref": "#/components/schemas/FunctionOwner"
          },
          "description": {
            "type": "string",
            "example": "My fantastic function with advanced ML",
            "maxLength": 500,
            "description": "Description of the function."
          },
          "metadata": {
            "$ref": "#/components/schemas/MetaData"
          },
          "secrets": {
            "type": "object",
            "description": "Object with additional secrets as key/value pairs. These can e.g. password to simulators or other data sources. Keys must be lowercase characters, numbers or dashes (-) and at most 15 characters. You can create at most 30 secrets, all keys must be unique, and cannot be `token`, `indexUrl`, or `extraIndexUrls`. For each secret, the combined size of the secret name and secret value is limited by 25 kB. The secrets are returned scrambled if set.",
            "maxProperties": 30,
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "MySecret": "***"
            }
          },
          "functionPath": {
            "type": "string",
            "example": "myfunction/handler.py",
            "maxLength": 500,
            "description": "Relative path from the root folder to the file containing the `handle` function. Defaults to `handler.py`. Must be on POSIX path format."
          },
          "envVars": {
            "type": "object",
            "description": "Object with environment variables as key/value pairs. Keys can contain only letters, numbers or the underscore character. You can create at most 100 environment variables.",
            "maxProperties": 100,
            "additionalProperties": {
              "type": "string"
            },
            "example": {
              "MyKey": "MyValue"
            }
          },
          "cpu": {
            "type": "number",
            "format": "float",
            "example": 1,
            "description": "Number of CPU cores per function. Allowed range and default value are given by the [limits endpoint](https://developer.cognite.com/api#tag/Functions/operation/functionsLimits). On Azure, only the default value is used."
          },
          "memory": {
            "type": "number",
            "format": "float",
            "example": 1.5,
            "description": "Memory per function measured in GB. Allowed range and default value are given by the [limits endpoint](https://developer.cognite.com/api#tag/Functions/operation/functionsLimits). On Azure, only the default value is used."
          },
          "runtime": {
            "type": "string",
            "example": "py311",
            "default": "py311",
            "enum": [
              "py39",
              "py310",
              "py311"
            ],
            "description": "The runtime of the function. For exmple, runtime \"py311\" translates to the latest version of the Python 3.11 series."
          },
          "runtimeVersion": {
            "type": "string",
            "example": "Python 3.11.10",
            "readOnly": true,
            "description": "The complete specification of the function runtime with major, minor and patch version numbers."
          },
          "error": {
            "allOf": [
              {
                "$ref": "#/components/schemas/FunctionBuildError"
              }
            ],
            "readOnly": true
          },
          "indexUrl": {
            "description": "Specify a different python package index, allowing for packages published in private repositories.\nSupports basic HTTP authentication as described in [pip basic authentication](https://pip.pypa.io/en/stable/topics/authentication/#basic-http-authentication).\nSee the\n[documentation](https://docs.cognite.com/cdf/functions/#additional-arguments)\nfor additional information related to the security risks of using this\noption.",
            "example": "https://username:password@pypi.company.com/simple",
            "type": "string",
            "writeOnly": true
          },
          "extraIndexUrls": {
            "description": "Extra package index URLs to use when building the function, allowing for packages published in private repositories.\nSupports basic HTTP authentication as described in [pip basic\nauthentication](https://pip.pypa.io/en/stable/topics/authentication/#basic-http-authentication).\nSee the\n[documentation](https://docs.cognite.com/cdf/functions/#additional-arguments)\nfor additional information related to the security risks of using this\noption.",
            "example": [
              "https://username:password@pypi.company.com/simple",
              "https://token@pypi.company.com/simple",
              "https://pypi.company.com/simple"
            ],
            "type": "array",
            "items": {
              "type": "string"
            },
            "writeOnly": true
          }
        }
      },
      "data": {
        "type": "object",
        "description": "Input data to the function (only present if provided on the schedule). This data is passed deserialized into the function through one of the arguments called `data`. **WARNING:** Secrets or other confidential information should not be passed via the `data` object. There is a dedicated `secrets` object in the request body to \"Create functions\" for this purpose.'",
        "example": {
          "timeSeriesId1": 13435351,
          "maxValue": 4
        }
      },
      "nonce": {
        "type": "string",
        "description": "Nonce retrieved from sessions API when creating a session. This will be used to bind the session before executing the function. The corresponding access token will be passed to the function and used to instantiate the client of the handle() function. You can create a session via the [Sessions API](#operation/createSessions). When using the Python SDK, the session will be created behind the scenes when creating the schedule.",
        "writeOnly": true
      },
      "ModelType": {
        "type": "string",
        "enum": [
          "CAD",
          "PointCloud",
          "Image360"
        ]
      },
      "NextCursor": {
        "type": "string",
        "description": "Cursor to get the next page of results (if available)."
      },
      "NextCursorData": {
        "type": "object",
        "properties": {
          "nextCursor": {
            "$ref": "#/components/schemas/NextCursor"
          }
        }
      },
      "CreatedTime": {
        "type": "integer",
        "description": "The creation time of the resource, in milliseconds since January 1, 1970 at 00:00 UTC.",
        "format": "int64",
        "example": 0
      },
      "DataIdentifier": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DataIdentifiers": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "uniqueItems": true,
            "type": "array",
            "description": "List of ID objects",
            "items": {
              "$ref": "#/components/schemas/DataIdentifier"
            },
            "maxItems": 1000,
            "minItems": 1
          }
        }
      },
      "DmsInstanceId": {
        "type": "object",
        "description": "Reference to a node in dms. The reference consists of a space and an external-id.",
        "required": [
          "space",
          "externalId"
        ],
        "properties": {
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "externalId": {
            "$ref": "#/components/schemas/NodeOrEdgeExternalId"
          }
        }
      },
      "DataDmsIdentifier": {
        "type": "object",
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "$ref": "#/components/schemas/DmsInstanceId"
          }
        }
      },
      "DataDmsIdentifiers": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "uniqueItems": true,
            "type": "array",
            "description": "List of ID objects",
            "items": {
              "$ref": "#/components/schemas/DataDmsIdentifier"
            },
            "maxItems": 1000,
            "minItems": 1
          }
        }
      },
      "SetDirectRelationReference": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/DirectRelationReference"
          }
        }
      },
      "SinglePatchDirectRelationReference": {
        "title": "set",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetDirectRelationReference"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "Model3D": {
        "type": "object",
        "required": [
          "name",
          "id",
          "createdTime"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the model.",
            "example": "My Model"
          },
          "id": {
            "type": "integer",
            "description": "The ID of the model.",
            "format": "int64",
            "example": 1000
          },
          "createdTime": {
            "$ref": "#/components/schemas/CreatedTime"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          },
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          }
        }
      },
      "Model3DWithCursorResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Model3DList"
          },
          {
            "$ref": "#/components/schemas/NextCursorData"
          }
        ]
      },
      "Model3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Model3D"
            }
          }
        }
      },
      "CreateModel3DClassicBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/CreateModel3D"
            }
          }
        }
      },
      "CreateModel3D": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255,
            "description": "The name of the model.",
            "example": "My Model"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          }
        }
      },
      "CreateModel3DDmsOnlyBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/CreateModel3DDmsOnly"
            }
          }
        }
      },
      "CreateModel3DDmsOnly": {
        "type": "object",
        "required": [
          "name",
          "space"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255,
            "description": "The name of the model.",
            "example": "My Model"
          },
          "space": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "thumbnailReference": {
            "$ref": "#/components/schemas/DirectRelationReference"
          },
          "type": {
            "$ref": "#/components/schemas/ModelType"
          }
        }
      },
      "UpdateModel3DClassicBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/UpdateModel3D"
            }
          }
        }
      },
      "UpdateModel3D": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataIdentifier"
          },
          {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/SetModelNameField"
                  },
                  "dataSetId": {
                    "$ref": "#/components/schemas/SinglePatchDataSetId"
                  },
                  "metadata": {
                    "allOf": [
                      {
                        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs."
                      },
                      {
                        "$ref": "#/components/schemas/ObjectPatch"
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "UpdateModel3DDmsOnlyBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/UpdateModel3DDmsOnly"
            }
          }
        }
      },
      "UpdateModel3DDmsOnly": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataDmsIdentifier"
          },
          {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/SetModelNameField"
                  },
                  "thumbnailReference": {
                    "$ref": "#/components/schemas/SinglePatchDirectRelationReference"
                  }
                }
              }
            }
          }
        ]
      },
      "SetModelNameField": {
        "type": "object",
        "properties": {
          "set": {
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          }
        }
      },
      "Revision3D": {
        "type": "object",
        "required": [
          "id",
          "fileId",
          "published",
          "status",
          "assetMappingCount",
          "createdTime"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the revision.",
            "format": "int64",
            "example": 1000
          },
          "fileId": {
            "type": "integer",
            "description": "The file id.",
            "format": "int64",
            "example": 1000
          },
          "published": {
            "type": "boolean",
            "description": "True if the revision is marked as published.",
            "default": false
          },
          "rotation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            },
            "example": [
              0,
              0,
              0
            ]
          },
          "scale": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global scale to be applied to the entire model. The scale is expressed by units in XYZ order.",
              "format": "double"
            },
            "example": [
              1,
              1,
              1
            ]
          },
          "translation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global translation to be applied to the entire model, to offset the position. The translation is expressed by units in XYZ order.",
              "format": "double"
            },
            "example": [
              0,
              0,
              0
            ]
          },
          "camera": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          },
          "status": {
            "type": "string",
            "enum": [
              "Queued",
              "Processing",
              "Done",
              "Failed"
            ],
            "description": "The status of the revision.",
            "example": "Done"
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          },
          "thumbnailThreedFileId": {
            "type": "integer",
            "description": "The threed file ID of a thumbnail for the revision. Use `/3d/files/{id}` to retrieve the file.",
            "format": "int64",
            "example": 1000
          },
          "thumbnailURL": {
            "type": "string",
            "description": "The URL of a thumbnail for the revision.",
            "example": "https://api.cognitedata.com/api/v1/project/myproject/3d/files/1000"
          },
          "assetMappingCount": {
            "type": "integer",
            "description": "The number of asset mappings for this revision.",
            "format": "int64",
            "example": 0
          },
          "createdTime": {
            "$ref": "#/components/schemas/CreatedTime"
          }
        }
      },
      "Metadata3D": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs.",
        "additionalProperties": {
          "type": "string"
        }
      },
      "NodeProperties3D": {
        "type": "object",
        "description": "Properties extracted from 3D model, with property categories containing key/value string pairs.",
        "example": {
          "category1": {
            "property1": "value1",
            "property2": "value2"
          },
          "category2": {
            "property1": "value1",
            "property2": "value2"
          }
        },
        "additionalProperties": {
          "description": "Property category.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "Revision3DWithCursorResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Revision3DList"
          },
          {
            "$ref": "#/components/schemas/NextCursorData"
          }
        ]
      },
      "Revision3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Revision3D"
            }
          }
        }
      },
      "CreateRevision3DClassicBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/CreateRevision3D"
            }
          }
        }
      },
      "CreateRevision3D": {
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "published": {
            "type": "boolean",
            "description": "True if the revision is marked as published.",
            "default": false
          },
          "rotation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            },
            "example": [
              0,
              0,
              0
            ]
          },
          "scale": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global scale to be applied to the entire model. The scale is expressed by units in XYZ order.",
              "format": "double"
            },
            "example": [
              1,
              1,
              1
            ]
          },
          "translation": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global translation to be applied to the entire model. The translation is expressed by units in XYZ order.",
              "format": "double"
            },
            "example": [
              0,
              0,
              0
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/Metadata3D"
          },
          "camera": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          },
          "fileId": {
            "type": "integer",
            "description": "The file id to a file uploaded to Cognite's Files API. Can only be set on revision creation, and can never be updated.",
            "format": "int64"
          }
        }
      },
      "CreateRevision3DDmsOnlyBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/CreateRevision3DDmsOnly"
            }
          }
        }
      },
      "CreateRevision3DDmsOnly": {
        "type": "object",
        "required": [
          "fileId",
          "nonce"
        ],
        "properties": {
          "nonce": {
            "title": "Nonce",
            "type": "string",
            "description": "Session nonce for a recently created CDF Session."
          },
          "fileId": {
            "type": "integer",
            "description": "The file id to a file uploaded to Cognite's Files API. Can only be set on revision creation, and can never be updated.",
            "format": "int64"
          }
        }
      },
      "UpdateRevision3DClassicBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/UpdateRevision3D"
            }
          }
        }
      },
      "UpdateRevision3D": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataIdentifier"
          },
          {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "properties": {
                  "published": {
                    "type": "object",
                    "properties": {
                      "set": {
                        "type": "boolean",
                        "description": "True if the revision is marked as published."
                      }
                    }
                  },
                  "rotation": {
                    "$ref": "#/components/schemas/SetRevisionRotation"
                  },
                  "scale": {
                    "$ref": "#/components/schemas/SetRevisionScale"
                  },
                  "translation": {
                    "$ref": "#/components/schemas/SetRevisionTranslation"
                  },
                  "camera": {
                    "$ref": "#/components/schemas/SetRevisionCameraProperties"
                  },
                  "metadata": {
                    "allOf": [
                      {
                        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 32 bytes, value 512 bytes, up to 16 key-value pairs."
                      },
                      {
                        "$ref": "#/components/schemas/ObjectPatch"
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      "UpdateRevision3DDmsOnlyBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/UpdateRevision3DDmsOnly"
            }
          }
        }
      },
      "UpdateRevision3DDmsOnly": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataDmsIdentifier"
          },
          {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "properties": {
                  "published": {
                    "type": "object",
                    "properties": {
                      "set": {
                        "type": "boolean",
                        "description": "True if the revision is marked as published."
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "Versioned3DFile": {
        "description": "The file ID of the data file for this resource, with multiple versions supported. Use /3d/files/{id} to retrieve the file.",
        "type": "object",
        "required": [
          "version",
          "fileId"
        ],
        "properties": {
          "version": {
            "type": "integer",
            "description": "Version of the file format.",
            "format": "int64",
            "example": 1
          },
          "fileId": {
            "type": "integer",
            "description": "File ID. Use `/3d/files/{id}` to retrieve the file.",
            "format": "int64",
            "example": 1000
          }
        }
      },
      "RevisionCameraProperties": {
        "type": "object",
        "properties": {
          "target": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "description": "Initial camera target.",
            "items": {
              "type": "number",
              "format": "double"
            }
          },
          "position": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "description": "Initial camera position.",
            "items": {
              "type": "number",
              "format": "double"
            }
          }
        },
        "description": "Initial camera position and target."
      },
      "SetRevisionRotation": {
        "type": "object",
        "properties": {
          "set": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global rotation to be applied to the entire model. The rotation is expressed by Euler angles in radians and in XYZ order.",
              "format": "double"
            }
          }
        }
      },
      "SetRevisionScale": {
        "type": "object",
        "properties": {
          "set": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global scale to be applied to the entire model. The scale is expressed by units in XYZ order.",
              "format": "double"
            }
          }
        }
      },
      "SetRevisionTranslation": {
        "type": "object",
        "properties": {
          "set": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "Global translation to be applied to the entire model, to offset the position. The translation is expressed by units in XYZ order.",
              "format": "double"
            }
          }
        }
      },
      "SetRevisionCameraProperties": {
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/RevisionCameraProperties"
          }
        }
      },
      "RevisionLog3D": {
        "type": "object",
        "required": [
          "timestamp",
          "severity",
          "type"
        ],
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/CreatedTime"
          },
          "severity": {
            "type": "integer",
            "description": "How severe is the message (3 = INFO, 5 = WARN, 7 = ERROR).",
            "example": 7
          },
          "type": {
            "type": "string",
            "description": "Main computer parsable log entry type",
            "example": "CONVERTER/FAILED"
          },
          "info": {
            "type": "string",
            "description": "Optional extra information related to the log entry"
          }
        }
      },
      "RevisionLog3DResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RevisionLog3D"
            }
          }
        }
      },
      "Node3D": {
        "type": "object",
        "required": [
          "id",
          "treeIndex",
          "depth",
          "name",
          "subtreeSize"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1000
          },
          "treeIndex": {
            "$ref": "#/components/schemas/TreeIndex"
          },
          "parentId": {
            "type": "integer",
            "description": "The parent of the node, null if it is the root node.",
            "format": "int64",
            "example": 2
          },
          "depth": {
            "type": "integer",
            "description": "The depth of the node in the tree, starting from 0 at the root node.",
            "format": "int64",
            "example": 2
          },
          "name": {
            "type": "string",
            "description": "The name of the node.",
            "example": "Node name"
          },
          "subtreeSize": {
            "$ref": "#/components/schemas/SubtreeSize"
          },
          "properties": {
            "$ref": "#/components/schemas/NodeProperties3D"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/BoundingBox3D"
          }
        }
      },
      "Node3DWithCursorResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Node3DList"
          },
          {
            "$ref": "#/components/schemas/NextCursorData"
          }
        ]
      },
      "Node3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Node3D"
            }
          }
        }
      },
      "Node3DIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Node3DId"
            },
            "maxItems": 1000,
            "minItems": 1
          }
        }
      },
      "Node3DId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1000
          }
        }
      },
      "BoundingBox3D": {
        "type": "object",
        "required": [
          "min",
          "max"
        ],
        "properties": {
          "max": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "The maximal coordinates of the bounding box.",
              "format": "double"
            }
          },
          "min": {
            "maxItems": 3,
            "minItems": 3,
            "type": "array",
            "items": {
              "type": "number",
              "description": "The minimal coordinates of the bounding box.",
              "format": "double"
            }
          }
        },
        "description": "The bounding box of the subtree with this sector as the root sector. Is null if there are no geometries in the subtree."
      },
      "Node3DNameFilter": {
        "type": "object",
        "description": "Filter used in searching for nodes by name.",
        "properties": {
          "names": {
            "type": "array",
            "items": {
              "type": "string",
              "description": "The names of the nodes you want returned",
              "maxItems": 1000,
              "minItems": 1
            },
            "example": [
              "PIPE-9MM-HG",
              "VALVE-HL3",
              "US-DIV-2"
            ]
          }
        }
      },
      "Node3DPropertyFilter": {
        "type": "object",
        "description": "Filters used in the search.",
        "properties": {
          "properties": {
            "type": "object",
            "description": "Contains one or more categories (namespaces), each of which contains one or more properties. Each property is associated with a list of values. The list of values acts as an OR-clause, so that if a node's corresponding property value equals ANY of the strings in the list, it satisfies the condition for that property. The different properties are concatenated with AND-operations, so that a node must satisfy the condition for ALL properties from all categories to be part of the returned set. The allowed number of property values is limited to 1000 values in total.",
            "example": {
              "PDMS": {
                "Area": [
                  "AB76",
                  "AB77",
                  "AB78"
                ],
                "Type": [
                  "PIPE",
                  "BEND",
                  "PIPESUP"
                ]
              }
            }
          }
        }
      },
      "Node3DNameFilterBody": {
        "description": "Filter request for nodes. Filters nodes with properties matching ones in a list of alternatives.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/Node3DNameFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/Limit"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/PartitionObject"
          }
        ]
      },
      "Node3DPropertyFilterBody": {
        "description": "Filter request for nodes. Filters nodes with properties matching ones in a list of alternatives.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/Node3DPropertyFilter"
              }
            }
          },
          {
            "$ref": "#/components/schemas/Limit"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/PartitionObject"
          }
        ]
      },
      "Model3DOutputResponseList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "description": "A list of named and versioned outputs for the model. Note that the list is not sorted.",
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "format",
                "version",
                "blobId"
              ],
              "properties": {
                "format": {
                  "description": "Format identifier.",
                  "example": "ept-pointcloud",
                  "type": "string"
                },
                "version": {
                  "description": "Version of the output format, starting at 1.",
                  "example": 1,
                  "type": "integer"
                },
                "blobId": {
                  "description": "Reference to 3D file containing output. 3D file can either be a single file or folder. Use `/3d/files/{id}`.",
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/CogniteInternalId"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "TreeIndex": {
        "type": "integer",
        "minimum": 0,
        "description": "The index of the node in the 3D model hierarchy, starting from 0. The tree is traversed in a depth-first order.",
        "format": "int64",
        "example": 3
      },
      "SubtreeSize": {
        "type": "integer",
        "description": "The number of descendants of the node, plus one (counting itself).",
        "format": "int64",
        "example": 4
      },
      "AssetMapping3D": {
        "type": "object",
        "required": [
          "nodeId",
          "assetId"
        ],
        "properties": {
          "nodeId": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1003
          },
          "assetId": {
            "type": "integer",
            "description": "The ID of the associated asset (Cognite's Assets API).",
            "format": "int64",
            "example": 3001
          },
          "treeIndex": {
            "$ref": "#/components/schemas/TreeIndex"
          },
          "subtreeSize": {
            "$ref": "#/components/schemas/SubtreeSize"
          }
        }
      },
      "AssetMapping3DWithCursorResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AssetMapping3DList"
          },
          {
            "$ref": "#/components/schemas/NextCursorData"
          }
        ]
      },
      "AssetMapping3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AssetMapping3D"
            }
          }
        }
      },
      "CreateAssetMapping3DClassicBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/CreateAssetMapping3D"
            }
          }
        }
      },
      "CreateAssetMapping3D": {
        "type": "object",
        "required": [
          "nodeId",
          "assetId"
        ],
        "properties": {
          "nodeId": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1003
          },
          "assetId": {
            "type": "integer",
            "description": "The ID of the associated asset (Cognite's Assets API).",
            "format": "int64",
            "example": 3001
          }
        }
      },
      "DmsCADContextualizationConfig": {
        "type": "object",
        "required": [
          "object3DSpace",
          "cadNodeSpace"
        ],
        "properties": {
          "object3DSpace": {
            "$ref": "#/components/schemas/SpaceSpecification"
          },
          "cadNodeSpace": {
            "$ref": "#/components/schemas/SpaceSpecification"
          }
        }
      },
      "CreateAssetMapping3DDmsOnlyBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/CreateAssetMapping3DDmsOnly"
            }
          },
          "dmsContextualizationConfig": {
            "$ref": "#/components/schemas/DmsCADContextualizationConfig"
          }
        }
      },
      "CreateAssetMapping3DDmsOnly": {
        "type": "object",
        "required": [
          "nodeId",
          "assetInstanceId"
        ],
        "properties": {
          "nodeId": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1003
          },
          "assetInstanceId": {
            "$ref": "#/components/schemas/DirectRelationReference"
          }
        }
      },
      "DeleteAssetMapping3DClassicBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/DeleteAssetMapping3D"
            }
          }
        }
      },
      "DeleteAssetMapping3D": {
        "type": "object",
        "required": [
          "nodeId",
          "assetId"
        ],
        "properties": {
          "nodeId": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1003
          },
          "assetId": {
            "type": "integer",
            "description": "The ID of the associated asset (Cognite's Assets API).",
            "format": "int64",
            "example": 3001
          }
        }
      },
      "DeleteAssetMapping3DDmsOnlyBody": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/DeleteAssetMapping3DDmsOnly"
            }
          },
          "dmsContextualizationConfig": {
            "$ref": "#/components/schemas/DmsCADContextualizationConfig"
          }
        }
      },
      "DeleteAssetMapping3DDmsOnly": {
        "type": "object",
        "required": [
          "nodeId",
          "assetInstanceId"
        ],
        "properties": {
          "nodeId": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1003
          },
          "assetInstanceId": {
            "$ref": "#/components/schemas/DirectRelationReference"
          }
        }
      },
      "AssetMapping3DFilterRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AssetMapping3DFilter"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "AssetMapping3DFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssetMapping3DAssetFilter"
              },
              {
                "$ref": "#/components/schemas/AssetMapping3DNodeFilter"
              },
              {
                "$ref": "#/components/schemas/AssetMapping3DTreeIndexFilter"
              }
            ]
          },
          "limit": {
            "description": "Limits the number of results to return.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "AssetMapping3DNodeFilter": {
        "type": "object",
        "required": [
          "nodeIds"
        ],
        "properties": {
          "nodeIds": {
            "type": "array",
            "minItems": 0,
            "maxItems": 100,
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "AssetMapping3DAssetFilter": {
        "type": "object",
        "required": [
          "assetIds"
        ],
        "properties": {
          "assetIds": {
            "type": "array",
            "minItems": 0,
            "maxItems": 100,
            "items": {
              "type": "integer",
              "format": "int64"
            }
          }
        }
      },
      "AssetMapping3DTreeIndexFilter": {
        "type": "object",
        "required": [
          "treeIndexes"
        ],
        "properties": {
          "treeIndexes": {
            "type": "array",
            "minItems": 0,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/TreeIndex"
            }
          }
        }
      },
      "UpdateRevision3DThumbnail": {
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "fileId": {
            "type": "integer",
            "description": "File ID of thumbnail file in Files API. _Only JPEG and PNG files are supported_.",
            "format": "int64"
          }
        },
        "description": "Request body for the updateModelRevisionThumbnail endpoint."
      },
      "ProjectAssetMapping3DList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Node3DAssetMapping"
            }
          }
        }
      },
      "Node3DAssetMapping": {
        "type": "object",
        "required": [
          "modelId",
          "revisionId",
          "nodeId"
        ],
        "properties": {
          "modelId": {
            "type": "integer",
            "description": "The ID of the associated model",
            "format": "int64",
            "example": 3001
          },
          "revisionId": {
            "type": "integer",
            "description": "The ID of the associated revision",
            "format": "int64",
            "example": 3001
          },
          "nodeId": {
            "type": "integer",
            "description": "The ID of the node.",
            "format": "int64",
            "example": 1003
          }
        }
      },
      "TimeSeriesResponse": {
        "$ref": "#/components/schemas/DataGetTimeSeriesMetadataDTO"
      },
      "DatapointsInsertQuery": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/DatapointsPostDatapoint"
            }
          }
        }
      },
      "DatapointsPostDatapoint": {
        "type": "object",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "DatapointsWithInternalId",
            "allOf": [
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsInsertProperties"
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "DatapointsWithExternalId",
            "allOf": [
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsInsertProperties"
              }
            ]
          },
          {
            "required": [
              "instanceId"
            ],
            "title": "DatapointsWithInstanceId",
            "allOf": [
              {
                "properties": {
                  "instanceId": {
                    "$ref": "#/components/schemas/CogniteInstanceId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsInsertProperties"
              }
            ]
          }
        ]
      },
      "DatapointsInsertProperties": {
        "required": [
          "datapoints"
        ],
        "properties": {
          "datapoints": {
            "type": "array",
            "description": "The list of data points. The total number of data points in a single request is limited to 100000, across all time series.",
            "items": {
              "$ref": "#/components/schemas/PostDatapoint"
            }
          }
        }
      },
      "DatapointsMultiQuery": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/DatapointsQuery"
                },
                "minItems": 1,
                "maxItems": 100
              },
              "start": {
                "$ref": "#/components/schemas/TimestampOrStringStart"
              },
              "end": {
                "$ref": "#/components/schemas/TimestampOrStringEnd"
              },
              "limit": {
                "type": "integer",
                "description": "Returns up to this number of data points. The maximum is 100000 non-aggregated data points and 10000 aggregated data points in total across all queries in a single request.",
                "format": "int32",
                "default": 100
              },
              "aggregates": {
                "type": "array",
                "description": "Specify the aggregates to return. Omit to return data points without aggregation.",
                "minItems": 1,
                "uniqueItems": true,
                "items": {
                  "$ref": "#/components/schemas/Aggregate"
                }
              },
              "granularity": {
                "type": "string",
                "description": "The time granularity size and unit to aggregate over. Valid entries are 'month, day, hour, minute, second', or short forms 'mo, d, h, m, s', or a multiple of these indicated by a number as a prefix. For 'second' and 'minute', the multiple must be an integer between 1 and 120 inclusive; for 'hour', 'day', and 'month', the multiple must be an integer between 1 and 100000 inclusive. For example, a granularity '5m' means that aggregates are calculated over 5 minutes. This field is required if aggregates are specified.",
                "example": "1h"
              },
              "includeOutsidePoints": {
                "type": "boolean",
                "description": "Defines whether to include the last data point before the requested\ntime period and the first one after. This option can be\nuseful for interpolating data. It's not available for aggregates or cursors.\n\nNote: If there are more than `limit` data points in the time period, we will omit\nthe excess data points and then append the first data point after the time period,\nthus causing a gap with omitted data points. When this is the case, we return\nup to `limit+2` data points.\n\nWhen doing manual paging (sequentially requesting smaller intervals instead of\nrequesting a larger interval and using cursors to get all the data points) with this\nfield set to true, the `start` of the each subsequent request should be one\nmillisecond more than the `timestamp` of the _second-to-last_ data point from the\nprevious response. This is because the last data point in most cases will be the\nextra point from outside the interval.",
                "default": false
              },
              "timeZone": {
                "type": "string",
                "description": "For aggregates of granularity 'hour' and longer, which [time zone](<https://developer.cognite.com/dev/concepts/aggregation/calendar>) should we align to.\nAlign to the start of the hour, start of the day or start of the month.\nFor time zones of type Region/Location, the aggregate duration can vary, typically due to daylight saving time.\nFor time zones of type UTC+/-HH:MM, use increments of 15 minutes.\n\nNote: Time zones with minute offsets (e.g. UTC+05:30 or Asia/Kolkata) may take longer to execute. Historical time zones, with offsets not multiples of 15 minutes, are not supported.",
                "default": "UTC",
                "example": "Europe/Oslo or UTC+05:30"
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DatapointsQuery": {
        "type": "object",
        "description": "Parameters describing a query for data points.",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "QueryWithInternalId",
            "allOf": [
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsQueryProperties"
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "QueryWithExternalId",
            "allOf": [
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsQueryProperties"
              }
            ]
          },
          {
            "required": [
              "instanceId"
            ],
            "title": "QueryWithInstanceId",
            "allOf": [
              {
                "properties": {
                  "instanceId": {
                    "$ref": "#/components/schemas/CogniteInstanceId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsQueryProperties"
              }
            ]
          }
        ]
      },
      "DatapointsQueryProperties": {
        "properties": {
          "start": {
            "$ref": "#/components/schemas/TimestampOrStringStart"
          },
          "end": {
            "$ref": "#/components/schemas/TimestampOrStringEnd"
          },
          "limit": {
            "type": "integer",
            "description": "Returns up to this number of data points. The maximum is 100000 non-aggregated data points and 10000 aggregated data points in total across all queries in a single request.",
            "format": "int32"
          },
          "aggregates": {
            "type": "array",
            "description": "Specify the aggregates to return. Omit to use top-level value.",
            "minItems": 1,
            "maxItems": 10,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/Aggregate"
            }
          },
          "granularity": {
            "type": "string",
            "description": "The granularity size and granularity of the aggregates. Omit to use top-level value.",
            "example": "1h"
          },
          "targetUnit": {
            "type": "string",
            "description": "The [unit](<https://developer.cognite.com/dev/concepts/resource_types/units/>) externalId of the data points returned. If the time series does not have a unitExternalId that can be converted to the targetUnit, an error will be returned. Cannot be used with targetUnitSystem.",
            "example": "temperature:deg_f"
          },
          "targetUnitSystem": {
            "type": "string",
            "description": "The [unit system](<https://developer.cognite.com/dev/concepts/resource_types/units/>) of the data points returned. Cannot be used with targetUnit.",
            "example": "imperial"
          },
          "includeOutsidePoints": {
            "type": "boolean",
            "description": "Defines whether to include the last data point before the requested time period and the first one after. This option can be useful for interpolating data. It's not available for aggregates or cursors.\nNote: If there are more than `limit` data points in the time period, we will omit the excess data points and then append the first data point after the time period, thus causing a gap with omitted data points. When this is the case, we return up to `limit+2` data points.\nWhen doing manual paging (sequentially requesting smaller intervals instead of requesting a larger interval and using cursors to get all the data points) with this field set to true, the `start` of the each subsequent request should be one millisecond more than the `timestamp` of the _second-to-last_ data point from the previous response. This is because the last data point in most cases will be the extra point from outside the interval.\n",
            "default": false
          },
          "includeStatus": {
            "type": "boolean",
            "description": "Show the [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>) for each data point in the response.\n_Good_ (code = 0) status codes are always omitted.\nOnly relevant for raw data points queries, not aggregates.",
            "default": false
          },
          "ignoreBadDataPoints": {
            "type": "boolean",
            "description": "Treat data points with a _Bad_ status code as if they do not exist.\n\nIf set to false, raw queries will include bad data points in the response, and\naggregates will in general omit the time period between a bad data point and the next good data point.\nAlso, the period between a bad data point and the previous good data point will be considered constant.\n\nNote that bad data points may contain the string values 'NaN', 'Infinity', or '-Infinity', or be null (omitted).",
            "default": true
          },
          "treatUncertainAsBad": {
            "type": "boolean",
            "description": "Treat data points with _Uncertain_ status codes as _Bad_. If false, treat data points with _Uncertain_ status codes as _Good_.\nUsed for both raw queries and aggregates.",
            "default": true
          },
          "cursor": {
            "type": "string",
            "description": "To retrieve next page, insert the `nextCursor` from a previous response. Be sure to match with the corresponding time series. Not compatible with `includeOutsidePoints`.\n"
          },
          "timeZone": {
            "type": "string",
            "description": "Which time zone to align aggregates to. Omit to use top-level value.\n",
            "default": "UTC",
            "example": "Europe/Oslo or UTC+05:30"
          }
        }
      },
      "DatapointsLatestQuery": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "description": "List of latest queries",
                "minItems": 1,
                "maxItems": 100,
                "items": {
                  "$ref": "#/components/schemas/LatestDataBeforeRequest"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "LatestDataBeforeRequest": {
        "type": "object",
        "description": "Describes the latest query.",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "QueryWithInternalId",
            "allOf": [
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/LatestDataPropertyFilter"
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "QueryWithExternalId",
            "allOf": [
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/LatestDataPropertyFilter"
              }
            ]
          },
          {
            "required": [
              "instanceId"
            ],
            "title": "QueryWithInstanceId",
            "allOf": [
              {
                "properties": {
                  "instanceId": {
                    "$ref": "#/components/schemas/CogniteInstanceId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/LatestDataPropertyFilter"
              }
            ]
          }
        ]
      },
      "LatestDataPropertyFilter": {
        "properties": {
          "before": {
            "type": "string",
            "description": "Get data points before this time. The format is N[timeunit]-ago where timeunit is w,d,h,m,s.\nExample: '2d-ago' gets data that is up to two days old. You can also specify time in milliseconds since epoch.",
            "default": "now"
          },
          "targetUnit": {
            "type": "string",
            "description": "The [unit](<https://developer.cognite.com/dev/concepts/resource_types/units/>) externalId of the data points returned. If the time series does not have a unitExternalId that can be converted to the targetUnit, an error will be returned. Cannot be used with targetUnitSystem.",
            "example": "temperature:deg_f"
          },
          "targetUnitSystem": {
            "type": "string",
            "description": "The [unit system](<https://developer.cognite.com/dev/concepts/resource_types/units/>) of the data points returned. Cannot be used with targetUnit.",
            "example": "imperial"
          },
          "includeStatus": {
            "type": "boolean",
            "description": "Show the [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>) for each data point in the response.\n_Good_ (code = 0) status codes are always omitted.",
            "default": false
          },
          "ignoreBadDataPoints": {
            "type": "boolean",
            "description": "Treat data points with a _Bad_ status code as if they do not exist.\nSet to false to include all data points.\n\nNote that bad data points may contain the string values 'NaN', 'Infinity', or '-Infinity', or be null (omitted).",
            "default": true
          },
          "treatUncertainAsBad": {
            "type": "boolean",
            "description": "Treat data points with _Uncertain_ status codes as _Bad_.\nSet to false to to include uncertain data points.",
            "default": true
          }
        }
      },
      "DatapointsDeleteQuery": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "List of delete filters.",
            "minItems": 1,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/DatapointsDeleteRequest"
            }
          }
        }
      },
      "DatapointsDeleteRequest": {
        "type": "object",
        "description": "Select time series and data points to delete.",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "QueryWithInternalId",
            "allOf": [
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsDeleteRange"
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "QueryWithExternalId",
            "allOf": [
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsDeleteRange"
              }
            ]
          },
          {
            "required": [
              "instanceId"
            ],
            "title": "QueryWithInstanceId",
            "allOf": [
              {
                "properties": {
                  "instanceId": {
                    "$ref": "#/components/schemas/CogniteInstanceId"
                  }
                }
              },
              {
                "$ref": "#/components/schemas/DatapointsDeleteRange"
              }
            ]
          }
        ]
      },
      "DatapointsDeleteRange": {
        "required": [
          "inclusiveBegin"
        ],
        "properties": {
          "inclusiveBegin": {
            "$ref": "#/components/schemas/TimeSeriesEpochTimestamp"
          },
          "exclusiveEnd": {
            "$ref": "#/components/schemas/TimeSeriesEpochTimestamp"
          }
        }
      },
      "TimeSeriesLookupByIdWithoutInstanceId": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "uniqueItems": true,
                "type": "array",
                "description": "List of ID objects.",
                "items": {
                  "oneOf": [
                    {
                      "type": "object",
                      "title": "QueryWithInternalId",
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "title": "QueryWithExternalId",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    }
                  ]
                },
                "maxItems": 1000,
                "minItems": 1
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "TimeSeriesLookupById": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "uniqueItems": true,
                "type": "array",
                "description": "List of ID objects.",
                "items": {
                  "oneOf": [
                    {
                      "type": "object",
                      "title": "QueryWithInternalId",
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "title": "QueryWithExternalId",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "title": "QueryWithInstanceId",
                      "properties": {
                        "instanceId": {
                          "$ref": "#/components/schemas/CogniteInstanceId"
                        }
                      }
                    }
                  ]
                },
                "maxItems": 1000,
                "minItems": 1
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "TimeSeriesUpdateRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/TimeSeriesUpdate"
            }
          }
        }
      },
      "TimeSeriesUpdate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesUpdateById"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesUpdateByExternalId"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesUpdateByInstanceId"
          }
        ]
      },
      "TimeSeriesUpdateById": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesPatch"
          }
        ]
      },
      "TimeSeriesUpdateByExternalId": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesPatch"
          }
        ]
      },
      "TimeSeriesUpdateByInstanceId": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "instanceId"
            ],
            "properties": {
              "instanceId": {
                "$ref": "#/components/schemas/CogniteInstanceId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesPatchDM"
          }
        ]
      },
      "TimeSeriesPatch": {
        "type": "object",
        "description": "Changes will be applied to time series.",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/NullableSinglePatchString"
              },
              "name": {
                "$ref": "#/components/schemas/NullableSinglePatchString"
              },
              "metadata": {
                "$ref": "#/components/schemas/ObjectPatch"
              },
              "unit": {
                "$ref": "#/components/schemas/NullableSinglePatchString"
              },
              "unitExternalId": {
                "$ref": "#/components/schemas/NullableSinglePatchString"
              },
              "assetId": {
                "$ref": "#/components/schemas/NullableSinglePatchLong"
              },
              "isStep": {
                "$ref": "#/components/schemas/SinglePatchBoolean"
              },
              "description": {
                "$ref": "#/components/schemas/NullableSinglePatchString"
              },
              "securityCategories": {
                "$ref": "#/components/schemas/ArrayPatchLong"
              },
              "dataSetId": {
                "$ref": "#/components/schemas/NullableSinglePatchLong"
              }
            }
          }
        }
      },
      "TimeSeriesPatchDM": {
        "type": "object",
        "description": "Changes will be applied to time series. Note that these changes will not be visible in data modeling.",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/NullableSinglePatchString"
              },
              "metadata": {
                "$ref": "#/components/schemas/ObjectPatch"
              },
              "assetId": {
                "$ref": "#/components/schemas/NullableSinglePatchLong"
              },
              "dataSetId": {
                "$ref": "#/components/schemas/NullableSinglePatchLong"
              }
            }
          }
        }
      },
      "Aggregate": {
        "type": "string",
        "enum": [
          "average",
          "max",
          "min",
          "count",
          "sum",
          "interpolation",
          "stepInterpolation",
          "totalVariation",
          "continuousVariance",
          "discreteVariance",
          "countGood",
          "countUncertain",
          "countBad",
          "durationGood",
          "durationUncertain",
          "durationBad"
        ]
      },
      "TimeSeriesCursorResponse": {
        "$ref": "#/components/schemas/DataWithCursorGetTimeSeriesMetadataDTO"
      },
      "TimeSeriesCreateRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/PostTimeSeriesMetadataDTO"
            }
          }
        }
      },
      "DataGetTimeSeriesMetadataDTO": {
        "description": "List of responses. The order matches the requests order.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GetTimeSeriesMetadataDTO"
            }
          }
        }
      },
      "PostDatapoint": {
        "oneOf": [
          {
            "required": [
              "timestamp"
            ],
            "title": "NumericalDatapoint",
            "type": "object",
            "properties": {
              "timestamp": {
                "minimum": -2208988800000,
                "maximum": 4102444799999,
                "description": "The timestamp in milliseconds since the Epoch (Jan 1, 1970). The timestamp must be from a year between 1900 and 2099, inclusive. Use a negative number for timestamps before 1970."
              },
              "value": {
                "type": "number",
                "description": "The numerical data value of a numerical metric.\nNumerical data values can be in the range (-1e100, 1e100)\n\nThe value is required unless the status is bad. Bad data points may also have one\nof the three special string values: 'NaN', 'Infinity' or '-Infinity'."
              },
              "status": {
                "$ref": "#/components/schemas/DatapointStatus"
              }
            }
          },
          {
            "required": [
              "timestamp"
            ],
            "type": "object",
            "title": "StringDatapoint",
            "properties": {
              "timestamp": {
                "minimum": -2208988800000,
                "maximum": 4102444799999,
                "description": "The timestamp in milliseconds since the Epoch (Jan 1, 1970). The timestamp must be from a year between 1900 and 2099, inclusive. Use a negative number for timestamps before 1970."
              },
              "value": {
                "maxLength": 255,
                "type": "string",
                "description": "The string data value of a string metric. The value is required unless the status is bad.\n"
              },
              "status": {
                "$ref": "#/components/schemas/DatapointStatus"
              }
            }
          }
        ]
      },
      "DatapointStatus": {
        "type": "object",
        "description": "The [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>) of the datapoint.\n\nThe most common status codes are:\\\n_Good_ (0) (Default)\\\n_Uncertain_ (1073741824)\\\n_Bad_ (2147483648)\n\nOnly one of code and symbol is required. If both are defined, they must match.",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int64",
            "description": "The numeric status code of the data point."
          },
          "symbol": {
            "type": "string",
            "description": "The status name of the data point."
          }
        }
      },
      "DataWithCursorGetTimeSeriesMetadataDTO": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "items": {
              "$ref": "#/components/schemas/GetTimeSeriesMetadataDTO"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects and possible cursors to get the next results page."
      },
      "PostTimeSeriesMetadataDTO": {
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "type": "string",
            "description": "Externally provided ID for the time series (optional, but recommended)."
          },
          "name": {
            "maxLength": 255,
            "type": "string",
            "description": "Human readable name of the time series."
          },
          "legacyName": {
            "deprecated": true,
            "maxLength": 255,
            "type": "string",
            "description": "This field is deprecated and ignored."
          },
          "isString": {
            "type": "boolean",
            "default": false,
            "description": "Defines whether the time series contains string values (true) or numeric values (false).\nNot updatable - this field cannot be changed after the time series has been created.\n"
          },
          "metadata": {
            "$ref": "#/components/schemas/TimeSeriesMetadata"
          },
          "unit": {
            "maxLength": 32,
            "type": "string",
            "description": "The physical unit of the time series (free-text field)"
          },
          "unitExternalId": {
            "maxLength": 64,
            "type": "string",
            "description": "The physical unit of the time series as [represented in the unit catalog](<https://developer.cognite.com/dev/concepts/resource_types/units/>). Only available for numeric time series."
          },
          "assetId": {
            "description": "Asset ID of equipment linked to this time series.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "isStep": {
            "type": "boolean",
            "default": false,
            "description": "Defines whether the time series is a step series or not."
          },
          "description": {
            "maxLength": 1000,
            "type": "string",
            "description": "A description of the time series."
          },
          "securityCategories": {
            "type": "array",
            "description": "The required security categories to access this time series.",
            "items": {
              "type": "integer",
              "description": "The required security categories to access this time series.",
              "format": "int64"
            }
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          }
        }
      },
      "TimeSeriesCountAggregateResponse": {
        "type": "object",
        "title": "Count",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The number of time series that match the given filters."
                }
              }
            }
          }
        }
      },
      "TimeSeriesCardinalityValuesAggregateResponse": {
        "type": "object",
        "title": "CardinalityValues",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The approximate number of unique values for the given property among the time series that match the given filters."
                }
              }
            }
          }
        }
      },
      "TimeSeriesCardinalityPropertiesAggregateResponse": {
        "type": "object",
        "title": "CardinalityProperties",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The approximate number of unique properties that begin with the given property path among the time series that match the given filters."
                }
              }
            }
          }
        }
      },
      "TimeSeriesUniqueValuesAggregateResponse": {
        "type": "object",
        "title": "UniqueValues",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "property",
                "count"
              ],
              "properties": {
                "values": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "description": "The single element in this array is a value that's taken on by the given property in one or more of the time series that match the given filters. Note that even if the original value was a number or a boolean, the value would be represented as a string in this array.",
                  "items": {
                    "type": "string",
                    "maxLength": 10000
                  }
                },
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The number of time series that match the given filters and have the corresponding value for the given property."
                }
              }
            }
          }
        }
      },
      "TimeSeriesUniquePropertiesAggregateResponse": {
        "type": "object",
        "title": "UniqueProperties",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "property",
                "count"
              ],
              "properties": {
                "values": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "items": {
                    "type": "object",
                    "properties": {
                      "property": {
                        "type": "array",
                        "minItems": 1,
                        "maxItems": 2,
                        "description": "The single element in this array is a property specification - either a top-level property, such as `['name']`, or a metadata property, such as `['metadata', 'tag']`.",
                        "items": {
                          "type": "string",
                          "maxLength": 10000
                        }
                      }
                    }
                  }
                },
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The number of time series that match the given filters and have the corresponding property."
                }
              }
            }
          }
        }
      },
      "GetDatapointMetadata": {
        "type": "object",
        "required": [
          "timestamp"
        ],
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/TimeSeriesEpochTimestamp"
          }
        }
      },
      "GetStringDatapoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GetDatapointMetadata"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string",
                "description": "The data value. The value is required unless the status is bad.\nIf the status is bad, the value may also be null (omitted).\n"
              },
              "status": {
                "$ref": "#/components/schemas/DatapointStatus"
              }
            }
          }
        ]
      },
      "GetDoubleDatapoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GetDatapointMetadata"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number",
                "description": "The data value.\nThe value is required unless the status is bad.\n\nIf the status is bad, the value may also be one of the 3 special string values:\n'NaN', 'Infinity' or '-Infinity'.",
                "format": "double"
              },
              "status": {
                "$ref": "#/components/schemas/DatapointStatus"
              }
            }
          }
        ]
      },
      "GetAggregateDatapoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GetDatapointMetadata"
          },
          {
            "type": "object",
            "properties": {
              "average": {
                "type": "number",
                "description": "The integral average value in the aggregate period.",
                "format": "double"
              },
              "max": {
                "type": "number",
                "description": "The maximum value in the aggregate period.",
                "format": "double"
              },
              "min": {
                "type": "number",
                "description": "The minimum value in the aggregate period.",
                "format": "double"
              },
              "count": {
                "type": "integer",
                "description": "The number of data points in the aggregate period.",
                "format": "int32"
              },
              "sum": {
                "type": "number",
                "description": "The sum of the data points in the aggregate period.",
                "format": "double"
              },
              "interpolation": {
                "type": "number",
                "description": "The interpolated value of the series in the beginning of the aggregate.",
                "format": "double"
              },
              "stepInterpolation": {
                "type": "number",
                "description": "The last value before or at the beginning of the aggregate.",
                "format": "double"
              },
              "continuousVariance": {
                "type": "number",
                "description": "The variance of the interpolated underlying function.",
                "format": "double"
              },
              "discreteVariance": {
                "type": "number",
                "description": "The variance of the data point values.",
                "format": "double"
              },
              "totalVariation": {
                "type": "number",
                "description": "The total variation of the interpolated underlying function.",
                "format": "double"
              },
              "countGood": {
                "type": "integer",
                "description": "The number of data points in the aggregate period that have a _Good_ [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>). _Uncertain_ does not count, irrespective of `treatUncertainAsBad` parameter.",
                "format": "int64"
              },
              "countUncertain": {
                "type": "integer",
                "description": "The number of data points in the aggregate period that have an _Uncertain_ [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>).",
                "format": "int64"
              },
              "countBad": {
                "type": "integer",
                "description": "The number of data points in the aggregate period that have a _Bad_ [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>). _Uncertain_ does not count, irrespective of `treatUncertainAsBad` parameter.",
                "format": "int64"
              },
              "durationGood": {
                "type": "integer",
                "description": "The duration the aggregate is defined and marked as good (regardless of `ignoreBadDataPoints` parameter). Measured in milliseconds. Equivalent to duration that the previous data point is _good_ and in range.",
                "format": "int64"
              },
              "durationUncertain": {
                "type": "integer",
                "description": "The duration the aggregate is defined and marked as uncertain (regardless of `ignoreBadDataPoints` parameter). Measured in milliseconds. Equivalent to duration that the previous data point is _uncertain_ and in range.",
                "format": "int64"
              },
              "durationBad": {
                "type": "integer",
                "description": "The duration the aggregate is defined but marked as bad (regardless of `ignoreBadDataPoints` parameter). Measured in milliseconds. Equivalent to duration that the previous data point is _bad_ and in range.",
                "format": "int64"
              }
            }
          }
        ]
      },
      "TimeSeriesMetadata": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Maximum length of key is 128 bytes, up to 256 key-value pairs, of total size of at most 10000 bytes across all keys and values.",
        "additionalProperties": {
          "type": "string"
        }
      },
      "GetTimeSeriesMetadataDTO": {
        "required": [
          "id",
          "isString",
          "isStep",
          "createdTime",
          "lastUpdatedTime"
        ],
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "maxLength": 255,
            "type": "string",
            "description": "The externally supplied ID for the time series."
          },
          "instanceId": {
            "$ref": "#/components/schemas/CogniteInstanceId"
          },
          "name": {
            "maxLength": 255,
            "type": "string",
            "description": "The display short name of the time series."
          },
          "isString": {
            "type": "boolean",
            "description": "True if the time series contains string values; false if it contains numeric values.\n"
          },
          "metadata": {
            "$ref": "#/components/schemas/TimeSeriesMetadata"
          },
          "unit": {
            "maxLength": 32,
            "type": "string",
            "description": "The physical unit of the time series (free-text field)"
          },
          "unitExternalId": {
            "maxLength": 64,
            "type": "string",
            "description": "The physical unit of the time series as [represented in the unit catalog](<https://developer.cognite.com/dev/concepts/resource_types/units/>)."
          },
          "assetId": {
            "description": "Asset ID of equipment linked to this time series.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "isStep": {
            "type": "boolean",
            "description": "Defines whether the time series is a step series or not."
          },
          "description": {
            "maxLength": 1000,
            "type": "string",
            "description": "Description of the time series."
          },
          "securityCategories": {
            "type": "array",
            "description": "The required security categories to access this time series.",
            "items": {
              "type": "integer",
              "description": "Security categories required to access this time series.",
              "format": "int64"
            }
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "DatapointsMetadata": {
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "maxLength": 255,
            "type": "string",
            "description": "The external ID of the time series the data points belong to."
          },
          "instanceId": {
            "$ref": "#/components/schemas/CogniteInstanceId"
          }
        }
      },
      "DatapointsGetStringDatapoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DatapointsMetadata"
          },
          {
            "type": "object",
            "required": [
              "datapoints",
              "isString"
            ],
            "properties": {
              "isString": {
                "description": "True if the time series contains string values; false if it contains numeric values.",
                "type": "boolean"
              },
              "unit": {
                "maxLength": 32,
                "type": "string",
                "description": "The physical unit of the time series (free-text field)."
              },
              "nextCursor": {
                "type": "string",
                "description": "The cursor to get the next page of results (if available).\n`nextCursor` will be omitted when the next data point is after the end of the\ninterval. Increase start/end to fetch more data.\n"
              },
              "datapoints": {
                "type": "array",
                "description": "The list of datapoints.",
                "items": {
                  "$ref": "#/components/schemas/GetStringDatapoint"
                }
              }
            }
          }
        ]
      },
      "DatapointsGetDoubleDatapoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DatapointsMetadata"
          },
          {
            "type": "object",
            "required": [
              "datapoints",
              "isString"
            ],
            "properties": {
              "isString": {
                "description": "True if the time series contains string values; false if it contains numeric values.",
                "type": "boolean"
              },
              "isStep": {
                "description": "Defines whether the time series is a step series or not.",
                "type": "boolean"
              },
              "unit": {
                "maxLength": 32,
                "type": "string",
                "description": "The physical unit of the time series (free-text field). Omitted if data points were converted to a different unit."
              },
              "unitExternalId": {
                "maxLength": 64,
                "type": "string",
                "description": "The physical unit of the time series as [represented in the unit catalog](<https://developer.cognite.com/dev/concepts/resource_types/units/>). Replaced with target unit if data points were converted."
              },
              "nextCursor": {
                "type": "string",
                "description": "The cursor to get the next page of results (if available).\n`nextCursor` will be omitted when the next data point is after the end of the\ninterval. Increase start/end to fetch more data.\n"
              },
              "datapoints": {
                "type": "array",
                "description": "The list of data points.",
                "items": {
                  "$ref": "#/components/schemas/GetDoubleDatapoint"
                }
              }
            }
          }
        ]
      },
      "DatapointsGetDatapoint": {
        "required": [
          "isString"
        ],
        "oneOf": [
          {
            "$ref": "#/components/schemas/DatapointsGetDoubleDatapoint"
          },
          {
            "$ref": "#/components/schemas/DatapointsGetStringDatapoint"
          }
        ]
      },
      "DatapointsGetAggregateDatapoint": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DatapointsMetadata"
          },
          {
            "type": "object",
            "required": [
              "datapoints",
              "isString",
              "isStep"
            ],
            "properties": {
              "isString": {
                "description": "True if the time series contains string values; false if it contains numeric values. Always false for aggregates, as they can only be requested for numeric time series.",
                "type": "boolean",
                "enum": [
                  false
                ]
              },
              "isStep": {
                "description": "Defines whether the time series is a step series or not.",
                "type": "boolean"
              },
              "unit": {
                "maxLength": 32,
                "type": "string",
                "description": "The physical unit of the time series (free-text field). Omitted if data points were converted to a different unit."
              },
              "unitExternalId": {
                "maxLength": 64,
                "type": "string",
                "description": "The physical unit of the time series as [represented in the unit catalog](<https://docs.cognite.com/dev/concepts/resource_types/units>). Replaced with target unit if data points were converted."
              },
              "nextCursor": {
                "type": "string",
                "description": "The cursor to get the next page of results (if available).\n`nextCursor` will be omitted when the next aggregate datapoint is after the end\nof the interval. Increase start/end to fetch more data.\n"
              },
              "datapoints": {
                "type": "array",
                "description": "The list of datapoints",
                "items": {
                  "$ref": "#/components/schemas/GetAggregateDatapoint"
                }
              }
            }
          }
        ]
      },
      "DatapointsOrAggregatesResponse": {
        "description": "The list of responses. The order matches the requests order.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DatapointsGetAggregateDatapoint"
                },
                {
                  "$ref": "#/components/schemas/DatapointsGetDatapoint"
                }
              ]
            }
          }
        }
      },
      "DatapointsResponse": {
        "type": "object",
        "description": "The list of responses. The order matches the requests order.",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DatapointsGetDatapoint"
            }
          }
        }
      },
      "Filter": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Filter on name.",
            "type": "string"
          },
          "unit": {
            "description": "Filter on unit.",
            "type": "string"
          },
          "unitExternalId": {
            "description": "Filter on unitExternalId.",
            "type": "string"
          },
          "unitQuantity": {
            "description": "Filter on unitQuantity.",
            "type": "string"
          },
          "isString": {
            "description": "Filter on isString.",
            "type": "boolean"
          },
          "isStep": {
            "description": "Filter on isStep.",
            "type": "boolean"
          },
          "metadata": {
            "$ref": "#/components/schemas/TimeSeriesMetadata"
          },
          "assetIds": {
            "type": "array",
            "description": "Only includes time series that reference these specific asset IDs.",
            "example": [
              363848954441724,
              793045462540095,
              1261042166839739
            ],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true
          },
          "assetExternalIds": {
            "type": "array",
            "uniqueItems": true,
            "minItems": 1,
            "maxItems": 100,
            "description": "Asset External IDs of related equipment that this time series relates to.",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          },
          "rootAssetIds": {
            "type": "array",
            "description": "Only includes time series that have a related asset in a tree rooted at any of these root `assetIds`.",
            "example": [
              343099548723932,
              88483999203217
            ],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true
          },
          "assetSubtreeIds": {
            "type": "array",
            "uniqueItems": true,
            "minItems": 1,
            "maxItems": 100,
            "description": "Only includes time series that are related to an asset in a subtree rooted at any of these `assetIds` (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "items": {
              "$ref": "#/components/schemas/AssetIdEither"
            }
          },
          "dataSetIds": {
            "type": "array",
            "uniqueItems": true,
            "minItems": 1,
            "maxItems": 100,
            "description": "Only includes time series that reference these specific data set IDs.",
            "items": {
              "$ref": "#/components/schemas/DataSetIdEither"
            }
          },
          "externalIdPrefix": {
            "$ref": "#/components/schemas/CogniteExternalIdPrefix"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          }
        }
      },
      "Search": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Prefix and fuzzy search on name.",
            "type": "string"
          },
          "description": {
            "description": "Prefix and fuzzy search on description.",
            "type": "string"
          },
          "query": {
            "description": "Whitespace-separated terms to search for in time series. Does a\nbest-effort fuzzy search in relevant fields (currently name and\ndescription) for variations of any search terms and\norders results by relevance. Uses a different search algorithm\nthan the name and description parameters and will generally give\nmuch better results. Matching and ordering aren't guaranteed to\nbe stable over time, and the fields being searched may be\nextended.",
            "type": "string",
            "example": "some other"
          }
        }
      },
      "TimeSeriesSearchDTO": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/Filter"
          },
          "search": {
            "$ref": "#/components/schemas/Search"
          },
          "limit": {
            "description": "Return up to this many results.",
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "format": "int32",
            "default": 100
          }
        }
      },
      "TimeSeriesListDTO": {
        "description": "Filter request for time series. Filters exact field matching or timestamp ranges inclusive min and max.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/Filter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/TimeSeriesFilterLanguage"
              },
              "limit": {
                "description": "Return up to this many results.",
                "maximum": 1000,
                "minimum": 1,
                "type": "integer",
                "format": "int32",
                "default": 100
              }
            }
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/PartitionObject"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesSort"
          }
        ]
      },
      "TimeSeriesAggregateDTO": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/Filter"
          },
          "advancedFilter": {
            "$ref": "#/components/schemas/TimeSeriesFilterLanguage"
          }
        }
      },
      "TimeSeriesAdvancedAggregateDTO": {
        "type": "object",
        "allOf": [
          {
            "properties": {
              "advancedFilter": {
                "$ref": "#/components/schemas/TimeSeriesFilterLanguage"
              },
              "filter": {
                "$ref": "#/components/schemas/Filter"
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/TimeSeriesAggregateFilter"
              }
            }
          },
          {
            "oneOf": [
              {
                "$ref": "#/components/schemas/TimeSeriesCountAggregate"
              },
              {
                "$ref": "#/components/schemas/TimeSeriesCardinalityValuesAggregate"
              },
              {
                "$ref": "#/components/schemas/TimeSeriesCardinalityPropertiesAggregate"
              },
              {
                "$ref": "#/components/schemas/TimeSeriesUniqueValuesAggregate"
              },
              {
                "$ref": "#/components/schemas/TimeSeriesUniquePropertiesAggregate"
              }
            ]
          }
        ]
      },
      "TimeSeriesCountAggregate": {
        "type": "object",
        "title": "Count",
        "properties": {
          "aggregate": {
            "description": "The `count` aggregation gets the number of time series that match the filter(s). This is the\r\ndefault aggregation, which will also be applied if `aggregate` is not specified.\r\n",
            "type": "string",
            "enum": [
              "count"
            ]
          }
        }
      },
      "TimeSeriesCardinalityValuesAggregate": {
        "title": "CardinalityValues",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `cardinalityValues` aggregation gets, from the time series that match the filter(s),\r\nthe approximate number of unique values that are taken on by the given property.\r\n",
                "type": "string",
                "enum": [
                  "cardinalityValues"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesAggregateProperties"
          }
        ]
      },
      "TimeSeriesCardinalityPropertiesAggregate": {
        "title": "CardinalityProperties",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `cardinalityProperties` aggregation gets, from the time series that match the filter(s),\r\nthe approximate number of unique properties whose property path begins with the given `path`.\r\nCurrently, the only supported value for `path` is `[\"metadata\"]`, which means that this aggregation\r\nwill get the approximate size of the set of unique metadata keys.\r\n",
                "type": "string",
                "enum": [
                  "cardinalityProperties"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesAggregatePath"
          }
        ]
      },
      "TimeSeriesUniqueValuesAggregate": {
        "title": "UniqueValues",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `uniqueValues` aggregation gets, from the time series that match the filter(s),\r\nthe set of unique values (up to max 1000) that are taken on by the given property. For each such\r\nvalue, the aggregation result will also specify the frequency - that is, the number of time series\r\nthat match the filter(s) and have that property value. The results are ordered by frequency in\r\ndescending order.\r\n",
                "type": "string",
                "enum": [
                  "uniqueValues"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesAggregateProperties"
          }
        ]
      },
      "TimeSeriesUniquePropertiesAggregate": {
        "title": "UniqueProperties",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `uniqueProperties` aggregation gets, from the time series that match the filter(s),\r\nthe set of unique properties (up to max 1000) whose property path begins with the given `path`.\r\nCurrently, the only supported value for `path` is `[\"metadata\"]`, which means that this aggregation\r\nwill get the set of unique metadata keys. For each such property, the aggregation result will also\r\nspecify the frequency - that is, the number of time series that match the filter(s) and have that\r\nproperty. The results are ordered by frequency in descending order.\r\n",
                "type": "string",
                "enum": [
                  "uniqueProperties"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/TimeSeriesAggregatePath"
          }
        ]
      },
      "TimeSeriesAggregateProperties": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "description": "The properties to which the aggregation should be applied. While this parameter is a list, it\r\ncurrently only accepts one element. Each element is an object with a single field called `property`,\r\nwhose value is another list (in order to accommodate nested properties). Thus, a top-level property\r\n`name` must be specified as `[{\"property\": [\"name\"]}]`, and a metadata property `tag` must be\r\nspecified as `[{\"property\": [\"metadata\", \"tag\"]}]`.\r\n\r\nThe supported top-level properties are:\r\n- `accessCategories`\r\n- `assetId`\r\n- `assetRootId`\r\n- `createdTime`\r\n- `dataSetId`\r\n- `description`\r\n- `externalId`\r\n- `id`\r\n- `isStep`\r\n- `isString`\r\n- `lastUpdatedTime`\r\n- `name`\r\n- `securityCategories`\r\n- `unit`\r\n",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "property"
              ],
              "properties": {
                "property": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 2,
                  "items": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 256
                  }
                }
              }
            }
          }
        }
      },
      "TimeSeriesAggregatePath": {
        "type": "object",
        "required": [
          "path"
        ],
        "properties": {
          "path": {
            "description": "The scope within which properties should be aggregated. The only value that is currently allowed is `[\"metadata\"]`, which will aggregate metadata keys.",
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "string",
              "enum": [
                "metadata"
              ]
            }
          }
        }
      },
      "NullableSinglePatchLong": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "type": "integer",
                "format": "int64"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "setNull"
            ],
            "properties": {
              "setNull": {
                "type": "boolean",
                "enum": [
                  true
                ]
              }
            }
          }
        ],
        "description": "The change that will be applied to the key."
      },
      "NullableSinglePatchString": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "type": "string"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "setNull"
            ],
            "properties": {
              "setNull": {
                "type": "boolean",
                "enum": [
                  true
                ]
              }
            }
          }
        ],
        "description": "The change that will be applied to the key."
      },
      "SubscriptionsCreateRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "description": "<details>\n<summary>\nSubscription definitions. A subscription may be configured explicitly with a list\nof time series, or it may be a configured dynamically through a filter. The\nsubscription cannot change type later.\n\nAn explicit list must be manually updated by the user, while a filter will be updated\nautomatically whenever a time series is added/deleted/updated (eventually consistent).\n\nThe filter subscriptions uses the same syntax as advanced filters in the _Filter time series_\nendpoint, with two exceptions: The field is named &#x60;filter&#x60; instead of &#x60;advancedFilter&#x60;,\nand we do not support the &#x60;search&#x60; LeafFilter.\n</summary>\n\n### Advanced filtering\n\nThe `filter`\nfield lets you create complex filtering expressions that combine simple operations,\nsuch as `equals`, `prefix`, and `exists`, by using the Boolean operators `and`, `or`, and `not`.\nFiltering applies to basic fields as well as metadata. See the `advancedFilter` syntax in the request example.\n\n\n\n#### Supported leaf filters\n\n| Leaf filter    | Supported fields       | Description and example                                                                                                                                                            |\n|----------------|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `containsAll`  | Array type fields      | Only includes results which contain all of the specified values. <br /> `{\"containsAll\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                         |\n| `containsAny`  | Array type fields      | Only includes results which contain at least one of the specified values. <br /> `{\"containsAny\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                |\n| `equals`       | Non-array type fields  | Only includes results that are equal to the specified value. <br /> `{\"equals\": {\"property\": [\"property\"], \"value\": \"example\"}}`                                                   |\n| `exists`       | All fields             | Only includes results where the specified property exists (has a value). <br /> `{\"exists\": {\"property\": [\"property\"]}}`                                                           |\n| `in`           | Non-array type fields  | Only includes results that are equal to one of the specified values. <br /> `{\"in\": {\"property\": [\"property\"], \"values\": [1, 2, 3]}}`                                              |\n| `prefix`       | String type fields     | Only includes results which start with the specified text. <br /> `{\"prefix\": {\"property\": [\"property\"], \"value\": \"example\"}}`                                                     |\n| `range`        | Non-array type fields  | Only includes results that fall within the specified range. <br /> `{\"range\": {\"property\": [\"property\"], \"gt\": 1, \"lte\": 5}}` <br /> Supported operators: `gt`, `lt`, `gte`, `lte` |\n\n#### Supported properties\n\n| Property                          | Type               |\n|-----------------------------------|--------------------|\n| `[\"description\"]`                 | string             |\n| `[\"externalId\"]`                  | string             |\n| `[\"metadata\", \"<someCustomKey>\"]` | string             |\n| `[\"name\"]`                        | string             |\n| `[\"unit\"]`                         | string              |\n| `[\"unitExternalId\"]`               | string              |\n| `[\"unitQuantity\"]`                 | string              |\n| `[\"instanceId\", \"space\"]`          | string              |\n| `[\"instanceId\", \"externalId\"]`     | string              |\n| `[\"assetId\"]`                      | number              |\n| `[\"assetRootId\"]`                  | number              |\n| `[\"createdTime\"]`                  | number              |\n| `[\"dataSetId\"]`                    | number              |\n| `[\"id\"]`                           | number              |\n| `[\"lastUpdatedTime\"]`              | number              |\n| `[\"isStep\"]`                       | Boolean             |\n| `[\"isString\"]`                     | Boolean             |\n\n#### Limits\n\n- Filter query max depth: 10.\n- Filter query max number of clauses: 100.\n- `and` and `or` clauses must have at least one element (and at most 99, since each element counts\n  towards the total clause limit, and so does the `and`/`or` clause itself).\n- The `property` array of each leaf filter has the following limitations:\n  - Number of elements in the array is 1 or 2.\n  - Elements must not be null or blank.\n  - Each element max length is 256 characters.\n  - The `property` array must match one of the existing properties (static top-level property or dynamic metadata property).\n- `containsAll`, `containsAny`, and `in` filter `values` array size must be in the range [1, 100].\n- `containsAll`, `containsAny`, and `in` filter `values` array must contain elements of number or string type (matching the type of the given property).\n- `range` filter must have at lest one of `gt`, `gte`, `lt`, `lte` attributes.\n  But `gt` is mutually exclusive to `gte`, while `lt` is mutually exclusive to `lte`.\n- `gt`, `gte`, `lt`, `lte` in the `range` filter must be of number or string type (matching the type of the given property).\n- The maximum length of the `value` of a leaf filter that is applied to a string property is 256.\n\n</details>",
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "maxLength": 255,
                  "type": "string",
                  "description": "Externally provided ID for the subscription. Must be unique."
                },
                "name": {
                  "maxLength": 255,
                  "type": "string",
                  "description": "Human readable name of the subscription."
                },
                "description": {
                  "maxLength": 1000,
                  "type": "string",
                  "description": "A description of the subscription."
                },
                "dataSetId": {
                  "$ref": "#/components/schemas/DataSetId"
                },
                "partitionCount": {
                  "description": "The maximum effective parallelism of this subscription (the number of clients that can read from it concurrently) will be limited to this number, but a higher partition count will cause a higher time overhead.",
                  "minimum": 1,
                  "maximum": 100,
                  "type": "integer",
                  "format": "int32"
                },
                "timeSeriesIds": {
                  "type": "array",
                  "description": "List of (external) ids of time series that this subscription will listen to. Not compatible with filter.",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                },
                "instanceIds": {
                  "type": "array",
                  "description": "List of instance ids of time series that this subscription will listen to. Not compatible with filter.",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "$ref": "#/components/schemas/CogniteInstanceId"
                  }
                },
                "filter": {
                  "$ref": "#/components/schemas/SubscriptionFilterLanguage"
                }
              }
            }
          }
        }
      },
      "ListSubscriptionDTO": {
        "description": "List of subscriptions.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SubscriptionDTO"
            }
          }
        }
      },
      "ListSubscriptionDTOWithCursor": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/SubscriptionDTO"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of subscriptions along with possible cursors to get the next page of result"
      },
      "ListSubscriptionMemberDTOWithCursor": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/SubscriptionMemberDTO"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of member time series along with possible cursors to get the next page of result"
      },
      "SubscriptionMemberDTO": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "instanceId": {
            "$ref": "#/components/schemas/CogniteInstanceId"
          }
        }
      },
      "SubscriptionDTO": {
        "type": "object",
        "required": [
          "externalId",
          "partitionCount",
          "createdTime",
          "lastUpdatedTime"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "description": "The display name of this subscription.",
            "type": "string"
          },
          "description": {
            "description": "Description of this subscription.",
            "type": "string"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          },
          "partitionCount": {
            "description": "The number of partitions in this subscriptions",
            "minimum": 1,
            "maximum": 100,
            "type": "integer",
            "format": "int32"
          },
          "timeSeriesCount": {
            "type": "integer",
            "format": "int32",
            "description": "The number of time series in the subscription."
          },
          "filter": {
            "$ref": "#/components/schemas/SubscriptionFilterLanguage"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "SubscriptionsByIdsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "allOf": [
          {
            "properties": {
              "items": {
                "uniqueItems": true,
                "type": "array",
                "maxItems": 1,
                "minItems": 1,
                "description": "List of ID objects",
                "items": {
                  "type": "object",
                  "title": "QueryWithExternalId",
                  "properties": {
                    "externalId": {
                      "$ref": "#/components/schemas/CogniteExternalId"
                    }
                  }
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "SubscriptionsUpdateRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "externalId",
                "update"
              ],
              "title": "Select by externalId",
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                },
                "update": {
                  "type": "object",
                  "properties": {
                    "timeSeriesIds": {
                      "description": "Update subscription definition (not applicable for filter subscriptions).",
                      "type": "object",
                      "oneOf": [
                        {
                          "properties": {
                            "add": {
                              "type": "array",
                              "description": "List of (external) ids of time series to add to the subscription.",
                              "minItems": 1,
                              "maxItems": 100,
                              "items": {
                                "$ref": "#/components/schemas/CogniteExternalId"
                              }
                            },
                            "remove": {
                              "type": "array",
                              "description": "List of (external) ids of time series to remove from the subscription.",
                              "minItems": 1,
                              "maxItems": 100,
                              "items": {
                                "$ref": "#/components/schemas/CogniteExternalId"
                              }
                            }
                          }
                        },
                        {
                          "properties": {
                            "set": {
                              "type": "array",
                              "description": "Replace the subscription's current list of time series with this list of (external) ids.",
                              "minItems": 1,
                              "maxItems": 100,
                              "items": {
                                "$ref": "#/components/schemas/CogniteExternalId"
                              }
                            }
                          }
                        }
                      ]
                    },
                    "instanceIds": {
                      "description": "Update subscription definition (not applicable for filter subscriptions).",
                      "type": "object",
                      "oneOf": [
                        {
                          "properties": {
                            "add": {
                              "type": "array",
                              "description": "List of instance ids of time series to add to the subscription.",
                              "minItems": 1,
                              "maxItems": 100,
                              "items": {
                                "$ref": "#/components/schemas/CogniteInstanceId"
                              }
                            },
                            "remove": {
                              "type": "array",
                              "description": "List of instance ids of time series to remove from the subscription.",
                              "minItems": 1,
                              "maxItems": 100,
                              "items": {
                                "$ref": "#/components/schemas/CogniteInstanceId"
                              }
                            }
                          }
                        },
                        {
                          "properties": {
                            "set": {
                              "type": "array",
                              "description": "Replace the subscription's current list of time series with this list of instance ids.",
                              "minItems": 1,
                              "maxItems": 100,
                              "items": {
                                "$ref": "#/components/schemas/CogniteInstanceId"
                              }
                            }
                          }
                        }
                      ]
                    },
                    "name": {
                      "$ref": "#/components/schemas/NullableSinglePatchString"
                    },
                    "description": {
                      "$ref": "#/components/schemas/NullableSinglePatchString"
                    },
                    "dataSetId": {
                      "$ref": "#/components/schemas/NullableSinglePatchLong"
                    },
                    "filter": {
                      "type": "object",
                      "description": "New filter definition of the subscription. This can only be used to\nupdate a filter subscription. It is not possible to delete a filter,\nyou will have to delete the subscription.\nThis update is eventually consistent, there may be a period of time where\nyou get a mix of data, both from the old and the new filter.",
                      "properties": {
                        "set": {
                          "$ref": "#/components/schemas/SubscriptionFilterLanguage"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "SubscriptionsDeleteRequest": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "uniqueItems": true,
                "type": "array",
                "description": "List of ID objects",
                "items": {
                  "type": "object",
                  "title": "QueryWithExternalId",
                  "properties": {
                    "externalId": {
                      "$ref": "#/components/schemas/CogniteExternalId"
                    }
                  }
                },
                "maxItems": 1,
                "minItems": 1
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "SubscriptionsListDataRequest": {
        "type": "object",
        "required": [
          "partitions"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "partitions": {
            "type": "array",
            "description": "Pairs of (partition, cursor) to fetch from.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionsDataPartitionRequestDTO"
            }
          },
          "limit": {
            "type": "integer",
            "description": "Approximate number of results to return across all partitions. We will batch together groups of updates, where each group come from the same ingestion request. Thus, if a single group is large, it may exceed limit, otherwise we will return up to limit results. To check whether you have reached the end, do not rely on the count. Instead, check the `hasNext` field.",
            "minimum": 1,
            "maximum": 100000,
            "default": 100
          },
          "initializeCursors": {
            "type": "string",
            "description": "If `partitions.cursor` is not set, the default behaviour is to start from the beginning of the stream.\n`initializeCursors` can be used to override this behaviour.\n\nThe format is \"N[timeunit]-ago\", where timeunit is w,d,h,m (week, day, hour, minute).\nFor instance, \"2d-ago\" will give a stream of changes ingested up to 2 days ago.\nYou can also use \"now\" to jump straight to the end of the stream.\n\nNote that initializeCursors is not exact; a deviation of some seconds can occur."
          },
          "pollTimeoutSeconds": {
            "type": "integer",
            "minimum": 0,
            "maximum": 5,
            "default": 5,
            "description": "The maximum time to wait for data to arrive, in seconds. As soon as data is available,\nthe request will return immediately with the data. If the timeout is reached while\nwaiting for data, the request will return an empty data response."
          },
          "includeStatus": {
            "type": "boolean",
            "description": "Show the [status code](<https://developer.cognite.com/dev/concepts/reference/status_codes>) for each data point in the response.\n_Good_ (code = 0) status codes are always omitted.",
            "default": false
          },
          "ignoreBadDataPoints": {
            "type": "boolean",
            "description": "Treat data points with a _Bad_ status code as if they do not exist.\nSet to false to include all data points.",
            "default": true
          },
          "treatUncertainAsBad": {
            "type": "boolean",
            "description": "Treat data points with _Uncertain_ status codes as _Bad_.\nSet to false to include uncertain data points.",
            "default": true
          }
        }
      },
      "SubscriptionsDataPartitionRequestDTO": {
        "type": "object",
        "properties": {
          "index": {
            "type": "integer",
            "description": "Partition index to fetch data from. Between 0 and `partitions-1` inclusive."
          },
          "cursor": {
            "type": "string",
            "description": "Position in the partition stream to start fetching data from. Defaults to start of stream."
          }
        }
      },
      "SubscriptionsListDataResponse": {
        "type": "object",
        "description": "Subscription data along with cursors.",
        "required": [
          "updates",
          "partitions",
          "hasNext"
        ],
        "properties": {
          "updates": {
            "type": "array",
            "description": "List of updates from the subscription, sorted by point in time they were applied to the time series. Every update contains a time series along with a set of changes to that time series.",
            "items": {
              "$ref": "#/components/schemas/SubscriptionsDataUpdateResponseDTO"
            }
          },
          "subscriptionChanges": {
            "type": "object",
            "description": "If present, this object represents changes to the subscription definition. The\nsubscription will now start/stop listening to changes from the time series\nlisted here.\n\nThese changes can be triggered by explicit changes through the _Update subscriptions_\nendpoint, or they can be caused by changes in time series, in that they start/stop\nmatching the filter for the subscription.\n\nTime series are added to these lists when the change takes effect, which may be\nlater than the actual trigger.\n\nThe object is partitioned - it will only be present in the response for the relevant\npartition, from which the time series was added/removed.",
            "properties": {
              "added": {
                "type": "array",
                "description": "Time series added to the subscription (for this partition).",
                "items": {
                  "$ref": "#/components/schemas/GetTimeSeriesForSubscription"
                }
              },
              "removed": {
                "type": "array",
                "description": "Time series removed from the subscription (for this partition).",
                "items": {
                  "$ref": "#/components/schemas/GetTimeSeriesForSubscription"
                }
              }
            }
          },
          "partitions": {
            "type": "array",
            "description": "List of partition/cursor pairs to use for the next request.",
            "items": {
              "type": "object",
              "required": [
                "index",
                "nextCursor"
              ],
              "properties": {
                "index": {
                  "type": "integer",
                  "description": "Partition index."
                },
                "nextCursor": {
                  "type": "string",
                  "description": "Cursor to use in subsequent query, to fetch the next batch of updates.\nThe cursor will always be present, even if there are no more updates at the time."
                }
              }
            }
          },
          "hasNext": {
            "type": "boolean",
            "description": "Whether there is more data available at the time of the query.\nIn rare cases, we may return true, even if there is no data available. If that is\nthe case, just continue to query with the updated cursors,\nand it will eventually return false."
          }
        }
      },
      "SubscriptionsDataUpdateResponseDTO": {
        "type": "object",
        "properties": {
          "timeSeries": {
            "$ref": "#/components/schemas/GetTimeSeriesForSubscription"
          },
          "upserts": {
            "$ref": "#/components/schemas/SubscriptionsDataUpsertsDTO"
          },
          "deletes": {
            "$ref": "#/components/schemas/SubscriptionsDataDeletesDTO"
          }
        }
      },
      "SubscriptionsDataUpsertsDTO": {
        "type": "array",
        "description": "List of data points inserted into the time series (possibly overwriting existing data).",
        "items": {
          "$ref": "#/components/schemas/PostDatapoint"
        }
      },
      "SubscriptionsDataDeletesDTO": {
        "type": "array",
        "description": "List of time ranges in which all data points were deleted.",
        "items": {
          "$ref": "#/components/schemas/DatapointsDeleteRange"
        }
      },
      "GetTimeSeriesForSubscription": {
        "type": "object",
        "required": [
          "id",
          "isString"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "instanceId": {
            "$ref": "#/components/schemas/CogniteInstanceId"
          },
          "isString": {
            "type": "boolean",
            "description": "True if the time series contains string values; false if it contains numeric values.\n"
          }
        }
      },
      "DuplicatedIdsInRequestResponse": {
        "type": "object",
        "required": [
          "error"
        ],
        "properties": {
          "error": {
            "type": "object",
            "description": "Error details",
            "required": [
              "code",
              "message",
              "duplicated"
            ],
            "properties": {
              "code": {
                "type": "integer",
                "description": "HTTP status code",
                "format": "int32",
                "example": 422
              },
              "message": {
                "type": "string",
                "description": "Error message"
              },
              "duplicated": {
                "uniqueItems": true,
                "type": "array",
                "description": "Items that are duplicated in the request.",
                "items": {
                  "description": "Ids and ExternalIds that are duplicated in the request.",
                  "oneOf": [
                    {
                      "type": "object",
                      "required": [
                        "id"
                      ],
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "externalId"
                      ],
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "ExternalIdsAlreadyExistResponse": {
        "type": "object",
        "required": [
          "error"
        ],
        "properties": {
          "error": {
            "type": "object",
            "description": "Error details",
            "required": [
              "code",
              "message",
              "duplicated"
            ],
            "properties": {
              "code": {
                "type": "integer",
                "description": "HTTP status code",
                "format": "int32",
                "example": 409
              },
              "message": {
                "type": "string",
                "description": "Error message"
              },
              "duplicated": {
                "uniqueItems": true,
                "type": "array",
                "description": "Items that are duplicated.",
                "items": {
                  "description": "ExternalIds that already exist.",
                  "type": "object",
                  "required": [
                    "externalId"
                  ],
                  "properties": {
                    "externalId": {
                      "$ref": "#/components/schemas/CogniteExternalId"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "NotFoundResponseWithoutInstanceId": {
        "type": "object",
        "required": [
          "error"
        ],
        "properties": {
          "error": {
            "type": "object",
            "description": "Error details.",
            "required": [
              "code",
              "message",
              "missing"
            ],
            "properties": {
              "code": {
                "type": "integer",
                "description": "HTTP status code",
                "format": "int32",
                "example": 400
              },
              "message": {
                "type": "string",
                "description": "Error message."
              },
              "missing": {
                "uniqueItems": true,
                "type": "array",
                "description": "Items that are not found.",
                "items": {
                  "description": "Ids, ExternalIds or InstanceIds that are not found.",
                  "oneOf": [
                    {
                      "type": "object",
                      "required": [
                        "id"
                      ],
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "externalId"
                      ],
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "NotFoundResponse": {
        "type": "object",
        "required": [
          "error"
        ],
        "properties": {
          "error": {
            "type": "object",
            "description": "Error details.",
            "required": [
              "code",
              "message",
              "missing"
            ],
            "properties": {
              "code": {
                "type": "integer",
                "description": "HTTP status code",
                "format": "int32",
                "example": 400
              },
              "message": {
                "type": "string",
                "description": "Error message."
              },
              "missing": {
                "uniqueItems": true,
                "type": "array",
                "description": "Items that are not found.",
                "items": {
                  "description": "Ids, ExternalIds or InstanceIds that are not found.",
                  "oneOf": [
                    {
                      "type": "object",
                      "title": "id",
                      "required": [
                        "id"
                      ],
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "title": "externalId",
                      "required": [
                        "externalId"
                      ],
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "title": "instanceId",
                      "required": [
                        "instanceId"
                      ],
                      "properties": {
                        "instanceId": {
                          "$ref": "#/components/schemas/CogniteInstanceId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "TimeSeriesEpochTimestamp": {
        "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds. Can be negative to define dates before 1970, up to 1900.",
        "type": "integer",
        "minimum": -2208988800000,
        "format": "int64",
        "example": 1638795554528
      },
      "TimeSeriesFilterLanguage": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define advanced filter queries.\n\nAt the top level, an `advancedFilter` expression is either a single Boolean filter or a\nsingle leaf filter. Boolean filters contain other Boolean filters and/or leaf filters. The\ntotal number of filters may be at most 100, and the depth (the greatest number of times\nfilters have been nested inside each other) may be at most 10. The `search` leaf filter may\nat most be used twice within a single `advancedFilter`, but all other filters can be used\nas many times as you like as long as the other limits are respected.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesBoolFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesLeafFilter"
          }
        ],
        "example": {
          "or": [
            {
              "not": {
                "and": [
                  {
                    "equals": {
                      "property": [
                        "metadata",
                        "manufacturer"
                      ],
                      "value": "acme"
                    }
                  },
                  {
                    "in": {
                      "property": [
                        "name"
                      ],
                      "values": [
                        "pump-1-temperature",
                        "motor-9-temperature"
                      ]
                    }
                  },
                  {
                    "range": {
                      "property": [
                        "dataSetId"
                      ],
                      "gte": 1,
                      "lt": 10
                    }
                  }
                ]
              }
            },
            {
              "and": [
                {
                  "equals": {
                    "property": [
                      "assetId"
                    ],
                    "value": 1234
                  }
                },
                {
                  "equals": {
                    "property": [
                      "description"
                    ],
                    "value": "Temperature in Celsius"
                  }
                }
              ]
            }
          ]
        }
      },
      "SubscriptionFilterLanguage": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define advanced filter queries.\n\nAt the top level, a `filter` expression is either a single Boolean filter or a\nsingle leaf filter. Boolean filters contain other Boolean filters and/or leaf filters. The\ntotal number of filters may be at most 100, and the depth (the greatest number of times\nfilters have been nested inside each other) may be at most 10.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesBoolFilter"
          },
          {
            "$ref": "#/components/schemas/SubscriptionLeafFilter"
          }
        ],
        "example": {
          "or": [
            {
              "not": {
                "and": [
                  {
                    "equals": {
                      "property": [
                        "metadata",
                        "manufacturer"
                      ],
                      "value": "acme"
                    }
                  },
                  {
                    "in": {
                      "property": [
                        "name"
                      ],
                      "values": [
                        "pump-1-temperature",
                        "motor-9-temperature"
                      ]
                    }
                  },
                  {
                    "range": {
                      "property": [
                        "dataSetId"
                      ],
                      "gte": 1,
                      "lt": 10
                    }
                  }
                ]
              }
            },
            {
              "and": [
                {
                  "equals": {
                    "property": [
                      "assetId"
                    ],
                    "value": 1234
                  }
                },
                {
                  "equals": {
                    "property": [
                      "description"
                    ],
                    "value": "Temperature in Celsius"
                  }
                }
              ]
            }
          ]
        }
      },
      "TimeSeriesLeafFilter": {
        "description": "Leaf filter.\n",
        "title": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesEqualsFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesInFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesRangeFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesPrefixFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesExistsFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesContainsAllFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesSearchFilter"
          }
        ]
      },
      "SubscriptionLeafFilter": {
        "description": "Leaf filter.\n",
        "title": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesEqualsFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesInFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesRangeFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesPrefixFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesExistsFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesContainsAllFilter"
          }
        ]
      },
      "TimeSeriesBoolFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt is built by nesting one or more Boolean clauses, each of which is one of `and`, `or`, and `not`.\nEach such clause contains one or more child clauses (though `not` can only have one).\nEach child clause can be either another Boolean clause or a leaf filter.\n",
        "title": "Boolean filter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "maxItems": 99,
                "items": {
                  "$ref": "#/components/schemas/TimeSeriesFilterLanguage"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "maxItems": 99,
                "items": {
                  "$ref": "#/components/schemas/TimeSeriesFilterLanguage"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TimeSeriesFilterLanguage"
                  }
                ]
              }
            }
          }
        ]
      },
      "TimeSeriesEqualsFilter": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the given property is **exactly** equal to the given value.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/TimeSeriesValue"
              }
            }
          }
        }
      },
      "TimeSeriesInFilter": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the given property is **exactly** equal to one of the given values.\nThis filter can only be applied to single-valued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/TimeSeriesValues"
              }
            }
          }
        }
      },
      "TimeSeriesRangeFilter": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain terms within the provided range.\n\nOne upper bound and/or one lower bound must be specified. It's not allowed to specify both inclusive and exclusive\nbounds \"on the same side\" together (at most one of `lte` and `lt` may be specified, and at most one of `gte` and `gt`).\n- `gte`: Greater than or equal to.\n- `gt`: Greater than.\n- `lte`: Less than or equal to.\n- `lt`: Less than.\n\nMay only be applied to string properties and number properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/TimeSeriesRangeValue"
              },
              "gt": {
                "$ref": "#/components/schemas/TimeSeriesRangeValue"
              },
              "lte": {
                "$ref": "#/components/schemas/TimeSeriesRangeValue"
              },
              "lt": {
                "$ref": "#/components/schemas/TimeSeriesRangeValue"
              }
            }
          }
        }
      },
      "TimeSeriesPrefixFilter": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the provided property begins with the given text.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/TimeSeriesStringValue"
              }
            }
          }
        }
      },
      "TimeSeriesExistsFilter": {
        "type": "object",
        "title": "exists",
        "required": [
          "exists"
        ],
        "properties": {
          "exists": {
            "required": [
              "property"
            ],
            "description": "Matches items that have a value for the specified property.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              }
            }
          }
        }
      },
      "TimeSeriesContainsAnyFilter": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more of the given values.\nThis filter can only be applied to multivalued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/TimeSeriesValues"
              }
            }
          }
        }
      },
      "TimeSeriesContainsAllFilter": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains all the given values.\nThis filter can only be applied to multivalued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/TimeSeriesValues"
              }
            }
          }
        }
      },
      "TimeSeriesSearchFilter": {
        "type": "object",
        "title": "search",
        "required": [
          "search"
        ],
        "properties": {
          "search": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the provided string property contains the given value according to a fuzzy search.\nThe value may exist anywhere in the string, even as a part of a word or with some grammatical\nvariations (e.g., searching for \"run\" will also find \"ran\").\n\nThe supported properties are `name` and `description`. It's also possible to set `property`\nto `[\"query\"]`, in which case both `name` and `description` will be searched.\n\nWhen the `search` filter is being used, and it's not nested inside a `not` filter (directly or indirectly),\nand no `sort` is specified, the results will be ranked according to how good the match is.\nWhen the `query` 'property' is specified, matches in `name` will rank higher than matches in `description`.\nThe `search` filter may be used at most twice within the same `advancedFilter` expression.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/TimeSeriesFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/TimeSeriesStringValue"
              }
            }
          }
        }
      },
      "TimeSeriesFilterProperty": {
        "description": "The property on which you want to filter. May be either:\n- A single-element list that contains the name of one of the predefined top-level\n  properties, in which case the filter will be applied to that top-level property.\n- A single-element list that contains `'metadata'`, in which case the filter will be applied\n  to _all_ metadata properties.\n- A two-element list where the first element is `'metadata'` and the second one is any\n  string, in which case the filter will be applied to metadata properties with that name.\n- A two-element list where the first element is `'instanceId'` and the second element is\n  either `'space'` or `'externalId'`.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 2,
        "items": {
          "type": "string",
          "minLength": 1,
          "maxLength": 256
        }
      },
      "TimeSeriesValue": {
        "description": "A value that you wish to find in the provided property.\n",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "TimeSeriesValues": {
        "description": "One or more values that you wish to find in the provided properties.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/TimeSeriesValue"
        }
      },
      "TimeSeriesStringValue": {
        "title": "String",
        "description": "A value that you wish to find in the provided property.\n",
        "type": "string",
        "maxLength": 256
      },
      "TimeSeriesRangeValue": {
        "description": "An upper or lower bound in a `range` filter.",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          }
        ]
      },
      "TimeSeriesAggregateFilter": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define aggregate filters.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesBoolAggregateFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesLeafAggregateFilter"
          }
        ]
      },
      "TimeSeriesLeafAggregateFilter": {
        "description": "Leaf filter.\n",
        "title": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/TimeSeriesInAggregateFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesRangeAggregateFilter"
          },
          {
            "$ref": "#/components/schemas/TimeSeriesPrefixAggregateFilter"
          }
        ]
      },
      "TimeSeriesBoolAggregateFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt's built by nesting one or more Boolean clauses, each of which is one of `and`, `or`, and `not`.\nEach such clause contains one or more child clauses (though `not` can only have one).\nEach child clause can be either another Boolean clause or a leaf filter.\n",
        "title": "Boolean filter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "title": "Aggregate filter DSL",
                "description": "The aggregation result will only contain items that match _all_ of the given\nsub-clauses.\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 19,
                "items": {
                  "$ref": "#/components/schemas/TimeSeriesAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "title": "Aggregate filter DSL",
                "description": "The aggregation result will only contain items that match _at least one_\n(but potentially many or even all) of the given sub-clauses.\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 19,
                "items": {
                  "$ref": "#/components/schemas/TimeSeriesAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Aggregate filter DSL",
                "description": "The aggregation result will only contain items that do _not_ match the given\nsub-clause.\n",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/TimeSeriesAggregateFilter"
                  }
                ]
              }
            }
          }
        ]
      },
      "TimeSeriesInAggregateFilter": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "values"
            ],
            "description": "Matches intermediate aggregation results where the property key or the property value is _exactly_\nequal to one of the given values. When the `aggregate` operation is `uniqueProperties` or\n`cardinalityProperties`, property _keys_ will be targeted; when it is `uniqueValues` or\n`cardinalityValues`, property _values_ will be targeted.\n",
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/TimeSeriesInAggregateValues"
              }
            }
          }
        }
      },
      "TimeSeriesPrefixAggregateFilter": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "value"
            ],
            "description": "Matches intermediate aggregation results where the property key or the property value begins with\nthe given text. When the `aggregate` operation is `uniqueProperties` or `cardinalityProperties`,\nproperty _keys_ will be targeted; when it is `uniqueValues` or `cardinalityValues`, property\n_values_ will be targeted.\n",
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/TimeSeriesPrefixAggregateValue"
              }
            }
          }
        }
      },
      "TimeSeriesRangeAggregateFilter": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "description": "Matches intermediate aggregation results where the property key or the property value is within the\nprovided range. When the `aggregate` operation is `uniqueProperties` or `cardinalityProperties`,\nproperty _keys_ will be targeted; when it is `uniqueValues` or `cardinalityValues`, property \n_values_ will be targeted.\n\nAt least one of the following bounds must be specified:\n- `gte`: Greater than or equal to.\n- `gt`: Greater than.\n- `lte`: Less than or equal to.\n- `lt`: Less than.\n\nIt is not valid to specify both inclusive and exclusive bounds \"on the same side\" together:\nat most one of `lte` and `lt` may be specified, and at most one of `gte` and `gt`.\n\nIn the case of `aggregate` being `uniqueProperties` or `cardinalityProperties`,\n`gte`/`gt`/`lte`/`lt` must be set to a string. In the case of `aggregate` being `uniqueValues` or\n`cardinalityValues`, this filter may only be applied to string properties or number properties,\nwith `gte`/`gt`/`lte`/`lt` containing values of the corresponding type.\n",
            "type": "object",
            "properties": {
              "gte": {
                "$ref": "#/components/schemas/TimeSeriesRangeAggregateValue"
              },
              "gt": {
                "$ref": "#/components/schemas/TimeSeriesRangeAggregateValue"
              },
              "lte": {
                "$ref": "#/components/schemas/TimeSeriesRangeAggregateValue"
              },
              "lt": {
                "$ref": "#/components/schemas/TimeSeriesRangeAggregateValue"
              }
            }
          }
        }
      },
      "TimeSeriesInAggregateValues": {
        "description": "The property keys or property values (depending on the `aggregate` operation) on which you want to\nfilter the intermediate aggregate results.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/TimeSeriesInAggregateValue"
        }
      },
      "TimeSeriesInAggregateValue": {
        "description": "The property key or property value (depending on the `aggregate` operation) on which you want to\nfilter the intermediate aggregate results.\n",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "TimeSeriesPrefixAggregateValue": {
        "title": "String",
        "description": "A string value that represents either a property key or a property value, depending on the\n`aggregate` operation.\n",
        "type": "string",
        "maxLength": 256
      },
      "TimeSeriesRangeAggregateValue": {
        "description": "An upper or lower bound for a property key or property value (depending on which `aggregate` was\nspecified at the top level of the aggregation request).\n",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          }
        ]
      },
      "TimeSeriesSort": {
        "type": "object",
        "properties": {
          "sort": {
            "description": "Sort by array of selected properties.\n",
            "type": "array",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "$ref": "#/components/schemas/TimeSeriesSortItem"
            }
          }
        }
      },
      "TimeSeriesSortItem": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "type": "array",
            "description": "Property to sort on.\nSorting can be done on the following properties:\n  | Property                          |\n  |-----------------------------------|\n  | `['assetId']`                     |\n  | `['createdTime']`                 |\n  | `['dataSetId']`                   |\n  | `['description']`                 |\n  | `['externalId']`                  |\n  | `['lastUpdatedTime']`             |\n  | `['metadata', '<someCustomKey>']` |\n  | `['name']`                        |\n  | `['_score_']`                     |\n  | `['instanceId', 'space']`         |\n  | `['instanceId', 'externalId']`    |",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "type": "string",
              "maxLength": 128
            }
          },
          "order": {
            "type": "string",
            "description": "The `order` attribute is optional and defaults to `desc` for `_score_` and `asc` for all\nother properties.",
            "enum": [
              "asc",
              "desc"
            ]
          },
          "nulls": {
            "type": "string",
            "description": "The `nulls` attribute is optional and defaults to `auto`. `auto` is translated to `last`\nfor the `asc` order and to `first` for the `desc` order.",
            "enum": [
              "first",
              "last",
              "auto"
            ],
            "default": "auto"
          }
        }
      },
      "SyntheticMultiQuery": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SyntheticQuery"
            },
            "minItems": 1,
            "maxItems": 10
          }
        }
      },
      "SyntheticQuery": {
        "type": "object",
        "description": "Synthetic query description",
        "required": [
          "expression"
        ],
        "properties": {
          "expression": {
            "type": "string",
            "description": "query definition. For limits, see the [guide to synthetic time series](https://developer.cognite.com/dev/concepts/resource_types/synthetic_timeseries.html#limits).",
            "example": "(5 + TS{externalId='hello'}) / TS{id=123, aggregate='average', granularity='1h'} * TS{space='dm space', externalId='dm id'}"
          },
          "start": {
            "$ref": "#/components/schemas/TimestampOrStringStart"
          },
          "end": {
            "$ref": "#/components/schemas/TimestampOrStringEnd"
          },
          "limit": {
            "type": "integer",
            "description": "Return up to this number of datapoints",
            "format": "int32",
            "example": 100,
            "minimum": 1,
            "maximum": 10000
          },
          "timeZone": {
            "type": "string",
            "description": "For aggregates of granularity 'hour' and longer, which [time zone](<https://developer.cognite.com/dev/concepts/aggregation/calendar>) should we align to. Align to the start of the hour, start of the day or start of the month. For time zones of type Region/Location, the aggregate duration can vary, typically due to daylight saving time. For time zones of type UTC+/-HH:MM, use increments of 15 minutes.\n",
            "default": "UTC",
            "example": "Europe/Oslo or UTC+05:30"
          }
        }
      },
      "SyntheticQueryResponses": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SyntheticQueryResponse"
            }
          }
        }
      },
      "SyntheticQueryResponse": {
        "type": "object",
        "required": [
          "datapoints"
        ],
        "properties": {
          "isString": {
            "type": "boolean",
            "example": false,
            "description": "whether the returned data points are of string type or floating point type. Currently it will always be false."
          },
          "datapoints": {
            "type": "array",
            "description": "list of data points",
            "items": {
              "$ref": "#/components/schemas/SyntheticDataPoint"
            }
          }
        }
      },
      "SyntheticDataPoint": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SyntheticDataValue"
          },
          {
            "$ref": "#/components/schemas/SyntheticDataError"
          }
        ]
      },
      "SyntheticDataValue": {
        "type": "object",
        "required": [
          "timestamp",
          "value"
        ],
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "value": {
            "type": "number",
            "description": "the data value"
          }
        }
      },
      "SyntheticDataError": {
        "type": "object",
        "required": [
          "timestamp",
          "error"
        ],
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "error": {
            "type": "string",
            "description": "Human readable string with description of what went wrong",
            "example": "Error BAD_DOMAIN: Division by zero"
          }
        }
      },
      "DataRawDB": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDB"
            }
          }
        }
      },
      "DeleteRawDB": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDB"
            }
          },
          "recursive": {
            "type": "boolean",
            "description": "When true, tables of this database are deleted with the database.",
            "default": false
          }
        }
      },
      "DataRawDBRow": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDBRowInsert"
            }
          }
        }
      },
      "DataRawDBRowKey": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDBRowKey"
            }
          }
        }
      },
      "DataRawDBTable": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDBTable"
            }
          }
        }
      },
      "DataWithCursorRawDBRow": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDBRow"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next, or previous, page of results"
      },
      "DataWithCursorRawDBTable": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDBTable"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next, or previous, page of results"
      },
      "DataRawDBTableCursors": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "A list of cursors"
      },
      "RawDBTable": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 64,
            "description": "Unique name of the table"
          }
        },
        "description": "A NoSQL database table to store customer data"
      },
      "RawRowCSV": {
        "type": "object",
        "properties": {
          "columnHeaders": {
            "type": "array",
            "description": "Headers for the different columns in the response.",
            "items": {
              "type": "string",
              "description": "Headers for the different columns in the response."
            }
          },
          "rows": {
            "type": "array",
            "description": "Rows of column values, in same order as columnHeaders.",
            "items": {
              "type": "array",
              "description": "Rows of column values, in same order as columnHeaders.",
              "items": {
                "type": "object",
                "description": "Rows of column values, in same order as columnHeaders."
              }
            }
          }
        },
        "description": "Raw row result written in CSV format, with column columnHeaders."
      },
      "DataWithCursorRawDB": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawDB"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next, or previous, page of results"
      },
      "RawDB": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "maxLength": 32,
            "description": "Unique name of a database."
          }
        },
        "description": "A NoSQL database to store customer data."
      },
      "RawDBRow": {
        "required": [
          "columns",
          "key",
          "lastUpdatedTime"
        ],
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Unique row key"
          },
          "columns": {
            "type": "object",
            "description": "Row data stored as a JSON object."
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "RawDBRowInsert": {
        "required": [
          "columns",
          "key"
        ],
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Unique row key"
          },
          "columns": {
            "type": "object",
            "description": "Row data stored as a JSON object."
          }
        }
      },
      "RawDBRowKey": {
        "required": [
          "key"
        ],
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Unique row key"
          }
        },
        "description": "A row key"
      },
      "GroupName": {
        "type": "string",
        "description": "Name of the group",
        "example": "Production Engineers",
        "maxLength": 255
      },
      "GroupSourceId": {
        "type": "string",
        "description": "ID of the group in the source. If this is the same ID as a group in the IdP, a principal in that group will implicitly be a part of this group as well.",
        "example": "b7c9a5a4-99c2-4785-bed3-5e6ad9a78603"
      },
      "GroupMetadata": {
        "type": "object",
        "description": "Custom, immutable application specific metadata. String key -> String value. Limits: Key are at most 32 bytes. Values are at most 512 bytes. Up to 16 key-value pairs. Total size is at most 4096.",
        "additionalProperties": {
          "type": "string",
          "maxLength": 512
        },
        "x-maxKeyLength": 32,
        "x-maxTotalSize": 4096,
        "maxProperties": 16
      },
      "GroupBase": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "$ref": "#/components/schemas/GroupName"
          },
          "capabilities": {
            "$ref": "#/components/schemas/CogniteCapability"
          },
          "metadata": {
            "$ref": "#/components/schemas/GroupMetadata"
          }
        }
      },
      "GroupMembershipManagedExternallyOrInCdf": {
        "oneOf": [
          {
            "title": "managedExternally",
            "allOf": [
              {
                "$ref": "#/components/schemas/GroupBase"
              },
              {
                "type": "object",
                "properties": {
                  "sourceId": {
                    "$ref": "#/components/schemas/GroupSourceId"
                  }
                }
              }
            ],
            "description": "Group membership managed by the external identity provider"
          },
          {
            "title": "managedInCDF",
            "allOf": [
              {
                "$ref": "#/components/schemas/GroupBase"
              },
              {
                "type": "object",
                "properties": {
                  "members": {
                    "description": "Specifies which principals are members of the group.",
                    "oneOf": [
                      {
                        "title": "PrincipalList",
                        "type": "array",
                        "description": "Grant capabilities to these specific principals.",
                        "maxItems": 100,
                        "items": {
                          "$ref": "#/components/schemas/PrincipalId"
                        }
                      },
                      {
                        "title": "allUserAccounts",
                        "type": "string",
                        "enum": [
                          "allUserAccounts"
                        ],
                        "description": "All authenticated user accounts in the organization will automatically become members of this\ngroup, granting them access to this project with the capabilities listed in this group."
                      }
                    ]
                  }
                }
              }
            ],
            "description": "Group membership managed in CDF"
          }
        ]
      },
      "Group": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GroupMembershipManagedExternallyOrInCdf"
          },
          {
            "type": "object",
            "required": [
              "id",
              "isDeleted"
            ],
            "properties": {
              "id": {
                "type": "integer",
                "format": "int64",
                "description": "Unique ID of the group"
              },
              "isDeleted": {
                "type": "boolean",
                "default": false
              },
              "deletedTime": {
                "type": "integer",
                "format": "int64"
              }
            }
          }
        ]
      },
      "GroupResponse": {
        "$ref": "#/components/schemas/DataGroup"
      },
      "GroupSpec": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GroupMembershipManagedExternallyOrInCdf"
          }
        ],
        "description": "A specification for creating a new group"
      },
      "DataGroup": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Group"
            }
          }
        }
      },
      "DataGroupSpec": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GroupSpec"
            }
          }
        }
      },
      "CogniteCapability": {
        "type": "array",
        "items": {
          "allOf": [
            {
              "oneOf": [
                {
                  "title": "analyticsAcl",
                  "required": [
                    "analyticsAcl"
                  ],
                  "properties": {
                    "analyticsAcl": {
                      "$ref": "#/components/schemas/cogniteanalytics_aclAcl"
                    }
                  }
                },
                {
                  "title": "annotationsAcl",
                  "properties": {
                    "annotationsAcl": {
                      "$ref": "#/components/schemas/annotations_aclAcl"
                    }
                  }
                },
                {
                  "title": "assetsAcl",
                  "required": [
                    "assetsAcl"
                  ],
                  "properties": {
                    "assetsAcl": {
                      "$ref": "#/components/schemas/cogniteassets_aclAcl"
                    }
                  }
                },
                {
                  "title": "dataModelInstancesAcl",
                  "required": [
                    "dataModelInstancesAcl"
                  ],
                  "properties": {
                    "dataModelInstancesAcl": {
                      "$ref": "#/components/schemas/cognitedatamodelinstances_aclAcl"
                    }
                  }
                },
                {
                  "title": "dataModelsAcl",
                  "required": [
                    "dataModelsAcl"
                  ],
                  "properties": {
                    "dataModelsAcl": {
                      "$ref": "#/components/schemas/cognitedatamodels_aclAcl"
                    }
                  }
                },
                {
                  "title": "datasetsAcl",
                  "required": [
                    "datasetsAcl"
                  ],
                  "properties": {
                    "datasetsAcl": {
                      "$ref": "#/components/schemas/cognitedatasets_aclAcl"
                    }
                  }
                },
                {
                  "title": "diagramParsingAcl",
                  "required": [
                    "diagramParsingAcl"
                  ],
                  "properties": {
                    "diagramParsingAcl": {
                      "$ref": "#/components/schemas/cognitediagramparsing_aclAcl"
                    }
                  }
                },
                {
                  "title": "digitalTwinAcl",
                  "required": [
                    "digitalTwinAcl"
                  ],
                  "properties": {
                    "digitalTwinAcl": {
                      "$ref": "#/components/schemas/cognitedigitaltwin_aclAcl"
                    }
                  }
                },
                {
                  "title": "entityMatchingAcl",
                  "properties": {
                    "entityMatchingAcl": {
                      "$ref": "#/components/schemas/entitymatching_aclAcl"
                    }
                  }
                },
                {
                  "title": "eventsAcl",
                  "required": [
                    "eventsAcl"
                  ],
                  "properties": {
                    "eventsAcl": {
                      "$ref": "#/components/schemas/cogniteevents_aclAcl"
                    }
                  }
                },
                {
                  "title": "extractionPipelinesAcl",
                  "properties": {
                    "extractionpipelinesAcl": {
                      "$ref": "#/components/schemas/extractionpipelines_aclAcl"
                    }
                  }
                },
                {
                  "title": "extractionRunsAcl",
                  "properties": {
                    "extractionrunsAcl": {
                      "$ref": "#/components/schemas/extractionruns_aclAcl"
                    }
                  }
                },
                {
                  "title": "ilainstancesAcl",
                  "required": [
                    "ilainstancesAcl"
                  ],
                  "properties": {
                    "ilainstancesAcl": {
                      "$ref": "#/components/schemas/cogniteilainstances_aclAcl"
                    }
                  }
                },
                {
                  "title": "filesAcl",
                  "required": [
                    "filesAcl"
                  ],
                  "properties": {
                    "filesAcl": {
                      "$ref": "#/components/schemas/cognitefiles_aclAcl"
                    }
                  }
                },
                {
                  "title": "functionsAcl",
                  "required": [
                    "functionsAcl"
                  ],
                  "properties": {
                    "functionsAcl": {
                      "$ref": "#/components/schemas/functions_aclAcl"
                    }
                  }
                },
                {
                  "title": "geospatialAcl",
                  "required": [
                    "geospatialAcl"
                  ],
                  "properties": {
                    "geospatialAcl": {
                      "$ref": "#/components/schemas/cognitegeospatial_aclAcl"
                    }
                  }
                },
                {
                  "title": "geospatialCrsAcl",
                  "required": [
                    "geospatialCrsAcl"
                  ],
                  "properties": {
                    "geospatialCrsAcl": {
                      "$ref": "#/components/schemas/cognitegeospatialcrs_aclAcl"
                    }
                  }
                },
                {
                  "title": "groupsAcl",
                  "required": [
                    "groupsAcl"
                  ],
                  "properties": {
                    "groupsAcl": {
                      "$ref": "#/components/schemas/cognitegroups_aclAcl"
                    }
                  }
                },
                {
                  "title": "labelsAcl",
                  "required": [
                    "labelsAcl"
                  ],
                  "properties": {
                    "labelsAcl": {
                      "$ref": "#/components/schemas/cognitelabels_aclAcl"
                    }
                  }
                },
                {
                  "title": "locationFiltersAcl",
                  "properties": {
                    "locationFiltersAcl": {
                      "$ref": "#/components/schemas/locationfilters_aclAcl"
                    }
                  }
                },
                {
                  "title": "projectsAcl",
                  "required": [
                    "projectsAcl"
                  ],
                  "properties": {
                    "projectsAcl": {
                      "$ref": "#/components/schemas/cogniteprojects_aclAcl"
                    }
                  }
                },
                {
                  "title": "rawAcl",
                  "required": [
                    "rawAcl"
                  ],
                  "properties": {
                    "rawAcl": {
                      "$ref": "#/components/schemas/cogniteraw_aclAcl"
                    }
                  }
                },
                {
                  "title": "relationshipsAcl",
                  "required": [
                    "relationshipsAcl"
                  ],
                  "properties": {
                    "relationshipsAcl": {
                      "$ref": "#/components/schemas/cogniterelationships_aclAcl"
                    }
                  }
                },
                {
                  "title": "roboticsAcl",
                  "required": [
                    "roboticsAcl"
                  ],
                  "properties": {
                    "groupsAcl": {
                      "$ref": "#/components/schemas/cogniterobotics_aclAcl"
                    }
                  }
                },
                {
                  "title": "securityCategoriesAcl",
                  "required": [
                    "securityCategoriesAcl"
                  ],
                  "properties": {
                    "securityCategoriesAcl": {
                      "$ref": "#/components/schemas/cognitesecuritycategories_aclAcl"
                    }
                  }
                },
                {
                  "title": "seismicAcl",
                  "required": [
                    "seismicAcl"
                  ],
                  "properties": {
                    "seismicAcl": {
                      "$ref": "#/components/schemas/cogniteseismic_aclAcl"
                    }
                  }
                },
                {
                  "title": "sequencesAcl",
                  "required": [
                    "sequencesAcl"
                  ],
                  "properties": {
                    "sequencesAcl": {
                      "$ref": "#/components/schemas/cognitesequences_aclAcl"
                    }
                  }
                },
                {
                  "title": "sessionsAcl",
                  "properties": {
                    "sessionsAcl": {
                      "$ref": "#/components/schemas/sessions_aclAcl"
                    }
                  }
                },
                {
                  "title": "threedAcl",
                  "required": [
                    "threedAcl"
                  ],
                  "properties": {
                    "threedAcl": {
                      "$ref": "#/components/schemas/cognitethreed_aclAcl"
                    }
                  }
                },
                {
                  "title": "timeSeriesAcl",
                  "required": [
                    "timeSeriesAcl"
                  ],
                  "properties": {
                    "timeSeriesAcl": {
                      "$ref": "#/components/schemas/cognitetimeseries_aclAcl"
                    }
                  }
                },
                {
                  "title": "timeSeriesSubscriptionsAcl",
                  "required": [
                    "timeSeriesSubscriptionsAcl"
                  ],
                  "properties": {
                    "timeSeriesSubscriptionsAcl": {
                      "$ref": "#/components/schemas/cognitetimeseriessubscriptions_aclAcl"
                    }
                  }
                },
                {
                  "title": "transformationsAcl",
                  "required": [
                    "transformationsAcl"
                  ],
                  "properties": {
                    "transformationsAcl": {
                      "$ref": "#/components/schemas/cognitetransformations_aclAcl"
                    }
                  }
                },
                {
                  "title": "typesAcl",
                  "required": [
                    "typesAcl"
                  ],
                  "properties": {
                    "typesAcl": {
                      "$ref": "#/components/schemas/cognitetypes_aclAcl"
                    }
                  }
                },
                {
                  "title": "workflowOrchestrationAcl",
                  "required": [
                    "workflowOrchestrationAcl"
                  ],
                  "properties": {
                    "workflowOrchestrationAcl": {
                      "$ref": "#/components/schemas/cogniteWorkflowOrchestration_aclAcl"
                    }
                  }
                },
                {
                  "title": "simulatorsAcl",
                  "required": [
                    "simulatorsAcl"
                  ],
                  "properties": {
                    "simulatorsAcl": {
                      "$ref": "#/components/schemas/simulators_aclAcl"
                    }
                  }
                }
              ]
            },
            {
              "type": "object",
              "title": "Project URL names",
              "properties": {
                "projectUrlNames": {
                  "required": [
                    "urlNames"
                  ],
                  "properties": {
                    "urlNames": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ProjectUrlName"
                      }
                    }
                  }
                }
              }
            }
          ]
        },
        "title": "Capability"
      },
      "cogniteanalytics_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteanalytics_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteanalytics_aclScope"
          }
        },
        "title": "Acl:Analytics"
      },
      "cogniteanalytics_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "EXECUTE",
          "LIST"
        ],
        "default": "READ",
        "title": "Analytics:Action"
      },
      "cogniteanalytics_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "Analytics:Scope"
      },
      "cogniteassets_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteassets_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteassets_aclScope"
          }
        },
        "title": "Acl:Asset"
      },
      "cogniteassets_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Asset:Action"
      },
      "cogniteassets_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Asset:Scope"
      },
      "cognitedatamodelinstances_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitedatamodelInstances_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitedatamodels_aclScope"
          }
        },
        "title": "Acl:DataModelInstances"
      },
      "cognitedatamodels_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitedatamodels_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitedatamodels_aclScope"
          }
        },
        "title": "Acl:DataModels"
      },
      "cognitedatamodelInstances_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE",
          "WRITE_PROPERTIES"
        ],
        "default": "READ",
        "title": "DataModelInstances:Action"
      },
      "cognitedatamodels_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "DataModels:Action"
      },
      "cognitedatamodels_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "spaceIdScope",
            "properties": {
              "spaceIdScope": {
                "$ref": "#/components/schemas/cognitedatamodels_aclSpaceIdScope"
              }
            }
          }
        ],
        "title": "DataModels:Scope"
      },
      "cognitedatamodels_aclSpaceIdScope": {
        "type": "object",
        "properties": {
          "spaceIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "title": "Space IDs"
          }
        },
        "title": "Scope:SpaceIdScope"
      },
      "cognitedatasets_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitedatasets_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitedatasets_aclScope"
          }
        },
        "title": "Acl:Datasets"
      },
      "cognitedatasets_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE",
          "OWNER"
        ],
        "default": "READ",
        "title": "Datasets:Action"
      },
      "cognitedatasets_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "idscope",
            "properties": {
              "idscope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Datasets:Scope"
      },
      "cognitedatasets_aclIdScope": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint64"
            },
            "title": "DataSet IDs"
          }
        },
        "title": "Scope:DataSetsIdScope"
      },
      "cognitediagramparsing_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitediagramparsing_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitediagramparsing_aclScope"
          }
        },
        "title": "Acl:Asset"
      },
      "cognitediagramparsing_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "DiagramParsing:Action"
      },
      "cognitediagramparsing_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          }
        ],
        "title": "DiagramParsing:Scope"
      },
      "cognitedigitaltwin_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitedigitaltwin_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitedigitaltwin_aclScope"
          }
        },
        "title": "Acl:DigitalTwin"
      },
      "cognitedigitaltwin_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "DigitalTwin:Action"
      },
      "cognitedigitaltwin_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "DigitalTwin:Scope"
      },
      "cogniteevents_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteevents_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteevents_aclScope"
          }
        },
        "title": "Acl:Event"
      },
      "cogniteevents_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Event:Action"
      },
      "cogniteevents_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Event:Scope"
      },
      "cogniteilainstances_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteilainstances_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitedatamodels_aclScope"
          }
        },
        "title": "Acl:IndustrialLogAnalyticsInstances"
      },
      "cogniteilainstances_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "IndustrialLogAnalytics:Action"
      },
      "cognitefiles_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitefiles_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitefiles_aclScope"
          }
        },
        "title": "Acl:File"
      },
      "cognitefiles_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "File:Action"
      },
      "cognitefiles_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "File:Scope"
      },
      "cognitegroups_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitegroups_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitegroups_aclScope"
          }
        },
        "title": "Acl:Group"
      },
      "cognitegroups_aclAction": {
        "type": "string",
        "enum": [
          "LIST",
          "READ",
          "CREATE",
          "UPDATE",
          "DELETE"
        ],
        "default": "LIST",
        "title": "Group:Action"
      },
      "cognitegroups_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/generic_aclAllScope"
                  }
                ],
                "title": "all groups"
              }
            }
          },
          {
            "title": "currentuserscope",
            "properties": {
              "currentuserscope": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/generic_aclCurrentUserScope"
                  }
                ],
                "title": "groups the current principal is in"
              }
            }
          }
        ],
        "title": "Group:Scope"
      },
      "cogniteprojects_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteprojects_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteprojects_aclScope"
          }
        },
        "title": "Acl:Project"
      },
      "cogniteprojects_aclAction": {
        "type": "string",
        "enum": [
          "LIST",
          "READ",
          "CREATE",
          "UPDATE"
        ],
        "default": "LIST",
        "title": "Project:Action"
      },
      "cogniteprojects_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "Project:Scope"
      },
      "cogniteraw_aclAcl": {
        "type": "object",
        "description": "Set access control on RAW",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteraw_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteraw_aclScope"
          }
        },
        "title": "Acl:Raw"
      },
      "cogniteraw_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE",
          "LIST"
        ],
        "default": "READ",
        "title": "Raw:Action"
      },
      "cogniteraw_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "tableScope",
            "properties": {
              "tableScope": {
                "$ref": "#/components/schemas/cogniteraw_aclDbsToTablesScope"
              }
            }
          }
        ],
        "title": "Raw:Scope"
      },
      "cogniteraw_aclDbsToTablesScope": {
        "type": "object",
        "description": "Scope access to certain tables within a database",
        "example": {
          "dbsToTables": {
            "db1": [
              "table1",
              "table2"
            ],
            "db2": [
              "table1",
              "table2"
            ]
          }
        },
        "title": "tableScope",
        "properties": {
          "dbsToTables": {
            "type": "object",
            "title": "dbtoTableScope",
            "description": "Scopes access to tables within a database. { database1: [table1, table2] } will give access to table1 and table2 within database1.",
            "additionalProperties": {
              "x-additionalPropertiesName": "databaseName",
              "type": "array",
              "example": [
                "table1",
                "table2"
              ],
              "description": "List of table names within the database",
              "items": {
                "type": "string",
                "example": "table1",
                "description": "Name of the table"
              }
            }
          }
        }
      },
      "cogniterelationships_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniterelationships_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniterelationships_aclScope"
          }
        },
        "title": "Acl:Relationships"
      },
      "cogniterelationships_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Relationships:Action"
      },
      "cogniterelationships_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Relationships:Scope"
      },
      "cogniterobotics_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniterobotics_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniterobotics_aclScope"
          }
        },
        "title": "Acl:Robotics"
      },
      "cogniterobotics_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "CREATE",
          "UPDATE",
          "DELETE"
        ],
        "default": "READ",
        "title": "Robotics:Action"
      },
      "cogniterobotics_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Robotics:Scope"
      },
      "cognitetransformations_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitetransformations_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitetransformations_aclScope"
          }
        },
        "title": "Acl:Transformations"
      },
      "cognitetransformations_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Transformations:Action"
      },
      "cognitetransformations_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Transformations:Scope"
      },
      "cognitesecuritycategories_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitesecuritycategories_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitesecuritycategories_aclScope"
          }
        },
        "title": "Acl:SecurityCategory"
      },
      "cognitesecuritycategories_aclAction": {
        "type": "string",
        "enum": [
          "MEMBEROF",
          "LIST",
          "CREATE",
          "DELETE",
          "UPDATE"
        ],
        "default": "MEMBEROF",
        "title": "SecurityCategory:Action"
      },
      "cognitesecuritycategories_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "idscope",
            "properties": {
              "idscope": {
                "$ref": "#/components/schemas/cognitesecuritycategories_aclIdScope"
              }
            }
          }
        ],
        "title": "SecurityCategory:Scope"
      },
      "cognitesecuritycategories_aclIdScope": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            },
            "title": "security category IDs"
          }
        },
        "title": "Scope:SecurityCategoryIdScope"
      },
      "cogniteseismic_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteseismic_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteseismic_aclScope"
          }
        },
        "title": "Acl:Seismic"
      },
      "cogniteseismic_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Seismic:Action"
      },
      "cogniteseismic_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "Seismic:Scope"
      },
      "cogniteWorkflowOrchestration_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cogniteWorkflowOrchestration_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cogniteWorkflowOrchestration_aclScope"
          }
        },
        "title": "ACL:WorkflowOrchestration"
      },
      "cogniteWorkflowOrchestration_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "WorkflowOrchestration:Action"
      },
      "cogniteWorkflowOrchestration_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "WorkflowOrchestration:Scope"
      },
      "cognitegeospatial_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitegeospatial_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitegeospatial_aclScope"
          }
        },
        "title": "Acl:Geospatial"
      },
      "cognitegeospatial_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Geospatial:Action"
      },
      "cognitegeospatial_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "Geospatial:Scope"
      },
      "cognitegeospatialcrs_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitegeospatialcrs_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitegeospatialcrs_aclScope"
          }
        },
        "title": "Acl:GeospatialCrs"
      },
      "cognitegeospatialcrs_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "GeospatialCrs:Action"
      },
      "cognitegeospatialcrs_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "GeospatialCrs:Scope"
      },
      "cognitesequences_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitesequences_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitesequences_aclScope"
          }
        },
        "title": "Acl:Sequences"
      },
      "cognitesequences_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Sequences:Action"
      },
      "cognitesequences_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Sequences:Scope"
      },
      "cognitethreed_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitethreed_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitethreed_aclScope"
          }
        },
        "title": "Acl:Threed"
      },
      "cognitethreed_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "CREATE",
          "UPDATE",
          "DELETE"
        ],
        "default": "READ",
        "title": "Threed:Action"
      },
      "cognitethreed_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ]
      },
      "cognitetimeseries_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitetimeseries_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitetimeseries_aclScope"
          }
        },
        "title": "Acl:Timeseries"
      },
      "cognitetimeseries_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Timeseries:Action"
      },
      "cognitetimeseries_aclIdScope": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint64"
            },
            "title": "time series IDs"
          }
        },
        "title": "Scope:TimeSeriesIdScope"
      },
      "cognitetimeseries_aclAssetRootIdScope": {
        "type": "object",
        "properties": {
          "rootIds": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint64"
            },
            "title": "asset root IDs"
          }
        },
        "title": "Scope:TimeSeriesAssetRootIdScope*"
      },
      "cognitetimeseries_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "idscope",
            "properties": {
              "idscope": {
                "$ref": "#/components/schemas/cognitetimeseries_aclIdScope"
              }
            }
          },
          {
            "title": "assetRootIdScope",
            "properties": {
              "assetRootIdScope": {
                "$ref": "#/components/schemas/cognitetimeseries_aclAssetRootIdScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Timeseries:Scope"
      },
      "cognitetimeseriessubscriptions_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitetimeseriessubscriptions_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitetimeseriessubscriptions_aclScope"
          }
        },
        "title": "Acl:TimeseriesSubscriptions"
      },
      "cognitetimeseriessubscriptions_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "TimeseriesSubscriptions:Action"
      },
      "cognitetimeseriessubscriptions_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "TimeseriesSubscriptions:Scope"
      },
      "cognitetypes_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitetypes_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitetypes_aclScope"
          }
        },
        "title": "Acl:Types"
      },
      "cognitetypes_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Types:Action"
      },
      "cognitetypes_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "Types:Scope"
      },
      "functions_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/functions_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/functions_aclScope"
          }
        },
        "title": "Acl:Functions"
      },
      "functions_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Functions:Action"
      },
      "functions_aclScope": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/generic_aclAllScope"
          }
        },
        "title": "Functions:Scope"
      },
      "cognitelabels_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cognitelabels_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/cognitelabels_aclScope"
          }
        },
        "title": "Acl:Labels"
      },
      "cognitelabels_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Labels:Action"
      },
      "cognitelabels_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Labels:Scope"
      },
      "extractionpipelines_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/extractionpipelines_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/extractionpipelines_aclScope"
          }
        },
        "title": "Acl:Extraction Pipelines"
      },
      "extractionpipelines_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Extraction Pipelines:Action"
      },
      "extractionpipelines_aclIdScope": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint64"
            },
            "title": "extraction pipeline IDs"
          }
        },
        "title": "Scope:ExtractionPipelinesIdScope"
      },
      "extractionpipelines_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "idscope",
            "properties": {
              "idscope": {
                "$ref": "#/components/schemas/extractionpipelines_aclIdScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Extraction Pipelines:Scope"
      },
      "extractionruns_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/extractionruns_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/extractionruns_aclScope"
          }
        },
        "title": "Acl:Extraction Pipelines Runs"
      },
      "extractionruns_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Extraction Pipelines Runs:Action"
      },
      "extractionruns_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "extractionpipelinescope",
            "properties": {
              "extractionpipelinescope": {
                "$ref": "#/components/schemas/extractionpipelines_aclIdScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Extraction Pipelines Runs:Scope"
      },
      "extractionconfigs_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/extractionconfigs_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/extractionconfigs_aclScope"
          }
        },
        "title": "Acl:Extraction Pipelines Configs"
      },
      "extractionconfigs_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Extraction Pipelines Configs:Action"
      },
      "extractionconfigs_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "extractionpipelinescope",
            "properties": {
              "extractionpipelinescope": {
                "$ref": "#/components/schemas/extractionpipelines_aclIdScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Extraction Pipelines Configs:Scope"
      },
      "locationfilters_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/locationfilters_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/locationfilters_aclScope"
          }
        },
        "title": "Acl:Location Filters"
      },
      "locationfilters_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Location Filters:Action"
      },
      "locationfilters_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "idScope",
            "properties": {
              "idScope": {
                "$ref": "#/components/schemas/locationfilters_aclIdScope"
              }
            }
          }
        ],
        "title": "Location Filters:Scope"
      },
      "locationfilters_aclIdScope": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint64"
            },
            "title": "location filter IDs"
          }
        },
        "title": "Scope:LocationFiltersIdScope"
      },
      "entitymatching_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/entitymatching_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/entitymatching_aclScope"
          }
        },
        "title": "Acl:Entity Matching"
      },
      "entitymatching_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE"
        ],
        "default": "READ",
        "title": "Entity Matching:Action"
      },
      "entitymatching_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          }
        ],
        "title": "Entity Matching:Scope"
      },
      "annotations_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/annotations_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/annotations_aclScope"
          }
        },
        "title": "Acl:Annotations"
      },
      "annotations_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE",
          "SUGGEST",
          "REVIEW"
        ],
        "default": "WRITE",
        "title": "Annotations:Action"
      },
      "annotations_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          }
        ],
        "title": "Annotations:Scope"
      },
      "sessions_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/sessions_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/sessions_aclScope"
          }
        },
        "title": "Acl:Sessions"
      },
      "sessions_aclAction": {
        "type": "string",
        "enum": [
          "LIST",
          "CREATE",
          "DELETE"
        ],
        "default": "LIST",
        "title": "Sessions:Action"
      },
      "sessions_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          }
        ],
        "title": "Sessions:Scope"
      },
      "simulators_aclAcl": {
        "type": "object",
        "required": [
          "actions",
          "scope"
        ],
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/simulators_aclAction"
            }
          },
          "scope": {
            "$ref": "#/components/schemas/simulators_aclScope"
          }
        },
        "title": "Acl:Simulators"
      },
      "simulators_aclAction": {
        "type": "string",
        "enum": [
          "READ",
          "WRITE",
          "DELETE",
          "RUN",
          "MANAGE"
        ],
        "default": "READ",
        "title": "Simulators:Action"
      },
      "simulators_aclScope": {
        "type": "object",
        "oneOf": [
          {
            "title": "all",
            "properties": {
              "all": {
                "$ref": "#/components/schemas/generic_aclAllScope"
              }
            }
          },
          {
            "title": "datasetScope",
            "properties": {
              "datasetScope": {
                "$ref": "#/components/schemas/cognitedatasets_aclIdScope"
              }
            }
          }
        ],
        "title": "Simulators:Scope"
      },
      "generic_aclAllScope": {
        "type": "object",
        "title": "Scope:All"
      },
      "generic_aclCurrentUserScope": {
        "type": "object",
        "title": "Scope:CurrentUser"
      },
      "DataProjectSpec": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NewProjectSpec"
            }
          }
        }
      },
      "NewProjectSpec": {
        "type": "object",
        "required": [
          "name",
          "urlName",
          "parentProjectUrlName"
        ],
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ProjectName"
          },
          "urlName": {
            "$ref": "#/components/schemas/ProjectUrlName"
          },
          "adminSourceGroupId": {
            "type": "string",
            "description": "ID of the group in the source. If this is the same ID as a group in the IdP, a principal in that group will implicitly be a part of this group as well.",
            "example": "b7c9a5a4-99c2-4785-bed3-5e6ad9a78603"
          },
          "oidcConfiguration": {
            "$ref": "#/components/schemas/OidcConfigurationDTO"
          },
          "userProfilesConfiguration": {
            "$ref": "#/components/schemas/UserProfilesConfigurationDTO"
          },
          "parentProjectUrlName": {
            "type": "string",
            "description": "The URL name of the project from which the new project is being created- this project must already exist.\n",
            "minLength": 3,
            "maxLength": 32,
            "example": "administrative-project"
          }
        },
        "description": "A specification for creating a new project"
      },
      "ProjectUpdateObjectDTO": {
        "type": "object",
        "description": "Contains the instructions on how to update the project.\n",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/SinglePatchRequiredString"
          },
          "oidcConfiguration": {
            "$ref": "#/components/schemas/OidcConfigurationUpdate"
          },
          "userProfilesConfiguration": {
            "$ref": "#/components/schemas/UserProfilesConfiguration"
          }
        }
      },
      "OidcConfigurationUpdate": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ModifyOidcConfigurationUpdateDTO"
          },
          {
            "$ref": "#/components/schemas/SetOidcConfigurationUpdateDTO"
          },
          {
            "$ref": "#/components/schemas/RemoveOidcConfiguration"
          }
        ]
      },
      "UserProfilesConfiguration": {
        "title": "modify",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ModifyUserProfilesConfigurationDTO"
          },
          {
            "$ref": "#/components/schemas/SetUserProfilesConfigurationDTO"
          }
        ]
      },
      "SinglePatchParentProjectId": {
        "type": "object",
        "properties": {
          "set": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64"
          }
        },
        "description": "Change the ID of the parent project. Currently only permitted to be updated by cluster administrators.",
        "required": [
          "set"
        ]
      },
      "SinglePatchIsOidcEnabled": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        },
        "description": "Sets if OIDC should be enabled for the project. If set to `false`, the project is considered \"locked\"."
      },
      "SinglePatchLeafProject": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        },
        "description": "Sets if the project should be a leaf project or not. Currently only permitted to be updated by cluster administrators.\n\nCluster administrators should exercise caution when updating the `leafProject` status of a project, as it has the potential\nto break the invariants that only leaf projects can contain industrial data (assets, timeseries, etc.), or that leaf projects\nshould not have child projects.\n\nTypically the `leafProject` state should only be updated if a project has been mistakenly created with the wrong status.\n"
      },
      "SinglePatchDataModelingStatus": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/DataModelingStatus"
          }
        },
        "description": "Sets the data modeling status of the project. Only permitted to be updated by cluster administrators."
      },
      "SinglePatchReservedPrefix": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ModifyReservedPrefix"
          },
          {
            "$ref": "#/components/schemas/RemoveReservedPrefix"
          }
        ]
      },
      "ModifyReservedPrefix": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "string",
            "description": "Reserves a prefix that can only be used by projects that are children of the project hierachy starting at\nthis project (reserved prefixes *MUST* only be specified for non-leaf projects).\n\nProjects outside this project hierachy will be rejected to create projects with url names starting with\nthis reserved prefix.\n\nOnly allowed for non-leaf projects. Currently only permitted to be updated by cluster administrators.\n",
            "example": "test"
          }
        }
      },
      "RemoveReservedPrefix": {
        "type": "object",
        "required": [
          "setNull"
        ],
        "properties": {
          "setNull": {
            "type": "boolean",
            "description": "Removes the reserved prefix.\nOnly allowed for non-leaf projects. Currently only permitted to be updated by cluster administrators.\n",
            "example": true
          }
        }
      },
      "SinglePatchCogIdpBetaOptIn": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "type": "boolean"
          }
        },
        "description": "Sets if the project should allow using Cognite IdP as an identity provider."
      },
      "SetGroupCallbackEnabled": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/GroupCallbackEnabled"
          }
        }
      },
      "SetUserProfilesConfigurationDTO": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/UserProfilesConfigurationDTO"
          }
        }
      },
      "ModifyUserProfilesConfigurationDTO": {
        "type": "object",
        "required": [
          "modify"
        ],
        "properties": {
          "modify": {
            "$ref": "#/components/schemas/UserProfilesConfigurationUpdateDTO"
          }
        }
      },
      "UserProfilesConfigurationDTO": {
        "type": "object",
        "required": [
          "enabled"
        ],
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Should collection of user profiles be enabled for the project."
          }
        }
      },
      "UserProfilesConfigurationUpdateDTO": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Should collection of user profiles be enabled for the project."
          }
        }
      },
      "SetOidcConfigurationUpdateDTO": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/OidcConfigurationDTO"
          }
        }
      },
      "ModifyOidcConfigurationUpdateDTO": {
        "type": "object",
        "required": [
          "modify"
        ],
        "properties": {
          "modify": {
            "$ref": "#/components/schemas/OidcConfigurationUpdateDTO"
          }
        }
      },
      "OidcConfigurationDTO": {
        "type": "object",
        "required": [
          "jwksUrl",
          "issuer",
          "audience",
          "accessClaims",
          "scopeClaims",
          "logClaims"
        ],
        "properties": {
          "jwksUrl": {
            "type": "string",
            "description": "The URL where the signing keys used to sign tokens from the identity provider are located"
          },
          "tokenUrl": {
            "type": "string",
            "description": "The URL of the OAuth 2.0 token endpoint"
          },
          "issuer": {
            "type": "string",
            "description": "The expected issuer value"
          },
          "audience": {
            "type": "string",
            "description": "The expected audience value (for CDF)"
          },
          "skewMs": {
            "type": "integer",
            "description": "Permitted clock skew (ms)"
          },
          "accessClaims": {
            "description": "Which claims to link CDF groups to, in order to grant access",
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimNamesArray"
              }
            ]
          },
          "scopeClaims": {
            "description": "Which claims to use when scoping access granted by access claims",
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimNamesArray"
              }
            ]
          },
          "logClaims": {
            "description": "Which token claims to record in the audit log",
            "allOf": [
              {
                "$ref": "#/components/schemas/ClaimNamesArray"
              }
            ]
          },
          "isGroupCallbackEnabled": {
            "description": "A group callback occurs when a user has too many groups attached. This property indicates whether\nthe group callback functionality should be supported for this project. This is only supported for AAD hosted IdPs.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/GroupCallbackEnabled"
              }
            ]
          },
          "identityProviderScope": {
            "type": "string",
            "description": "The scope sent to the identity provider when a session is created. The default value is the value required for a default Azure AD IdP configuration."
          }
        }
      },
      "OidcConfigurationUpdateDTO": {
        "type": "object",
        "properties": {
          "jwksUrl": {
            "description": "The URL where the signing keys used to sign tokens from the identity provider are located",
            "allOf": [
              {
                "$ref": "#/components/schemas/SetStringField"
              }
            ]
          },
          "tokenUrl": {
            "description": "The URL of the OAuth 2.0 token endpoint",
            "allOf": [
              {
                "$ref": "#/components/schemas/SinglePatchString"
              }
            ]
          },
          "issuer": {
            "description": "The expected issuer value",
            "allOf": [
              {
                "$ref": "#/components/schemas/SetStringField"
              }
            ]
          },
          "audience": {
            "description": "The expected audience value (for CDF)",
            "allOf": [
              {
                "$ref": "#/components/schemas/SetStringField"
              }
            ]
          },
          "skewMs": {
            "description": "Permitted clock skew (ms)",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModifyPatchInteger"
              }
            ]
          },
          "accessClaims": {
            "description": "Which claims to link CDF groups to, in order to grant access",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModifyPatchClaimNames"
              }
            ]
          },
          "scopeClaims": {
            "description": "Which claims to use when scoping access granted by access claims",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModifyPatchClaimNames"
              }
            ]
          },
          "logClaims": {
            "description": "Which token claims to record in the audit log",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModifyPatchClaimNames"
              }
            ]
          },
          "isGroupCallbackEnabled": {
            "description": "A group callback occurs when a user has too many groups attached. This property indicates whether\nthe group callback functionality should be supported for this project. This is only supported for AAD hosted IdPs.\n",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModifyPatchBoolean"
              }
            ]
          },
          "identityProviderScope": {
            "description": "The scope sent to the identity provider when a session is created. The default value is the value required for a default Azure AD IdP configuration.",
            "allOf": [
              {
                "$ref": "#/components/schemas/SinglePatchString"
              }
            ]
          }
        }
      },
      "ModifyPatchClaimNames": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SetClaimNames"
          },
          {
            "$ref": "#/components/schemas/AddClaimNames"
          },
          {
            "$ref": "#/components/schemas/RemoveClaimNames"
          }
        ]
      },
      "RemoveClaimNames": {
        "type": "object",
        "required": [
          "remove"
        ],
        "properties": {
          "remove": {
            "$ref": "#/components/schemas/ClaimNamesArray"
          }
        }
      },
      "SetClaimNames": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ClaimNamesArray"
          }
        }
      },
      "AddClaimNames": {
        "type": "object",
        "required": [
          "add"
        ],
        "properties": {
          "add": {
            "$ref": "#/components/schemas/ClaimNamesArray"
          }
        }
      },
      "ClaimNamesArray": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ClaimName"
        }
      },
      "ClaimName": {
        "type": "object",
        "required": [
          "claimName"
        ],
        "properties": {
          "claimName": {
            "type": "string"
          }
        }
      },
      "RemoveOidcConfiguration": {
        "type": "object",
        "required": [
          "setNull"
        ],
        "properties": {
          "setNull": {
            "type": "boolean",
            "example": true
          }
        }
      },
      "ProjectName": {
        "type": "string",
        "description": "The user-friendly name of the project.",
        "example": "Open Industrial Data"
      },
      "GroupCallbackEnabled": {
        "type": "boolean",
        "description": "A group callback occurs when a user has too many groups attached. This property indicates whether the group callback functionality should be supported for this project. This is only supported for AAD hosted IdPs.\n",
        "example": false
      },
      "DataSecurityCategorySpecDTO": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minLength": 1,
            "items": {
              "$ref": "#/components/schemas/SecurityCategorySpecDTO"
            }
          }
        }
      },
      "SecurityCategoryResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SecurityCategoryDTO"
            }
          }
        }
      },
      "SecurityCategoryWithCursorResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SecurityCategoryDTO"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next page of results"
      },
      "SecurityCategorySpecDTO": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the security category",
            "example": "Guarded by vendor x"
          }
        }
      },
      "SecurityCategoryDTO": {
        "required": [
          "name",
          "id"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the security category",
            "example": "Guarded by vendor x"
          },
          "id": {
            "type": "integer",
            "description": "ID of the security category",
            "format": "int64"
          }
        }
      },
      "DataSetList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataSet"
            }
          }
        }
      },
      "DataSetListWithCursor": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DataSetList"
          },
          {
            "type": "object",
            "properties": {
              "nextCursor": {
                "type": "string",
                "description": "The cursor to get the next page of results (if available)."
              }
            }
          }
        ]
      },
      "DataSetAggregateRequest": {
        "description": "Aggregation request of data sets. Filters exact field matching or timestamp ranges inclusive min and max.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/DataSetFilter"
              }
            }
          }
        ]
      },
      "DataSetFilter": {
        "description": "Filter on data sets with strict matching.",
        "type": "object",
        "properties": {
          "metadata": {
            "$ref": "#/components/schemas/DataSetMetadata"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "externalIdPrefix": {
            "$ref": "#/components/schemas/CogniteExternalIdPrefix"
          },
          "writeProtected": {
            "type": "boolean"
          }
        }
      },
      "DataSetFilterRequest": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/DataSetFilter"
              },
              "limit": {
                "description": "Limits the number of results to return.",
                "type": "integer",
                "format": "int32",
                "minimum": 1,
                "maximum": 1000,
                "default": 100
              }
            }
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "DataSetSpecList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataSetSpec"
            },
            "minItems": 1,
            "maxItems": 10
          }
        }
      },
      "DataSetUpdateList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataSetUpdate"
            }
          }
        }
      },
      "DataSet": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataSetSpec"
          },
          {
            "type": "object",
            "required": [
              "id",
              "createdTime",
              "lastUpdatedTime",
              "writeProtected"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        ]
      },
      "DataSetMetadata": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "additionalProperties": {
          "type": "string",
          "maxLength": 10240
        },
        "x-maxKeyLength": 128,
        "x-maxTotalSize": 10240,
        "maxProperties": 256
      },
      "DataSetSpec": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "description": "The name of the data set.",
            "minLength": 1,
            "maxLength": 50,
            "type": "string"
          },
          "description": {
            "description": "The description of the data set.",
            "minLength": 1,
            "maxLength": 500,
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/DataSetMetadata"
          },
          "writeProtected": {
            "default": false,
            "type": "boolean",
            "description": "To write data to a write-protected data set, you need to be a member of a group that has the \"datasets:owner\" action for the data set. To learn more about write-protected data sets, follow this [guide](https://docs.cognite.com/cdf/data_governance/concepts/datasets/#write-protection)."
          }
        }
      },
      "DataSetIdEitherList": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "minItems": 1,
                "maxItems": 1000,
                "uniqueItems": true,
                "items": {
                  "$ref": "#/components/schemas/DataSetIdEither"
                }
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DataSetUpdate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DataSetChangeById"
          },
          {
            "$ref": "#/components/schemas/DataSetChangeByExternalId"
          }
        ]
      },
      "DataSetChangeById": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataSetPatch"
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "DataSetChangeByExternalId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DataSetPatch"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "DataSetPatch": {
        "type": "object",
        "description": "Update applied to single data set",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "name": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "metadata": {
                "$ref": "#/components/schemas/ObjectPatchDataSet"
              },
              "writeProtected": {
                "$ref": "#/components/schemas/SinglePatchBoolean"
              }
            }
          }
        }
      },
      "DataDataSetAggregate": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/DataSetAggregate"
            }
          }
        }
      },
      "DataSetAggregate": {
        "description": "Aggregation group of data sets",
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Size of the aggregation group",
            "format": "int64"
          }
        }
      },
      "SequenceWithCursorResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GetSequenceDTO"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available). Learn more about [pagination](https://developer.cognite.com/dev/concepts/pagination.html)."
          }
        }
      },
      "SequencesCountAggregateResponse": {
        "type": "object",
        "title": "Count",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The number of sequences that match the given filters."
                }
              }
            }
          }
        }
      },
      "SequencesCardinalityValuesAggregateResponse": {
        "type": "object",
        "title": "CardinalityValues",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The approximate number of unique values for the given property among the sequences that match the given filters."
                }
              }
            }
          }
        }
      },
      "SequencesCardinalityPropertiesAggregateResponse": {
        "type": "object",
        "title": "CardinalityProperties",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "count"
              ],
              "properties": {
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The approximate number of unique properties that begin with the given property path among the sequences that match the given filters."
                }
              }
            }
          }
        }
      },
      "SequencesUniqueValuesAggregateResponse": {
        "type": "object",
        "title": "UniqueValues",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "property",
                "count"
              ],
              "properties": {
                "values": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "description": "The single element in this array is a value that is taken on by the given property in one or more of the sequences that match the given filters. Note that even if the original value was a number or a boolean, the value will be represented as a string in this array.",
                  "items": {
                    "type": "string",
                    "maxLength": 255
                  }
                },
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The number of sequences that match the given filters and have the corresponding value for the given property."
                }
              }
            }
          }
        }
      },
      "SequencesUniquePropertiesAggregateResponse": {
        "type": "object",
        "title": "UniqueProperties",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "property",
                "count"
              ],
              "properties": {
                "values": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "items": {
                    "type": "object",
                    "properties": {
                      "property": {
                        "type": "array",
                        "minItems": 1,
                        "maxItems": 2,
                        "description": "The single element in this array is a property specification - either a top-level property, such as `['name']`, or a metadata property, such as `['metadata', 'tag']`.",
                        "items": {
                          "type": "string",
                          "maxLength": 255
                        }
                      }
                    }
                  }
                },
                "count": {
                  "type": "integer",
                  "format": "int64",
                  "description": "The number of sequences that match the given filters and have the corresponding property."
                }
              }
            }
          }
        }
      },
      "DataResourceIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "object",
                  "title": "Select by Id",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/CogniteInternalId"
                    }
                  }
                },
                {
                  "type": "object",
                  "title": "Select by ExternalId",
                  "properties": {
                    "externalId": {
                      "$ref": "#/components/schemas/CogniteExternalId"
                    }
                  }
                }
              ]
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "DataResourceIdsWithIgnoreUnknownIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "type": "object",
                      "title": "Select by Id",
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "title": "Select by ExternalId",
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    }
                  ]
                },
                "minItems": 1,
                "maxItems": 1000
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "DataGetSequence": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GetSequenceDTO"
            }
          }
        }
      },
      "DataPostSequence": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PostSequenceDTO"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "DataSequenceDataDeleteRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SequenceDeleteDataRequest"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "SequenceDataRequest": {
        "type": "object",
        "description": "Parameters describing a query for datapoints.",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "Select by Id",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceDataRequestDTO"
              },
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "Select by ExternalId",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceDataRequestDTO"
              },
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              }
            ]
          }
        ]
      },
      "SequenceLatestDataRequest": {
        "type": "object",
        "description": "Parameters describing a query for the last row in a sequence.",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "Select by Id",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceLatestDataRequestDTO"
              },
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "Select by ExternalId",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceLatestDataRequestDTO"
              },
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              }
            ]
          }
        ]
      },
      "SequenceDeleteDataRequest": {
        "type": "object",
        "description": "Parameters describing datapoints to be deleted.",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "Select by Id",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceDataDeleteRequestDTO"
              },
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "Select by ExternalId",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceDataDeleteRequestDTO"
              },
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              }
            ]
          }
        ]
      },
      "DataSequencePostData": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SequencePostData"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        },
        "example": {
          "items": [
            {
              "externalId": "DL/DRILL412/20190103/T3",
              "columns": [
                "Depth",
                "DepthSource",
                "PowerSetting"
              ],
              "rows": [
                {
                  "rowNumber": 1,
                  "values": [
                    23331.3,
                    "s2",
                    61
                  ]
                }
              ]
            }
          ]
        }
      },
      "DataSequenceChange": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SequencesUpdate"
            },
            "minItems": 1,
            "maxItems": 1000
          }
        }
      },
      "PostSequenceDTO": {
        "required": [
          "columns"
        ],
        "type": "object",
        "description": "Describes a new sequence.",
        "properties": {
          "name": {
            "type": "string",
            "example": "Any relevant name",
            "description": "Name of the sequence.",
            "maxLength": 255
          },
          "description": {
            "type": "string",
            "example": "Optional description",
            "description": "Description of the sequence.",
            "maxLength": 1000
          },
          "assetId": {
            "type": "integer",
            "example": 1221123111,
            "description": "Optional asset this sequence is associated with.",
            "format": "int64"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "metadata": {
            "type": "object",
            "example": {
              "extracted-by": "cognite"
            },
            "description": "Custom, application specific metadata. String key -> String value. Maximum length of key is 128 bytes, up to 256 key-value pairs, up to a total size of 10000 bytes across all keys and values.\n",
            "additionalProperties": {
              "type": "string"
            }
          },
          "columns": {
            "type": "array",
            "description": "List of column definitions. Maximum number of numeric columns is 400. Maximum number of string columns is 200. Maximum total number of columns is 400.",
            "items": {
              "$ref": "#/components/schemas/PostSequenceColumnDTO"
            },
            "minItems": 1,
            "maxItems": 400
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          }
        }
      },
      "GetSequenceDTO": {
        "type": "object",
        "required": [
          "id",
          "columns",
          "createdTime",
          "lastUpdatedTime"
        ],
        "description": "Information about the sequence stored in the database.",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Unique Cognite-provided identifier for the sequence.",
            "example": 1,
            "format": "int64",
            "readOnly": true
          },
          "name": {
            "type": "string",
            "example": "Any relevant name",
            "description": "Name of the sequence."
          },
          "description": {
            "type": "string",
            "example": "Optional description",
            "description": "Description of the sequence."
          },
          "assetId": {
            "type": "integer",
            "example": 1221123111,
            "description": "Optional asset this sequence is associated with.",
            "format": "int64"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "metadata": {
            "type": "object",
            "example": {
              "extracted-by": "cognite"
            },
            "description": "Custom, application specific metadata. String key -> String value. Maximum length of key is 128 bytes, up to 256 key-value pairs, up to a total size of 10000 bytes across all keys and values.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "columns": {
            "type": "array",
            "description": "List of column definitions.",
            "items": {
              "$ref": "#/components/schemas/GetSequenceColumnDTO"
            }
          },
          "createdTime": {
            "type": "integer",
            "example": 100000000000,
            "description": "Time when this sequence was created in CDF in milliseconds since Jan 1, 1970.",
            "format": "int64",
            "readOnly": true
          },
          "lastUpdatedTime": {
            "type": "integer",
            "example": 100000000000,
            "description": "The last time this sequence was updated in CDF, in milliseconds since Jan 1, 1970.",
            "format": "int64",
            "readOnly": true
          },
          "dataSetId": {
            "type": "integer",
            "format": "int64",
            "description": "Data set this sequence belongs to.",
            "example": 2718281828459
          }
        }
      },
      "PostSequenceColumnDTO": {
        "type": "object",
        "description": "Describes a new column.",
        "required": [
          "externalId"
        ],
        "properties": {
          "name": {
            "type": "string",
            "example": "depth",
            "description": "Human readable name of the sequence.",
            "maxLength": 255
          },
          "externalId": {
            "type": "string",
            "example": "DPS1",
            "maxLength": 255,
            "description": "User provided column identifier (unique for a given sequence)."
          },
          "description": {
            "type": "string",
            "example": "Optional description",
            "description": "Description of the column.",
            "maxLength": 1000
          },
          "valueType": {
            "$ref": "#/components/schemas/SequenceValueTypeEnum"
          },
          "metadata": {
            "type": "object",
            "example": {
              "extracted-by": "cognite"
            },
            "description": "Custom, application specific metadata. String key -> String value. Maximum length of key is 128 bytes, up to 256 key-value pairs, up to a total size of 10000 bytes across all keys and values.\n",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "GetSequenceColumnDTO": {
        "type": "object",
        "required": [
          "id",
          "valueType",
          "createdTime",
          "lastUpdatedTime"
        ],
        "description": "Information about a column stored in the database.",
        "properties": {
          "name": {
            "type": "string",
            "example": "depth",
            "description": "Human readable name of the column."
          },
          "externalId": {
            "type": "string",
            "example": "DPS1",
            "description": "User provided column identifier (unique for a given sequence)."
          },
          "description": {
            "type": "string",
            "example": "Optional description",
            "description": "Description of the column."
          },
          "valueType": {
            "$ref": "#/components/schemas/SequenceValueTypeEnum"
          },
          "metadata": {
            "type": "object",
            "example": {
              "extracted-by": "cognite"
            },
            "description": "Custom, application specific metadata. String key -> String value.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "createdTime": {
            "type": "integer",
            "example": 100000000000,
            "description": "Time when this asset was created in CDF in milliseconds since Jan 1, 1970.",
            "format": "int64",
            "readOnly": true
          },
          "lastUpdatedTime": {
            "type": "integer",
            "example": 100000000000,
            "description": "The last time this asset was updated in CDF, in milliseconds since Jan 1, 1970.",
            "format": "int64",
            "readOnly": true
          }
        }
      },
      "SequenceDataRequestDTO": {
        "type": "object",
        "description": "A request for datapoints stored.",
        "properties": {
          "start": {
            "type": "integer",
            "description": "Lowest row number included.",
            "default": 0,
            "format": "int64"
          },
          "end": {
            "type": "integer",
            "description": "Get rows up to, but excluding, this row number. Default - No limit.",
            "example": 1,
            "format": "int64"
          },
          "limit": {
            "type": "integer",
            "description": "Maximum number of rows returned in one request. API might return less even if there's more data, but it will provide a cursor for continuation. If there's more data beyond this limit, a cursor will be returned to simplify further fetching of data.",
            "minimum": 1,
            "maximum": 10000,
            "default": 100,
            "example": 1,
            "format": "int32"
          },
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination returned from a previous request. Apart from this cursor, the rest of the request object is the same as for the original request."
          },
          "columns": {
            "type": "array",
            "description": "Columns to include. Specified as a list of the `externalId` of each column to include.\nIf this filter isn't set, all available columns will be returned.\n",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "maxItems": 400
          }
        }
      },
      "SequenceLatestDataRequestDTO": {
        "type": "object",
        "description": "A request for the last row.",
        "properties": {
          "columns": {
            "type": "array",
            "description": "Columns to include. Specified as a list of the `externalId` of each column to include.\nIf this filter isn't set, all available columns will be returned.\n",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "maxItems": 400
          },
          "before": {
            "type": "integer",
            "description": "Get rows up to, but not including, this row number.",
            "minimum": 1,
            "format": "int64"
          }
        }
      },
      "SequenceDataDeleteRequestDTO": {
        "type": "object",
        "required": [
          "rows"
        ],
        "description": "Rows to delete from a sequence.",
        "properties": {
          "rows": {
            "type": "array",
            "items": {
              "type": "integer",
              "example": 1,
              "format": "int64"
            },
            "minItems": 1,
            "maxItems": 10000
          }
        }
      },
      "SequenceGetData": {
        "type": "object",
        "required": [
          "id",
          "columns",
          "rows"
        ],
        "description": "Data from a sequence.",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "columns": {
            "type": "array",
            "description": "Column information in the order given by data.",
            "items": {
              "$ref": "#/components/schemas/BasicGetSequenceColumnInfo"
            }
          },
          "rows": {
            "type": "array",
            "description": "List of row information.",
            "items": {
              "$ref": "#/components/schemas/SequenceRowDTO"
            }
          }
        },
        "example": {
          "id": 1112,
          "externalId": "DL/DRILL412/20190103/T3",
          "columns": [
            {
              "externalId": "Depth"
            },
            {
              "externalId": "DepthSource"
            },
            {
              "externalId": "PowerSetting"
            }
          ],
          "rows": [
            {
              "rowNumber": 1,
              "values": [
                23331.3,
                "s2",
                61
              ]
            }
          ]
        }
      },
      "SequenceGetDataWithCursor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/SequenceGetData"
          },
          {
            "properties": {
              "nextCursor": {
                "type": "string",
                "description": "Cursor to get the next page of results (if available)."
              }
            }
          }
        ]
      },
      "SequencePostData": {
        "type": "object",
        "oneOf": [
          {
            "required": [
              "id"
            ],
            "title": "Select by Id",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceDataInsertion"
              },
              {
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/CogniteInternalId"
                  }
                }
              }
            ]
          },
          {
            "required": [
              "externalId"
            ],
            "title": "Select by ExternalId",
            "allOf": [
              {
                "$ref": "#/components/schemas/SequenceDataInsertion"
              },
              {
                "properties": {
                  "externalId": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              }
            ]
          }
        ],
        "example": {
          "externalId": "DL/DRILL412/20190103/T3",
          "columns": [
            "Depth",
            "DepthSource",
            "PowerSetting"
          ],
          "rows": [
            {
              "rowNumber": 1,
              "values": [
                23331.3,
                "s2",
                61
              ]
            }
          ]
        }
      },
      "SequenceDataInsertion": {
        "type": "object",
        "required": [
          "columns",
          "rows"
        ],
        "description": "Data from a sequence.",
        "properties": {
          "columns": {
            "type": "array",
            "description": "Column external IDs in the same order as the values for each row.",
            "items": {
              "type": "string"
            },
            "minItems": 1,
            "maxItems": 200
          },
          "rows": {
            "type": "array",
            "description": "List of rows. The number of rows per request is limited to 10000. The total number of values, including nulls, in a single request is limited to 100000.",
            "items": {
              "$ref": "#/components/schemas/SequenceRowDTO"
            },
            "minItems": 1,
            "maxItems": 10000
          }
        }
      },
      "BasicGetSequenceColumnInfo": {
        "type": "object",
        "description": "Column information returned on data requests.",
        "properties": {
          "externalId": {
            "type": "string",
            "example": "DPS1",
            "description": "User provided column identifier (unique for a given sequence)."
          },
          "name": {
            "type": "string",
            "example": "Depth sensor 1",
            "description": "Human readable name of the column."
          },
          "valueType": {
            "$ref": "#/components/schemas/SequenceValueTypeEnum"
          }
        }
      },
      "SequenceRowDTO": {
        "type": "object",
        "description": "A single row of datapoints.",
        "required": [
          "rowNumber",
          "values"
        ],
        "properties": {
          "rowNumber": {
            "type": "integer",
            "description": "The row number for this row.",
            "example": 1,
            "minimum": 0,
            "format": "int64"
          },
          "values": {
            "type": "array",
            "description": "List of values in the order defined in the columns field. Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters.",
            "items": {
              "$ref": "#/components/schemas/SequenceItemDTO"
            },
            "minItems": 1,
            "maxItems": 400
          }
        }
      },
      "SequenceItemDTO": {
        "oneOf": [
          {
            "type": "number",
            "description": "JSON element of type corresponding to the column type. May include NULL.",
            "example": 10000.123
          },
          {
            "type": "string",
            "description": "JSON element of type corresponding to the column type. May include NULL.",
            "example": "ON"
          }
        ]
      },
      "SequencesUpdate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SequencesUpdateById"
          },
          {
            "$ref": "#/components/schemas/SequencesUpdateByExternalId"
          }
        ]
      },
      "SequencesUpdateById": {
        "title": "Select by Id",
        "allOf": [
          {
            "$ref": "#/components/schemas/SequenceChangeDTO"
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "SequencesUpdateByExternalId": {
        "title": "Select by ExternalId",
        "allOf": [
          {
            "$ref": "#/components/schemas/SequenceChangeDTO"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "SequenceChangeDTO": {
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "description": "A description of changes that should be done to the sequence.",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "assetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "externalId": {
                "$ref": "#/components/schemas/SinglePatchString"
              },
              "metadata": {
                "$ref": "#/components/schemas/ObjectPatch"
              },
              "dataSetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "columns": {
                "$ref": "#/components/schemas/SequenceColumnChangeDTO"
              }
            }
          }
        }
      },
      "SequenceColumnChangeDTO": {
        "description": "Add, remove, or modify sequence columns. After the update, the number of numeric columns and\ndeleted columns should be  400; the number of string columns and deleted columns should\nbe  200; and the number of numeric columns, string columns, and deleted columns should\nbe  400.\n",
        "properties": {
          "modify": {
            "type": "array",
            "description": "List of single column updates.",
            "items": {
              "description": "Modify a single sequence column by column externalId",
              "required": [
                "externalId",
                "update"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                },
                "update": {
                  "type": "object",
                  "description": "Modifications to apply to a single column.",
                  "properties": {
                    "description": {
                      "$ref": "#/components/schemas/SinglePatchString"
                    },
                    "externalId": {
                      "$ref": "#/components/schemas/SinglePatchRequiredString"
                    },
                    "name": {
                      "$ref": "#/components/schemas/SinglePatchString"
                    },
                    "metadata": {
                      "$ref": "#/components/schemas/ObjectPatch"
                    }
                  }
                }
              }
            }
          },
          "add": {
            "type": "array",
            "description": "List of column definitions to add.",
            "items": {
              "$ref": "#/components/schemas/PostSequenceColumnDTO"
            }
          },
          "remove": {
            "type": "array",
            "description": "List of columns to remove.",
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          }
        }
      },
      "SequenceFilter": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Returns only sequences with this name."
          },
          "externalIdPrefix": {
            "$ref": "#/components/schemas/CogniteExternalIdPrefix"
          },
          "metadata": {
            "description": "Filters the sequences by metadata fields and values. Format is {'key1':'value1','key2':'value2'}.",
            "example": {
              "key1": "value1",
              "key2": "value2"
            },
            "type": "object"
          },
          "assetIds": {
            "type": "array",
            "description": "Returns only sequences linked to one of the specified assets.",
            "example": [
              363848954441724,
              793045462540095,
              1261042166839739
            ],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true
          },
          "rootAssetIds": {
            "type": "array",
            "description": "Only includes sequences that have a related asset in a tree rooted at any of these root `assetIds`.",
            "example": [
              363848954441724,
              793045462540095,
              1261042166839739
            ],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            },
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true
          },
          "assetSubtreeIds": {
            "type": "array",
            "description": "Only includes sequences that have a related asset in a subtree rooted at any of these `assetIds` (including the roots given). If the total size of the given subtrees exceeds 100,000 assets, an error will be returned.",
            "example": [
              {
                "id": 1234567890
              },
              {
                "externalId": "externalId123"
              }
            ],
            "items": {
              "$ref": "#/components/schemas/AssetIdEither"
            },
            "minItems": 1,
            "maxItems": 100,
            "uniqueItems": true
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "dataSetIds": {
            "type": "array",
            "maxItems": 100,
            "uniqueItems": true,
            "description": "Only includes sequences that belong to these datasets.",
            "items": {
              "$ref": "#/components/schemas/DataSetIdEither"
            }
          }
        }
      },
      "SequenceSearch": {
        "type": "object",
        "properties": {
          "name": {
            "description": "Prefix and fuzzy search on name.",
            "type": "string"
          },
          "description": {
            "description": "Prefix and fuzzy search on description.",
            "type": "string"
          },
          "query": {
            "description": "Searches on name and description using wildcard search on each of the words (separated by spaces). Retrieves results where at least one word must match. For example, '*some other*'.",
            "type": "string"
          }
        }
      },
      "SequencesSearchDTO": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/SequenceFilter"
          },
          "search": {
            "$ref": "#/components/schemas/SequenceSearch"
          },
          "limit": {
            "description": "Returns up to this many results.",
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "format": "int32",
            "default": 100
          }
        }
      },
      "SequencesAdvancedListDTO": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/SequenceFilter"
              },
              "advancedFilter": {
                "$ref": "#/components/schemas/SequencesFilterLanguage"
              },
              "limit": {
                "description": "Returns up to this many results per page.",
                "maximum": 1000,
                "minimum": 1,
                "type": "integer",
                "format": "int32",
                "default": 100
              }
            }
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/PartitionObject"
          },
          {
            "$ref": "#/components/schemas/SequencesSort"
          }
        ]
      },
      "SequencesAdvancedAggregateDTO": {
        "type": "object",
        "allOf": [
          {
            "properties": {
              "advancedFilter": {
                "$ref": "#/components/schemas/SequencesFilterLanguage"
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/SequencesAggregateFilter"
              },
              "filter": {
                "$ref": "#/components/schemas/SequenceFilter"
              }
            }
          },
          {
            "oneOf": [
              {
                "$ref": "#/components/schemas/SequencesCountAggregate"
              },
              {
                "$ref": "#/components/schemas/SequencesCardinalityValuesAggregate"
              },
              {
                "$ref": "#/components/schemas/SequencesCardinalityPropertiesAggregate"
              },
              {
                "$ref": "#/components/schemas/SequencesUniqueValuesAggregate"
              },
              {
                "$ref": "#/components/schemas/SequencesUniquePropertiesAggregate"
              }
            ]
          }
        ]
      },
      "SequencesCountAggregate": {
        "type": "object",
        "title": "Count",
        "properties": {
          "aggregate": {
            "description": "The `count` aggregation gets the number of sequences that match the filter(s). This is the\r\ndefault aggregation, which will also be applied if `aggregate` is not specified.\r\n",
            "type": "string",
            "enum": [
              "count"
            ]
          }
        }
      },
      "SequencesCardinalityValuesAggregate": {
        "title": "CardinalityValues",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `cardinalityValues` aggregation gets, from the sequences that match the filter(s),\r\nthe approximate number of unique values that are taken on by the given property.\r\n",
                "type": "string",
                "enum": [
                  "cardinalityValues"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/SequencesAggregateProperties"
          }
        ]
      },
      "SequencesCardinalityPropertiesAggregate": {
        "title": "CardinalityProperties",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `cardinalityProperties` aggregation gets, from the sequences that match the filter(s),\r\nthe approximate number of unique properties whose property path begins with the given `path`.\r\nCurrently, the only supported value for `path` is `[\"metadata\"]`, which means that this aggregation\r\nwill get the approximate size of the set of unique metadata keys.\r\n",
                "type": "string",
                "enum": [
                  "cardinalityProperties"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/SequencesAggregatePath"
          }
        ]
      },
      "SequencesUniqueValuesAggregate": {
        "title": "UniqueValues",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `uniqueValues` aggregation gets, from the sequences that match the filter(s),\r\nthe set of unique values (up to max 1000) that are taken on by the given property. For each such\r\nvalue, the aggregation result will also specify the frequency - that is, the number of sequences\r\nthat match the filter(s) and have that property value. The results are ordered by frequency in\r\ndescending order.\r\n",
                "type": "string",
                "enum": [
                  "uniqueValues"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/SequencesAggregateProperties"
          }
        ]
      },
      "SequencesUniquePropertiesAggregate": {
        "title": "UniqueProperties",
        "allOf": [
          {
            "type": "object",
            "required": [
              "aggregate"
            ],
            "properties": {
              "aggregate": {
                "description": "The `uniqueProperties` aggregation gets, from the sequences that match the filter(s),\r\nthe set of unique properties (up to max 1000) whose property path begins with the given `path`.\r\nCurrently, the only supported value for `path` is `[\"metadata\"]`, which means that this aggregation\r\nwill get the set of unique metadata keys. For each such property, the aggregation result will also\r\nspecify the frequency - that is, the number of sequences that match the filter(s) and have that\r\nproperty. The results are ordered by frequency in descending order.\r\n",
                "type": "string",
                "enum": [
                  "uniqueProperties"
                ]
              }
            }
          },
          {
            "$ref": "#/components/schemas/SequencesAggregatePath"
          }
        ]
      },
      "SequencesAggregateProperties": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "description": "The properties to which the aggregation should be applied. While this parameter is a list, it\r\ncurrently only accepts one element. Each element is an object with a single field called `property`,\r\nwhose value is another list (in order to accommodate nested properties). Thus, a top-level property\r\n`name` must be specified as `[{\"property\": [\"name\"]}]`, and a metadata property `tag` must be\r\nspecified as `[{\"property\": [\"metadata\", \"tag\"]}]`.\r\n\r\nThe supported top-level properties are:\r\n- `accessCategories`\r\n- `assetId`\r\n- `assetRootId`\r\n- `createdTime`\r\n- `dataSetId`\r\n- `description`\r\n- `externalId`\r\n- `id`\r\n- `lastUpdatedTime`\r\n- `name`\r\n",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "object",
              "required": [
                "property"
              ],
              "properties": {
                "property": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 2,
                  "items": {
                    "type": "string",
                    "minLength": 1,
                    "maxLength": 128
                  }
                }
              }
            }
          }
        }
      },
      "SequencesAggregatePath": {
        "type": "object",
        "required": [
          "path"
        ],
        "properties": {
          "path": {
            "description": "The scope within which properties should be aggregated. The only value that is currently allowed is `['metadata']`, which will aggregate metadata keys.",
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "type": "string",
              "enum": [
                "metadata"
              ]
            }
          }
        }
      },
      "SequenceValueTypeEnum": {
        "type": "string",
        "description": "What type the datapoints in a column will have. DOUBLE is restricted to the range [-1E100, 1E100]",
        "default": "DOUBLE",
        "enum": [
          "STRING",
          "DOUBLE",
          "LONG"
        ]
      },
      "SequencesFilterLanguage": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define advanced filter queries.\n\nAt the top level, an `advancedFilter` expression is either a single Boolean filter or a\nsingle leaf filter. Boolean filters contain other Boolean filters and/or leaf filters. The\ntotal number of filters may be at most 100, and the depth (the greatest number of times\nfilters have been nested inside each other) may be at most 10. The `search` leaf filter may\nat most be used twice within a single `advancedFilter`, but all other filters can be used\nas many times as you like as long as the other limits are respected.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SequencesBoolFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesLeafFilter"
          }
        ],
        "example": {
          "or": [
            {
              "not": {
                "and": [
                  {
                    "equals": {
                      "property": [
                        "metadata",
                        "manufacturer"
                      ],
                      "value": "acme"
                    }
                  },
                  {
                    "in": {
                      "property": [
                        "name"
                      ],
                      "values": [
                        "pump-1-temperature",
                        "motor-9-temperature"
                      ]
                    }
                  },
                  {
                    "range": {
                      "property": [
                        "dataSetId"
                      ],
                      "gte": 1,
                      "lt": 10
                    }
                  }
                ]
              }
            },
            {
              "and": [
                {
                  "equals": {
                    "property": [
                      "assetId"
                    ],
                    "value": 1234
                  }
                },
                {
                  "equals": {
                    "property": [
                      "description"
                    ],
                    "value": "Temperature in Celsius"
                  }
                }
              ]
            }
          ]
        }
      },
      "SequencesLeafFilter": {
        "description": "Leaf filter.\n",
        "title": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SequencesEqualsFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesInFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesRangeFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesPrefixFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesExistsFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesContainsAllFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesSearchFilter"
          }
        ]
      },
      "SequencesBoolFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt is built by nesting one or more Boolean clauses, each of which is one of `and`, `or`, and `not`.\nEach such clause contains one or more child clauses (though `not` can only have one).\nEach child clause can be either another Boolean clause or a leaf filter.\n",
        "title": "Boolean filter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "maxItems": 99,
                "items": {
                  "$ref": "#/components/schemas/SequencesFilterLanguage"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "maxItems": 99,
                "items": {
                  "$ref": "#/components/schemas/SequencesFilterLanguage"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter DSL",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SequencesFilterLanguage"
                  }
                ]
              }
            }
          }
        ]
      },
      "SequencesEqualsFilter": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the given property is **exactly** equal to the given value.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/SequencesValue"
              }
            }
          }
        }
      },
      "SequencesInFilter": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the given property is **exactly** equal to one of the given values.\nThis filter can only be applied to single-valued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/SequencesValues"
              }
            }
          }
        }
      },
      "SequencesRangeFilter": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain terms within the provided range.\n\nOne upper bound and/or one lower bound must be specified. It's not allowed to specify both inclusive and exclusive\nbounds \"on the same side\" together (at most one of `lte` and `lt` may be specified, and at most one of `gte` and `gt`).\n- `gte`: Greater than or equal to.\n- `gt`: Greater than.\n- `lte`: Less than or equal to.\n- `lt`: Less than.\n\nMay only be applied to string properties and number properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/SequencesRangeValue"
              },
              "gt": {
                "$ref": "#/components/schemas/SequencesRangeValue"
              },
              "lte": {
                "$ref": "#/components/schemas/SequencesRangeValue"
              },
              "lt": {
                "$ref": "#/components/schemas/SequencesRangeValue"
              }
            }
          }
        }
      },
      "SequencesPrefixFilter": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the provided property begins with the given text.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/SequencesStringValue"
              }
            }
          }
        }
      },
      "SequencesExistsFilter": {
        "type": "object",
        "title": "exists",
        "required": [
          "exists"
        ],
        "properties": {
          "exists": {
            "required": [
              "property"
            ],
            "description": "Matches items that have a value for the specified property.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              }
            }
          }
        }
      },
      "SequencesContainsAnyFilter": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more of the given values.\nThis filter can only be applied to multivalued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/SequencesValues"
              }
            }
          }
        }
      },
      "SequencesContainsAllFilter": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains all the given values.\nThis filter can only be applied to multivalued properties.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/SequencesValues"
              }
            }
          }
        }
      },
      "SequencesSearchFilter": {
        "type": "object",
        "title": "search",
        "required": [
          "search"
        ],
        "properties": {
          "search": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items where the provided string property contains the given value according to a fuzzy search.\nThe value may exist anywhere in the string, even as a part of a word or with some grammatical\nvariations (e.g., searching for \"run\" will also find \"ran\").\n\nThe supported properties are `name` and `description`. It's also possible to set `property`\nto `[\"query\"]`, in which case both `name` and `description` will be searched.\n\nWhen the `search` filter is being used, and it's not nested inside a `not` filter (directly or indirectly),\nand no `sort` is specified, the results will be ranked according to how good the match is.\nWhen the `query` 'property' is specified, matches in `name` will rank higher than matches in `description`.\nThe `search` filter may be used at most twice within the same `advancedFilter` expression.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/SequencesFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/SequencesStringValue"
              }
            }
          }
        }
      },
      "SequencesFilterProperty": {
        "description": "The property on which you want to filter. May be either:\n- A single-element list that contains the name of one of the predefined top-level\n  properties, in which case the filter will be applied to that top-level property.\n- A single-element list that contains `'metadata'`, in which case the filter will be applied\n  to _all_ metadata properties.\n- A two-element list where the first element is `'metadata'` and the second one is any\n  string, in which case the filter will be applied to metadata properties with that name.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 2,
        "items": {
          "type": "string",
          "minLength": 1,
          "maxLength": 256
        }
      },
      "SequencesValue": {
        "description": "A value that you wish to find in the provided property.\n",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "SequencesValues": {
        "description": "One or more values that you wish to find in the provided properties.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/SequencesValue"
        }
      },
      "SequencesStringValue": {
        "title": "String",
        "description": "A value that you wish to find in the provided property.\n",
        "type": "string",
        "maxLength": 256
      },
      "SequencesRangeValue": {
        "description": "An upper or lower bound in a `range` filter.",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          }
        ]
      },
      "SequencesAggregateFilter": {
        "type": "object",
        "description": "A filter DSL (Domain Specific Language) to define aggregate filters.\n",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SequencesBoolAggregateFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesLeafAggregateFilter"
          }
        ]
      },
      "SequencesLeafAggregateFilter": {
        "description": "Leaf filter.\n",
        "title": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/SequencesInAggregateFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesRangeAggregateFilter"
          },
          {
            "$ref": "#/components/schemas/SequencesPrefixAggregateFilter"
          }
        ]
      },
      "SequencesBoolAggregateFilter": {
        "description": "A query that matches items matching boolean combinations of other queries.\nIt's built by nesting one or more Boolean clauses, each of which is one of `and`, `or`, and `not`.\nEach such clause contains one or more child clauses (though `not` can only have one).\nEach child clause can be either another Boolean clause or a leaf filter.\n",
        "title": "Boolean filter",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "title": "Aggregate filter DSL",
                "description": "The aggregation result will only contain items that match _all_ of the given\nsub-clauses.\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 19,
                "items": {
                  "$ref": "#/components/schemas/SequencesAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "title": "Aggregate filter DSL",
                "description": "The aggregation result will only contain items that match _at least one_\n(but potentially many or even all) of the given sub-clauses.\n",
                "type": "array",
                "minItems": 1,
                "maxItems": 19,
                "items": {
                  "$ref": "#/components/schemas/SequencesAggregateFilter"
                }
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Aggregate filter DSL",
                "description": "The aggregation result will only contain items that do _not_ match the given\nsub-clause.\n",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/SequencesAggregateFilter"
                  }
                ]
              }
            }
          }
        ]
      },
      "SequencesInAggregateFilter": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "values"
            ],
            "description": "Matches intermediate aggregation results where the property key or the property value is _exactly_\nequal to one of the given values. When the `aggregate` operation is `uniqueProperties` or\n`cardinalityProperties`, property _keys_ will be targeted; when it is `uniqueValues` or\n`cardinalityValues`, property _values_ will be targeted.\n",
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/SequencesInAggregateValues"
              }
            }
          }
        }
      },
      "SequencesPrefixAggregateFilter": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "value"
            ],
            "description": "Matches intermediate aggregation results where the property key or the property value begins with\nthe given text. When the `aggregate` operation is `uniqueProperties` or `cardinalityProperties`,\nproperty _keys_ will be targeted; when it is `uniqueValues` or `cardinalityValues`, property\n_values_ will be targeted.\n",
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/SequencesPrefixAggregateValue"
              }
            }
          }
        }
      },
      "SequencesRangeAggregateFilter": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "description": "Matches intermediate aggregation results where the property key or the property value is within the\nprovided range. When the `aggregate` operation is `uniqueProperties` or `cardinalityProperties`,\nproperty _keys_ will be targeted; when it is `uniqueValues` or `cardinalityValues`, property \n_values_ will be targeted.\n\nAt least one of the following bounds must be specified:\n- `gte`: Greater than or equal to.\n- `gt`: Greater than.\n- `lte`: Less than or equal to.\n- `lt`: Less than.\n\nIt is not valid to specify both inclusive and exclusive bounds \"on the same side\" together:\nat most one of `lte` and `lt` may be specified, and at most one of `gte` and `gt`.\n\nIn the case of `aggregate` being `uniqueProperties` or `cardinalityProperties`,\n`gte`/`gt`/`lte`/`lt` must be set to a string. In the case of `aggregate` being `uniqueValues` or\n`cardinalityValues`, this filter may only be applied to string properties or number properties,\nwith `gte`/`gt`/`lte`/`lt` containing values of the corresponding type.\n",
            "type": "object",
            "properties": {
              "gte": {
                "$ref": "#/components/schemas/SequencesRangeAggregateValue"
              },
              "gt": {
                "$ref": "#/components/schemas/SequencesRangeAggregateValue"
              },
              "lte": {
                "$ref": "#/components/schemas/SequencesRangeAggregateValue"
              },
              "lt": {
                "$ref": "#/components/schemas/SequencesRangeAggregateValue"
              }
            }
          }
        }
      },
      "SequencesInAggregateValues": {
        "description": "The property keys or property values (depending on the `aggregate` operation) on which you want to\nfilter the intermediate aggregate results.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/SequencesInAggregateValue"
        }
      },
      "SequencesInAggregateValue": {
        "description": "The property key or property value (depending on the `aggregate` operation) on which you want to\nfilter the intermediate aggregate results.\n",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "SequencesPrefixAggregateValue": {
        "title": "String",
        "description": "A string value that represents either a property key or a property value, depending on the\n`aggregate` operation.\n",
        "type": "string",
        "maxLength": 256
      },
      "SequencesRangeAggregateValue": {
        "description": "An upper or lower bound for a property key or property value (depending on which `aggregate` was\nspecified at the top level of the aggregation request).\n",
        "oneOf": [
          {
            "type": "string",
            "maxLength": 256
          },
          {
            "type": "number"
          },
          {
            "type": "integer"
          }
        ]
      },
      "SequencesSort": {
        "type": "object",
        "properties": {
          "sort": {
            "description": "Sort by array of selected properties.\n",
            "type": "array",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "$ref": "#/components/schemas/SequencesSortItem"
            }
          }
        }
      },
      "SequencesSortItem": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "type": "array",
            "description": "Property to sort on.\nSorting can be done on the following properties:\n  | Property                          |\n  |-----------------------------------|\n  | `['assetId']`                     |\n  | `['createdTime']`                 |\n  | `['dataSetId']`                   |\n  | `['description']`                 |\n  | `['externalId']`                  |\n  | `['lastUpdatedTime']`             |\n  | `['metadata', '<someCustomKey>']` |\n  | `['name']`                        |\n  | `['_score_']`                     |",
            "minItems": 1,
            "maxItems": 2,
            "items": {
              "type": "string",
              "maxLength": 128
            }
          },
          "order": {
            "type": "string",
            "description": "The `order` attribute is optional and defaults to `desc` for `_score_` and `asc` for all\nother properties.",
            "enum": [
              "asc",
              "desc"
            ]
          },
          "nulls": {
            "type": "string",
            "description": "The `nulls` attribute is optional and defaults to `auto`. `auto` is translated to `last`\nfor the `asc` order and to `first` for the `desc` order.",
            "enum": [
              "first",
              "last",
              "auto"
            ],
            "default": "auto"
          }
        }
      },
      "LabelDefinitionCreateList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/LabelDefinition"
            }
          }
        }
      },
      "LabelDefinitionList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 1000,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/LabelDefinition"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        }
      },
      "ExternalLabelDefinitionList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "uniqueItems": true,
            "items": {
              "$ref": "#/components/schemas/ExternalLabelDefinition"
            }
          }
        }
      },
      "LabelDefinition": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExternalLabelDefinition"
          },
          {
            "type": "object",
            "required": [
              "createdTime"
            ],
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        ]
      },
      "ExternalLabelDefinition": {
        "type": "object",
        "required": [
          "externalId",
          "name"
        ],
        "description": "A label definition is a globally defined label that can later be attached to resources (e.g., assets). For example, can you define a \"Pump\" label definition and attach that label to your pump assets.\n",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "description": "Name of the label.",
            "type": "string",
            "minLength": 1,
            "maxLength": 140
          },
          "description": {
            "description": "Description of the label.",
            "type": "string",
            "maxLength": 500
          },
          "dataSetId": {
            "description": "The id of the dataset this label belongs to.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          }
        }
      },
      "LabelDefinitionListScope": {
        "allOf": [
          {
            "$ref": "#/components/schemas/LabelDefinitionFilter"
          },
          {
            "$ref": "#/components/schemas/Cursor"
          },
          {
            "$ref": "#/components/schemas/Limit"
          }
        ]
      },
      "LabelDefinitionFilter": {
        "type": "object",
        "properties": {
          "filter": {
            "type": "object",
            "description": "Filter on labels definitions with strict matching.",
            "title": "Filter",
            "properties": {
              "name": {
                "description": "Returns the label definitions matching that name.",
                "type": "string",
                "minLength": 1,
                "maxLength": 140
              },
              "externalIdPrefix": {
                "$ref": "#/components/schemas/ExternalIdPrefixFilter"
              },
              "dataSetIds": {
                "type": "array",
                "maxItems": 1000,
                "items": {
                  "$ref": "#/components/schemas/DataSetIdEither"
                }
              }
            }
          }
        }
      },
      "LabelsIdsWithIgnoreUnknownIds": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/LabelSelectByExternalId"
                },
                "minItems": 1,
                "maxItems": 1000
              }
            }
          },
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          }
        ]
      },
      "LabelSelectByExternalId": {
        "type": "object",
        "title": "Select by ExternalId",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "fetchResources": {
        "description": "If true,\nwill try to fetch the resources referred to in the relationship,\nbased on the users access rights.\nWill silently fail to attatch the resources if the user lacks access to some of them.\n",
        "type": "boolean",
        "default": false
      },
      "relationshipExternalId": {
        "type": "string",
        "minLength": 1,
        "maxLength": 255,
        "description": "The external ID of the relationship."
      },
      "resourceExternalId": {
        "type": "string",
        "minLength": 1,
        "maxLength": 255
      },
      "externalIdObject": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/relationshipExternalId"
          }
        },
        "required": [
          "externalId"
        ]
      },
      "persistedObject": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/relationshipExternalId"
          },
          "createdTime": {
            "description": "The time, in milliseconds since Jan. 1, 1970, when the relationship was created.",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "lastUpdatedTime": {
            "description": "The time, in milliseconds since Jan. 1, 1970, when the relationship was last updated.",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          }
        },
        "required": [
          "externalId",
          "createdTime",
          "lastUpdatedTime"
        ]
      },
      "enrichedRelationship": {
        "type": "object",
        "properties": {
          "source": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Asset"
              },
              {
                "$ref": "#/components/schemas/GetTimeSeriesMetadataDTO"
              },
              {
                "$ref": "#/components/schemas/Event"
              },
              {
                "$ref": "#/components/schemas/FilesMetadata"
              },
              {
                "$ref": "#/components/schemas/GetSequenceDTO"
              }
            ]
          },
          "target": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/Asset"
              },
              {
                "$ref": "#/components/schemas/GetTimeSeriesMetadataDTO"
              },
              {
                "$ref": "#/components/schemas/Event"
              },
              {
                "$ref": "#/components/schemas/FilesMetadata"
              },
              {
                "$ref": "#/components/schemas/GetSequenceDTO"
              }
            ]
          }
        }
      },
      "generalErrorWrapper": {
        "type": "object",
        "required": [
          "error"
        ],
        "description": "Error wrapper Error message",
        "properties": {
          "error": {
            "$ref": "#/components/schemas/generalError"
          }
        }
      },
      "generalError": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code",
            "format": "int32",
            "example": 409
          },
          "message": {
            "type": "string",
            "description": "Error message",
            "example": "Could not authenticate."
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object",
              "additionalProperties": true
            }
          }
        }
      },
      "resourceType": {
        "type": "string",
        "enum": [
          "asset",
          "timeSeries",
          "file",
          "event",
          "sequence"
        ]
      },
      "resourceReferenceWithExternalId": {
        "type": "object",
        "required": [
          "resource",
          "resourceId"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/resourceType"
          },
          "externalId": {
            "$ref": "#/components/schemas/resourceExternalId"
          }
        }
      },
      "confidence": {
        "description": "Confidence value of the existence of the relationship. Generated relationships provide a score of the likelihood of the relationship existing. Relationships without a confidence value can be interpreted at the discretion of each project.",
        "type": "number",
        "format": "float",
        "minimum": 0,
        "maximum": 1
      },
      "dataSetId": {
        "description": "The ID of the dataset the relationship belongs to.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "relationship": {
        "description": "The representation of a relationship consists of a source and a target and additional parameters.",
        "type": "object",
        "required": [
          "externalId",
          "sourceExternalId",
          "sourceType",
          "targetExternalId",
          "targetType"
        ],
        "properties": {
          "externalId": {
            "description": "External ID of the relationship, must be unique within the project.",
            "allOf": [
              {
                "$ref": "#/components/schemas/relationshipExternalId"
              }
            ]
          },
          "sourceExternalId": {
            "$ref": "#/components/schemas/sourceExternalId"
          },
          "sourceType": {
            "$ref": "#/components/schemas/sourceType"
          },
          "targetExternalId": {
            "$ref": "#/components/schemas/targetExternalId"
          },
          "targetType": {
            "$ref": "#/components/schemas/targetType"
          },
          "startTime": {
            "$ref": "#/components/schemas/startTime"
          },
          "endTime": {
            "$ref": "#/components/schemas/endTime"
          },
          "confidence": {
            "$ref": "#/components/schemas/confidence"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/dataSetId"
          },
          "labels": {
            "$ref": "#/components/schemas/LabelList"
          }
        }
      },
      "sourceExternalId": {
        "description": "The external ID of the resource that is the relationship source.",
        "allOf": [
          {
            "$ref": "#/components/schemas/resourceExternalId"
          }
        ]
      },
      "sourceType": {
        "description": "The resource type of the relationship source. Must be one of the specified values.",
        "allOf": [
          {
            "$ref": "#/components/schemas/resourceType"
          }
        ]
      },
      "targetExternalId": {
        "description": "The external ID of the resource that is the relationship target.",
        "allOf": [
          {
            "$ref": "#/components/schemas/relationshipExternalId"
          }
        ]
      },
      "targetType": {
        "description": "The resource type of the relationship target. Must be one of the specified values.",
        "allOf": [
          {
            "$ref": "#/components/schemas/resourceType"
          }
        ]
      },
      "startTime": {
        "description": "The time, in milliseconds since Jan. 1, 1970, when the relationship became active. If there is no startTime, the relationship is active from the beginning of time until endTime.",
        "allOf": [
          {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        ]
      },
      "endTime": {
        "description": "The time, in milliseconds since Jan. 1, 1970, when the relationship became inactive. If there is no endTime, the relationship is active from startTime until the present or any point in the future. If endTime and startTime are set, the endTime must be greater than startTime.",
        "allOf": [
          {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        ]
      },
      "updateSourceType": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/sourceType"
          }
        },
        "description": "Set a new value for the relationship source type."
      },
      "updateSourceExternalId": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/sourceExternalId"
          }
        },
        "description": "Set a new value for the relationship source external ID."
      },
      "updateTargetType": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/targetType"
          }
        },
        "description": "Set a new value for the relationship target type."
      },
      "updateTargetExternalId": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/targetExternalId"
          }
        },
        "description": "Set a new value for the relationship target external ID."
      },
      "updateConfidence": {
        "title": "updateConfidence",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/setConfidence"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the confidence, or remove the value."
      },
      "setConfidence": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/confidence"
          }
        }
      },
      "updateStartTime": {
        "title": "updateStartTime",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/setStartTime"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the start time, or remove the value."
      },
      "setStartTime": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/startTime"
          }
        }
      },
      "updateEndTime": {
        "title": "updateEndTime",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/setEndTime"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ]
      },
      "updateDataSetId": {
        "title": "updateDataSetId",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/setDataSetId"
          },
          {
            "$ref": "#/components/schemas/RemoveField"
          }
        ],
        "description": "Set a new value for the dataSet Ids, or remove the value."
      },
      "setDataSetId": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/dataSetId"
          }
        }
      },
      "setEndTime": {
        "type": "object",
        "title": "set",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/endTime"
          }
        }
      },
      "relationshipUpdateContent": {
        "type": "object",
        "properties": {
          "sourceType": {
            "$ref": "#/components/schemas/updateSourceType"
          },
          "sourceExternalId": {
            "$ref": "#/components/schemas/updateSourceExternalId"
          },
          "targetType": {
            "$ref": "#/components/schemas/updateTargetType"
          },
          "targetExternalId": {
            "$ref": "#/components/schemas/updateTargetExternalId"
          },
          "confidence": {
            "$ref": "#/components/schemas/updateConfidence"
          },
          "startTime": {
            "$ref": "#/components/schemas/updateStartTime"
          },
          "endTime": {
            "$ref": "#/components/schemas/updateEndTime"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/updateDataSetId"
          },
          "labels": {
            "$ref": "#/components/schemas/LabelsPatch"
          }
        }
      },
      "relationshipUpdate": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/relationshipExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/relationshipUpdateContent"
          }
        }
      },
      "byIdsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "$ref": "#/components/schemas/itemsArray"
          },
          "ignoreUnknownIds": {
            "$ref": "#/components/schemas/ignoreUnknownIds"
          },
          "fetchResources": {
            "$ref": "#/components/schemas/fetchResources"
          }
        }
      },
      "deleteRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "$ref": "#/components/schemas/itemsArray"
          },
          "ignoreUnknownIds": {
            "$ref": "#/components/schemas/ignoreUnknownIds"
          }
        }
      },
      "itemsArray": {
        "type": "array",
        "minItems": 1,
        "maxItems": 1000,
        "items": {
          "$ref": "#/components/schemas/externalIdObject"
        }
      },
      "ignoreUnknownIds": {
        "description": "Ignore external IDs that are not found.",
        "type": "boolean",
        "default": false
      },
      "advancedListFilter": {
        "type": "object",
        "description": "Filter on relationships with exact match. Multiple filter elements in one property, for example `sourceExternalIds: [ \"a\", \"b\" ], returns all relationships where the sourceExternalId field is either `a` or `b`. Filters in multiple properties return relationships that match all criteria. If the filter is not specified, it defaults to an empty filter.",
        "properties": {
          "sourceExternalIds": {
            "type": "array",
            "description": "Include relationships that have any of these values in their `sourceExternalId` field",
            "items": {
              "$ref": "#/components/schemas/resourceExternalId"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "sourceTypes": {
            "type": "array",
            "description": "Include relationships that have any of these values in their `sourceType` field",
            "items": {
              "$ref": "#/components/schemas/resourceType"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "targetExternalIds": {
            "type": "array",
            "description": "Include relationships that have any of these values in their `targetExternalId` field",
            "items": {
              "$ref": "#/components/schemas/resourceExternalId"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "targetTypes": {
            "type": "array",
            "description": "Include relationships that have any of these values in their `targetType` field",
            "items": {
              "$ref": "#/components/schemas/resourceType"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "dataSetIds": {
            "type": "array",
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/DataSetIdEither"
            }
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "confidence": {
            "$ref": "#/components/schemas/floatRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "activeAtTime": {
            "description": "Limits results to those active within the specified time range, that is, if there is any overlap in the intervals [`activeAtTime.min`, `activeAtTime.max`] and [`startTime`, `endTime`], where both intervals are inclusive. If a relationship does not have a `startTime`, it is regarded as active from the beginning of time by this filter. If it does not have an `endTime` is is regarded as active until the end of time. Similarly, if a `min` is not supplied to the filter, the `min` is implicitly set to the beginning of time. If a `max` is not supplied, the `max` is implicitly set to the end of time.",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestampRange"
              }
            ]
          },
          "labels": {
            "$ref": "#/components/schemas/LabelFilter"
          },
          "sourcesOrTargets": {
            "type": "array",
            "description": "Include relationships that match any of the resources in either their source- or target-related fields.",
            "items": {
              "$ref": "#/components/schemas/resourceReferenceWithExternalId"
            },
            "minItems": 1,
            "maxItems": 1
          }
        }
      },
      "relationshipsAdvancedListRequest": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/advancedListFilter"
          },
          "limit": {
            "$ref": "#/components/schemas/Limit/properties/limit"
          },
          "cursor": {
            "$ref": "#/components/schemas/Cursor/properties/cursor"
          },
          "fetchResources": {
            "$ref": "#/components/schemas/fetchResources"
          },
          "partition": {
            "$ref": "#/components/schemas/Partition"
          }
        }
      },
      "cursorObject": {
        "type": "object",
        "properties": {
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        }
      },
      "floatRange": {
        "type": "object",
        "description": "Range to filter the field for (inclusive).",
        "properties": {
          "min": {
            "type": "number"
          },
          "max": {
            "type": "number"
          }
        }
      },
      "relationshipRequestWrapper": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/relationship"
            }
          }
        }
      },
      "updateRelationshipWrapper": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/relationshipUpdate"
            }
          }
        }
      },
      "relationshipResponse": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/relationship"
          },
          {
            "$ref": "#/components/schemas/persistedObject"
          }
        ]
      },
      "enrichedRelationshipResponse": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/relationship"
          },
          {
            "$ref": "#/components/schemas/persistedObject"
          },
          {
            "$ref": "#/components/schemas/enrichedRelationship"
          }
        ]
      },
      "relationshipResponseWrapper": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "minItems": 1,
            "maxItems": 1000,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/relationshipResponse"
            }
          }
        }
      },
      "enrichedRelationshipResponseWrapper": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "minItems": 1,
            "maxItems": 1000,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/enrichedRelationshipResponse"
            }
          }
        }
      },
      "pagedRelationshipResponseWrapper": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/relationshipResponseWrapper"
          },
          {
            "$ref": "#/components/schemas/cursorObject"
          }
        ]
      },
      "pagedEnrichedRelationshipResponseWrapper": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/enrichedRelationshipResponseWrapper"
          },
          {
            "$ref": "#/components/schemas/cursorObject"
          }
        ]
      },
      "JobId": {
        "description": "Contextualization job ID.",
        "type": "integer",
        "example": 123,
        "format": "int64"
      },
      "JobStatus": {
        "description": "The status of the job.",
        "type": "string",
        "enum": [
          "Queued",
          "Running",
          "Completed",
          "Failed"
        ]
      },
      "JobToken": {
        "type": "string",
        "description": "A string token that can be attached to the header of a request fetching the job status. Authenticates the user fetching the job status as the same one who originally posted the job."
      },
      "ModelId": {
        "description": "The ID of the model.",
        "type": "integer",
        "example": 456,
        "format": "int64"
      },
      "ErrorMessage": {
        "description": "Error message returned by the model if it fails.",
        "type": "string",
        "example": "Found zero entities, expecting more."
      },
      "ModelName": {
        "type": "string",
        "description": "User defined name.",
        "example": "simple_model_1",
        "maxLength": 256
      },
      "ModelDescription": {
        "type": "string",
        "description": "User defined description.",
        "example": "Simple model 1",
        "maxLength": 500
      },
      "FeatureType": {
        "type": "string",
        "example": "simple",
        "enum": [
          "simple",
          "insensitive",
          "bigram",
          "frequencyweightedbigram",
          "bigramextratokenizers",
          "bigramcombo"
        ],
        "default": "simple",
        "description": "Each feature type defines the combination of features that will be created and used in the entity matcher model."
      },
      "Classifier": {
        "type": "string",
        "description": "The classifier used in the model. Only relevant if there are trueMatches/labeled data and a supervised model is fitted.",
        "example": "randomforest",
        "default": "randomforest",
        "enum": [
          "randomforest",
          "decisiontree",
          "logisticregression",
          "augmentedlogisticregression",
          "augmentedrandomforest"
        ]
      },
      "IgnoreMissingFields": {
        "type": "boolean",
        "default": false,
        "example": true,
        "description": "If True, replaces missing fields in `sources` or `targets` entities, for fields set in set in `matchFields`, with empty strings. Else, returns an error if there are missing data."
      },
      "MatchFields": {
        "type": "array",
        "example": [
          {
            "source": "name",
            "target": "name"
          },
          {
            "source": "name",
            "target": "someField"
          }
        ],
        "default": [
          {
            "source": "name",
            "target": "name"
          }
        ],
        "description": "List of pairs of fields from the target and source items, used to calculate features. All source and target items should have all the `source` and `target` fields specified here.",
        "items": {
          "type": "object",
          "required": [
            "source",
            "target"
          ],
          "properties": {
            "source": {
              "type": "string"
            },
            "target": {
              "type": "string"
            }
          }
        }
      },
      "Sources": {
        "type": "array",
        "minItems": 0,
        "maxItems": 2000000,
        "items": {
          "type": "object",
          "example": {
            "id": 10,
            "name": "a_name",
            "field": "value",
            "ignoredfield": {
              "key": "value"
            }
          }
        },
        "description": "List of custom source object to match from, for example, time series. String key -> value. Only string values are considered in the matching. Both `id` and `externalId` fields are optional, only mandatory if the item is to be referenced in `trueMatches`."
      },
      "Targets": {
        "type": "array",
        "minItems": 1,
        "maxItems": 2000000,
        "items": {
          "type": "object",
          "example": {
            "id": 6,
            "name": "some_name",
            "somefield": "value",
            "ignoredfield": {
              "key": "value"
            }
          }
        },
        "description": "List of custom target object to match to, for example, assets. String key -> value. Only string values are considered in the matching. Both `id` and `externalId` fields are optional, only mandatory if the item is to be referenced in `trueMatches`."
      },
      "OneOfId": {
        "type": "array",
        "example": [
          {
            "id": 2563587950655335
          },
          {
            "externalId": "myUniqueName"
          }
        ],
        "description": "List of ids or externalIds of models.",
        "items": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          ]
        }
      },
      "SourceId": {
        "description": "The id for the from-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "SourceExternalId": {
        "description": "The external id for the source-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        ]
      },
      "TargetId": {
        "description": "The id for the target-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "TargetExternalId": {
        "description": "The external id for the to-object of the match.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        ]
      },
      "Match": {
        "type": "object",
        "description": "A pair of source ID and target ID, that indicates a match between two entities in the source and target spaces.\nInternal and external IDs are supported.",
        "example": {
          "sourceId": 23,
          "targetExternalId": "my.known.id"
        },
        "oneOf": [
          {
            "properties": {
              "sourceId": {
                "$ref": "#/components/schemas/SourceId"
              },
              "targetId": {
                "$ref": "#/components/schemas/TargetId"
              }
            },
            "required": [
              "sourceId",
              "targetId"
            ]
          },
          {
            "properties": {
              "sourceId": {
                "$ref": "#/components/schemas/SourceId"
              },
              "targetExternalId": {
                "$ref": "#/components/schemas/TargetExternalId"
              }
            },
            "required": [
              "sourceId",
              "targetExternalId"
            ]
          },
          {
            "properties": {
              "sourceExternalId": {
                "$ref": "#/components/schemas/SourceExternalId"
              },
              "targetId": {
                "$ref": "#/components/schemas/TargetId"
              }
            },
            "required": [
              "sourceExternalId",
              "targetId"
            ]
          },
          {
            "properties": {
              "sourceExternalId": {
                "$ref": "#/components/schemas/SourceExternalId"
              },
              "targetExternalId": {
                "$ref": "#/components/schemas/TargetExternalId"
              }
            },
            "required": [
              "sourceExternalId",
              "targetExternalId"
            ]
          }
        ]
      },
      "TrueMatches": {
        "type": "array",
        "description": "A list of confirmed source/target matches, which will be used to train the model. If omitted, an unsupervised\nmodel is trained.",
        "minItems": 1,
        "maxItems": 2000000,
        "items": {
          "$ref": "#/components/schemas/Match"
        }
      },
      "EntityMatchingFilterSchema": {
        "type": "object",
        "properties": {
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "classifier": {
            "$ref": "#/components/schemas/Classifier"
          },
          "originalId": {
            "type": "integer",
            "description": "The ID of original model, only relevant when the model is a retrained model.",
            "example": 111
          },
          "name": {
            "$ref": "#/components/schemas/ModelName"
          },
          "description": {
            "$ref": "#/components/schemas/ModelDescription"
          }
        }
      },
      "EntityMatchingFeatureSchema": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ModelName"
          },
          "description": {
            "$ref": "#/components/schemas/ModelDescription"
          },
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "matchFields": {
            "$ref": "#/components/schemas/MatchFields"
          },
          "ignoreMissingFields": {
            "description": "If True, missing fields in `sources` or `targets` entities set in `matchFields`, are replaced with empty strings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/IgnoreMissingFields"
              }
            ]
          },
          "classifier": {
            "description": "Name of the classifier used in the model, \"Unsupervised\" if unsupervised model.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Classifier"
              }
            ]
          },
          "originalId": {
            "type": "integer",
            "description": "The ID of original model, only relevant when the model is a retrained model.",
            "example": 111
          }
        }
      },
      "EntityMatcherResponseSchema": {
        "type": "object",
        "required": [
          "id",
          "externalId",
          "name",
          "description"
        ],
        "allOf": [
          {
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          },
          {
            "$ref": "#/components/schemas/StatusSchema"
          },
          {
            "$ref": "#/components/schemas/EntityMatchingFeatureSchema"
          }
        ]
      },
      "EntityMatchingPredictFeatureSchema": {
        "type": "object",
        "properties": {
          "sources": {
            "description": "List of source entities to predict matches for, for example, time series. If omitted, will use `sources` from create and `assetsAcl:READ` capability will be required for the request.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Sources"
              }
            ]
          },
          "targets": {
            "description": "List of potential target entities to match to one or more of the source entities, for example, assets. If omitted, will use `targets` from create and `assetsAcl:READ` capability will be required for the request.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Targets"
              }
            ]
          },
          "numMatches": {
            "type": "integer",
            "example": 3,
            "minimum": 0,
            "maximum": 100,
            "description": "The maximum number of results to return for each source entity."
          },
          "scoreThreshold": {
            "type": "number",
            "example": 0.7,
            "minimum": 0,
            "maximum": 1,
            "description": "Only return matches with score above this threshold."
          }
        }
      },
      "EntityMatchingPredictSchema": {
        "type": "object",
        "oneOf": [
          {
            "allOf": [
              {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "description": "The ID of the model that is used to predict matches.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/CogniteInternalId"
                      }
                    ]
                  }
                }
              },
              {
                "$ref": "#/components/schemas/EntityMatchingPredictFeatureSchema"
              }
            ]
          },
          {
            "allOf": [
              {
                "type": "object",
                "required": [
                  "externalId"
                ],
                "properties": {
                  "externalId": {
                    "description": "The externalId of the model that is used to predict matches.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/CogniteExternalId"
                      }
                    ]
                  }
                }
              },
              {
                "$ref": "#/components/schemas/EntityMatchingPredictFeatureSchema"
              }
            ]
          }
        ]
      },
      "EntityMatchingRefitFeatureSchema": {
        "type": "object",
        "required": [
          "trueMatches"
        ],
        "properties": {
          "newExternalId": {
            "description": "ExternalId for the new refitted model provided by client. Must be unique within the project.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          },
          "trueMatches": {
            "description": "List of additional confirmed matches used to train the model. The new model uses a combination of this and trueMatches from the orginal model. If there are identical match-from ids, the pair from the original model is dropped.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TrueMatches"
              }
            ]
          },
          "sources": {
            "description": "List of source entities, for example, time series. If omitted, will use data from fit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Sources"
              }
            ]
          },
          "targets": {
            "description": "List of target entities, for example, assets. If omitted, will use data from fit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/Targets"
              }
            ]
          }
        }
      },
      "EntityMatchingRefitSchema": {
        "type": "object",
        "oneOf": [
          {
            "allOf": [
              {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "description": "The ID of the original model.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/CogniteInternalId"
                      }
                    ]
                  }
                }
              },
              {
                "$ref": "#/components/schemas/EntityMatchingRefitFeatureSchema"
              }
            ]
          },
          {
            "allOf": [
              {
                "type": "object",
                "required": [
                  "externalId"
                ],
                "properties": {
                  "externalId": {
                    "description": "The externalId of the original model.",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/CogniteExternalId"
                      }
                    ]
                  }
                }
              },
              {
                "$ref": "#/components/schemas/EntityMatchingRefitFeatureSchema"
              }
            ]
          }
        ]
      },
      "StatusSchema": {
        "type": "object",
        "required": [
          "status",
          "createdTime",
          "startTime",
          "statusTime"
        ],
        "properties": {
          "status": {
            "$ref": "#/components/schemas/JobStatus"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "statusTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "errorMessage": {
            "type": "string",
            "description": "If the job failed, some more information about the error cause.",
            "example": null,
            "default": null
          }
        }
      },
      "SinglePatchRequiredModelName": {
        "title": "Name",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelName"
          }
        },
        "description": "Set a new value for name.",
        "required": [
          "set"
        ]
      },
      "SinglePatchRequiredModelDescription": {
        "title": "Description",
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelDescription"
          }
        },
        "description": "Set a new value for description.",
        "required": [
          "set"
        ]
      },
      "ModelChange": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ModelChangeById"
          },
          {
            "$ref": "#/components/schemas/ModelChangeByExternalId"
          }
        ]
      },
      "ModelChangeById": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ModelPatch"
          },
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            }
          }
        ]
      },
      "ModelChangeByExternalId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ModelPatch"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "ModelPatch": {
        "type": "object",
        "description": "Changes applied to model",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/SinglePatchRequiredModelName"
              },
              "description": {
                "$ref": "#/components/schemas/SinglePatchRequiredModelDescription"
              }
            }
          }
        }
      },
      "DiagramFileId": {
        "type": "integer",
        "example": 1234,
        "description": "The ID of a file in CDF. The file must have mime_type application/pdf, image/jpeg, image/png or image/tiff.",
        "format": "int64"
      },
      "DiagramFileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The external ID of a file in CDF. The file must have mime_type application/pdf, image/jpeg, image/png or image/tiff."
      },
      "DiagramInstanceId": {
        "type": "object",
        "required": [
          "space",
          "externalId"
        ],
        "example": {
          "space": "space",
          "externalId": "externalId"
        },
        "description": "The instance id of a file in CDF. The file must have mime_type application/pdf, image/jpeg, image/png or image/tiff.",
        "properties": {
          "space": {
            "$ref": "#/components/schemas/InstanceSpace"
          },
          "externalId": {
            "$ref": "#/components/schemas/InstanceExternalId"
          }
        }
      },
      "OneOfFileId": {
        "type": "object",
        "required": [
          "fileId",
          "fileExternalId",
          "fileInstanceId"
        ],
        "description": "An object containing file (external/instance) id. The file can have at most 50 pages.",
        "oneOf": [
          {
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/DiagramFileId"
              }
            }
          },
          {
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/DiagramFileExternalId"
              }
            }
          },
          {
            "properties": {
              "fileInstanceId": {
                "$ref": "#/components/schemas/DiagramInstanceId"
              }
            }
          }
        ]
      },
      "PageRange": {
        "type": "object",
        "required": [
          "begin",
          "end"
        ],
        "description": "An inclusive range of up to 50 pages, starting at 1. For example, the first 10 pages are given by begin=1, end=10. Page ranges only apply to PDF files.",
        "properties": {
          "begin": {
            "type": "integer",
            "description": "The first page of the page range.",
            "minimum": 1,
            "example": 51
          },
          "end": {
            "type": "integer",
            "description": "The last page of the page range, must be greater than or equal to begin.",
            "minimum": 1,
            "example": 100
          }
        }
      },
      "FileReferenceWithPageRange": {
        "type": "object",
        "required": [
          "fileId",
          "fileExternalId",
          "fileInstanceId"
        ],
        "description": "Either file id, external id or instance id, and optionally a page range. At most 50 pages can be queried.",
        "oneOf": [
          {
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/DiagramFileId"
              }
            }
          },
          {
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/DiagramFileExternalId"
              }
            }
          },
          {
            "properties": {
              "fileInstanceId": {
                "$ref": "#/components/schemas/DiagramInstanceId"
              }
            }
          }
        ],
        "properties": {
          "pageRange": {
            "$ref": "#/components/schemas/PageRange"
          }
        }
      },
      "AllOfFileId": {
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/DiagramFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/DiagramFileExternalId"
          },
          "fileInstanceId": {
            "$ref": "#/components/schemas/DiagramInstanceId"
          }
        }
      },
      "AllOfFileIdWithPageRange": {
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/DiagramFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/DiagramFileExternalId"
          },
          "fileInstanceId": {
            "$ref": "#/components/schemas/DiagramInstanceId"
          },
          "pageRange": {
            "$ref": "#/components/schemas/PageRange"
          },
          "pageCount": {
            "$ref": "#/components/schemas/PageCount"
          }
        }
      },
      "PageCount": {
        "type": "integer",
        "description": "The total number of pages in the file, returned if page range was provided.",
        "example": 51
      },
      "DiagramDetectEntities": {
        "type": "array",
        "items": {
          "type": "object",
          "maxProperties": 256
        },
        "minItems": 1,
        "maxItems": 500000,
        "example": [
          {
            "userDefinedField": "21PT1017",
            "ignoredField": "AA11"
          },
          {
            "userDefinedField": [
              "21PT1017-A",
              "21PT1017-B"
            ]
          }
        ],
        "description": "A list of entities to look for. For example, all the assets under a root node. The `searchField` determines the strings that identify the entities."
      },
      "DiagramSearchField": {
        "type": "string",
        "example": "userDefinedField",
        "default": "name",
        "description": "This field determines the string to search for and to identify object entities."
      },
      "DiagramPartialMatch": {
        "type": "boolean",
        "description": "Allow partial (fuzzy) matching of entities in the engineering diagrams. Creates a match only when it is possible to do so unambiguously.",
        "default": false
      },
      "DiagramMinTokens": {
        "type": "integer",
        "description": "Each detected item must match the detected entity on at least this number of tokens. A token is a substring of consecutive letters or digits.",
        "default": 2
      },
      "Page": {
        "type": "integer",
        "example": 1,
        "description": "The page of the file where the annotations in `annotations` were detected.",
        "minimum": 1
      },
      "DiagramDetectConfig": {
        "type": "object",
        "properties": {
          "searchField": {
            "$ref": "#/components/schemas/DiagramSearchField"
          },
          "partialMatch": {
            "$ref": "#/components/schemas/DiagramPartialMatch"
          },
          "minTokens": {
            "$ref": "#/components/schemas/DiagramMinTokens"
          }
        }
      },
      "DiagramDetectBetaConfig": {
        "type": "object",
        "description": "Configuration for diagram detect that is only available in beta.",
        "properties": {
          "annotationExtract": {
            "type": "boolean",
            "description": "Read SHX text embedded in the diagram file. If present, this text will override overlapping OCR text. Cannot be used at the same time as read_embedded_text."
          },
          "caseSensitive": {
            "type": "boolean",
            "description": "Case sensitive text matching.",
            "default": true
          },
          "connectionFlags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Connection flags for token graph. Two flags are supported thus far: `no_text_inbetween` and `natural_reading_order`."
          },
          "customizeFuzziness": {
            "$ref": "#/components/schemas/CustomizeFuzziness"
          },
          "directionDelta": {
            "type": "number",
            "format": "float",
            "minimum": 0,
            "maximum": 180,
            "description": "Maximum angle between the direction of two text boxes for them to be connected. Directions are currently multiples of 90 degrees."
          },
          "directionWeights": {
            "$ref": "#/components/schemas/DirectionWeights"
          },
          "minFuzzyScore": {
            "type": "number",
            "description": "For each detection, this controls to which degree characters can be replaced from the OCR text with similar characters, e.g. I and 1. A value of 1 will disable character replacements entirely. See also 'substitutions' for the characters that may be replaced.",
            "default": 0.85,
            "minimum": 0.7,
            "maximum": 1
          },
          "readEmbeddedText": {
            "type": "boolean",
            "description": "Read text embedded in the PDF file. If present, this text will override overlapping OCR text.",
            "default": true
          },
          "removeLeadingZeros": {
            "type": "boolean",
            "description": "Disregard leading zeroes when matching tags (e.g. \"A0001\" will match \"A1\")."
          },
          "substitutions": {
            "type": "object",
            "description": "Override the default mapping of characters to an array of allowed substitute characters. The default mapping contains characters commonly confused by OCR. Provide your custom mapping in the format like so: `{\"0\": [\"O\", \"Q\"], \"1\": [\"l\", \"I\"]}`. This means: `0` (zero) is allowed to be replaced by uppercase letter `O` or `Q`, and `1` (one) is allowed to be replaced by lowercase letter `l` or uppercase letter `I`. No other replacements are allowed.\n\nThe substitutions are performed on the raw OCR text. For example, if we want to match a tag \"T10\" and OCR recognized the text as \"TI0\", mapping `{\"I\": [\"1\"]}` would allow the match. This substitution would happen given the default mapping. On the contrary, if the OCR accuracy is high, you may want to disable such substitutions to reduce false positive matches by overriding the mapping with `{\"I\": [\"I\"]}`.\n\nCurrently the default substitution mapping is as follows (it may be updated without notice):\n```\n{\n    \"0\": [\"C\", \"D\", \"O\"],\n    \"1\": [\"T\", \"I\"],\n    \"3\": [\"B\"],\n    \"6\": [\"G\"],\n    \"8\": [\"B\"],\n    \"\": [\"A\"],\n    \"\": [\"A\"],\n    \"\": [\"A\"],\n    \"B\": [\"8\", \"3\"],\n    \"C\": [\"0\"],\n    \"D\": [\"1)\", \"O\", \"0\"],\n    \"G\": [\"6\"],\n    \"I\": [\"T\", \"1\", \"l\"],\n    \"\": [\"I\", \"T\", \"l\", \"1\"],\n    \"K\": [\"|X\"],\n    \"O\": [\"C\", \"D\", \"0\"],\n    \"Q\": [\"0\", \"O\"],\n    \"T\": [\"1\", \"I\"],\n    \"\": [\"0\"],\n    \"l\": [\"I\"],\n    \"p\": [\"P\", \"0\"],\n    \"v\": [\"V\"],\n    \"\": [\"0\", \"\"],\n    \"?\": [\"2\"],\n    \"\": [\"x\", \"X\"]\n}\n```",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      },
      "DirectionWeights": {
        "type": "object",
        "description": "Direction weights that control how far subsequent ocr text boxes can be from another in a particular direction and still be combined into the same detection. Lower value means larger distance is allowed. The direction is relative to the text orientation.",
        "properties": {
          "left": {
            "type": "number",
            "format": "float",
            "minimum": 0.5,
            "maximum": 3,
            "default": 1
          },
          "right": {
            "type": "number",
            "format": "float",
            "minimum": 0.1,
            "maximum": 3,
            "default": 1
          },
          "up": {
            "type": "number",
            "format": "float",
            "minimum": 0.5,
            "maximum": 3,
            "default": 1
          },
          "down": {
            "type": "number",
            "format": "float",
            "minimum": 0.5,
            "maximum": 3,
            "default": 1
          }
        }
      },
      "CustomizeFuzziness": {
        "type": "object",
        "description": "Additional requirements for the fuzzy matching algorithm. The fuzzy match is allowed if any of these are true for each match candidate. The overall minFuzzyScore still applies, but a stricter fuzzyScore can be set here, which would not be enforced if either the minChars or maxBoxes conditions are met, making it possible to exclude detections using replacements if they are either short, or combined from many boxes.",
        "properties": {
          "minChars": {
            "type": "integer",
            "description": "The minimum number of characters that must be present in the candidate match string."
          },
          "maxBoxes": {
            "type": "integer",
            "description": "Maximum number of text boxes the potential match is composed of."
          },
          "fuzzyScore": {
            "type": "number",
            "format": "float",
            "description": "The minimum fuzzy score of the candidate match.",
            "minimum": 0.7,
            "maximum": 1,
            "default": 1
          }
        }
      },
      "PatternMode": {
        "type": "boolean",
        "description": "Only available in beta. If true, entities are not required to contain the search field. Instead they require a field called 'sample'. The sample field can be string, or list of alternative strings. Each string defines a pattern. E.g. 21-PT-1019 enables detecting tags consisting of 2 digits, 2 letters and 4 digits. Special characters are not necessary for detecting, but will be included in the detected string. It is possible to mark parts of the sample as constant strings by enclosing them in square brackets. Within square brackets, a | character can be used to separate alternative constants. Alternative constants must be either all digits or all letters. If false, regular diagram detect is performed, searching for occurrences of the search strings of the entities."
      },
      "DiagramConvertConfig": {
        "type": "object",
        "properties": {
          "grayscale": {
            "$ref": "#/components/schemas/Grayscale"
          }
        }
      },
      "Grayscale": {
        "type": "boolean",
        "example": true,
        "default": true,
        "description": "Return the SVG version in grayscale colors only (reduces the file size)."
      },
      "NewAnnotation": {
        "type": "object",
        "required": [
          "text",
          "region"
        ],
        "properties": {
          "text": {
            "description": "The text and entities detected by the service.",
            "type": "string",
            "example": "21-PT-1019"
          },
          "confidence": {
            "type": "number",
            "description": "The confidence for the detection.",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "region": {
            "required": [
              "shape",
              "vertices",
              "page"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/DiagramRegion"
              },
              {
                "properties": {
                  "page": {
                    "$ref": "#/components/schemas/Page"
                  }
                }
              }
            ]
          }
        }
      },
      "DiagramDetectedEntities": {
        "type": "array",
        "example": [
          {
            "userDefinedField": "21PT1017",
            "ignoredField": "AA11"
          },
          {
            "userDefinedField": [
              "21PT1017-A",
              "21PT1017-B"
            ]
          }
        ],
        "description": "A list of entities detected per annotation.",
        "items": {
          "type": "object"
        },
        "minItems": 1,
        "maxItems": 5
      },
      "DiagramAnnotation": {
        "description": "Annotation representing a detected entity.",
        "allOf": [
          {
            "$ref": "#/components/schemas/NewAnnotation"
          },
          {
            "type": "object",
            "properties": {
              "entities": {
                "$ref": "#/components/schemas/DiagramDetectedEntities"
              }
            }
          }
        ]
      },
      "DiagramDetectResultSchema": {
        "description": "An array of detected results, returned when the job finished or failed partially.",
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "annotations": {
                      "type": "array",
                      "description": "Annotations of entities detected by the service",
                      "items": {
                        "$ref": "#/components/schemas/DiagramAnnotation"
                      }
                    }
                  }
                }
              ],
              "required": [
                "annotations"
              ]
            },
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileIdWithPageRange"
                },
                {
                  "properties": {
                    "errorMessage": {
                      "type": "string",
                      "description": "Error message for the file."
                    }
                  }
                }
              ],
              "required": [
                "errorMessage"
              ]
            }
          ]
        }
      },
      "DiagramSvgPngResultSchema": {
        "type": "object",
        "oneOf": [
          {
            "properties": {
              "page": {
                "$ref": "#/components/schemas/Page"
              },
              "svgUrl": {
                "type": "string",
                "example": "https://storage.googleapis.com/cluster/1234/PH-ME-P-0004-001.svg",
                "description": "A signed URL to an interactive SVG version of the engineering diagram (valid for 10 minutes)."
              },
              "pngUrl": {
                "type": "string",
                "example": "https://storage.googleapis.com/cluster/1234/PH-ME-P-0004-001.png",
                "description": "A signed URL to a PNG version of the engineering diagram (valid for 10 minutes)."
              }
            },
            "required": [
              "page",
              "svgUrl",
              "pngUrl"
            ]
          },
          {
            "properties": {
              "page": {
                "$ref": "#/components/schemas/Page"
              },
              "errorMessage": {
                "type": "string",
                "description": "The error message for the page and file."
              }
            },
            "required": [
              "page",
              "errorMessage"
            ]
          }
        ]
      },
      "DiagramConvertResultSchema": {
        "description": "An array of converted results, returned when the job finished or failed partially.",
        "type": "array",
        "items": {
          "type": "object",
          "oneOf": [
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/DiagramSvgPngResultSchema"
                      },
                      "maxItems": 50
                    }
                  }
                }
              ],
              "required": [
                "results"
              ]
            },
            {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AllOfFileId"
                },
                {
                  "properties": {
                    "errorMessage": {
                      "type": "string",
                      "description": "The error message for a file."
                    }
                  }
                }
              ],
              "required": [
                "errorMessage"
              ]
            }
          ]
        }
      },
      "DiagramConvertRequestSchema": {
        "description": "An array of files and annotations to create interactive diagrams.",
        "type": "array",
        "maxItems": 50,
        "minItems": 1,
        "items": {
          "type": "object",
          "required": [
            "annotations"
          ],
          "allOf": [
            {
              "$ref": "#/components/schemas/OneOfFileId"
            },
            {
              "properties": {
                "annotations": {
                  "description": "Annotations to draw on the engineering diagrams",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DiagramAnnotation"
                  },
                  "maxItems": 1000
                }
              }
            }
          ]
        }
      },
      "Vertex": {
        "type": "object",
        "description": "A vertex represents a 2D point in the image. The vertex coordinates are normalized.",
        "example": {
          "x": 0.58,
          "y": 0.12
        },
        "required": [
          "x",
          "y"
        ],
        "properties": {
          "x": {
            "type": "number",
            "description": "Normalized x coordinate.",
            "minimum": 0,
            "maximum": 1
          },
          "y": {
            "type": "number",
            "description": "Normalized y coordinate.",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "DiagramRegion": {
        "description": "Shape and coordinates of the detected entity in the image.",
        "type": "object",
        "required": [
          "shape",
          "vertices"
        ],
        "properties": {
          "shape": {
            "type": "string",
            "description": "The geometrical shape of the image region to which a detected entity belongs.",
            "enum": [
              "rectangle"
            ]
          },
          "vertices": {
            "type": "array",
            "description": "List of vertices representing the image region to which a detected entity belongs.",
            "items": {
              "$ref": "#/components/schemas/Vertex"
            },
            "minItems": 4,
            "maxItems": 4
          }
        }
      },
      "BatchJobStatus": {
        "description": "The status of the job.",
        "type": "string",
        "enum": [
          "Queued",
          "Distributing",
          "Running",
          "Collecting",
          "Completed",
          "Failed",
          "Timeout"
        ]
      },
      "DiagramOcrRequestSchema": {
        "description": "File id and page range to get ocr result for.",
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "fileId": {
            "type": "integer",
            "example": 123456789,
            "description": "File id to get ocr results for."
          },
          "startPage": {
            "description": "The first page in the range to get ocr results from.",
            "type": "integer",
            "example": 1,
            "default": 1,
            "minimum": 1
          },
          "limit": {
            "description": "The maximum number of pages to get results for. With a limit of 10 and start page of 1, results for pages 1-10 are returned if they are available.",
            "type": "integer",
            "example": 10,
            "default": 100,
            "minimum": 1,
            "maximum": 100
          }
        }
      },
      "DiagramOcrResponseSchema": {
        "description": "A list of ocr results by page for a single file.",
        "items": {
          "$ref": "#/components/schemas/DiagramOcrPageSchema"
        }
      },
      "DiagramOcrPageSchema": {
        "description": "Contains OCR data for a single page.",
        "properties": {
          "height": {
            "type": "number",
            "description": "The height of the page in pixels."
          },
          "width": {
            "type": "number",
            "description": "The width of the page in pixels."
          },
          "annotations": {
            "description": "Annotations representing detected text with location.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DiagramOcrAnnotationSchema"
            }
          },
          "page": {
            "description": "The page number of the page.",
            "type": "integer"
          },
          "updatedTimestamp": {
            "type": "integer",
            "description": "The time in milliseconds since epoch when the ocr result was last updated."
          }
        }
      },
      "DiagramOcrAnnotationSchema": {
        "description": "An annotation describing a detected text string with location.",
        "properties": {
          "text": {
            "description": "Detected text.",
            "type": "string"
          },
          "boundingBox": {
            "type": "object",
            "$ref": "#/components/schemas/DiagramOcrBoundingBoxSchema"
          },
          "confidence": {
            "$ref": "#/components/schemas/UnitIntervalNumber",
            "description": "A number indicating the confidence in the detected text as determined by the ocr provider."
          },
          "direction": {
            "type": "number",
            "description": "The angle of the text direction. 0 means horizontal left to right, 90 means vertical downwards.",
            "minimum": 0,
            "maximum": 360
          }
        }
      },
      "DiagramOcrBoundingBoxSchema": {
        "description": "A normalized bounding box describing a rectangular region aligned with the x-y-axes.",
        "properties": {
          "xMin": {
            "$ref": "#/components/schemas/UnitIntervalNumber",
            "description": "The lowest value of x within the box."
          },
          "yMin": {
            "$ref": "#/components/schemas/UnitIntervalNumber",
            "description": "The lowest value of y within the box."
          },
          "xMax": {
            "$ref": "#/components/schemas/UnitIntervalNumber",
            "description": "The highest value of x within the box."
          },
          "yMax": {
            "$ref": "#/components/schemas/UnitIntervalNumber",
            "description": "The highest value of y within the box."
          }
        }
      },
      "UnitIntervalNumber": {
        "description": "A number in the range [0, 1].",
        "type": "number",
        "minimum": 0,
        "maximum": 1
      },
      "PipelineCreateItem": {
        "type": "object",
        "description": "Pipeline to create",
        "required": [
          "sources",
          "targets"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "$ref": "#/components/schemas/PipelineName"
          },
          "description": {
            "$ref": "#/components/schemas/PipelineDescription"
          },
          "modelParameters": {
            "$ref": "#/components/schemas/ModelParameters"
          },
          "sources": {
            "$ref": "#/components/schemas/PipelineSources"
          },
          "targets": {
            "$ref": "#/components/schemas/PipelineTargets"
          },
          "trueMatches": {
            "$ref": "#/components/schemas/TrueMatches"
          },
          "confirmedMatches": {
            "$ref": "#/components/schemas/ConfirmedMatches"
          },
          "rejectedMatches": {
            "$ref": "#/components/schemas/RejectedMatches"
          },
          "useExistingMatches": {
            "$ref": "#/components/schemas/PipelineUseExistingMatches"
          },
          "generateRules": {
            "$ref": "#/components/schemas/GenerateRules"
          },
          "replacements": {
            "$ref": "#/components/schemas/PipelineReplacements"
          },
          "rules": {
            "$ref": "#/components/schemas/MatchRules"
          },
          "rejectedRules": {
            "$ref": "#/components/schemas/MatchRules"
          },
          "scoreThreshold": {
            "$ref": "#/components/schemas/PipelineScoreThreshold"
          },
          "scheduleInterval": {
            "$ref": "#/components/schemas/ScheduleInterval"
          }
        }
      },
      "PipelineCreatedItem": {
        "type": "object",
        "allOf": [
          {
            "type": "object",
            "required": [
              "id",
              "createdTime"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/CogniteInternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "owner": {
                "type": "string",
                "description": "Owner of the pipeline. This is only provided in case the pipeline was created in the Fusion front-end.",
                "example": "alice@example.com"
              }
            }
          },
          {
            "$ref": "#/components/schemas/PipelineCreateItem"
          }
        ]
      },
      "PipelineUpdatedItem": {
        "$ref": "#/components/schemas/PipelineCreatedItem"
      },
      "PipelineResponseItem": {
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/PipelineCreatedItem"
          },
          {
            "type": "object",
            "properties": {
              "lastRun": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineRunItem"
                  },
                  {
                    "type": "object",
                    "description": "The latest run for this pipeline, if it was ever run.",
                    "nullable": true
                  }
                ]
              }
            }
          }
        ]
      },
      "PipelineUpdateItem": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdEither"
          }
        ],
        "type": "object",
        "description": "Update patch for a pipeline",
        "required": [
          "update"
        ],
        "properties": {
          "update": {
            "$ref": "#/components/schemas/PipelineUpdateData"
          }
        }
      },
      "PipelineUpdateData": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/PatchPipelineName"
          },
          "description": {
            "$ref": "#/components/schemas/PatchPipelineDescription"
          },
          "modelParameters": {
            "$ref": "#/components/schemas/PatchModelParameters"
          },
          "sources": {
            "$ref": "#/components/schemas/PatchPipelineSources"
          },
          "targets": {
            "$ref": "#/components/schemas/PatchPipelineTargets"
          },
          "trueMatches": {
            "$ref": "#/components/schemas/PatchTrueMatches"
          },
          "rejectedMatches": {
            "$ref": "#/components/schemas/PatchRejectedMatches"
          },
          "confirmedMatches": {
            "$ref": "#/components/schemas/PatchConfirmedMatches"
          },
          "useExistingMatches": {
            "$ref": "#/components/schemas/SinglePatchBoolean"
          },
          "generateRules": {
            "$ref": "#/components/schemas/SinglePatchBoolean"
          },
          "replacements": {
            "$ref": "#/components/schemas/PatchPipelineReplacements"
          },
          "rules": {
            "allOf": [
              {
                "description": "Set a new value for rules."
              },
              {
                "$ref": "#/components/schemas/PatchMatchRules"
              }
            ]
          },
          "rejectedRules": {
            "allOf": [
              {
                "description": "Set a new value for rejected rules."
              },
              {
                "$ref": "#/components/schemas/PatchMatchRules"
              }
            ]
          },
          "scoreThreshold": {
            "$ref": "#/components/schemas/PatchPipelineScoreThreshold"
          },
          "scheduleInterval": {
            "$ref": "#/components/schemas/ModifyPatchInteger"
          }
        }
      },
      "PipelineRunItem": {
        "allOf": [
          {
            "$ref": "#/components/schemas/StatusSchema"
          },
          {
            "type": "object",
            "required": [
              "pipelineId",
              "jobId"
            ],
            "properties": {
              "jobId": {
                "$ref": "#/components/schemas/JobId"
              }
            }
          }
        ]
      },
      "PipelineRunItemWithResults": {
        "allOf": [
          {
            "$ref": "#/components/schemas/PipelineRunItem"
          },
          {
            "type": "object",
            "properties": {
              "matches": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/PipelineMatch"
                }
              },
              "suggestedRules": {
                "type": "array",
                "description": "Suggested rules based on matches",
                "items": {
                  "$ref": "#/components/schemas/SuggestedRule"
                }
              },
              "generatedRules": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/GeneratedRule"
                }
              },
              "errors": {
                "type": "array",
                "description": "Errors that occurred during the pipeline run, if any.",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        ]
      },
      "PipelineName": {
        "type": "string",
        "description": "User-defined name of the pipeline.",
        "example": "myPipeline",
        "maxLength": 256
      },
      "PatchPipelineName": {
        "type": "object",
        "description": "Set a new value for name.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineName"
          }
        }
      },
      "PipelineDescription": {
        "type": "string",
        "description": "User-defined description of the pipeline.",
        "example": "My pipeline",
        "maxLength": 500
      },
      "PatchPipelineDescription": {
        "type": "object",
        "description": "Set a new value for description.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineDescription"
          }
        }
      },
      "PipelineScoreThreshold": {
        "type": "number",
        "example": 0.7,
        "minimum": 0,
        "maximum": 1,
        "default": 0,
        "description": "Only return model matches with score above this threshold."
      },
      "PatchPipelineScoreThreshold": {
        "type": "object",
        "description": "Set a new value for score threshold.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineScoreThreshold"
          }
        }
      },
      "ScheduleInterval": {
        "type": "integer",
        "example": 7200,
        "minimum": 3600,
        "maximum": 2678400,
        "description": "How often to schedule the pipeline, in seconds. The interval can be between 1 hour and 31 days."
      },
      "PipelineReplacements": {
        "type": "array",
        "description": "Replace strings in entity fields. You can use this field to add input naming variations to the entity matching\nmodel to improve the suggested matches, for example, 'pmp' for 'pump' and 'bhp' for 'bottom hole pressure'.\nTo avoid false positives, we recommend using the longer string as `string` and the shorter as `replacement`.",
        "items": {
          "type": "object",
          "required": [
            "field",
            "string",
            "replacement"
          ],
          "properties": {
            "field": {
              "type": "string",
              "description": "Which field to replace in. Can be '*' to affect all fields in both source and targets.",
              "example": "*"
            },
            "string": {
              "type": "string",
              "description": "String to search for and replace in both sources and targets.",
              "example": "Bottom-hole pressure"
            },
            "replacement": {
              "type": "string",
              "description": "Replacement for the string.",
              "example": "bhp"
            }
          },
          "minItems": 1,
          "maxItems": 1000
        }
      },
      "PatchPipelineReplacements": {
        "type": "object",
        "description": "Set a new value for replacements.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineReplacements"
          }
        }
      },
      "PipelineUseExistingMatches": {
        "type": "boolean",
        "default": false,
        "nullable": true,
        "description": "Use existing (id/assetId) links on the CDF resources as training data when the entity matching model is created."
      },
      "GenerateRules": {
        "type": "boolean",
        "default": true,
        "nullable": true,
        "description": "Whether to generate match rules automatically"
      },
      "PipelineSources": {
        "type": "object",
        "description": "Source of the pipeline",
        "oneOf": [
          {
            "properties": {
              "dataSetIds": {
                "type": "array",
                "description": "List of data set internal or external IDs.",
                "items": {
                  "$ref": "#/components/schemas/IdEither"
                }
              },
              "resource": {
                "default": "time_series",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "properties": {
              "assetSubtreeIds": {
                "type": "array",
                "description": "List of asset subtree internal or external IDs.",
                "items": {
                  "$ref": "#/components/schemas/IdEither"
                }
              },
              "resource": {
                "default": "time_series",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "properties": {
              "entities": {
                "type": "array",
                "items": {
                  "type": "object",
                  "example": {
                    "id": 10,
                    "name": "a_name",
                    "field": "value",
                    "ignoredfield": {
                      "key": "value"
                    }
                  }
                },
                "description": "List of custom source object to match from, for example, time series. String key -> value. Optional id and/or externalId fields."
              }
            }
          }
        ]
      },
      "PatchPipelineSources": {
        "type": "object",
        "description": "Set a new value for sources.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineSources"
          }
        }
      },
      "PipelineTargets": {
        "type": "object",
        "description": "Targets for the pipeline",
        "oneOf": [
          {
            "description": "Target a dataset",
            "properties": {
              "dataSetIds": {
                "type": "array",
                "description": "List of id or externalId for datasets to use.",
                "items": {
                  "$ref": "#/components/schemas/IdEither"
                }
              },
              "resource": {
                "default": "assets",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "description": "Target asset subtrees",
            "properties": {
              "assetSubtreeIds": {
                "type": "array",
                "description": "List of id or externalId for asset subtrees to use.",
                "items": {
                  "$ref": "#/components/schemas/IdEither"
                }
              },
              "resource": {
                "default": "assets",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/PipelineResourceType"
                  }
                ]
              }
            }
          },
          {
            "description": "Custom target",
            "properties": {
              "entities": {
                "type": "array",
                "items": {
                  "type": "object",
                  "example": {
                    "id": 10,
                    "name": "a_name",
                    "field": "value",
                    "ignoredfield": {
                      "key": "value"
                    }
                  }
                },
                "description": "List of custom target object to match to, for example, assets. String key -> value. Optional id and/or externalId fields."
              }
            }
          }
        ]
      },
      "PatchPipelineTargets": {
        "type": "object",
        "description": "Set a new value for targets.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/PipelineTargets"
          }
        }
      },
      "PipelineResourceType": {
        "type": "string",
        "description": "CDF resource type.",
        "example": "assets",
        "enum": [
          "assets",
          "time_series",
          "events",
          "files",
          "sequences"
        ]
      },
      "PatchTrueMatches": {
        "type": "object",
        "description": "Set a new value for true matches.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/TrueMatches"
          }
        }
      },
      "ConfirmedMatches": {
        "type": "array",
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a confirmed match by the user. A source and target pair in this list will override results from a model or rules and will therefore always be returned as a match. The matches are also used as training data when the entity matcher model is created.",
        "items": {
          "$ref": "#/components/schemas/Match"
        }
      },
      "PatchConfirmedMatches": {
        "type": "object",
        "description": "Set a new value for confirmed matches.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ConfirmedMatches"
          }
        }
      },
      "RejectedMatches": {
        "type": "array",
        "description": "List of objects of pairs of sourceId or sourceExternalId and targetId or targetExternalId, that corresponds to entities in source and target respectively, that indicates a match rejected by the user. A source and target pair in this list will override results from a model or rules and will never be returned as a match.",
        "items": {
          "$ref": "#/components/schemas/Match"
        }
      },
      "PatchRejectedMatches": {
        "type": "object",
        "description": "Set a new value for rejected matches.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/RejectedMatches"
          }
        }
      },
      "ModelParameters": {
        "type": "object",
        "example": {
          "featureType": "bigram"
        },
        "description": "The parameters to use in the entity matching model.",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "type": "string",
            "maxLength": 256,
            "nullable": true
          },
          "description": {
            "type": "string",
            "maxLength": 512,
            "nullable": true
          },
          "featureType": {
            "$ref": "#/components/schemas/FeatureType"
          },
          "classifier": {
            "$ref": "#/components/schemas/Classifier"
          },
          "matchFields": {
            "$ref": "#/components/schemas/MatchFields"
          }
        }
      },
      "PatchModelParameters": {
        "type": "object",
        "description": "Set a new value for modelParameters.",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ModelParameters"
          }
        }
      },
      "MatchRule": {
        "type": "object",
        "description": "An entity matching rule matches source entities with target entities based on a pattern defined by the rule.\nA rule has extractors that both require entities to follow a certain format, and produce lists of features.\n\nFor a regex extractor, a specific field must match a pattern, and parts of the pattern become the features.\nThe conditions of a rule express which extracted features must be equal for two entities to match.\n\nSince extractors restrict the scopes of rules to entities that conform with patterns, two rules will often not\nhave entities in common that they apply to. But if they do, the more specific rule is given higher priority.\n\nIf one rule is not a special case of the other, they may be inconsistent (conflict) or redundant (overlap).",
        "required": [
          "extractors",
          "conditions"
        ],
        "properties": {
          "extractors": {
            "type": "array",
            "description": "An extractor produces a list of features based on a source entity or a target entity. In particular a regex extractor defines which entities (e.g. sources) it acts on, a field (e.g. name) and a regular expression. The extractor will only produce features if the field of an entity matches the pattern. The returned features are then substrings of the field as defined in the pattern. Entities in the relevant set that do not match the pattern will not be matched by the rule, but may be matched by other rules.",
            "items": {
              "$ref": "#/components/schemas/RegexExtractor"
            }
          },
          "conditions": {
            "type": "array",
            "description": "List of conditions that must be met for the rule to link two entities. The conditions refer to features extracted by the extractors. A condition of type \"equals\" that refers to features extracted from a source entity and a target entity requires these features to be equal for the entities to match.",
            "items": {
              "$ref": "#/components/schemas/MatchCondition"
            }
          },
          "priority": {
            "type": "number",
            "format": "int64",
            "minimum": 0,
            "default": 0,
            "description": "In case different rules provide matches for the same source entities, only the highest priority rules are applied to these entities."
          }
        },
        "example": {
          "extractors": [
            {
              "entitySet": "sources",
              "extractorType": "regex",
              "field": "species",
              "pattern": "(.*)"
            },
            {
              "entitySet": "targets",
              "extractorType": "regex",
              "field": "species",
              "pattern": "(.*)"
            }
          ],
          "conditions": [
            {
              "conditionType": "equals",
              "arguments": [
                [
                  0,
                  0
                ],
                [
                  1,
                  0
                ]
              ]
            }
          ],
          "priority": 10
        }
      },
      "MatchRules": {
        "type": "array",
        "description": "A collection of match rules",
        "minItems": 0,
        "maxItems": 1000,
        "default": [],
        "items": {
          "$ref": "#/components/schemas/MatchRule"
        }
      },
      "PatchMatchRules": {
        "type": "object",
        "required": [
          "set"
        ],
        "properties": {
          "set": {
            "$ref": "#/components/schemas/MatchRules"
          }
        }
      },
      "RegexExtractor": {
        "type": "object",
        "required": [
          "entitySet",
          "extractorType",
          "field",
          "pattern"
        ],
        "description": "An extractor that acts on entities from 'entitySet'. An entity must have a value of 'field' that matches the regular expression 'pattern' to get features. The features are the catching groups of the pattern, that is the parts that are in parenthesis. E.g. ([A-Z])-00([0-9]) applied to A-007 produces [A, 7] as features.",
        "properties": {
          "entitySet": {
            "type": "string",
            "description": "Which set of entities the extractor will extract features from.",
            "enum": [
              "sources",
              "targets"
            ]
          },
          "extractorType": {
            "type": "string",
            "description": "The type of extractor. Currently,  we only support \"regex\".",
            "enum": [
              "regex"
            ]
          },
          "field": {
            "type": "string",
            "description": "The entity field that the extractor will get features from."
          },
          "pattern": {
            "type": "string",
            "description": "A regular expression without nested catching groups."
          }
        }
      },
      "MatchCondition": {
        "type": "object",
        "required": [
          "conditionType",
          "arguments"
        ],
        "properties": {
          "conditionType": {
            "type": "string",
            "description": "The type of condition. Currently, we only support the 'equals' condition. It requires all features referenced by its arguments to be equal.",
            "enum": [
              "equals"
            ]
          },
          "arguments": {
            "type": "array",
            "description": "References to features. Each argument is a list with two zero indexed indices. E.g. [0, 1] refers to the 1th (second) feature produced by the 0th (first) extractor of the rule.",
            "items": {
              "type": "array",
              "items": {
                "type": "number",
                "format": "int64",
                "minimum": 0
              }
            }
          },
          "config": {
            "$ref": "#/components/schemas/MatchConditionConfig"
          }
        }
      },
      "MatchConditionConfig": {
        "type": "object",
        "description": "Configuration of the condition not captured in its arguments and type.",
        "properties": {
          "synonyms": {
            "type": "array",
            "description": "Entries describing tokens that are equivalent.",
            "items": {
              "$ref": "#/components/schemas/SynonymEntry"
            },
            "example": [
              {
                "sources": [
                  "odour"
                ],
                "targets": [
                  "odor"
                ]
              },
              {
                "sources": [
                  "petrol"
                ],
                "targets": [
                  "gas",
                  "gasoline"
                ]
              }
            ]
          }
        }
      },
      "SynonymEntry": {
        "type": "object",
        "description": "List of sources and targets words that all mean the same.",
        "properties": {
          "sources": {
            "type": "array",
            "description": "List of tokens that have the same meaning when appearing in a source entity.",
            "items": {
              "type": "string"
            }
          },
          "targets": {
            "type": "array",
            "description": "List of tokens that have the same meaning when appearing in a target entity.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "PipelineMatch": {
        "type": "object",
        "description": "A match between a source and a target",
        "properties": {
          "matchType": {
            "type": "string",
            "enum": [
              "previously_mapped",
              "model",
              "rule_rule_input_pattern->rule_predict_pattern"
            ],
            "example": "model"
          },
          "score": {
            "type": "number",
            "description": "A confidence score output by the pipeline",
            "minimum": 0,
            "maximum": 1,
            "example": 0.98
          },
          "source": {
            "type": "object",
            "description": "The source item",
            "example": {
              "field": "value",
              "ignoredField": {
                "key": "value"
              }
            }
          },
          "target": {
            "type": "object",
            "description": "The target item",
            "example": {
              "field": "value",
              "ignoredField": {
                "key": "value"
              }
            }
          }
        }
      },
      "SuggestedRule": {
        "type": "object",
        "properties": {
          "matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RuleMatch"
            }
          },
          "inputPattern": {
            "type": "string"
          },
          "predictPattern": {
            "type": "string"
          },
          "numMatches": {
            "type": "integer",
            "description": "The number of matches belonging to the rule",
            "example": 14
          },
          "avgScore": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "example": 0.73
          },
          "matchIndex": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "example": [
              1,
              7
            ]
          }
        }
      },
      "RuleMatch": {
        "type": "object",
        "properties": {
          "sourceKeyField": {
            "type": "string"
          },
          "targetKeyField": {
            "type": "string"
          },
          "source": {
            "type": "object"
          },
          "target": {
            "type": "object"
          },
          "existingMatchType": {
            "type": "string"
          },
          "consistentMatch": {
            "type": "boolean"
          }
        }
      },
      "GeneratedRule": {
        "type": "object",
        "description": "An entity matching rule matches source entities with target entities based on a pattern defined by the rule.\nA rule has extractors that both require entities to follow a certain format, and produce lists of features.\n\nFor a regex extractor, a specific field must match a pattern, and parts of the pattern become the features.\nThe conditions of a rule express which extracted features must be equal for two entities to match.\n\nSince extractors restrict the scopes of rules to entities that conform with patterns, two rules will often not\nhave entities in common that they apply to. But if they do, the more specific rule is given higher priority.\n\nIf one rule is not a special case of the other, they may be inconsistent (conflict) or redundant (overlap).",
        "properties": {
          "matches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RuleMatch"
            }
          },
          "numConflicts": {
            "type": "integer",
            "example": 3
          },
          "numOverlaps": {
            "type": "integer",
            "example": 1
          }
        }
      },
      "NextPageCursor": {
        "type": "string",
        "nullable": true,
        "description": "A cursor to get the next page of results (if available).\nIf you want the next page of results, call the endpoint with the same parameters, and set `cursor`\nto this value.",
        "example": {
          "$ref": "#/components/parameters/Cursor/schema/example"
        }
      },
      "ConnectionDto": {
        "description": "Connection between two entities in a diagram. The connected entities can either be in the same or different diagrams.",
        "type": "object",
        "required": [
          "createdTime",
          "diagramId",
          "endNodeId",
          "externalId",
          "isUserDetected",
          "lastUpdatedTime",
          "startNodeId"
        ],
        "properties": {
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "diagramId": {
            "description": "The external ID of a diagram the connection belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "endNodeId": {
            "description": "The external ID of a diagram entity with a connection to the other diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "externalId": {
            "description": "The external ID of the connection",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "isUserDetected": {
            "description": "Checks whether the connection was detected by a user or not. Returns a boolean value.",
            "type": "boolean"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "startNodeId": {
            "description": "The external ID of a diagram entity with a connection to the other diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "CreateConnectionsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of connections to create",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/ConnectionCreateDraft"
            }
          }
        }
      },
      "ConnectionCreateDraft": {
        "type": "object",
        "required": [
          "diagramId",
          "endNodeId",
          "isUserDetected",
          "startNodeId"
        ],
        "properties": {
          "diagramId": {
            "description": "The external ID of a diagram the connection belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "endNodeId": {
            "description": "External ID of a diagram entity to connect to another diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "isUserDetected": {
            "description": "Whether or not the connection was created by a user",
            "type": "boolean"
          },
          "startNodeId": {
            "description": "The external ID of a diagram entity to connect to another diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "DiagramDto": {
        "type": "object",
        "required": [
          "createdTime",
          "externalId",
          "fileId",
          "lastUpdatedTime",
          "libraryId",
          "pageNumber",
          "status"
        ],
        "properties": {
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "externalId": {
            "description": "The external ID of the diagram",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "fileId": {
            "description": "DMS identifier of a file the diagram is parsed from",
            "$ref": "#/components/schemas/DmsId"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "libraryId": {
            "description": "The external ID of a library the diagram is parsed with",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "message": {
            "description": "Message containing errors or other information",
            "type": "string"
          },
          "pageNumber": {
            "description": "The page number of a file the diagram is parsed from",
            "type": "integer"
          },
          "status": {
            "description": "Parsing status of a diagram",
            "$ref": "#/components/schemas/ParseStatus"
          }
        }
      },
      "DiagramFilters": {
        "type": "array",
        "description": "List of filters used to filter diagrams",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/DiagramFilter"
        }
      },
      "DiagramFilter": {
        "type": "object",
        "description": "List of properties used to filter diagrams",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "fileId": {
            "description": "DMS identifier of a file the diagram is parsed from",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DmsId"
            }
          },
          "libraryId": {
            "description": "The external ID of the library the diagram is parsed with",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CogniteExternalId"
            }
          },
          "pageNumber": {
            "description": "The page number of a file the diagram is parsed from",
            "type": "array",
            "items": {
              "type": "integer"
            }
          },
          "status": {
            "description": "Parsing status of a diagram",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ParseStatus"
            }
          }
        }
      },
      "ExtendedDiagramDto": {
        "description": "Diagram with all of its entities and connections joined",
        "type": "object",
        "required": [
          "connections",
          "createdTime",
          "entities",
          "externalId",
          "fileId",
          "lastUpdatedTime",
          "libraryId",
          "pageNumber",
          "status"
        ],
        "properties": {
          "connections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectionDto"
            }
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "entities": {
            "description": "List of entities of this diagram",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityDto"
            }
          },
          "externalId": {
            "description": "The external ID of the diagram",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "fileId": {
            "description": "ID of a file the diagram is parsed from",
            "$ref": "#/components/schemas/DmsId"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "libraryId": {
            "description": "The external ID of a library the diagram is parsed with",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "pageNumber": {
            "description": "The page number of a file the diagram is parsed from",
            "type": "integer"
          },
          "message": {
            "description": "Message containing errors or other information for a diagram",
            "type": "string"
          },
          "status": {
            "description": "Parsing status of a diagram",
            "$ref": "#/components/schemas/ParseStatus"
          }
        }
      },
      "ExtendedDiagramWithPathsDto": {
        "description": "Diagram with its entities, connections, and SVG paths data",
        "type": "object",
        "required": [
          "connections",
          "createdTime",
          "entities",
          "externalId",
          "fileId",
          "height",
          "lastUpdatedTime",
          "libraryId",
          "pageNumber",
          "status",
          "viewBox",
          "width"
        ],
        "properties": {
          "connections": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectionDto"
            }
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EntityWithPathsDto"
            }
          },
          "externalId": {
            "description": "The external ID of the diagram",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "fileId": {
            "description": "ID of a file the diagram is parsed from",
            "$ref": "#/components/schemas/DmsId"
          },
          "height": {
            "description": "Height attribute of the SVG diagram",
            "type": "string"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "libraryId": {
            "description": "The external ID of a library the diagram is parsed with",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "message": {
            "description": "Message containing errors or other information",
            "type": "string"
          },
          "pageNumber": {
            "description": "The page number of a file the diagram is parsed from",
            "type": "integer"
          },
          "status": {
            "description": "Parsing status of a diagram",
            "$ref": "#/components/schemas/ParseStatus"
          },
          "viewBox": {
            "description": "ViewBox attribute of the SVG diagram",
            "type": "string"
          },
          "width": {
            "description": "Width attribute of the SVG diagram",
            "type": "string"
          }
        }
      },
      "CreateGeometriesRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of geometries to create",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/GeometryCreateDraft"
            }
          }
        }
      },
      "GeometryCreateDraft": {
        "type": "object",
        "required": [
          "externalId",
          "paths",
          "symbolId"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the geometry",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "paths": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Path"
            }
          },
          "symbolId": {
            "description": "The external ID of a symbol the geometry belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "GeometryDto": {
        "type": "object",
        "required": [
          "createdTime",
          "externalId",
          "lastUpdatedTime",
          "paths",
          "symbolId"
        ],
        "properties": {
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "externalId": {
            "description": "The external ID of the geometry",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "paths": {
            "type": "array",
            "description": "List of paths of this geometry",
            "items": {
              "$ref": "#/components/schemas/Path"
            }
          },
          "symbolId": {
            "description": "The external ID of a symbol the geometry belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "GeometryUpdateDraft": {
        "type": "object",
        "properties": {
          "paths": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Path"
            }
          }
        }
      },
      "GeometryUpdateItem": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the geometry",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "description": "The properties to be updated",
            "$ref": "#/components/schemas/GeometryUpdateDraft"
          }
        }
      },
      "UpdateGeometriesRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of geometries to update",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/GeometryUpdateItem"
            }
          }
        }
      },
      "CopyLibraryInput": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "description": "The name of the copied library",
            "type": "string"
          }
        }
      },
      "CreateLibrariesRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of libraries to create",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/LibraryCreateDraft"
            }
          }
        }
      },
      "ExtendedLibraryDto": {
        "description": "Library with all of its symbols and geometries joined",
        "type": "object",
        "required": [
          "createdTime",
          "externalId",
          "lastUpdatedTime",
          "name",
          "scope",
          "symbols"
        ],
        "properties": {
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "externalId": {
            "description": "The external ID of the library",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "name": {
            "description": "The name of the library",
            "type": "string"
          },
          "scope": {
            "description": "Global or project scope where the library is available",
            "$ref": "#/components/schemas/LibraryScope"
          },
          "symbols": {
            "description": "List of symbols of this library",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtendedSymbolDto"
            }
          }
        }
      },
      "LibraryCreateDraft": {
        "type": "object",
        "required": [
          "externalId",
          "name"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the library",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "description": "The name of the library",
            "type": "string"
          }
        }
      },
      "LibraryDto": {
        "type": "object",
        "required": [
          "createdTime",
          "externalId",
          "lastUpdatedTime",
          "name",
          "scope"
        ],
        "properties": {
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "externalId": {
            "description": "The external ID of the library",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "name": {
            "description": "The name of the library",
            "type": "string"
          },
          "scope": {
            "description": "Global or project scope where the library is available",
            "$ref": "#/components/schemas/LibraryScope"
          }
        }
      },
      "LibraryScope": {
        "description": "Global or project scope where library is available",
        "type": "string",
        "enum": [
          "Global",
          "Project"
        ]
      },
      "LibraryUpdateDraft": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The name of the library",
            "type": "string"
          }
        }
      },
      "LibraryUpdateItem": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the library",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "description": "The properties to be updated",
            "$ref": "#/components/schemas/LibraryUpdateDraft"
          }
        }
      },
      "UpdateLibrariesRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of libraries to update",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/LibraryUpdateItem"
            }
          }
        }
      },
      "EntityDto": {
        "type": "object",
        "required": [
          "createdTime",
          "diagramId",
          "externalId",
          "isAssetVerified",
          "isUserDetected",
          "lastUpdatedTime",
          "pathIds",
          "symbolId"
        ],
        "properties": {
          "annotationId": {
            "description": "DMS identifier of a linked Diagram Annotation",
            "$ref": "#/components/schemas/DmsId"
          },
          "assetId": {
            "description": "DMS identifier of a mapped asset",
            "$ref": "#/components/schemas/DmsId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "diagramId": {
            "description": "The external ID of a diagram this entity belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "externalId": {
            "description": "The external ID of the diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "isAssetVerified": {
            "description": "Determines if a diagram entity has a verified asset mapping",
            "type": "boolean"
          },
          "isUserDetected": {
            "description": "Determines if a diagram entity was detected manually",
            "type": "boolean"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "pathIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "symbolId": {
            "description": "The external ID of the symbol this diagram entity is detected as",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "CreateEntitiesRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of diagram entities to create",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/EntityCreateDraft"
            }
          }
        }
      },
      "EntityCreateDraft": {
        "type": "object",
        "required": [
          "diagramId",
          "externalId",
          "isAssetVerified",
          "isUserDetected",
          "pathIds",
          "symbolId"
        ],
        "properties": {
          "annotationId": {
            "description": "DMS identifier of a Diagram Annotation used to determine the asset to which the diagram entity is mapped",
            "$ref": "#/components/schemas/DmsId"
          },
          "assetId": {
            "description": "DMS identifier of the asset to which the diagram entity is mapped",
            "$ref": "#/components/schemas/DmsId"
          },
          "diagramId": {
            "description": "The external ID of a diagram the entity belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "externalId": {
            "description": "The external ID of the diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "isAssetVerified": {
            "description": "Determines if a diagram entity has a verified asset mapping",
            "type": "boolean"
          },
          "isUserDetected": {
            "description": "Determines if a diagram entity was detected manually",
            "type": "boolean"
          },
          "pathIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "symbolId": {
            "description": "The external ID of the symbol this diagram entity is detected as",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "EntityUpdateDraft": {
        "type": "object",
        "properties": {
          "annotationId": {
            "description": "DMS identifier of a linked diagram annotation",
            "anyOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/DmsId"
              }
            ]
          },
          "assetId": {
            "description": "DMS identifier of a mapped asset",
            "anyOf": [
              {
                "type": "null"
              },
              {
                "$ref": "#/components/schemas/DmsId"
              }
            ]
          },
          "isAssetVerified": {
            "description": "Determines if a diagram entity has a verified asset mapping",
            "type": "boolean"
          },
          "isUserDetected": {
            "description": "Determines if a diagram entity was detected manually",
            "type": "boolean"
          }
        }
      },
      "EntityUpdateItem": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "description": "The properties to be updated",
            "$ref": "#/components/schemas/EntityUpdateDraft"
          }
        }
      },
      "EntityWithPathsDto": {
        "description": "Diagram entity with its paths joined by pathIds",
        "type": "object",
        "required": [
          "createdTime",
          "diagramId",
          "externalId",
          "isAssetVerified",
          "isUserDetected",
          "lastUpdatedTime",
          "paths",
          "symbolId"
        ],
        "properties": {
          "annotationId": {
            "description": "DMS identifier of a linked diagram annotation",
            "$ref": "#/components/schemas/DmsId"
          },
          "assetId": {
            "description": "DMS identifier of a mapped asset",
            "$ref": "#/components/schemas/DmsId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "diagramId": {
            "description": "The external ID of a diagram the entity belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "externalId": {
            "description": "The external ID of the diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "isAssetVerified": {
            "description": "Determines if a diagram entity has a verified asset mapping",
            "type": "boolean"
          },
          "isUserDetected": {
            "description": "Determines if a diagram entity was detected manually",
            "type": "boolean"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "paths": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Path"
            }
          },
          "symbolId": {
            "description": "The external ID of the symbol this diagram entity is detected as",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "UpdateEntitiesRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of diagram entities to update",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/EntityUpdateItem"
            }
          }
        }
      },
      "DocumentIdentifier": {
        "type": "object",
        "required": [
          "fileId",
          "pageNumber"
        ],
        "properties": {
          "fileId": {
            "description": "DMS identifier of a file to be parsed",
            "$ref": "#/components/schemas/DmsId"
          },
          "pageNumber": {
            "description": "Page number of the file to be parsed",
            "type": "integer"
          }
        }
      },
      "DiagramParseInput": {
        "type": "object",
        "required": [
          "documents",
          "libraryId",
          "nonce"
        ],
        "properties": {
          "documents": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/DocumentIdentifier"
            }
          },
          "libraryId": {
            "description": "The external ID of a library for parsing",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "nonce": {
            "description": "Nonce parameter",
            "type": "string"
          }
        }
      },
      "InstantParseInput": {
        "type": "object",
        "required": [
          "document",
          "libraryId"
        ],
        "properties": {
          "document": {
            "type": "object",
            "$ref": "#/components/schemas/DocumentIdentifier"
          },
          "libraryId": {
            "description": "The external ID of a library for parsing",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "InstantParseResult": {
        "description": "Temporary diagram entity data resulting from running instant parsing with a library on a file.",
        "type": "object",
        "required": [
          "entities",
          "status"
        ],
        "properties": {
          "entities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/VirtualEntity"
            }
          },
          "message": {
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/ParseStatus"
          }
        }
      },
      "ParseStatus": {
        "description": "Status of a parsing job",
        "type": "string",
        "enum": [
          "Failed",
          "InProgress",
          "InQueue",
          "Pending",
          "Success"
        ]
      },
      "VirtualEntity": {
        "description": "Diagram entity with its paths joined by pathIds",
        "type": "object",
        "required": [
          "externalId",
          "pathIds",
          "symbolId"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the diagram entity",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "pathIds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "symbolId": {
            "description": "The external ID of the symbol this diagram entity is detected as",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "CreateSymbolsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of symbols to create",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/SymbolCreateDraft"
            }
          }
        }
      },
      "ExtendedSymbolDto": {
        "description": "Symbol with all of its geometries joined",
        "type": "object",
        "required": [
          "assetTypeId",
          "externalId",
          "geometries",
          "lastUpdatedTime",
          "libraryId"
        ],
        "properties": {
          "assetTypeId": {
            "$ref": "#/components/schemas/DmsId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "externalId": {
            "description": "The external ID of the symbol",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "geometries": {
            "description": "List of geometries of this symbol",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeometryDto"
            }
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "libraryId": {
            "description": "The external ID of a library the symbol belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "SymbolCreateDraft": {
        "type": "object",
        "required": [
          "assetTypeId",
          "externalId",
          "libraryId"
        ],
        "properties": {
          "assetTypeId": {
            "description": "The DMS identifier of the asset type that the symbol represents",
            "$ref": "#/components/schemas/DmsId"
          },
          "externalId": {
            "description": "The external ID of the symbol",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "libraryId": {
            "description": "The external ID of a library the symbol belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "SymbolDto": {
        "type": "object",
        "required": [
          "assetTypeId",
          "createdTime",
          "externalId",
          "lastUpdatedTime",
          "libraryId"
        ],
        "properties": {
          "assetTypeId": {
            "$ref": "#/components/schemas/DmsId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "externalId": {
            "description": "The external ID of the symbol",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "libraryId": {
            "description": "The external ID of a library the symbol belongs to",
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "SymbolUpdateDraft": {
        "type": "object",
        "properties": {
          "assetTypeId": {
            "$ref": "#/components/schemas/DmsId"
          }
        }
      },
      "SymbolUpdateItem": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "description": "The external ID of the symbol",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "description": "The properties to be updated",
            "$ref": "#/components/schemas/SymbolUpdateDraft"
          }
        }
      },
      "UpdateSymbolsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "description": "List of symbols to update",
        "minItems": 1,
        "maxItems": 100,
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/SymbolUpdateItem"
            }
          }
        }
      },
      "DetectTagsResourceType": {
        "description": "Type of resources loaded for tag detection.",
        "type": "string",
        "enum": [
          "Asset",
          "File"
        ]
      },
      "DetectTagsResourceFilter": {
        "type": "object",
        "properties": {
          "Asset": {
            "type": "object",
            "additionalProperties": true
          },
          "File": {
            "type": "object",
            "additionalProperties": true
          }
        }
      },
      "FullParseInput": {
        "type": "object",
        "required": [
          "documents",
          "filters",
          "libraryId",
          "nonce"
        ],
        "properties": {
          "documents": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "$ref": "#/components/schemas/DocumentIdentifier"
            }
          },
          "filters": {
            "description": "Map of filters for DMS list operations used to load assets and files",
            "type": "object",
            "$ref": "#/components/schemas/DetectTagsResourceFilter"
          },
          "libraryId": {
            "description": "The externalId of a library to use for parsing",
            "$ref": "#/components/schemas/ExternalId"
          },
          "minTokens": {
            "description": "Each detected item must match the detected entity on at least this number of tokens. A token is a substring of consecutive letters or digits.",
            "type": "integer"
          },
          "nonce": {
            "description": "Session nonce value",
            "type": "string"
          },
          "partialMatch": {
            "description": "Allow partial (fuzzy) matching of entities in the engineering diagrams. Creates a match only when it is possible to do so unambiguously.",
            "type": "boolean"
          },
          "searchField": {
            "description": "This field determines the string to search for and to identify object entities.",
            "type": "string"
          }
        }
      },
      "Path": {
        "description": "SVG path in a custom format",
        "type": "object",
        "required": [
          "id",
          "d"
        ],
        "properties": {
          "id": {
            "type": "string"
          },
          "d": {
            "description": "The d attribute of an SVG path",
            "type": "string"
          },
          "styleId": {
            "description": "The id of the style used for this path",
            "type": "string"
          }
        }
      },
      "PathsDict": {
        "description": "Map representation of paths",
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/Path"
        }
      },
      "PathStylesDict": {
        "description": "Map linking styleIds to SVG path style properties",
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/PathStyle"
        }
      },
      "PathStyle": {
        "description": "Representation of an SVG path style attribute",
        "type": "object",
        "required": [],
        "properties": {
          "fill": {
            "type": "string"
          },
          "fillOpacity": {
            "type": "string"
          },
          "fillRule": {
            "type": "string",
            "enum": [
              "nonzero",
              "evenodd"
            ],
            "default": "nonzero"
          },
          "stroke": {
            "type": "string"
          },
          "strokeDasharray": {
            "type": "string"
          },
          "strokeDashoffset": {
            "type": "string"
          },
          "strokeLinecap": {
            "type": "string",
            "enum": [
              "butt",
              "round",
              "square"
            ],
            "default": "butt"
          },
          "strokeLinejoin": {
            "type": "string",
            "enum": [
              "bevel",
              "miter",
              "round"
            ],
            "default": "miter"
          },
          "strokeMiterlimit": {
            "type": "string"
          },
          "strokeOpacity": {
            "type": "string"
          },
          "strokeWidth": {
            "type": "string"
          }
        }
      },
      "SvgData": {
        "description": "SVG data extracted for a file.",
        "type": "object",
        "required": [
          "height",
          "paths",
          "pathStyles",
          "viewBox",
          "width"
        ],
        "properties": {
          "height": {
            "description": "Height attribute of the SVG diagram",
            "type": "number"
          },
          "paths": {
            "$ref": "#/components/schemas/PathsDict"
          },
          "pathStyles": {
            "$ref": "#/components/schemas/PathStylesDict"
          },
          "viewBox": {
            "description": "ViewBox attribute of the SVG diagram",
            "type": "string"
          },
          "width": {
            "description": "Width attribute of the SVG diagram",
            "type": "number"
          }
        }
      },
      "DmsId": {
        "description": "A DMS Identifier using the space and externalId",
        "type": "object",
        "required": [
          "space",
          "externalId"
        ],
        "properties": {
          "space": {
            "type": "string"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "ExternalIdsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          }
        }
      },
      "VisionFileId": {
        "type": "integer",
        "example": 1234,
        "description": "The ID of a file in CDF.",
        "format": "int64"
      },
      "VisionFileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The external ID of a file in CDF."
      },
      "VisionInstanceId": {
        "type": "object",
        "required": [
          "space",
          "externalId"
        ],
        "example": {
          "space": "space",
          "externalId": "externalId"
        },
        "description": "The instance id of a file in CDF.",
        "properties": {
          "space": {
            "$ref": "#/components/schemas/InstanceSpace"
          },
          "externalId": {
            "$ref": "#/components/schemas/InstanceExternalId"
          }
        }
      },
      "FileReference": {
        "type": "object",
        "required": [
          "fileId",
          "fileExternalId",
          "fileInstanceId"
        ],
        "description": "An external-id or instance-id reference to the referenced file.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "fileId"
            ],
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/VisionFileId"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "fileExternalId"
            ],
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/VisionFileExternalId"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "fileInstanceId"
            ],
            "properties": {
              "fileInstanceId": {
                "$ref": "#/components/schemas/VisionInstanceId"
              }
            }
          }
        ]
      },
      "VisionAllOfFileId": {
        "type": "object",
        "required": [
          "fileId"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/VisionFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/VisionFileExternalId"
          },
          "fileInstanceId": {
            "$ref": "#/components/schemas/VisionInstanceId"
          }
        }
      },
      "FailedBatch": {
        "description": "List of the items and the corresponding error message(s) per failed batch.",
        "type": "object",
        "properties": {
          "errorMessage": {
            "type": "string",
            "description": "The error message(s) of the failed batch."
          },
          "items": {
            "type": "array",
            "description": "List of the items in the failed batch.",
            "items": {
              "$ref": "#/components/schemas/VisionAllOfFileId"
            }
          }
        }
      },
      "ThresholdParameter": {
        "title": "Threshold",
        "description": "The confidence threshold returns predictions as positive if their confidence score is the selected value or higher.\nA higher confidence threshold increases precision but lowers recall, and vice versa.\n",
        "type": "number",
        "example": 0.8,
        "minimum": 0,
        "maximum": 1
      },
      "DeadAngle": {
        "type": "number",
        "example": 60,
        "description": "The angle between the start and end point on the bottom part of an analog gauge, measured in degrees."
      },
      "MinLevel": {
        "type": "number",
        "example": 0,
        "description": "The min value of the gauge."
      },
      "MaxLevel": {
        "type": "number",
        "example": 100,
        "description": "The max value of the gauge."
      },
      "CommaPos": {
        "type": "integer",
        "example": 3,
        "description": "Number of digits after comma in a digital gauge."
      },
      "MinNumDigits": {
        "type": "integer",
        "example": 2,
        "description": "Minimum number of digits on a digital gauge."
      },
      "MaxNumDigits": {
        "type": "integer",
        "example": 5,
        "description": "Maximum number of digits on a digital gauge."
      },
      "NonLinAngle": {
        "type": "number",
        "example": 60,
        "description": "If the gauge is nonlinear, the non-linear angle from the metadata is used to part the scale in two separate linear scales. The first scale goes from min to 0. The second from 0 to max. The needle angle determines which scale is used."
      },
      "TextDetection": {
        "title": "TextDetection",
        "description": "Detect text in images.",
        "type": "string",
        "enum": [
          "TextDetection"
        ]
      },
      "AssetTagDetection": {
        "title": "AssetTagDetection",
        "description": "Detect external ID or name of assets (from your CDF projects) in images. Usage of this feature requires `['assetsAcl:READ']` capability.",
        "type": "string",
        "enum": [
          "AssetTagDetection"
        ]
      },
      "PeopleDetection": {
        "title": "PeopleDetection",
        "description": "Detect people in images.",
        "type": "string",
        "enum": [
          "PeopleDetection"
        ]
      },
      "IndustrialObjectDetection": {
        "title": "IndustrialObjectDetection",
        "description": "Detect industrial objects such as gauges and valves in images. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "string",
        "enum": [
          "IndustrialObjectDetection"
        ]
      },
      "PersonalProtectiveEquipmentDetection": {
        "title": "PersonalProtectiveEquipmentDetection",
        "description": "Detect personal protective equipment, such as helmet, protective eyewear, and mask in images. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "string",
        "enum": [
          "PersonalProtectiveEquipmentDetection"
        ]
      },
      "DialGaugeDetection": {
        "title": "DialGaugeDetection",
        "description": "Detect and read value of dial gauges in images. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "string",
        "enum": [
          "DialGaugeDetection"
        ]
      },
      "LevelGaugeDetection": {
        "title": "LevelGaugeDetection",
        "description": "Detect and read value of level gauges in images. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "string",
        "enum": [
          "LevelGaugeDetection"
        ]
      },
      "DigitalGaugeDetection": {
        "title": "DigitalGaugeDetection",
        "description": "Detect and read value of digital gauges in images. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "string",
        "enum": [
          "DigitalGaugeDetection"
        ]
      },
      "ValveDetection": {
        "title": "ValveDetection",
        "description": "Detect and read state of a valve in an image. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "string",
        "enum": [
          "ValveDetection"
        ]
      },
      "VisionExtractFeature": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/TextDetection"
          },
          {
            "$ref": "#/components/schemas/AssetTagDetection"
          },
          {
            "$ref": "#/components/schemas/PeopleDetection"
          },
          {
            "$ref": "#/components/schemas/IndustrialObjectDetection"
          },
          {
            "$ref": "#/components/schemas/PersonalProtectiveEquipmentDetection"
          },
          {
            "$ref": "#/components/schemas/DialGaugeDetection"
          },
          {
            "$ref": "#/components/schemas/LevelGaugeDetection"
          },
          {
            "$ref": "#/components/schemas/DigitalGaugeDetection"
          },
          {
            "$ref": "#/components/schemas/ValveDetection"
          }
        ]
      },
      "TextDetectionParameters": {
        "description": "Parameters for text detection",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "AssetTagDetectionParameters": {
        "description": "Parameters for asset tag detection.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          },
          "partialMatch": {
            "description": "Allow partial (fuzzy) matching of detected external IDs in the file.\nWill only match when it is possible to do so unambiguously.\n",
            "type": "boolean",
            "default": false,
            "example": true
          },
          "assetSubtreeIds": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "description": "Search for external ID or name of assets that are in a subtree rooted at one of\nthe assetSubtreeIds (including the roots given).\n",
            "example": [
              1,
              2
            ]
          }
        }
      },
      "PeopleDetectionParameters": {
        "description": "Parameters for people detection.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "IndustrialObjectDetectionParameters": {
        "description": "Parameters for industrial object detection. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "PersonalProtectiveEquipmentDetectionParameters": {
        "description": "Parameters for industrial personal protective equipment detection. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "DialGaugeDetectionParameters": {
        "description": "Parameters for dial gauge detection and reading. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "object",
        "properties": {
          "minLevel": {
            "$ref": "#/components/schemas/MinLevel"
          },
          "maxLevel": {
            "$ref": "#/components/schemas/MaxLevel"
          },
          "deadAngle": {
            "$ref": "#/components/schemas/DeadAngle"
          },
          "nonLinAngle": {
            "$ref": "#/components/schemas/NonLinAngle"
          },
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "LevelGaugeDetectionParameters": {
        "description": "Parameters for level gauge detection and reading. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "object",
        "properties": {
          "minLevel": {
            "$ref": "#/components/schemas/MinLevel"
          },
          "maxLevel": {
            "$ref": "#/components/schemas/MaxLevel"
          },
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "DigitalGaugeDetectionParameters": {
        "description": "Parameters for digital gauge detection and reading. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "object",
        "properties": {
          "commaPos": {
            "$ref": "#/components/schemas/CommaPos"
          },
          "minNumDigits": {
            "$ref": "#/components/schemas/MinNumDigits"
          },
          "maxNumDigits": {
            "$ref": "#/components/schemas/MaxNumDigits"
          },
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "ValveDetectionParameters": {
        "description": "Parameters for detecting and reading the state of a valve. In beta. Available only when the `cdf-version: beta` header is provided.",
        "type": "object",
        "properties": {
          "threshold": {
            "$ref": "#/components/schemas/ThresholdParameter"
          }
        }
      },
      "FeatureParameters": {
        "description": "Feature-specific parameters. New feature extractor parameters may appear.",
        "type": "object",
        "properties": {
          "textDetectionParameters": {
            "$ref": "#/components/schemas/TextDetectionParameters"
          },
          "assetTagDetectionParameters": {
            "$ref": "#/components/schemas/AssetTagDetectionParameters"
          },
          "peopleDetectionParameters": {
            "$ref": "#/components/schemas/PeopleDetectionParameters"
          },
          "industrialObjectDetectionParameters": {
            "$ref": "#/components/schemas/IndustrialObjectDetectionParameters"
          },
          "personalProtectiveEquipmentDetectionParameters": {
            "$ref": "#/components/schemas/PersonalProtectiveEquipmentDetectionParameters"
          },
          "dialGaugeDetectionParameters": {
            "$ref": "#/components/schemas/DialGaugeDetectionParameters"
          },
          "levelGaugeDetectionParameters": {
            "$ref": "#/components/schemas/LevelGaugeDetectionParameters"
          },
          "digitalGaugeDetectionParameters": {
            "$ref": "#/components/schemas/DigitalGaugeDetectionParameters"
          },
          "valveDetectionParameters": {
            "$ref": "#/components/schemas/ValveDetectionParameters"
          }
        },
        "example": {
          "textDetectionParameters": {
            "threshold": 0.8
          },
          "assetTagDetectionParameters": {
            "threshold": 0.8,
            "partialMatch": true,
            "assetSubtreeIds": [
              1,
              2
            ]
          },
          "peopleDetectionParameters": {
            "threshold": 0.8
          }
        }
      },
      "VisionExtractPredictions": {
        "title": "Predictions",
        "description": "Detected features in images. New fields may appear in case new feature extractors are add.",
        "type": "object",
        "properties": {
          "textPredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.TextRegion"
            }
          },
          "assetTagPredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.annotation_types__images__AssetLink"
            }
          },
          "peoplePredictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          },
          "industrialObjectPredictions": {
            "type": "array",
            "description": "In beta. Available only when the `cdf-version: beta` header is provided.",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          },
          "personalProtectiveEquipmentPredictions": {
            "type": "array",
            "description": "In beta. Available only when the `cdf-version: beta` header is provided.",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          },
          "dialGaugePredictions": {
            "type": "array",
            "description": "In beta. Available only when the `cdf-version: beta` header is provided.",
            "items": {
              "type": "object",
              "properties": {
                "objectDetection": {
                  "$ref": "#/components/schemas/Annotations.ObjectDetection"
                },
                "keypointCollection": {
                  "$ref": "#/components/schemas/Annotations.KeypointCollection"
                }
              }
            }
          },
          "levelGaugePredictions": {
            "type": "array",
            "description": "In beta. Available only when the `cdf-version: beta` header is provided.",
            "items": {
              "type": "object",
              "properties": {
                "objectDetection": {
                  "$ref": "#/components/schemas/Annotations.ObjectDetection"
                },
                "keypointCollection": {
                  "$ref": "#/components/schemas/Annotations.KeypointCollection"
                }
              }
            }
          },
          "digitalGaugePredictions": {
            "type": "array",
            "description": "In beta. Available only when the `cdf-version: beta` header is provided.",
            "items": {
              "$ref": "#/components/schemas/Annotations.ObjectDetection"
            }
          },
          "valvePredictions": {
            "type": "array",
            "description": "In beta. Available only when the `cdf-version: beta` header is provided.",
            "items": {
              "type": "object",
              "properties": {
                "objectDetection": {
                  "$ref": "#/components/schemas/Annotations.ObjectDetection"
                },
                "keypointCollection": {
                  "$ref": "#/components/schemas/Annotations.KeypointCollection"
                }
              }
            }
          }
        },
        "example": {
          "textPredictions": [
            {
              "confidence": 0.9,
              "text": "string",
              "textRegion": {
                "xMin": 0.5,
                "xMax": 0.9,
                "yMin": 0.5,
                "yMax": 0.9
              }
            }
          ],
          "assetTagPredictions": [
            {
              "confidence": 0.9,
              "assetRef": {
                "id": 1233
              },
              "text": "string",
              "textRegion": {
                "xMin": 0.5,
                "xMax": 0.9,
                "yMin": 0.5,
                "yMax": 0.9
              }
            }
          ],
          "peoplePredictions": [
            {
              "label": "person",
              "confidence": 0.8,
              "boundingBox": {
                "xMin": 0.5,
                "xMax": 0.9,
                "yMin": 0.5,
                "yMax": 0.9
              }
            }
          ]
        }
      },
      "VisionExtractItem": {
        "type": "object",
        "required": [
          "fileId",
          "predictions"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/VisionFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/VisionFileExternalId"
          },
          "predictions": {
            "$ref": "#/components/schemas/VisionExtractPredictions"
          }
        }
      },
      "SegmentPoint": {
        "type": "object",
        "required": [
          "x",
          "y"
        ],
        "properties": {
          "x": {
            "type": "number",
            "example": 0.8,
            "minimum": 0,
            "maximum": 1
          },
          "y": {
            "type": "number",
            "example": 0.8,
            "minimum": 0,
            "maximum": 1
          },
          "label": {
            "type": "number",
            "description": "Label for the input point prompt. 0 is a negative input point (background) while 1 is a positive input point (foreground).",
            "enum": [
              0,
              1
            ],
            "example": 1,
            "default": 1
          }
        }
      },
      "SegmentBoundingBox": {
        "type": "object",
        "description": "Box prompt.",
        "required": [
          "xMin",
          "yMin",
          "xMax",
          "yMax"
        ],
        "properties": {
          "xMin": {
            "type": "number",
            "example": 0.1,
            "minimum": 0,
            "maximum": 1
          },
          "yMin": {
            "type": "number",
            "example": 0.2,
            "minimum": 0,
            "maximum": 1
          },
          "xMax": {
            "type": "number",
            "example": 0.5,
            "minimum": 0,
            "maximum": 1
          },
          "yMax": {
            "type": "number",
            "example": 0.6,
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "VisionSegmentPredictions": {
        "title": "Segments",
        "description": "Detected segments in the image, returned as polygons.",
        "type": "array",
        "items": {
          "type": "object",
          "required": [
            "score",
            "polygons"
          ],
          "properties": {
            "score": {
              "type": "number",
              "description": "Score for the calculated mask by Segment Anything model.",
              "example": 0.8,
              "minimum": 0,
              "maximum": 1
            },
            "polygons": {
              "type": "array",
              "description": "Polygons representing the segmented object",
              "items": {
                "$ref": "#/components/schemas/Annotations.Polygon"
              }
            }
          }
        }
      },
      "VisionSegmentItem": {
        "type": "object",
        "required": [
          "fileId",
          "segments"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/VisionFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/VisionFileExternalId"
          },
          "segments": {
            "$ref": "#/components/schemas/VisionSegmentPredictions"
          }
        }
      },
      "VisionSegmentEmbeddingItem": {
        "type": "object",
        "required": [
          "fileId",
          "embedding"
        ],
        "properties": {
          "fileId": {
            "$ref": "#/components/schemas/VisionFileId"
          },
          "fileExternalId": {
            "$ref": "#/components/schemas/VisionFileExternalId"
          },
          "embedding": {
            "type": "string"
          }
        }
      },
      "AggregateObjectRequest": {
        "additionalProperties": false,
        "properties": {
          "group_by": {
            "title": "Group By",
            "type": "string"
          },
          "properties": {
            "$ref": "#/components/schemas/CompletionAggregateProperties-Input"
          }
        },
        "required": [
          "properties"
        ],
        "title": "AggregateObjectRequest",
        "type": "object"
      },
      "Answer": {
        "additionalProperties": false,
        "properties": {
          "content": {
            "description": "The content of an answer consists of one or more parts. Each part can have a different set of document locations connected to it.",
            "items": {
              "$ref": "#/components/schemas/Content"
            },
            "title": "Content",
            "type": "array"
          }
        },
        "required": [
          "content"
        ],
        "title": "Answer",
        "type": "object"
      },
      "ChatCompletionRequest": {
        "additionalProperties": false,
        "properties": {
          "maxTokens": {
            "default": 2000,
            "description": "The maximum number of tokens to generate in the completion. The token count of your prompt plus maxTokens can't exceed the model's context length",
            "exclusiveMinimum": 0,
            "title": "Maxtokens",
            "type": "integer"
          },
          "messages": {
            "description": "The messages to generate chat completions for, in the chat format.",
            "items": {
              "$ref": "#/components/schemas/ChatMessage-Input"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Messages",
            "type": "array"
          },
          "model": {
            "$ref": "#/components/schemas/ValidLanguageModel",
            "description": "Name of the model to use."
          },
          "stream": {
            "default": false,
            "description": "Whether to stream back partial progress.",
            "title": "Stream",
            "type": "boolean"
          },
          "temperature": {
            "default": 0,
            "description": "What sampling temperature to use. Higher values means the model will take more risks. Try 0.9 for more creative applications, and 0 for ones with a well-defined answer.",
            "title": "Temperature",
            "type": "number"
          },
          "toolChoice": {
            "description": "Controls which (if any) tool is called by the model. `none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. Specifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ChatCompletionsToolChoice"
              },
              {
                "enum": [
                  "none",
                  "auto"
                ],
                "type": "string"
              }
            ],
            "title": "Toolchoice"
          },
          "tools": {
            "description": "A list of tools the model may use",
            "items": {
              "$ref": "#/components/schemas/ChatCompletionsTool"
            },
            "maxItems": 20,
            "minItems": 1,
            "title": "Tools",
            "type": "array"
          }
        },
        "required": [
          "messages"
        ],
        "title": "ChatCompletionRequest",
        "type": "object"
      },
      "ChatCompletionsContent-Input": {
        "additionalProperties": false,
        "properties": {
          "imageUrl": {
            "$ref": "#/components/schemas/ChatCompletionsContentImageURL",
            "description": "The URL of the image"
          },
          "text": {
            "description": "The text content",
            "title": "Text",
            "type": "string"
          },
          "type": {
            "description": "The type of content",
            "enum": [
              "text",
              "image_url"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "title": "ChatCompletionsContent",
        "type": "object"
      },
      "ChatCompletionsContent-Output": {
        "additionalProperties": false,
        "properties": {
          "image_url": {
            "$ref": "#/components/schemas/ChatCompletionsContentImageURL",
            "description": "The URL of the image"
          },
          "text": {
            "description": "The text content",
            "title": "Text",
            "type": "string"
          },
          "type": {
            "description": "The type of content",
            "enum": [
              "text",
              "image_url"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "title": "ChatCompletionsContent",
        "type": "object"
      },
      "ChatCompletionsContentImageURL": {
        "additionalProperties": false,
        "properties": {
          "url": {
            "description": "The URL of the image",
            "title": "Url",
            "type": "string"
          }
        },
        "required": [
          "url"
        ],
        "title": "ChatCompletionsContentImageURL",
        "type": "object"
      },
      "ChatCompletionsFunctionCall": {
        "additionalProperties": false,
        "properties": {
          "arguments": {
            "description": "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may fabricate parameters not defined by your function schema. Validate the arguments in your code before calling your function.",
            "title": "Arguments",
            "type": "string"
          },
          "name": {
            "description": "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.",
            "maxLength": 64,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          }
        },
        "title": "ChatCompletionsFunctionCall",
        "type": "object"
      },
      "ChatCompletionsFunctionName": {
        "additionalProperties": false,
        "properties": {
          "name": {
            "description": "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.",
            "maxLength": 64,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          }
        },
        "required": [
          "name"
        ],
        "title": "ChatCompletionsFunctionName",
        "type": "object"
      },
      "ChatCompletionsFunctions": {
        "additionalProperties": false,
        "example": {
          "description": "Get the current weather in a given location",
          "name": "get_current_weather",
          "parameters": {
            "properties": {
              "location": {
                "description": "The city and state, e.g. San Francisco, CA",
                "type": "string"
              },
              "unit": {
                "enum": [
                  "celsius",
                  "fahrenheit"
                ],
                "type": "string"
              }
            },
            "required": [
              "location"
            ],
            "type": "object"
          }
        },
        "properties": {
          "description": {
            "description": "A description of what the function does. The model will use this description when selecting the function and interpreting its parameters.",
            "title": "Description",
            "type": "string"
          },
          "name": {
            "description": "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.",
            "maxLength": 64,
            "minLength": 1,
            "title": "Name",
            "type": "string"
          },
          "parameters": {
            "$ref": "#/components/schemas/FunctionParameters",
            "description": "The parameters the functions accepts, described as a JSON Schema object."
          }
        },
        "required": [
          "name",
          "parameters"
        ],
        "title": "ChatCompletionsFunctions",
        "type": "object"
      },
      "ChatCompletionsResponse": {
        "additionalProperties": false,
        "properties": {
          "choices": {
            "description": "The list of completion choices",
            "items": {
              "$ref": "#/components/schemas/Choice"
            },
            "title": "Choices",
            "type": "array"
          },
          "created": {
            "description": "The time the completion was created",
            "title": "Created",
            "type": "integer"
          },
          "model": {
            "description": "The model used",
            "title": "Model",
            "type": "string"
          },
          "usage": {
            "$ref": "#/components/schemas/Usage",
            "description": "The usage of the completion"
          }
        },
        "required": [
          "model",
          "created",
          "choices",
          "usage"
        ],
        "title": "ChatCompletionsResponse",
        "type": "object"
      },
      "ChatCompletionsStreamResponse": {
        "additionalProperties": false,
        "properties": {
          "choices": {
            "description": "The list of completion choices",
            "items": {
              "$ref": "#/components/schemas/StreamChoice"
            },
            "title": "Choices",
            "type": "array"
          },
          "created": {
            "description": "The time the completion was created",
            "title": "Created",
            "type": "integer"
          },
          "model": {
            "description": "The model used",
            "title": "Model",
            "type": "string"
          },
          "usage": {
            "$ref": "#/components/schemas/Usage",
            "description": "The token usage related to the completion chunk"
          }
        },
        "required": [
          "model",
          "created",
          "choices"
        ],
        "title": "ChatCompletionsStreamResponse",
        "type": "object"
      },
      "ChatCompletionsStreamToolCall": {
        "additionalProperties": false,
        "properties": {
          "function": {
            "$ref": "#/components/schemas/ChatCompletionsFunctionCall"
          },
          "id": {
            "title": "Id",
            "type": "string"
          },
          "index": {
            "description": "The index of the tool in the list of tools",
            "title": "Index",
            "type": "integer"
          },
          "type": {
            "const": "function",
            "default": "function",
            "description": "The type of tool",
            "enum": [
              "function"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "index",
          "id",
          "function"
        ],
        "title": "ChatCompletionsStreamToolCall",
        "type": "object"
      },
      "ChatCompletionsTool": {
        "additionalProperties": false,
        "example": {
          "function": {
            "description": "Get the current weather in a given location",
            "name": "get_current_weather",
            "parameters": {
              "properties": {
                "location": {
                  "description": "The city and state, e.g. San Francisco, CA",
                  "type": "string"
                },
                "unit": {
                  "enum": [
                    "celsius",
                    "fahrenheit"
                  ],
                  "type": "string"
                }
              },
              "required": [
                "location"
              ],
              "type": "object"
            }
          },
          "type": "function"
        },
        "properties": {
          "function": {
            "$ref": "#/components/schemas/ChatCompletionsFunctions",
            "description": "The function the model may call"
          },
          "type": {
            "const": "function",
            "default": "function",
            "description": "The type of tool",
            "enum": [
              "function"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "function"
        ],
        "title": "ChatCompletionsTool",
        "type": "object"
      },
      "ChatCompletionsToolCall": {
        "additionalProperties": false,
        "properties": {
          "function": {
            "$ref": "#/components/schemas/ChatCompletionsFunctionCall"
          },
          "id": {
            "title": "Id",
            "type": "string"
          },
          "type": {
            "const": "function",
            "default": "function",
            "description": "The type of tool",
            "enum": [
              "function"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "id",
          "function"
        ],
        "title": "ChatCompletionsToolCall",
        "type": "object"
      },
      "ChatCompletionsToolChoice": {
        "additionalProperties": false,
        "properties": {
          "function": {
            "$ref": "#/components/schemas/ChatCompletionsFunctionName"
          },
          "type": {
            "const": "function",
            "enum": [
              "function"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type",
          "function"
        ],
        "title": "ChatCompletionsToolChoice",
        "type": "object"
      },
      "ChatMessage-Input": {
        "additionalProperties": false,
        "properties": {
          "content": {
            "description": "The contents of the message.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/ChatCompletionsContent-Input"
                },
                "type": "array"
              }
            ],
            "title": "Content"
          },
          "functionCall": {
            "$ref": "#/components/schemas/ChatCompletionsFunctionCall",
            "description": "The name and arguments of a function that should be called, as generated by the model."
          },
          "name": {
            "description": "The name of a function in a function call.",
            "title": "Name",
            "type": "string"
          },
          "role": {
            "$ref": "#/components/schemas/ChatMessageRole",
            "description": "The role of the author of this message."
          },
          "tool_call_id": {
            "description": "The ID of the tool to be called",
            "title": "Tool Call Id",
            "type": "string"
          },
          "tool_calls": {
            "description": "The tools to be called",
            "items": {
              "$ref": "#/components/schemas/ChatCompletionsToolCall"
            },
            "title": "Tool Calls",
            "type": "array"
          }
        },
        "required": [
          "role"
        ],
        "title": "ChatMessage",
        "type": "object"
      },
      "ChatMessage-Output": {
        "additionalProperties": false,
        "properties": {
          "content": {
            "description": "The contents of the message.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/ChatCompletionsContent-Output"
                },
                "type": "array"
              }
            ],
            "title": "Content"
          },
          "function_call": {
            "$ref": "#/components/schemas/ChatCompletionsFunctionCall",
            "description": "The name and arguments of a function that should be called, as generated by the model."
          },
          "name": {
            "description": "The name of a function in a function call.",
            "title": "Name",
            "type": "string"
          },
          "role": {
            "$ref": "#/components/schemas/ChatMessageRole",
            "description": "The role of the author of this message."
          },
          "tool_call_id": {
            "description": "The ID of the tool to be called",
            "title": "Tool Call Id",
            "type": "string"
          },
          "tool_calls": {
            "description": "The tools to be called",
            "items": {
              "$ref": "#/components/schemas/ChatCompletionsToolCall"
            },
            "title": "Tool Calls",
            "type": "array"
          }
        },
        "required": [
          "role"
        ],
        "title": "ChatMessage",
        "type": "object"
      },
      "ChatMessageRole": {
        "enum": [
          "user",
          "system",
          "assistant",
          "function",
          "tool"
        ],
        "title": "ChatMessageRole",
        "type": "string"
      },
      "Choice": {
        "additionalProperties": false,
        "properties": {
          "finish_reason": {
            "description": "The reason the conversation ended",
            "title": "Finish Reason",
            "type": "string"
          },
          "message": {
            "$ref": "#/components/schemas/ChatMessage-Output",
            "description": "The generated completion in the chat format"
          }
        },
        "required": [
          "message",
          "finish_reason"
        ],
        "title": "Choice",
        "type": "object"
      },
      "CodeEditRequest": {
        "additionalProperties": false,
        "properties": {
          "currentCode": {
            "description": "Code to edit.",
            "maxLength": 4096,
            "title": "Currentcode",
            "type": "string"
          },
          "previousCodeContext": {
            "description": "Previously executed code.",
            "maxLength": 16384,
            "title": "Previouscodecontext",
            "type": "string"
          },
          "prompt": {
            "description": "The query to be completed.",
            "maxLength": 2048,
            "minLength": 10,
            "title": "Prompt",
            "type": "string"
          }
        },
        "required": [
          "prompt",
          "currentCode"
        ],
        "title": "CodeEditRequest",
        "type": "object"
      },
      "CodeGenerationRequest": {
        "additionalProperties": false,
        "properties": {
          "previousCodeContext": {
            "description": "Previously executed code.",
            "maxLength": 16384,
            "title": "Previouscodecontext",
            "type": "string"
          },
          "prompt": {
            "description": "The query to be completed.",
            "maxLength": 2048,
            "minLength": 10,
            "title": "Prompt",
            "type": "string"
          }
        },
        "required": [
          "prompt"
        ],
        "title": "CodeGenerationRequest",
        "type": "object"
      },
      "Completion": {
        "additionalProperties": false,
        "properties": {
          "content": {
            "description": "Generated content",
            "title": "Content",
            "type": "string"
          },
          "previous_context": {
            "description": "Previous context",
            "items": {
              "type": "object"
            },
            "title": "Previous Context",
            "type": "array"
          }
        },
        "required": [
          "content",
          "previous_context"
        ],
        "title": "Completion",
        "type": "object"
      },
      "CompletionAggregateProperties-Input": {
        "properties": {
          "avg": {
            "items": {
              "type": "string"
            },
            "title": "Avg",
            "type": "array"
          },
          "count": {
            "items": {
              "type": "string"
            },
            "title": "Count",
            "type": "array"
          },
          "max": {
            "items": {
              "type": "string"
            },
            "title": "Max",
            "type": "array"
          },
          "min": {
            "items": {
              "type": "string"
            },
            "title": "Min",
            "type": "array"
          },
          "sum": {
            "items": {
              "type": "string"
            },
            "title": "Sum",
            "type": "array"
          }
        },
        "title": "CompletionAggregateProperties",
        "type": "object"
      },
      "CompletionAggregateProperties-Output": {
        "title": "CompletionAggregateProperties",
        "type": "object"
      },
      "CompletionAggregateResponse": {
        "properties": {
          "group_by": {
            "title": "Group By",
            "type": "string"
          },
          "properties": {
            "$ref": "#/components/schemas/CompletionAggregateProperties-Output"
          }
        },
        "title": "CompletionAggregateResponse",
        "type": "object"
      },
      "CompletionData": {
        "additionalProperties": false,
        "properties": {
          "aggregate": {
            "$ref": "#/components/schemas/CompletionAggregateResponse",
            "description": "Relevant aggregate model type from a given data model"
          },
          "dataModelView": {
            "$ref": "#/components/schemas/ResponseDataModelView",
            "description": "Relevant data model view from a given data model"
          },
          "filter": {
            "description": "Relevant filters for the data model view",
            "title": "Filter",
            "type": "object"
          },
          "limit": {
            "description": "Relevant limit for the data model view",
            "title": "Limit",
            "type": "integer"
          },
          "operation": {
            "description": "The query operation to complete",
            "maxLength": 255,
            "minLength": 1,
            "title": "Operation",
            "type": "string"
          },
          "properties": {
            "description": "Relevant properties for the data model view",
            "oneOf": [
              {
                "additionalProperties": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "type": "object"
              },
              {
                "items": {
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "additionalProperties": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "type": "object"
                    }
                  ]
                },
                "type": "array"
              }
            ],
            "title": "Properties"
          },
          "search": {
            "$ref": "#/components/schemas/CompletionSearchResponse",
            "description": "Relevant aggregate model type from a given data model"
          },
          "sort": {
            "description": "Relevant sort for the data model view",
            "items": {
              "$ref": "#/components/schemas/CompletionSortResponse"
            },
            "title": "Sort",
            "type": "array"
          }
        },
        "required": [
          "operation",
          "dataModelView",
          "properties"
        ],
        "title": "CompletionData",
        "type": "object"
      },
      "CompletionSearchResponse": {
        "properties": {
          "fields": {
            "items": {
              "type": "string"
            },
            "title": "Fields",
            "type": "array"
          },
          "query": {
            "title": "Query",
            "type": "string"
          }
        },
        "required": [
          "query",
          "fields"
        ],
        "title": "CompletionSearchResponse",
        "type": "object"
      },
      "CompletionSortResponse": {
        "properties": {
          "direction": {
            "default": "ascending",
            "description": "The sort direction",
            "enum": [
              "ascending",
              "descending"
            ],
            "title": "Direction",
            "type": "string"
          },
          "field": {
            "description": "The field to sort by",
            "maxLength": 255,
            "minLength": 1,
            "title": "Field",
            "type": "string"
          }
        },
        "required": [
          "field"
        ],
        "title": "CompletionSortResponse",
        "type": "object"
      },
      "Content": {
        "additionalProperties": false,
        "properties": {
          "references": {
            "description": "The document locations that this part of the answer is sourced from",
            "items": {
              "$ref": "#/components/schemas/ReferenceAI"
            },
            "title": "References",
            "type": "array"
          },
          "text": {
            "description": "A part of the answer from the LLM.",
            "title": "Text",
            "type": "string"
          }
        },
        "required": [
          "text"
        ],
        "title": "Content",
        "type": "object"
      },
      "CustomLanguageModelRequest": {
        "additionalProperties": false,
        "properties": {
          "apiKey": {
            "description": "API Key to access third party model",
            "format": "password",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Apikey",
            "type": "string",
            "writeOnly": true
          },
          "endpoint": {
            "description": "URL of endpoint of the Model",
            "format": "password",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Endpoint",
            "type": "string",
            "writeOnly": true
          },
          "host": {
            "$ref": "#/components/schemas/ExternalHostOptions",
            "description": "Host of the third part model"
          },
          "model": {
            "description": "Name of the third party model",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Model",
            "type": "string"
          }
        },
        "required": [
          "host",
          "model",
          "apiKey",
          "endpoint"
        ],
        "title": "CustomLanguageModelRequest",
        "type": "object"
      },
      "DataModelTypeAI": {
        "properties": {
          "externalId": {
            "description": "The external ID of the data model",
            "maxLength": 255,
            "minLength": 1,
            "title": "Externalid",
            "type": "string"
          },
          "space": {
            "description": "The space the data model is in",
            "maxLength": 43,
            "minLength": 1,
            "title": "Space",
            "type": "string"
          },
          "type": {
            "description": "Relevant data model type",
            "maxLength": 255,
            "minLength": 1,
            "title": "Type",
            "type": "string"
          },
          "version": {
            "description": "The version of the data model",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "space",
          "externalId",
          "version",
          "type"
        ],
        "title": "DataModelTypeAI",
        "type": "object"
      },
      "DataModelViewAI": {
        "properties": {
          "externalId": {
            "description": "The external ID of the data model",
            "maxLength": 255,
            "minLength": 1,
            "title": "Externalid",
            "type": "string"
          },
          "space": {
            "description": "The space the data model is in",
            "maxLength": 43,
            "minLength": 1,
            "title": "Space",
            "type": "string"
          },
          "version": {
            "description": "The version of the data model",
            "title": "Version",
            "type": "string"
          },
          "view": {
            "description": "Relevant data model view",
            "maxLength": 255,
            "minLength": 1,
            "title": "View",
            "type": "string"
          }
        },
        "required": [
          "space",
          "externalId",
          "version",
          "view"
        ],
        "title": "DataModelViewAI",
        "type": "object"
      },
      "DocumentExternalId": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "description": "The external ID for the document. This value matches the externalId set in the Files API.",
            "title": "Externalid",
            "type": "string"
          }
        },
        "required": [
          "externalId"
        ],
        "title": "DocumentExternalId",
        "type": "object"
      },
      "DocumentInstanceId": {
        "additionalProperties": false,
        "properties": {
          "instanceId": {
            "$ref": "#/components/schemas/InstanceIdAI",
            "description": "The Data Modeling instance ID for the document."
          }
        },
        "required": [
          "instanceId"
        ],
        "title": "DocumentInstanceId",
        "type": "object"
      },
      "DocumentInternalId": {
        "additionalProperties": false,
        "properties": {
          "id": {
            "description": "The file ID for the document.",
            "title": "Id",
            "type": "integer"
          }
        },
        "required": [
          "id"
        ],
        "title": "DocumentInternalId",
        "type": "object"
      },
      "DocumentQARequest": {
        "additionalProperties": false,
        "properties": {
          "additionalContext": {
            "description": "Optional additional context that the model can use to improve its answer",
            "maxLength": 2048,
            "minLength": 10,
            "title": "Additionalcontext",
            "type": "string"
          },
          "fileIds": {
            "description": "List of file ids, external ids, or instance ids pointing to PDF documents",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DocumentInternalId"
                },
                {
                  "$ref": "#/components/schemas/DocumentExternalId"
                },
                {
                  "$ref": "#/components/schemas/DocumentInstanceId"
                }
              ]
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Fileids",
            "type": "array"
          },
          "ignoreUnknownIds": {
            "default": false,
            "description": "If True, the API will not fail if any documents are missing or not fully processed, but generate an answer based on available documents",
            "title": "Ignoreunknownids",
            "type": "boolean"
          },
          "language": {
            "$ref": "#/components/schemas/DocumentsQALanguage",
            "default": "English",
            "description": "The language name (ISO 639) of the language that the answer should be in"
          },
          "question": {
            "description": "Question to ask about the documents",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Question",
            "type": "string"
          }
        },
        "required": [
          "question",
          "fileIds"
        ],
        "title": "DocumentQARequest",
        "type": "object"
      },
      "DocumentSummarizationRequest": {
        "additionalProperties": false,
        "properties": {
          "ignoreUnknownIds": {
            "default": false,
            "description": "If True, the API will not fail if any documents are missing, but summaries for the missing documents will be excluded from the response.",
            "title": "Ignoreunknownids",
            "type": "boolean"
          },
          "items": {
            "description": "List of documents to summarize",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DocumentInternalId"
                },
                {
                  "$ref": "#/components/schemas/DocumentExternalId"
                },
                {
                  "$ref": "#/components/schemas/DocumentInstanceId"
                }
              ]
            },
            "maxItems": 1,
            "minItems": 1,
            "title": "Items",
            "type": "array"
          }
        },
        "required": [
          "items"
        ],
        "title": "DocumentSummarizationRequest",
        "type": "object"
      },
      "DocumentSummarizationResponse": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "description": "List of documents with summaries",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DocumentSummarizationResponseItemInternalId"
                },
                {
                  "$ref": "#/components/schemas/DocumentSummarizationResponseItemExternalId"
                },
                {
                  "$ref": "#/components/schemas/DocumentSummarizationResponseItemInstanceId"
                }
              ]
            },
            "title": "Items",
            "type": "array"
          }
        },
        "required": [
          "items"
        ],
        "title": "DocumentSummarizationResponse",
        "type": "object"
      },
      "DocumentSummarizationResponseItemExternalId": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "description": "The external ID for the document. This value matches the externalId set in the Files API.",
            "title": "Externalid",
            "type": "string"
          },
          "summary": {
            "description": "Summary of the document",
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "externalId",
          "summary"
        ],
        "title": "DocumentSummarizationResponseItemExternalId",
        "type": "object"
      },
      "DocumentSummarizationResponseItemInstanceId": {
        "additionalProperties": false,
        "properties": {
          "instanceId": {
            "$ref": "#/components/schemas/InstanceIdAI",
            "description": "The Data Modeling instance ID for the document."
          },
          "summary": {
            "description": "Summary of the document",
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "instanceId",
          "summary"
        ],
        "title": "DocumentSummarizationResponseItemInstanceId",
        "type": "object"
      },
      "DocumentSummarizationResponseItemInternalId": {
        "additionalProperties": false,
        "properties": {
          "id": {
            "description": "The file ID for the document.",
            "title": "Id",
            "type": "integer"
          },
          "summary": {
            "description": "Summary of the document",
            "title": "Summary",
            "type": "string"
          }
        },
        "required": [
          "id",
          "summary"
        ],
        "title": "DocumentSummarizationResponseItemInternalId",
        "type": "object"
      },
      "DocumentsQALanguage": {
        "enum": [
          "Chinese",
          "Dutch",
          "English",
          "French",
          "German",
          "Italian",
          "Japanese",
          "Korean",
          "Latvian",
          "Norwegian",
          "Portuguese",
          "Spanish",
          "Swedish"
        ],
        "title": "DocumentsQALanguage",
        "type": "string"
      },
      "EmbeddingAPIRequest": {
        "additionalProperties": false,
        "properties": {
          "dimensions": {
            "description": "The number of dimensions the resulting output embeddings should have. Only supported for certain models.",
            "title": "Dimensions",
            "type": "integer"
          },
          "encodingFormat": {
            "$ref": "#/components/schemas/EncodingFormat",
            "default": "float",
            "description": "The encoding for the document. Currently, we only support float."
          },
          "items": {
            "description": "List of items to create Embeddings for.",
            "items": {
              "$ref": "#/components/schemas/EmbeddingsAPIRequestItem"
            },
            "maxItems": 100,
            "minItems": 1,
            "title": "Items",
            "type": "array"
          },
          "model": {
            "$ref": "#/components/schemas/ValidEmbeddingModel",
            "description": "The model to use for vectorization."
          }
        },
        "required": [
          "model",
          "items"
        ],
        "title": "EmbeddingAPIRequest",
        "type": "object"
      },
      "EmbeddingAPIResponse": {
        "additionalProperties": false,
        "properties": {
          "dimensions": {
            "description": "The number of dimensions the resulting output embeddings should have. Only supported for certain models.",
            "title": "Dimensions",
            "type": "integer"
          },
          "encodingFormat": {
            "$ref": "#/components/schemas/EncodingFormat",
            "default": "float",
            "description": "The encoding for the document. Currently, we only support float."
          },
          "items": {
            "description": "List of Items that we created embeddings for.",
            "items": {
              "$ref": "#/components/schemas/EmbeddingAPIResponseItem"
            },
            "title": "Items",
            "type": "array"
          },
          "model": {
            "$ref": "#/components/schemas/ValidEmbeddingModel",
            "description": "The model to use for vectorization."
          }
        },
        "required": [
          "model",
          "items"
        ],
        "title": "EmbeddingAPIResponse",
        "type": "object"
      },
      "EmbeddingAPIResponseItem": {
        "additionalProperties": false,
        "properties": {
          "embedding": {
            "description": "The Embedding results for the text requested.",
            "items": {
              "type": "number"
            },
            "title": "Embedding",
            "type": "array"
          },
          "text": {
            "description": "The text data that will be vectorized.",
            "maxLength": 1000000,
            "title": "Text",
            "type": "string"
          }
        },
        "required": [
          "text",
          "embedding"
        ],
        "title": "EmbeddingAPIResponseItem",
        "type": "object"
      },
      "EmbeddingsAPIRequestItem": {
        "additionalProperties": false,
        "properties": {
          "text": {
            "description": "The text data that will be vectorized.",
            "maxLength": 1000000,
            "title": "Text",
            "type": "string"
          }
        },
        "required": [
          "text"
        ],
        "title": "EmbeddingsAPIRequestItem",
        "type": "object"
      },
      "EncodingFormat": {
        "const": "float",
        "enum": [
          "float"
        ],
        "title": "EncodingFormat",
        "type": "string"
      },
      "ExternalHostOptions": {
        "const": "AZURE_OPEN_AI",
        "enum": [
          "AZURE_OPEN_AI"
        ],
        "title": "ExternalHostOptions",
        "type": "string"
      },
      "FunctionParameters": {
        "additionalProperties": false,
        "properties": {
          "description": {
            "description": "A description of the parameter",
            "title": "Description",
            "type": "string"
          },
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/GenericProperties"
            },
            "description": "Properties are used to define the format of input/output data. Represents a select subset of an OpenAPI 3.0 schema object. **NOTE**: Fields that are not supported by underlying models will be ignored.",
            "title": "Properties",
            "type": "object"
          },
          "propertyOrdering": {
            "description": "The order of the properties",
            "items": {
              "type": "string"
            },
            "title": "Propertyordering",
            "type": "array"
          },
          "required": {
            "description": "The required properties of the parameter",
            "items": {
              "type": "string"
            },
            "title": "Required",
            "type": "array"
          },
          "type": {
            "const": "object",
            "description": "The type of the parameter",
            "enum": [
              "object"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "title": "FunctionParameters",
        "type": "object"
      },
      "GenericProperties": {
        "additionalProperties": false,
        "example": {
          "default": "East",
          "description": "Description of the parameter",
          "enum": [
            "East",
            "West",
            "North",
            "South"
          ],
          "example": "South",
          "format": "enum",
          "items": {},
          "maxItems": 3,
          "maxLength": 4,
          "maxProperties": 5,
          "maximum": 4,
          "minItems": 1,
          "minLength": 4,
          "minProperties": 1,
          "minimum": 4,
          "nullable": true,
          "pattern": "^(North|South|East|West)$",
          "properties": {},
          "propertyOrdering": [
            "North",
            "South",
            "East",
            "West"
          ],
          "required": [],
          "title": "Title of the parameter",
          "type": "string"
        },
        "properties": {
          "anyOf": {
            "description": "The anyOf values of the parameter",
            "items": {
              "$ref": "#/components/schemas/GenericProperties"
            },
            "title": "Anyof",
            "type": "array"
          },
          "default": {
            "description": "The default value of the parameter",
            "title": "Default"
          },
          "description": {
            "description": "A description of the parameter",
            "title": "Description",
            "type": "string"
          },
          "enum": {
            "description": "The enum values of the parameter",
            "items": {
              "type": "string"
            },
            "title": "Enum",
            "type": "array"
          },
          "format": {
            "description": "The format of the data. Supported formats: for 'number' type: 'float', 'double' for 'integer' type: 'int32', 'int64' for 'string' type: 'email', 'byte', etc.",
            "title": "Format",
            "type": "string"
          },
          "items": {
            "$ref": "#/components/schemas/GenericProperties",
            "description": "The items of the parameter for type 'array'"
          },
          "maxItems": {
            "description": "Maximum number of the elements for type 'array'",
            "title": "Maxitems",
            "type": "integer"
          },
          "maxLength": {
            "description": "Maximum length of the parameter for type 'string'",
            "title": "Maxlength",
            "type": "integer"
          },
          "maximum": {
            "description": "Maximum value for the parameter for type 'number' and 'integer'",
            "title": "Maximum",
            "type": "integer"
          },
          "minItems": {
            "description": "Minimum number of the elements for type 'array'",
            "title": "Minitems",
            "type": "integer"
          },
          "minLength": {
            "description": "Minimum length of the parameter for type 'string'",
            "title": "Minlength",
            "type": "integer"
          },
          "minimum": {
            "description": "Minimum value for the parameter for type 'number' and 'integer'",
            "title": "Minimum",
            "type": "integer"
          },
          "nullable": {
            "description": "Whether the parameter can be null",
            "title": "Nullable",
            "type": "boolean"
          },
          "pattern": {
            "description": "The regular expression pattern of the parameter for type 'string'",
            "title": "Pattern",
            "type": "string"
          },
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/GenericProperties"
            },
            "description": "The properties of the parameter for type 'object'",
            "title": "Properties",
            "type": "object"
          },
          "propertyOrdering": {
            "description": "The order of the properties",
            "items": {
              "type": "string"
            },
            "title": "Propertyordering",
            "type": "array"
          },
          "required": {
            "description": "The required properties of the parameter for type 'object'",
            "items": {
              "type": "string"
            },
            "title": "Required",
            "type": "array"
          },
          "title": {
            "description": "The title of the schema",
            "title": "Title",
            "type": "string"
          },
          "type": {
            "description": "The type of the parameter",
            "enum": [
              "object",
              "array",
              "boolean",
              "integer",
              "number",
              "string"
            ],
            "title": "Type",
            "type": "string"
          }
        },
        "required": [
          "type"
        ],
        "title": "GenericProperties",
        "type": "object"
      },
      "GraphQLCompletionsRequest": {
        "additionalProperties": false,
        "properties": {
          "dataModelType": {
            "$ref": "#/components/schemas/DataModelTypeAI",
            "description": "Relevant data model type from a given data model"
          },
          "dataModels": {
            "description": "List of relevant Data models",
            "items": {
              "$ref": "#/components/schemas/cog_ai__tools__graphql__common__types__DataModel"
            },
            "maxItems": 80,
            "minItems": 1,
            "title": "Datamodels",
            "type": "array"
          },
          "prompt": {
            "description": "The query to generate GraphQL completions for",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Prompt",
            "type": "string"
          },
          "stream": {
            "default": true,
            "description": "Whether to stream back partial progress.",
            "title": "Stream",
            "type": "boolean"
          }
        },
        "required": [
          "prompt"
        ],
        "title": "GraphQLCompletionsRequest",
        "type": "object"
      },
      "InstanceIdAI": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "description": "The Data Modeling external ID of the document.",
            "pattern": "^[^\u0000]{1,256}$",
            "title": "Externalid",
            "type": "string"
          },
          "space": {
            "description": "The Data Modeling space of the document.",
            "pattern": "^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$",
            "title": "Space",
            "type": "string"
          }
        },
        "required": [
          "space",
          "externalId"
        ],
        "title": "InstanceIdAI",
        "type": "object"
      },
      "LanguageModelMetadata": {
        "additionalProperties": false,
        "properties": {
          "maxOutputTokens": {
            "description": "The number of tokens that can be generated by the model in a single request.",
            "title": "Maxoutputtokens",
            "type": "integer"
          },
          "maxTokens": {
            "description": "The number of input tokens that can be processed by the model in a single request.",
            "title": "Maxtokens",
            "type": "integer"
          },
          "name": {
            "description": "Language model name.",
            "title": "Name",
            "type": "string"
          },
          "native": {
            "description": "Indicates if the model is hosted in the same cloud as the project",
            "title": "Native",
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "native",
          "maxTokens",
          "maxOutputTokens"
        ],
        "title": "LanguageModelMetadata",
        "type": "object"
      },
      "LocationAI": {
        "additionalProperties": false,
        "properties": {
          "bottom": {
            "title": "Bottom",
            "type": "number"
          },
          "left": {
            "title": "Left",
            "type": "number"
          },
          "pageNumber": {
            "description": "The page number within the file. Page numbers start at 1.",
            "title": "Pagenumber",
            "type": "integer"
          },
          "right": {
            "title": "Right",
            "type": "number"
          },
          "top": {
            "title": "Top",
            "type": "number"
          }
        },
        "required": [
          "pageNumber",
          "left",
          "right",
          "top",
          "bottom"
        ],
        "title": "LocationAI",
        "type": "object"
      },
      "QueryCompletionsRequest": {
        "additionalProperties": false,
        "properties": {
          "dataModels": {
            "description": "List of relevant Data models",
            "items": {
              "$ref": "#/components/schemas/cog_ai__tools__query__generate__common__types__DataModel"
            },
            "maxItems": 80,
            "minItems": 1,
            "title": "Datamodels",
            "type": "array"
          },
          "filterFormat": {
            "default": "legacy",
            "description": "Format for generated filters.",
            "enum": [
              "legacy",
              "dms"
            ],
            "title": "Filterformat",
            "type": "string"
          },
          "prompt": {
            "description": "The prompt to generate query completions from",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Prompt",
            "type": "string"
          },
          "propertyFormat": {
            "default": "legacy",
            "description": "Format for generated properties.",
            "enum": [
              "legacy",
              "dms"
            ],
            "title": "Propertyformat",
            "type": "string"
          },
          "stream": {
            "default": true,
            "description": "Whether to stream back partial progress.",
            "title": "Stream",
            "type": "boolean"
          }
        },
        "required": [
          "prompt",
          "dataModels"
        ],
        "title": "QueryCompletionsRequest",
        "type": "object"
      },
      "RcaRequest": {
        "additionalProperties": false,
        "properties": {
          "customLanguageModel": {
            "$ref": "#/components/schemas/CustomLanguageModelRequest",
            "description": "optional parameters to override language model, must include endpoint and credentials"
          },
          "maxTokens": {
            "default": 2000,
            "description": "The maximum number of tokens to generate in the completion. The token count of your prompt plus maxTokens can't exceed the model's context length",
            "exclusiveMinimum": 0,
            "title": "Maxtokens",
            "type": "integer"
          },
          "messageHistory": {
            "default": [],
            "description": "Previously executed messages.",
            "items": {
              "type": "object"
            },
            "title": "Messagehistory",
            "type": "array"
          },
          "prompt": {
            "description": "User prompt",
            "maxLength": 2048,
            "minLength": 1,
            "title": "Prompt",
            "type": "string"
          }
        },
        "required": [
          "prompt"
        ],
        "title": "RcaRequest",
        "type": "object"
      },
      "ReferenceAI": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "description": "The external id of the file",
            "title": "Externalid",
            "type": "string"
          },
          "fileId": {
            "description": "The id of the file",
            "title": "Fileid",
            "type": "integer"
          },
          "fileName": {
            "description": "The name of the file",
            "title": "Filename",
            "type": "string"
          },
          "instanceId": {
            "$ref": "#/components/schemas/InstanceId",
            "description": "The instance id of the file"
          },
          "locations": {
            "description": "The locations in the document that contain the relevant text",
            "items": {
              "$ref": "#/components/schemas/LocationAI"
            },
            "title": "Locations",
            "type": "array"
          }
        },
        "required": [
          "fileId",
          "fileName",
          "locations"
        ],
        "title": "ReferenceAI",
        "type": "object"
      },
      "ResponseDataModelView": {
        "properties": {
          "externalId": {
            "description": "The external ID of the data model",
            "maxLength": 255,
            "minLength": 1,
            "title": "Externalid",
            "type": "string"
          },
          "space": {
            "description": "The space the data model is in",
            "maxLength": 43,
            "minLength": 1,
            "title": "Space",
            "type": "string"
          },
          "version": {
            "description": "The version of the data model",
            "title": "Version",
            "type": "string"
          },
          "view": {
            "description": "Relevant data model view",
            "maxLength": 255,
            "minLength": 1,
            "title": "View",
            "type": "string"
          },
          "views": {
            "description": "The views of the data model",
            "items": {
              "type": "string"
            },
            "title": "Views",
            "type": "array"
          }
        },
        "required": [
          "space",
          "externalId",
          "version",
          "view"
        ],
        "title": "ResponseDataModelView",
        "type": "object"
      },
      "SearchExecutionRequest": {
        "additionalProperties": false,
        "properties": {
          "aggregate": {
            "$ref": "#/components/schemas/AggregateObjectRequest",
            "description": "The aggregate object - must be filled out if operation is 'aggregate'"
          },
          "dataModelView": {
            "$ref": "#/components/schemas/DataModelViewAI",
            "description": "Relevant data model view from a given data model"
          },
          "filter": {
            "description": "Filters to apply to the query",
            "title": "Filter",
            "type": "object"
          },
          "filterFormat": {
            "default": "legacy",
            "description": "Format to generate filters.",
            "enum": [
              "legacy",
              "dms"
            ],
            "title": "Filterformat",
            "type": "string"
          },
          "limit": {
            "default": 20,
            "description": "The limit of the query",
            "maximum": 100,
            "minimum": 1,
            "title": "Limit",
            "type": "integer"
          },
          "operation": {
            "description": "The query operation to complete",
            "enum": [
              "list",
              "search",
              "aggregate"
            ],
            "title": "Operation",
            "type": "string"
          },
          "properties": {
            "description": "Relevant properties for the data model view",
            "oneOf": [
              {
                "additionalProperties": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "type": "object"
              },
              {
                "items": {
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "additionalProperties": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      },
                      "type": "object"
                    }
                  ]
                },
                "type": "array"
              }
            ],
            "title": "Properties"
          },
          "search": {
            "$ref": "#/components/schemas/SearchObjectRequest",
            "description": "The search object - must be filled out if operation is 'search'"
          },
          "sort": {
            "default": [],
            "description": "The sort object",
            "items": {
              "$ref": "#/components/schemas/SortObjectRequest"
            },
            "maxItems": 2,
            "title": "Sort",
            "type": "array"
          }
        },
        "required": [
          "dataModelViewAI",
          "operation",
          "properties"
        ],
        "title": "SearchExecutionRequest",
        "type": "object"
      },
      "SearchExecutionResponse": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "description": "Data Returned For Query",
            "items": {},
            "title": "Items",
            "type": "array"
          }
        },
        "required": [
          "items"
        ],
        "title": "SearchExecutionResponse",
        "type": "object"
      },
      "SearchObjectRequest": {
        "additionalProperties": false,
        "properties": {
          "fields": {
            "description": "Fields to search against",
            "items": {
              "type": "string"
            },
            "maxItems": 5,
            "minItems": 0,
            "title": "Fields",
            "type": "array"
          },
          "query": {
            "description": "The search query.",
            "maxLength": 1000,
            "minLength": 1,
            "title": "Query",
            "type": "string"
          }
        },
        "required": [
          "query",
          "fields"
        ],
        "title": "SearchObjectRequest",
        "type": "object"
      },
      "ServiceInfo": {
        "additionalProperties": false,
        "properties": {
          "available": {
            "description": "Whether service is available.",
            "examples": [
              true
            ],
            "title": "Available",
            "type": "boolean"
          },
          "defaultLanguageModel": {
            "default": "default",
            "description": "Default language model",
            "examples": [
              "azure/gpt-4o"
            ],
            "title": "Defaultlanguagemodel",
            "type": "string"
          },
          "name": {
            "description": "Service name.",
            "examples": [
              "Chat completions"
            ],
            "title": "Name",
            "type": "string"
          },
          "path": {
            "description": "Service path.",
            "examples": [
              "/ai/chat/completions"
            ],
            "title": "Path",
            "type": "string"
          },
          "supportedLanguageModels": {
            "default": [
              "default"
            ],
            "description": "Available language models",
            "examples": [
              [
                "azure/gpt-4o",
                "azure/gpt-4o-mini"
              ]
            ],
            "oneOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/ValidLanguageModel"
                },
                "type": "array"
              },
              {
                "items": {
                  "const": "default",
                  "enum": [
                    "default"
                  ],
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "title": "Supportedlanguagemodels"
          }
        },
        "required": [
          "name",
          "path",
          "available"
        ],
        "title": "ServiceInfo",
        "type": "object"
      },
      "ServiceInfoResponse": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "description": "Service availability information.",
            "items": {
              "$ref": "#/components/schemas/ServiceInfo"
            },
            "title": "Items",
            "type": "array"
          },
          "languageModels": {
            "description": "Language model metadata.",
            "items": {
              "$ref": "#/components/schemas/LanguageModelMetadata"
            },
            "title": "Languagemodels",
            "type": "array"
          }
        },
        "required": [
          "items",
          "languageModels"
        ],
        "title": "ServiceInfoResponse",
        "type": "object"
      },
      "SortObjectRequest": {
        "additionalProperties": false,
        "properties": {
          "direction": {
            "default": "ascending",
            "description": "The sort direction",
            "enum": [
              "ascending",
              "descending"
            ],
            "title": "Direction",
            "type": "string"
          },
          "field": {
            "description": "The field to sort by",
            "maxLength": 255,
            "minLength": 1,
            "title": "Field",
            "type": "string"
          }
        },
        "required": [
          "field"
        ],
        "title": "SortObjectRequest",
        "type": "object"
      },
      "StreamChoice": {
        "additionalProperties": false,
        "description": "Streaming responses have a 'delta' field rather than a message field with\noptional 'role' and 'content' fields, as well as an optional 'finishReason' field",
        "properties": {
          "delta": {
            "$ref": "#/components/schemas/StreamDelta",
            "description": "The incremental changes to the conversation"
          },
          "finish_reason": {
            "description": "The reason the conversation ended",
            "title": "Finish Reason",
            "type": "string"
          },
          "index": {
            "description": "The index of the choice in the list of choices.",
            "title": "Index",
            "type": "integer"
          }
        },
        "required": [
          "delta",
          "index"
        ],
        "title": "StreamChoice",
        "type": "object"
      },
      "StreamDelta": {
        "additionalProperties": false,
        "description": "When using streaming, 'role' and 'content' are optional",
        "properties": {
          "content": {
            "description": "The contents of the message.",
            "title": "Content",
            "type": "string"
          },
          "function_call": {
            "$ref": "#/components/schemas/ChatCompletionsFunctionCall",
            "description": "The name and arguments of a function that should be called, as generated by the model."
          },
          "name": {
            "description": "The name of a function in a function call.",
            "title": "Name",
            "type": "string"
          },
          "role": {
            "$ref": "#/components/schemas/ChatMessageRole",
            "description": "The role of the author of this message."
          },
          "tool_call_id": {
            "description": "The ID of the tool to be called",
            "title": "Tool Call Id",
            "type": "string"
          },
          "tool_calls": {
            "description": "The tools to be called",
            "items": {
              "$ref": "#/components/schemas/ChatCompletionsStreamToolCall"
            },
            "title": "Tool Calls",
            "type": "array"
          }
        },
        "title": "StreamDelta",
        "type": "object"
      },
      "Usage": {
        "additionalProperties": false,
        "properties": {
          "completion_tokens": {
            "description": "The number of tokens the completion used",
            "title": "Completion Tokens",
            "type": "integer"
          },
          "prompt_tokens": {
            "description": "The number of tokens in the prompt",
            "title": "Prompt Tokens",
            "type": "integer"
          },
          "total_tokens": {
            "description": "The total number of tokens",
            "title": "Total Tokens",
            "type": "integer"
          }
        },
        "required": [
          "completion_tokens",
          "prompt_tokens",
          "total_tokens"
        ],
        "title": "Usage",
        "type": "object"
      },
      "ValidEmbeddingModel": {
        "enum": [
          "azure/text-embedding-ada-002",
          "azure/text-embedding-3-small",
          "azure/text-embedding-3-large"
        ],
        "title": "ValidEmbeddingModel",
        "type": "string"
      },
      "ValidLanguageModel": {
        "enum": [
          "azure/gpt-4",
          "azure/gpt-4-turbo",
          "azure/gpt-4o",
          "azure/gpt-4o-mini",
          "gcp/gemini-1.5-pro",
          "gcp/gemini-1.5-flash",
          "aws/claude-3.5-sonnet",
          "aws/claude-3-haiku"
        ],
        "title": "ValidLanguageModel",
        "type": "string"
      },
      "cog_ai__tools__graphql__common__types__DataModel": {
        "properties": {
          "externalId": {
            "description": "The external ID of the data model",
            "maxLength": 255,
            "minLength": 1,
            "title": "Externalid",
            "type": "string"
          },
          "space": {
            "description": "The space the data model is in",
            "maxLength": 43,
            "minLength": 1,
            "title": "Space",
            "type": "string"
          },
          "version": {
            "description": "The version of the data model",
            "title": "Version",
            "type": "string"
          }
        },
        "required": [
          "space",
          "externalId",
          "version"
        ],
        "title": "DataModelAI",
        "type": "object"
      },
      "cog_ai__tools__query__generate__common__types__DataModel": {
        "properties": {
          "externalId": {
            "description": "The external ID of the data model",
            "maxLength": 255,
            "minLength": 1,
            "title": "Externalid",
            "type": "string"
          },
          "space": {
            "description": "The space the data model is in",
            "maxLength": 43,
            "minLength": 1,
            "title": "Space",
            "type": "string"
          },
          "version": {
            "description": "The version of the data model",
            "title": "Version",
            "type": "string"
          },
          "views": {
            "description": "The views of the data model",
            "items": {
              "type": "string"
            },
            "title": "Views",
            "type": "array"
          }
        },
        "required": [
          "space",
          "externalId",
          "version"
        ],
        "title": "DataModelAI",
        "type": "object"
      },
      "jobId": {
        "description": "ID for Document Parser job"
      },
      "DocumentParserFileId": {
        "type": "integer",
        "example": 1234,
        "description": "The ID of a file in CDF.",
        "format": "int64"
      },
      "DocumentParserFileExternalId": {
        "type": "string",
        "example": "1234",
        "description": "The external ID of a file in CDF."
      },
      "DocumentParserInstanceId": {
        "type": "object",
        "required": [
          "space",
          "externalId"
        ],
        "example": {
          "space": "space",
          "externalId": "externalId"
        },
        "description": "The instance id of a file in CDF.",
        "properties": {
          "space": {
            "$ref": "#/components/schemas/InstanceSpace"
          },
          "externalId": {
            "$ref": "#/components/schemas/InstanceExternalId"
          }
        }
      },
      "DocumentParserFileReference": {
        "type": "object",
        "required": [
          "fileId",
          "fileExternalId",
          "fileInstanceId"
        ],
        "description": "An external-id or instance-id reference to the referenced file.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "fileId"
            ],
            "properties": {
              "fileId": {
                "$ref": "#/components/schemas/DocumentParserFileId"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "fileExternalId"
            ],
            "properties": {
              "fileExternalId": {
                "$ref": "#/components/schemas/DocumentParserFileExternalId"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "fileInstanceId"
            ],
            "properties": {
              "fileInstanceId": {
                "$ref": "#/components/schemas/DocumentParserInstanceId"
              }
            }
          }
        ]
      },
      "DocumentParserStartJobRequest": {
        "type": "object",
        "required": [
          "viewConfig",
          "files"
        ],
        "properties": {
          "viewConfig": {
            "$ref": "#/components/schemas/ViewConfig"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentParserFileReference"
            }
          },
          "node": {
            "$ref": "#/components/schemas/Node"
          }
        }
      },
      "DocumentParserResult": {
        "type": "object",
        "required": [
          "jobStatus"
        ],
        "properties": {
          "resultSchema": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            },
            "description": "A dictionary of extracted key-value pairs."
          },
          "viewConfig": {
            "$ref": "#/components/schemas/ViewConfigPlus"
          },
          "scores": {
            "$ref": "#/components/schemas/Scores"
          },
          "rawResponses": {
            "$ref": "#/components/schemas/RawResponses"
          },
          "data": {
            "$ref": "#/components/schemas/RawResponses"
          }
        }
      },
      "RawResponseItemCore": {
        "type": "object",
        "properties": {
          "fileId": {
            "type": "integer",
            "description": "The internal ID for the File."
          },
          "pageNum": {
            "type": "integer",
            "description": "Page number the answer is in."
          },
          "propertyId": {
            "type": "string",
            "description": "property_id of the View"
          },
          "spatialData": {
            "$ref": "#/components/schemas/SpatialData",
            "description": "The relative position in the document where the data was found."
          },
          "value": {
            "type": "object",
            "description": "The extracted value returned in the expected data type."
          },
          "selectedAnswerIndex": {
            "type": "integer",
            "description": "This field is the index of the selected answer. If index is -1, it means that the main answer is selected. If index is 0 or greater, it means that the answer at that index in the other_answers list is selected."
          }
        },
        "required": [
          "fileId",
          "pageNum",
          "propertyId",
          "spatialData",
          "value"
        ]
      },
      "RawResponseItem": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RawResponseItemCore"
          },
          {
            "type": "object",
            "properties": {
              "otherAnswers": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/RawResponseItemCore"
                }
              }
            }
          }
        ],
        "required": [
          "otherAnswers"
        ]
      },
      "SpatialData": {
        "type": "object",
        "properties": {
          "xMax": {
            "type": "number",
            "format": "double",
            "description": "Normalized x coordinate."
          },
          "xMin": {
            "type": "number",
            "format": "double",
            "description": "Normalized x coordinate."
          },
          "yMax": {
            "type": "number",
            "format": "double",
            "description": "Normalized x coordinate."
          },
          "yMin": {
            "type": "number",
            "format": "double",
            "description": "Normalized x coordinate."
          }
        },
        "required": [
          "xMax",
          "xMin",
          "yMax",
          "yMin"
        ]
      },
      "RawResponses": {
        "type": "object",
        "description": "A dictionary where each key represents a property name (e.g., 'operatingPressure') and the value is a 'RawResponseItem' schema.\n",
        "additionalProperties": {
          "$ref": "#/components/schemas/RawResponseItem"
        }
      },
      "DocumentParserListRequest": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "default": 100,
            "maximum": 1000
          },
          "filter": {
            "$ref": "#/components/schemas/DocumentParserFilter"
          },
          "cursor": {
            "type": "string",
            "description": "Cursor for paging through results."
          }
        }
      },
      "DocumentParserListResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentParserJob"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "DocumentParserUpdateRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentParserUpdateRequestItem"
            }
          }
        }
      },
      "DocumentParserUpdateResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentParserUpdateResponseItem"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "DocumentParserUpdateResponseItem": {
        "type": "object",
        "properties": {
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "updatedTimestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "status": {
            "$ref": "#/components/schemas/DocumentParserStatus"
          }
        },
        "required": [
          "job_id",
          "updatedTimestamp",
          "validationStatus",
          "viewStatus"
        ]
      },
      "DocumentParserWriteResultsRequest": {
        "type": "object",
        "required": [
          "jobId",
          "data"
        ],
        "properties": {
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "data": {
            "$ref": "#/components/schemas/RawResponses"
          },
          "node": {
            "$ref": "#/components/schemas/Node"
          }
        }
      },
      "DocumentParserWriteResultsResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "jobId": {
                  "$ref": "#/components/schemas/JobId"
                },
                "viewStatus": {
                  "$ref": "#/components/schemas/ViewStatus"
                },
                "node": {
                  "$ref": "#/components/schemas/Node"
                }
              },
              "required": [
                "jobId",
                "viewStatus",
                "node"
              ]
            }
          }
        }
      },
      "ViewConfig": {
        "type": "object",
        "description": "The view the job is based on.\n",
        "properties": {
          "space": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "version": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSVersion"
              }
            ]
          }
        }
      },
      "Node": {
        "type": "object",
        "description": "The node ID where the job results.\n",
        "properties": {
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NodeOrEdgeExternalId"
              }
            ]
          },
          "space": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          }
        }
      },
      "ViewConfigPlus": {
        "type": "object",
        "description": "The view the job is based on.\n",
        "properties": {
          "space": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SpaceSpecification"
              }
            ]
          },
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSExternalId"
              }
            ]
          },
          "version": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DMSVersion"
              }
            ]
          },
          "description": {
            "type": "string",
            "description": "Description of the View"
          },
          "name": {
            "type": "string",
            "description": "Name of the View"
          },
          "title": {
            "type": "string",
            "description": "Title of the View"
          }
        }
      },
      "ValidationStatus": {
        "type": "string",
        "enum": [
          "not_ready",
          "ready",
          "approved",
          "rejected"
        ],
        "description": "The status of document parser validation, which can be not ready, ready for review, approved, or rejected.\n"
      },
      "ViewStatus": {
        "type": "string",
        "enum": [
          "instance_updated",
          "instance_created",
          "waiting"
        ],
        "description": "The status of the instance written to the View of Data Models.\n"
      },
      "DocumentParserJob": {
        "type": "object",
        "required": [
          "jobId",
          "updatedTimestamp",
          "createdTimestamp",
          "viewConfig",
          "node",
          "status",
          "files",
          "result"
        ],
        "properties": {
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "createdTimestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "updatedTimestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "viewConfig": {
            "$ref": "#/components/schemas/ViewConfig"
          },
          "node": {
            "$ref": "#/components/schemas/Node"
          },
          "status": {
            "$ref": "#/components/schemas/DocumentParserStatus"
          },
          "files": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentParserFileReference"
            }
          },
          "result": {
            "$ref": "#/components/schemas/DocumentParserResult"
          }
        }
      },
      "DocumentParserUpdateRequestItem": {
        "type": "object",
        "properties": {
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "validationStatus": {
            "$ref": "#/components/schemas/ValidationStatus"
          },
          "data": {
            "$ref": "#/components/schemas/RawResponses"
          }
        }
      },
      "DocumentParserFilter": {
        "type": "object",
        "properties": {
          "validationStatus": {
            "$ref": "#/components/schemas/ValidationStatus"
          }
        }
      },
      "DocumentParserStartJobResponse": {
        "type": "object",
        "properties": {
          "createdTimestamp": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "jobId": {
            "$ref": "#/components/schemas/JobId"
          },
          "status": {
            "$ref": "#/components/schemas/JobStatus"
          }
        },
        "required": [
          "createdTimestamp",
          "jobId",
          "status"
        ]
      },
      "DocumentParserStatus": {
        "type": "object",
        "description": "The status field containing information about the job status, view status, and validation status.\n",
        "properties": {
          "job": {
            "$ref": "#/components/schemas/JobStatus"
          },
          "view": {
            "$ref": "#/components/schemas/ViewStatus"
          },
          "validation": {
            "$ref": "#/components/schemas/ValidationStatus"
          }
        },
        "required": [
          "jobStatus",
          "viewStatus",
          "validationStatus"
        ]
      },
      "Scores": {
        "type": "object",
        "properties": {
          "completenessScore": {
            "$ref": "#/components/schemas/ScoreItem"
          },
          "typeScore": {
            "$ref": "#/components/schemas/ScoreItem"
          }
        },
        "required": [
          "completenessScore",
          "typeScore"
        ],
        "description": "Currently supports two scoring metrics: 'completenessScore' and 'typeScore'.\n"
      },
      "ScoreItem": {
        "type": "object",
        "properties": {
          "error_count": {
            "type": "integer"
          },
          "score": {
            "type": "number",
            "format": "double"
          },
          "status": {
            "type": "string"
          }
        },
        "required": [
          "error_count",
          "score",
          "status"
        ],
        "description": "Represents a scoring item, including the count of errors, a numeric score, and a status message. The score is a float value, while the status message provides additional details or context about the score.\n"
      },
      "DocumentParserByJobIdsRequest": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "jobId": {
                  "$ref": "#/components/schemas/JobId"
                }
              },
              "required": [
                "jobId"
              ]
            }
          }
        }
      },
      "DocumentSearchRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearch"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchAggregates"
          },
          {
            "$ref": "#/components/schemas/DocumentSort"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchLimit"
          },
          {
            "$ref": "#/components/schemas/DocumentCursor"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchHighlight"
          }
        ]
      },
      "DocumentSemanticSearchRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSemanticSearchFilter"
          },
          {
            "$ref": "#/components/schemas/DocumentSemanticSearchPassageExpansion"
          },
          {
            "$ref": "#/components/schemas/DocumentSemanticSearchLimit"
          }
        ]
      },
      "DocumentPassagesSearchRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentPassagesSearchFilter"
          },
          {
            "$ref": "#/components/schemas/DocumentPassagesSearchPassageExpansion"
          },
          {
            "$ref": "#/components/schemas/DocumentPassagesSearchLimit"
          }
        ]
      },
      "DocumentStatusOldRequest": {
        "required": [
          "items"
        ],
        "description": "List of document ids to check the status for.",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            }
          },
          "includeStatistics": {
            "type": "boolean",
            "description": "Whether or not to include statistics about the document. This gives additional insight such as the number of pages, number of vectors, etc.",
            "default": false
          }
        }
      },
      "DocumentStatusRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IgnoreUnknownIdsField"
          },
          {
            "type": "object",
            "required": [
              "items"
            ],
            "description": "List of document ids to check the status for.",
            "properties": {
              "items": {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "type": "object",
                      "required": [
                        "id"
                      ],
                      "properties": {
                        "id": {
                          "$ref": "#/components/schemas/CogniteInternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "externalId"
                      ],
                      "properties": {
                        "externalId": {
                          "$ref": "#/components/schemas/CogniteExternalId"
                        }
                      }
                    },
                    {
                      "type": "object",
                      "required": [
                        "instanceId"
                      ],
                      "properties": {
                        "instanceId": {
                          "$ref": "#/components/schemas/CogniteInstanceId"
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        ]
      },
      "DocumentListRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentListFilter"
          },
          {
            "$ref": "#/components/schemas/DocumentSort"
          },
          {
            "$ref": "#/components/schemas/DocumentListLimit"
          },
          {
            "$ref": "#/components/schemas/DocumentCursor"
          }
        ]
      },
      "DocumentContentRequest": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentContentInternalId"
          },
          {
            "$ref": "#/components/schemas/DocumentContentExternalId"
          },
          {
            "$ref": "#/components/schemas/DocumentContentInstanceId"
          }
        ]
      },
      "DocumentElementsRequest": {
        "type": "object",
        "properties": {
          "granularity": {
            "type": "string",
            "description": "Adjust the level of detail in the response.",
            "enum": [
              "WORDS",
              "ELEMENTS",
              "LINES"
            ],
            "default": "WORDS"
          }
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentContentInternalId"
          },
          {
            "$ref": "#/components/schemas/DocumentContentExternalId"
          },
          {
            "$ref": "#/components/schemas/DocumentContentInstanceId"
          }
        ]
      },
      "DocumentContentInternalId": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        }
      },
      "DocumentContentExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "DocumentContentInstanceId": {
        "type": "object",
        "required": [
          "instanceId"
        ],
        "properties": {
          "instanceId": {
            "$ref": "#/components/schemas/CogniteInstanceId"
          }
        }
      },
      "DocumentSearchFilter": {
        "description": "Filter with exact match",
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/DocumentFilter"
          }
        }
      },
      "DocumentSemanticSearchFilter": {
        "description": "Narrow down search results. You must specify exactly one `semanticSearch` filter.",
        "type": "object",
        "required": [
          "filter"
        ],
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/DocumentSemanticFilter"
          }
        }
      },
      "DocumentPassagesSearchFilter": {
        "description": "Narrow down search results. You must specify atleast one filter of type `semanticSearch`, `lexicalSearch` or both.",
        "type": "object",
        "required": [
          "filter"
        ],
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/DocumentPassagesFilter"
          }
        }
      },
      "DocumentSemanticSearchVectorspace": {
        "description": "Limit search to namespace",
        "type": "object",
        "required": [
          "namespace"
        ],
        "properties": {
          "namespace": {
            "type": "string"
          }
        }
      },
      "DocumentListFilter": {
        "description": "Filter with exact match",
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/DocumentFilter"
          }
        }
      },
      "DocumentSearchLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items. When using highlights the maximum value is reduced to 20.",
            "type": "integer",
            "format": "int32",
            "minimum": 0,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DocumentSemanticSearchPassageExpansionSymmetric": {
        "type": "object",
        "required": [
          "strategy",
          "chunk_count"
        ],
        "properties": {
          "strategy": {
            "description": "Expand the passage with adjacent passages that exists before and after a passage.",
            "type": "string",
            "enum": [
              "symmetric"
            ],
            "default": "symmetric"
          },
          "chunk_count": {
            "description": "Number of passages to expand a given passage by",
            "type": "integer",
            "minimum": 1,
            "maximum": 4
          }
        }
      },
      "DocumentSemanticSearchPassageExpansion": {
        "type": "object",
        "required": [
          "expansionStrategy"
        ],
        "properties": {
          "expansionStrategy": {
            "description": "A expansion strategy to to increase the text view for each passage returned. Helpful to increase context for an LLM.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/DocumentSemanticSearchPassageExpansionSymmetric"
              }
            ]
          }
        }
      },
      "DocumentSemanticSearchLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 10,
            "default": 10
          }
        }
      },
      "DocumentPassagesSearchPassageExpansionSymmetric": {
        "type": "object",
        "required": [
          "strategy",
          "chunk_count"
        ],
        "properties": {
          "strategy": {
            "description": "Expand the passage with adjacent passages that exists before and after a passage.",
            "type": "string",
            "enum": [
              "symmetric"
            ],
            "default": "symmetric"
          },
          "chunk_count": {
            "description": "Number of passages to expand a given passage by",
            "type": "integer",
            "minimum": 1,
            "maximum": 4
          }
        }
      },
      "DocumentPassagesSearchPassageExpansion": {
        "type": "object",
        "required": [
          "expansionStrategy"
        ],
        "properties": {
          "expansionStrategy": {
            "description": "A expansion strategy to to increase the text view for each passage returned. Helpful to increase context for an LLM.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/DocumentPassagesSearchPassageExpansionSymmetric"
              }
            ]
          }
        }
      },
      "DocumentPassagesSearchLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 10,
            "default": 10
          }
        }
      },
      "DocumentListLimit": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Maximum number of items per page. Use the cursor to get more pages.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "DocumentSort": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "array",
            "description": "List of properties to sort by. Currently only supports 1 property.",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentSortItem"
            }
          }
        }
      },
      "DocumentSortItem": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "order": {
            "type": "string",
            "enum": [
              "asc",
              "desc"
            ],
            "default": "asc"
          },
          "property": {
            "$ref": "#/components/schemas/DocumentFilterProperty"
          }
        }
      },
      "DocumentCursor": {
        "type": "object",
        "properties": {
          "cursor": {
            "description": "Cursor for paging through results.",
            "type": "string"
          }
        }
      },
      "DocumentSearchHighlight": {
        "type": "object",
        "properties": {
          "highlight": {
            "description": "Whether or not matches in search results should be highlighted.",
            "type": "boolean"
          }
        }
      },
      "DocumentSearchInAggregate": {
        "type": "object",
        "properties": {
          "search": {
            "type": "object",
            "required": [
              "query"
            ],
            "properties": {
              "query": {
                "type": "string",
                "description": "The free text search query as described in detail above.",
                "maxLength": 1000,
                "example": "cognite \"lorem ipsum\""
              }
            }
          }
        }
      },
      "DocumentSearch": {
        "type": "object",
        "properties": {
          "search": {
            "type": "object",
            "required": [
              "query"
            ],
            "properties": {
              "query": {
                "type": "string",
                "description": "The free text search query as described in detail above.",
                "maxLength": 1000,
                "example": "cognite \"lorem ipsum\""
              },
              "highlight": {
                "deprecated": true,
                "type": "boolean",
                "description": "Whether or not matches in search results should be highlighted.",
                "default": false
              }
            }
          }
        }
      },
      "DocumentSearchItem": {
        "type": "object",
        "required": [
          "item"
        ],
        "properties": {
          "highlight": {
            "$ref": "#/components/schemas/DocumentHighlight"
          },
          "item": {
            "$ref": "#/components/schemas/Document"
          }
        }
      },
      "DocumentSemanticSearchItem": {
        "type": "object",
        "required": [
          "item",
          "match"
        ],
        "description": "Each item contains the semantic match and the relevant document it belongs to.",
        "properties": {
          "match": {
            "$ref": "#/components/schemas/DocumentSemanticMatch"
          },
          "item": {
            "$ref": "#/components/schemas/Document"
          }
        }
      },
      "DocumentPassageLocation": {
        "type": "object",
        "description": "Insight about a search result",
        "properties": {
          "pageNumber": {
            "type": "number",
            "format": "int32"
          },
          "left": {
            "type": "number",
            "format": "float"
          },
          "right": {
            "type": "number",
            "format": "float"
          },
          "up": {
            "type": "number",
            "format": "float"
          },
          "bottom": {
            "type": "number",
            "format": "float"
          }
        },
        "example": {
          "page": 7,
          "left": 68.78,
          "right": 478.56,
          "top": 75.04,
          "bottom": 386.1
        }
      },
      "DocumentPassagesSearchItem": {
        "type": "object",
        "required": [
          "text",
          "locations",
          "document"
        ],
        "description": "Each item contains the semantic match and the relevant document it belongs to.",
        "example": {
          "text": "Pump installation\nFollow these 15 steps:\n ...",
          "document": {
            "id": 1234
          },
          "locations": [
            {
              "page_number": 3,
              "left": 68.78,
              "right": 478.56,
              "top": 75.04,
              "bottom": 386.1
            },
            {
              "page_number": 4,
              "left": 68.78,
              "right": 478.56,
              "top": 75.04,
              "bottom": 386.1
            }
          ]
        },
        "properties": {
          "text": {
            "type": "string",
            "description": "The text representing the document passage that was related to your search query."
          },
          "locations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentPassageLocation"
            }
          },
          "document": {
            "$ref": "#/components/schemas/PassageDocument"
          }
        }
      },
      "PassageDocument": {
        "type": "object",
        "required": [
          "id",
          "sourceFile"
        ],
        "description": "A document",
        "properties": {
          "id": {
            "description": "The unique identifier for the document. This is automatically generated by CDF, and will be the same as the corresponding value in the Files API.",
            "example": 2384,
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "externalId": {
            "example": "haml001",
            "description": "The external ID for the document. This field will be the same as the value set in the Files API.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          },
          "instanceId": {
            "description": "The instance ID for documents created through Data Modeling. This field will be the same as the value set in the Files API.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInstanceId"
              }
            ]
          },
          "sourceFile": {
            "$ref": "#/components/schemas/PassageSourceFile"
          }
        }
      },
      "PassageSourceFile": {
        "type": "object",
        "description": "The source file that this document is derived from.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the file.",
            "example": "hamlet.txt"
          },
          "hash": {
            "type": "string",
            "description": "The hash of the source file. This is a SHA256 hash of the original file. The hash only covers the file content, and not other CDF metadata.",
            "example": "23203f9264161714cdb8d2f474b9b641e6a735f8cea4098c40a3cab8743bd749"
          }
        }
      },
      "DocumentStatus": {
        "type": "object",
        "required": [
          "status",
          "available"
        ],
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "waiting",
              "running",
              "failed",
              "completed"
            ],
            "description": "The status of this specific document collection or endpoint. The collection is fully synced with the files api once the status is `completed`. However, when a file is being updated (eg. re-uploaded), the older version of the Document may still be available for search or other read operations (see the available field)."
          },
          "available": {
            "type": "boolean",
            "description": "Whether or not the collection/endpoint has available information. Note that this does not guarentee that the data is up to date, refer to `status` for the current progression."
          },
          "reason": {
            "type": "string",
            "description": "Provides additional insight when `status` is `failed`."
          }
        }
      },
      "DocumentStatusItem": {
        "type": "object",
        "required": [
          "passages",
          "content",
          "elements"
        ],
        "description": "Status information of different Documents collections.",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "instanceId": {
            "$ref": "#/components/schemas/CogniteInstanceId"
          },
          "passages": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentStatus"
              },
              {
                "type": "object",
                "description": "Status of the document passages collection used in semantic search queries.",
                "properties": {
                  "count": {
                    "type": "integer"
                  }
                }
              }
            ]
          },
          "elements": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentStatus"
              },
              {
                "type": "object",
                "description": "Status of the document layout analysis."
              }
            ]
          },
          "content": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentStatus"
              },
              {
                "type": "object",
                "description": "Status of the extracted textual information found in documents.",
                "properties": {
                  "pages": {
                    "type": "integer"
                  }
                }
              }
            ]
          }
        }
      },
      "DocumentStatusItemOld": {
        "type": "object",
        "required": [
          "id",
          "semanticSearch",
          "elements"
        ],
        "description": "Each item contains the semantic match and the relevant document it belongs to.",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "semanticSearch": {
            "type": "object",
            "required": [
              "status"
            ],
            "description": "Status of the document in the semantic search system.",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "waiting",
                  "ignored",
                  "error",
                  "indexed",
                  "progress"
                ],
                "description": "The status of the document in the semantic search index. File is searchable when the status is `indexed`."
              },
              "reason": {
                "type": "string",
                "description": "Provides additional insight for an error status."
              }
            }
          },
          "elements": {
            "type": "object",
            "required": [
              "status"
            ],
            "description": "Status of the document layout analysis.",
            "properties": {
              "status": {
                "type": "string",
                "enum": [
                  "waiting",
                  "ignored",
                  "error",
                  "indexed",
                  "progress"
                ],
                "description": "The status of the document for layout analysis. Document elements is retrievable when the status is `indexed`."
              },
              "reason": {
                "type": "string",
                "description": "Provides additional insight for an error status."
              }
            }
          },
          "statistics": {
            "type": "object",
            "description": "Statistics about the document. This is only available when setting `includeStatistics` to `true` in the request.",
            "properties": {
              "numberOfPages": {
                "type": "integer",
                "description": "The number of pages in the document. This is only available for documents that have been indexed."
              },
              "numberOfVectors": {
                "type": "integer",
                "description": "The number of vectors (passages) in the document. This is only available for documents that have been indexed."
              }
            }
          }
        }
      },
      "DocumentSearchAggregate": {
        "type": "object",
        "required": [
          "name",
          "groups",
          "total"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined name for this aggregate"
          },
          "groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSearchAggregateGroup"
            }
          },
          "total": {
            "type": "integer",
            "format": "int32",
            "description": "Total number of results for this aggregate"
          }
        }
      },
      "DocumentSearchAggregateGroupIdentifier": {
        "type": "object",
        "required": [
          "property",
          "value"
        ],
        "properties": {
          "property": {
            "description": "The property that is being aggregated on.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              }
            ]
          },
          "value": {
            "description": "The value of the property for this group.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentFilterValue"
              }
            ]
          }
        }
      },
      "DocumentSearchAggregateGroup": {
        "type": "object",
        "required": [
          "group",
          "count"
        ],
        "properties": {
          "group": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DocumentSearchAggregateGroupIdentifier"
            }
          },
          "count": {
            "description": "The number of documents in this group.",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "DocumentSearchAggregates": {
        "type": "object",
        "properties": {
          "aggregates": {
            "deprecated": true,
            "type": "array",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/DocumentSearchCountAggregate"
            },
            "example": [
              {
                "name": "countOfTypes",
                "aggregate": "count",
                "groupBy": [
                  {
                    "property": [
                      "type"
                    ]
                  }
                ]
              }
            ]
          }
        }
      },
      "DocumentSearchCountAggregate": {
        "type": "object",
        "required": [
          "name",
          "aggregate"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "User defined name for this aggregate"
          },
          "aggregate": {
            "type": "string",
            "enum": [
              "count"
            ],
            "description": "count",
            "example": "count"
          },
          "groupBy": {
            "type": "array",
            "description": "List of properties to group the count by. It's currently only possible to group by 0 or 1 properties. If grouping by 0 properties, the aggregate value is the total count of all documents.",
            "minItems": 0,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentSearchCountAggregatesGroup"
            }
          }
        },
        "example": {
          "name": "countOfTypes",
          "aggregate": "count",
          "groupBy": [
            {
              "property": [
                "type"
              ]
            }
          ]
        }
      },
      "DocumentSearchCountAggregatesGroup": {
        "type": "object",
        "required": [
          "property"
        ],
        "properties": {
          "property": {
            "description": "A property to group by.",
            "example": [
              "type"
            ],
            "allOf": [
              {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              }
            ]
          }
        }
      },
      "DocumentSourceFile": {
        "type": "object",
        "description": "The source file that this document is derived from.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the file.",
            "example": "hamlet.txt"
          },
          "directory": {
            "type": "string",
            "description": "The directory the file can be found in",
            "example": "plays/shakespeare"
          },
          "source": {
            "type": "string",
            "description": "The source of the file",
            "example": "SubsurfaceConnectors"
          },
          "mimeType": {
            "type": "string",
            "description": "The mime type of the file",
            "example": "application/octet-stream"
          },
          "size": {
            "type": "number",
            "format": "int64",
            "description": "The size of the source file in bytes",
            "example": 1000
          },
          "hash": {
            "type": "string",
            "description": "The hash of the source file. This is a SHA256 hash of the original file. The hash only covers the file content, and not other CDF metadata.",
            "example": "23203f9264161714cdb8d2f474b9b641e6a735f8cea4098c40a3cab8743bd749"
          },
          "assetIds": {
            "type": "array",
            "description": "The ids of the assets related to this file",
            "example": [],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "labels": {
            "allOf": [
              {
                "description": "A list of labels associated with this document's source file in CDF.",
                "example": [
                  {
                    "externalId": "play"
                  },
                  {
                    "externalId": "tragedy"
                  }
                ]
              },
              {
                "$ref": "#/components/schemas/LabelList"
              }
            ]
          },
          "geoLocation": {
            "$ref": "#/components/schemas/DocumentGeoJsonGeometry"
          },
          "datasetId": {
            "description": "The id if the dataset this file belongs to, if any",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "securityCategories": {
            "type": "array",
            "description": "The security category IDs required to access this file",
            "example": [],
            "items": {
              "type": "number",
              "format": "int64"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "Document": {
        "type": "object",
        "required": [
          "id",
          "createdTime",
          "sourceFile"
        ],
        "description": "A document",
        "properties": {
          "id": {
            "description": "The unique identifier for the document. This is automatically generated by CDF, and will be the same as the corresponding value in the Files API.",
            "example": 2384,
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ]
          },
          "externalId": {
            "example": "haml001",
            "description": "The external ID for the document. This field will be the same as the value set in the Files API.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ]
          },
          "instanceId": {
            "description": "The instance ID for documents created through Data Modeling. This field will be the same as the value set in the Files API.",
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInstanceId"
              }
            ]
          },
          "title": {
            "description": "The title of the document",
            "type": "string",
            "example": "Hamlet"
          },
          "author": {
            "description": "The author of the document",
            "type": "string",
            "example": "William Shakespeare"
          },
          "producer": {
            "description": "The producer of the document. Many document types contain metadata indicating what software or system was used to create the document.",
            "type": "string"
          },
          "createdTime": {
            "description": "When the document was created, measured in milliseconds since 00:00:00 Thursday, 1 January 1970. We do a best effort to determine the created time for the document, and it will be derived from either the document metadata, the user-specified created time provided when uploading the file or as a last resort the creation timestamp of the underlying file resource.",
            "example": 1519862400000,
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "modifiedTime": {
            "description": "When the document was last modified, measured in milliseconds since 00:00:00 Thursday, 1 January 1970. This holdes the user-specified modified time provided for the underlying file resource, but might in the future also be derived from document metadata.",
            "example": 1519958703000,
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "lastIndexedTime": {
            "description": "When the document was last indexed in the documents search engine, measured in milliseconds since 00:00:00 Thursday, 1 January 1970.",
            "example": 1521062805000,
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "mimeType": {
            "description": "Detected mime type for the document",
            "type": "string",
            "example": "text/plain"
          },
          "extension": {
            "type": "string",
            "description": "Extension of the file (always in lowercase)",
            "example": "pdf"
          },
          "pageCount": {
            "description": "Number of pages for multi-page documents",
            "type": "integer",
            "format": "int32",
            "example": 2
          },
          "type": {
            "description": "Detected type of document",
            "type": "string",
            "example": "Document"
          },
          "language": {
            "description": "The detected language used in the document",
            "type": "string",
            "example": "en"
          },
          "truncatedContent": {
            "description": "The textual content of the document. Truncated to 155 characters but subject to change",
            "type": "string",
            "example": "ACT I\nSCENE I. Elsinore. A platform before the castle.\n  FRANCISCO at his post. Enter to him BERNARDO\nBERNARDO\n  Who's there?\n"
          },
          "assetIds": {
            "deprecated": true,
            "description": "The ids of any assets referred to in the document",
            "type": "array",
            "example": [
              42,
              101
            ],
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          },
          "labels": {
            "allOf": [
              {
                "deprecated": true
              },
              {
                "$ref": "#/components/schemas/LabelList"
              }
            ]
          },
          "sourceFile": {
            "$ref": "#/components/schemas/DocumentSourceFile"
          },
          "geoLocation": {
            "allOf": [
              {
                "deprecated": true
              },
              {
                "$ref": "#/components/schemas/DocumentGeoJsonGeometry"
              },
              {
                "description": "Geolocation derived for this document. Represented using a GeoJSON Geometry.\n\nThe derived geolocation also includes geolocation information from a matched\nasset (see assetIds property). For matched assets without geolocation information\nthe parent chain is followed until it finds an asset with geolocation information.\n"
              }
            ]
          }
        }
      },
      "DocumentHighlight": {
        "type": "object",
        "description": "Highlighted snippets from name and content fields which show where the query matches are. The matched terms will be placed inside <em> tags",
        "required": [
          "name",
          "content"
        ],
        "properties": {
          "name": {
            "type": "array",
            "description": "Matches in name.",
            "items": {
              "type": "string"
            }
          },
          "content": {
            "type": "array",
            "description": "Matches in content.",
            "items": {
              "type": "string"
            }
          }
        },
        "example": {
          "name": [
            "amet elit <em>non diam</em> aliquam suscipit"
          ],
          "content": [
            "Nunc <em>vulputate erat</em> ipsum, at aliquet ligula vestibulum at",
            "<em>Quisque</em> lectus ex, fringilla aliquet <em>eleifend</em> nec, laoreet a velit.\n\nPhasellus <em>faucibus</em> risus arcu"
          ]
        }
      },
      "DocumentSemanticMatch": {
        "type": "object",
        "description": "Semantic insight about a search result",
        "required": [
          "text"
        ],
        "properties": {
          "text": {
            "type": "string"
          },
          "locations": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "pageNumber": {
                  "type": "number",
                  "format": "int32"
                },
                "left": {
                  "type": "number",
                  "format": "float"
                },
                "right": {
                  "type": "number",
                  "format": "float"
                },
                "up": {
                  "type": "number",
                  "format": "float"
                },
                "bottom": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        },
        "example": {
          "text": "Pump installation\nFollow these 15 steps:\n ...",
          "location": [
            {
              "page": 7,
              "left": 68.78,
              "right": 478.56,
              "top": 75.04,
              "bottom": 386.1
            }
          ]
        }
      },
      "DocumentGeoJsonGeometry": {
        "description": "GeoJSON Geometry.",
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "description": "Type of the GeoJSON Geometry. When filtering there is a limit of specifying up to 100 positions in the data.",
            "type": "string",
            "example": "Point"
          },
          "coordinates": {
            "description": "Coordinates of the geometry.",
            "anyOf": [
              {
                "type": "array",
                "example": [
                  10.74609,
                  59.91273
                ],
                "items": {
                  "type": "number",
                  "format": "float"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": {
                    "type": "number",
                    "format": "float"
                  }
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": {
                    "type": "array",
                    "items": {
                      "type": "number",
                      "format": "float"
                    }
                  }
                }
              }
            ]
          },
          "geometries": {
            "type": "array",
            "description": "List of geometries for a GeometryCollection. Nested GeometryCollection is not supported",
            "items": {
              "$ref": "#/components/schemas/DocumentGeoJsonGeometry"
            }
          }
        },
        "example": {
          "type": "Point",
          "coordinates": [
            10.74609,
            59.91273
          ]
        }
      },
      "DocumentFilter": {
        "description": "A JSON based filtering language. See detailed documentation above.\n",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentFilterBool"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterLeaf"
          }
        ]
      },
      "DocumentSemanticFilter": {
        "description": "A JSON based filtering language. See detailed documentation above.\n",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentSemanticFilterBool"
          },
          {
            "$ref": "#/components/schemas/DocumentSemanticFilterLeaf"
          }
        ]
      },
      "DocumentPassagesFilter": {
        "description": "A JSON based filtering language. See detailed documentation above.\n",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentPassagesFilterBool"
          },
          {
            "$ref": "#/components/schemas/DocumentPassagesFilterLeaf"
          }
        ]
      },
      "DocumentFilterBool": {
        "title": "bool filters",
        "description": "A query that matches items matching boolean combinations of other queries.\nIt is built using one or more boolean clauses, which can be of types: `and`, `or` or `not`\n",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/DocumentFilter"
                },
                "example": [
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Report"
                    }
                  },
                  {
                    "equals": {
                      "property": [
                        "type"
                      ],
                      "value": "PDF"
                    }
                  }
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/DocumentFilter"
                },
                "example": [
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Report"
                    }
                  },
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Summary"
                    }
                  }
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DocumentFilter"
                  }
                ],
                "example": [
                  {
                    "equals": {
                      "property": [
                        "type"
                      ],
                      "value": "PDF"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "DocumentSemanticFilterBool": {
        "title": "bool filters",
        "description": "A query that matches items matching boolean combinations of other queries.\nCurrently only supports `and` clause.\n",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/DocumentSemanticFilter"
                },
                "example": [
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Report"
                    }
                  },
                  {
                    "equals": {
                      "property": [
                        "type"
                      ],
                      "value": "PDF"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "DocumentPassagesFilterBool": {
        "title": "bool filters",
        "description": "A query that matches items matching boolean combinations of other queries.\nCurrently only supports `and` clause.\n",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/DocumentPassagesFilter"
                },
                "example": [
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Report"
                    }
                  },
                  {
                    "equals": {
                      "property": [
                        "type"
                      ],
                      "value": "PDF"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "DocumentFilterLeaf": {
        "title": "leaf filters",
        "description": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentFilterEquals"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterIn"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterContainsAny"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterContainsAll"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterRange"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterPrefix"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterSearch"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterExists"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterGeoJsonIntersects"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterGeoJsonDisjoint"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterGeoJsonWithin"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterInAssetSubtree"
          }
        ]
      },
      "DocumentSemanticFilterLeaf": {
        "title": "leaf filters",
        "description": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentPassagesFilterEquals"
          },
          {
            "$ref": "#/components/schemas/DocumentPassagesFilterIn"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterSemanticSearch"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterLexicalSearch"
          }
        ]
      },
      "DocumentPassagesFilterLeaf": {
        "title": "leaf filters",
        "description": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentFilterEquals"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterIn"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterSemanticSearch"
          },
          {
            "$ref": "#/components/schemas/DocumentFilterLexicalSearch"
          }
        ]
      },
      "DocumentFilterEquals": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contain the exact value in the provided property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/DocumentFilterValue"
              }
            },
            "example": {
              "property": [
                "type"
              ],
              "value": "PDF"
            }
          }
        }
      },
      "DocumentFilterIn": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property matches one of the given values",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/DocumentFilterValueList"
              }
            },
            "example": {
              "property": [
                "author"
              ],
              "values": [
                "Etiam Eget",
                "Praesent Vestibulum"
              ]
            }
          }
        }
      },
      "DocumentFilterContainsAny": {
        "type": "object",
        "title": "containsAny",
        "required": [
          "containsAny"
        ],
        "properties": {
          "containsAny": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more of the given values",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/DocumentFilterValueList"
              }
            },
            "example": {
              "property": [
                "assetIds"
              ],
              "values": [
                51276,
                94287
              ]
            }
          }
        }
      },
      "DocumentFilterContainsAll": {
        "type": "object",
        "title": "containsAll",
        "required": [
          "containsAll"
        ],
        "properties": {
          "containsAll": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains all the given values",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/DocumentFilterValueList"
              }
            },
            "example": {
              "property": [
                "assetIds"
              ],
              "values": [
                51276,
                94287
              ]
            }
          }
        }
      },
      "DocumentFilterRange": {
        "type": "object",
        "title": "range",
        "required": [
          "range"
        ],
        "properties": {
          "range": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain terms within the provided range.\nRange must include both an upper and a lower bound. It is not allowed to specify both inclusive and exclusive\nbounds (like `gte`, `gt`) together.\n`gte`: Greater than or equal to.\n`gt`: Greater than.\n`lte`: Less than or equal to.\n`lt`: Less than.\n",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "gte": {
                "$ref": "#/components/schemas/DocumentFilterRangeValue"
              },
              "gt": {
                "$ref": "#/components/schemas/DocumentFilterRangeValue"
              },
              "lte": {
                "$ref": "#/components/schemas/DocumentFilterRangeValue"
              },
              "lt": {
                "$ref": "#/components/schemas/DocumentFilterRangeValue"
              }
            },
            "example": {
              "property": [
                "createdTime"
              ],
              "gte": 1609459200000,
              "lt": 1640995200000
            }
          }
        }
      },
      "DocumentFilterPrefix": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contain a specific prefix in the provided property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/DocumentFilterValue"
              }
            },
            "example": {
              "property": [
                "name"
              ],
              "value": "Report"
            }
          }
        }
      },
      "DocumentFilterSearch": {
        "type": "object",
        "title": "search",
        "required": [
          "search"
        ],
        "properties": {
          "search": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contains the search query.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "value": {
                "type": "string"
              }
            },
            "example": {
              "property": [
                "content"
              ],
              "value": "Report"
            }
          }
        }
      },
      "DocumentPassagesFilterValue": {
        "description": "Value you wish to find in the provided property.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "DocumentPassagesFilterValueList": {
        "description": "One or more values you wish to find in the provided property.",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/DocumentPassagesFilterValue"
        }
      },
      "DocumentPassagesFilterEquals": {
        "type": "object",
        "title": "equals",
        "required": [
          "equals"
        ],
        "properties": {
          "equals": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches items that contain the exact value in the provided property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "value": {
                "$ref": "#/components/schemas/DocumentPassagesFilterValue"
              }
            },
            "example": {
              "property": [
                "type"
              ],
              "value": "PDF"
            }
          }
        }
      },
      "DocumentPassagesFilterIn": {
        "type": "object",
        "title": "in",
        "required": [
          "in"
        ],
        "properties": {
          "in": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property matches one of the given values",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/DocumentPassagesFilterValueList"
              }
            },
            "example": {
              "property": [
                "id"
              ],
              "values": [
                6546,
                45756456
              ]
            }
          }
        }
      },
      "DocumentFilterSemanticSearch": {
        "type": "object",
        "title": "semanticSearch",
        "required": [
          "semanticSearch"
        ],
        "properties": {
          "semanticSearch": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches passages that have similar semantic meaning as the search query.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "value": {
                "type": "string"
              }
            },
            "example": {
              "property": [
                "content"
              ],
              "value": "Report"
            }
          }
        }
      },
      "DocumentFilterLexicalSearch": {
        "type": "object",
        "title": "lexicalSearch",
        "required": [
          "lexicalSearch"
        ],
        "properties": {
          "lexicalSearch": {
            "required": [
              "property",
              "value"
            ],
            "description": "Matches passages that contains specified keywords.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "value": {
                "type": "string"
              }
            },
            "example": {
              "property": [
                "content"
              ],
              "value": "Report"
            }
          }
        }
      },
      "DocumentFilterExists": {
        "type": "object",
        "title": "exists",
        "required": [
          "exists"
        ],
        "properties": {
          "exists": {
            "required": [
              "property"
            ],
            "description": "Matches items that contain a value for the provided property.",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              }
            },
            "example": {
              "property": [
                "language"
              ]
            }
          }
        }
      },
      "DocumentFilterProperty": {
        "description": "Property you wish to filter. It's a list of strings to allow specifying nested properties.\nFor example, If you have the object `{\"foo\": {\"../bar\": \"baz\"}, \"bar\": 123}`, you can refer to the nested property as `[\"foo\", \"../bar\"]` and the un-nested one as `[\"bar\"]`.\n",
        "type": "array",
        "minItems": 1,
        "maxItems": 3,
        "items": {
          "type": "string"
        },
        "example": [
          "sourceFile",
          "name"
        ]
      },
      "DocumentFilterValue": {
        "description": "Value you wish to find in the provided property.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          },
          {
            "$ref": "#/components/schemas/Label"
          },
          {
            "$ref": "#/components/schemas/CogniteInstanceId"
          }
        ]
      },
      "DocumentAggregateValue": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "$ref": "#/components/schemas/Label"
          }
        ]
      },
      "DocumentFilterValueList": {
        "description": "One or more values you wish to find in the provided property.",
        "type": "array",
        "minItems": 1,
        "maxItems": 100,
        "items": {
          "$ref": "#/components/schemas/DocumentFilterValue"
        }
      },
      "DocumentFilterRangeValue": {
        "description": "Value you wish to find in the provided property using a range clause.",
        "type": "number"
      },
      "DocumentFilterGeoJsonIntersects": {
        "type": "object",
        "title": "geojsonIntersects",
        "required": [
          "geojsonIntersects"
        ],
        "properties": {
          "geojsonIntersects": {
            "required": [
              "property",
              "geometry"
            ],
            "description": "Matches items with geolocations that intersect the provided geometry",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "geometry": {
                "$ref": "#/components/schemas/DocumentGeoJsonGeometry"
              }
            }
          }
        }
      },
      "DocumentFilterGeoJsonDisjoint": {
        "type": "object",
        "title": "geojsonDisjoint",
        "required": [
          "geojsonDisjoint"
        ],
        "properties": {
          "geojsonDisjoint": {
            "required": [
              "property",
              "geometry"
            ],
            "description": "Matches items with geolocations that are disjoint from the provided geometry",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "geometry": {
                "$ref": "#/components/schemas/DocumentGeoJsonGeometry"
              }
            }
          }
        }
      },
      "DocumentFilterGeoJsonWithin": {
        "type": "object",
        "title": "geojsonWithin",
        "required": [
          "geojsonWithin"
        ],
        "properties": {
          "geojsonWithin": {
            "required": [
              "property",
              "geometry"
            ],
            "description": "Matches items with geolocations that are within the provided geometry",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "geometry": {
                "$ref": "#/components/schemas/DocumentGeoJsonGeometry"
              }
            }
          }
        }
      },
      "DocumentFilterInAssetSubtree": {
        "type": "object",
        "title": "inAssetSubtree",
        "required": [
          "inAssetSubtree"
        ],
        "properties": {
          "inAssetSubtree": {
            "required": [
              "property",
              "values"
            ],
            "description": "Matches items where the property contains one or more assets in a subtree rooted at any of the given values",
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/DocumentFilterProperty"
              },
              "values": {
                "$ref": "#/components/schemas/DocumentFilterValueList"
              }
            },
            "example": {
              "property": [
                "assetIds"
              ],
              "values": [
                51276,
                94287
              ]
            }
          }
        }
      },
      "DocumentAggregateFilter": {
        "description": "A JSON based filtering language. See detailed documentation above.\n",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentAggregateFilterBool"
          },
          {
            "$ref": "#/components/schemas/DocumentAggregateFilterLeaf"
          }
        ]
      },
      "DocumentAggregateFilterBool": {
        "title": "bool filters",
        "description": "A query that matches items matching boolean combinations of other queries.\nIt is built using one or more boolean clauses, which can be of types: `and`, `or` or `not`\n",
        "type": "object",
        "oneOf": [
          {
            "type": "object",
            "title": "and",
            "required": [
              "and"
            ],
            "properties": {
              "and": {
                "description": "All of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/DocumentAggregateFilter"
                },
                "example": [
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Report"
                    }
                  },
                  {
                    "equals": {
                      "property": [
                        "type"
                      ],
                      "value": "PDF"
                    }
                  }
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "or",
            "required": [
              "or"
            ],
            "properties": {
              "or": {
                "description": "At least one of the sub-clauses in the query must appear in matching items.",
                "type": "array",
                "minItems": 1,
                "items": {
                  "$ref": "#/components/schemas/DocumentAggregateFilter"
                },
                "example": [
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Report"
                    }
                  },
                  {
                    "prefix": {
                      "property": [
                        "name"
                      ],
                      "value": "Summary"
                    }
                  }
                ]
              }
            }
          },
          {
            "type": "object",
            "title": "not",
            "required": [
              "not"
            ],
            "properties": {
              "not": {
                "title": "Filter",
                "description": "Sub-clauses in the query must not appear in matching items.",
                "type": "object",
                "allOf": [
                  {
                    "$ref": "#/components/schemas/DocumentAggregateFilter"
                  }
                ],
                "example": [
                  {
                    "equals": {
                      "property": [
                        "type"
                      ],
                      "value": "PDF"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "DocumentAggregateFilterLeaf": {
        "title": "leaf filters",
        "description": "Leaf filter",
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentAggregateFilterPrefix"
          }
        ]
      },
      "DocumentAggregateFilterPrefix": {
        "type": "object",
        "title": "prefix",
        "required": [
          "prefix"
        ],
        "properties": {
          "prefix": {
            "required": [
              "value"
            ],
            "description": "Matches items that contain a specific prefix in the provided property.",
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/DocumentFilterValue"
              }
            },
            "example": {
              "property": [
                "name"
              ],
              "value": "Report"
            }
          }
        }
      },
      "DocumentsAggregateCountRequest": {
        "title": "Count",
        "description": "Count of documents.",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "properties": {
              "aggregate": {
                "description": "Count of documents matching the specified filters and search.",
                "type": "string",
                "enum": [
                  "count"
                ],
                "default": "count"
              }
            }
          }
        ]
      },
      "DocumentsAggregateCountResponse": {
        "title": "Count",
        "type": "object",
        "description": "Response for count aggregate.",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateCountItem"
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 10
            }
          ]
        }
      },
      "DocumentsAggregateCountItem": {
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of items in this aggregation group.",
            "format": "int64"
          }
        }
      },
      "DocumentsAggregateUniqueValuesRequest": {
        "title": "UniqueValues",
        "description": "Top unique values for given properties.",
        "type": "object",
        "required": [
          "aggregate",
          "properties"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "properties": {
              "aggregate": {
                "type": "string",
                "enum": [
                  "uniqueValues"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/DocumentAggregateFilter"
              },
              "properties": {
                "type": "array",
                "description": "List of properties to group by. It is currently only possible to group by 1 property.",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "object",
                  "required": [
                    "property"
                  ],
                  "properties": {
                    "property": {
                      "description": "A property to group by.",
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/DocumentFilterProperty"
                        }
                      ]
                    }
                  }
                }
              },
              "limit": {
                "description": "Maximum number of items.",
                "type": "integer",
                "format": "int32",
                "minimum": 1,
                "maximum": 10000,
                "default": 100
              }
            }
          }
        ]
      },
      "DocumentsAggregateUniqueValuesResponse": {
        "title": "UniqueValues",
        "description": "Response for uniqueValues aggregate.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateUniqueValuesItem"
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 4,
              "values": [
                "hello"
              ]
            },
            {
              "count": 33,
              "values": [
                "world"
              ]
            }
          ]
        }
      },
      "DocumentsAggregateUniqueValuesItem": {
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of items in this aggregation group.",
            "format": "int64"
          },
          "values": {
            "type": "array",
            "description": "A unique value found in the specified properties. Each item is a value for the specified property with same index.",
            "items": {
              "$ref": "#/components/schemas/DocumentAggregateValue"
            }
          }
        }
      },
      "DocumentsAggregateUniquePropertiesRequest": {
        "title": "UniqueProperties",
        "description": "Top unique metadata property names",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "required": [
              "aggregate",
              "properties"
            ],
            "properties": {
              "aggregate": {
                "type": "string",
                "enum": [
                  "uniqueProperties"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/DocumentAggregateFilter"
              },
              "properties": {
                "type": "array",
                "description": "List of properties for which you want to get the nested property names. The only supported property is currently `[\"sourceFile\", \"metadata\"]`.",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "object",
                  "required": [
                    "property"
                  ],
                  "properties": {
                    "property": {
                      "description": "The property to list nested properties for",
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/DocumentFilterProperty"
                        }
                      ]
                    }
                  }
                }
              },
              "limit": {
                "description": "Maximum number of items.",
                "type": "integer",
                "format": "int32",
                "minimum": 1,
                "maximum": 10000,
                "default": 100
              }
            }
          }
        ]
      },
      "DocumentsAggregateUniquePropertiesResponse": {
        "title": "UniqueProperties",
        "description": "Response for the uniqueProperties aggregate.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateUniquePropertiesItem"
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 4,
              "values": [
                "hello"
              ]
            },
            {
              "count": 33,
              "values": [
                "world"
              ]
            }
          ]
        }
      },
      "DocumentsAggregateUniquePropertiesItem": {
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of properties with this name",
            "format": "int64"
          },
          "values": {
            "type": "array",
            "description": "A property name",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "DocumentsAggregateAllUniquePropertiesRequest": {
        "deprecated": true,
        "title": "All unique properties",
        "description": "Find all metadata property names",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "required": [
              "aggregate",
              "properties"
            ],
            "properties": {
              "aggregate": {
                "type": "string",
                "enum": [
                  "allUniqueProperties"
                ]
              },
              "properties": {
                "type": "array",
                "description": "List of properties for which you want to get the nested property names. The only supported property is currently `[\"sourceFile\", \"metadata\"]`.",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "object",
                  "required": [
                    "property"
                  ],
                  "properties": {
                    "property": {
                      "description": "The property to list nested properties for",
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/DocumentFilterProperty"
                        }
                      ]
                    }
                  }
                }
              },
              "limit": {
                "description": "Maximum number of items.",
                "type": "integer",
                "format": "int32",
                "minimum": 1,
                "maximum": 10000,
                "default": 100
              },
              "cursor": {
                "description": "Cursor for paging through results.",
                "type": "string"
              }
            }
          }
        ]
      },
      "DocumentsAggregateAllUniquePropertiesResponse": {
        "deprecated": true,
        "title": "All unique properties",
        "description": "Response for the allUniqueProperties aggregate.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateAllUniquePropertiesItem"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "example": {
          "items": [
            {
              "count": 4,
              "values": [
                "hello"
              ]
            },
            {
              "count": 33,
              "values": [
                "world"
              ]
            }
          ]
        }
      },
      "DocumentsAggregateAllUniquePropertiesItem": {
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of properties with this name",
            "format": "int64"
          },
          "values": {
            "type": "array",
            "description": "A property name",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "DocumentsAggregateAllUniqueValuesRequest": {
        "deprecated": true,
        "title": "All unique values",
        "description": "Paginated list of all unique values for given properties.",
        "type": "object",
        "required": [
          "aggregate",
          "properties"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "properties": {
              "aggregate": {
                "type": "string",
                "enum": [
                  "allUniqueValues"
                ]
              },
              "properties": {
                "type": "array",
                "description": "List of properties to group by. It is currently only possible to group by 1 property.",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "object",
                  "required": [
                    "property"
                  ],
                  "properties": {
                    "property": {
                      "description": "A property to group by.",
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/DocumentFilterProperty"
                        }
                      ]
                    }
                  }
                }
              },
              "limit": {
                "description": "Maximum number of items per page.",
                "type": "integer",
                "format": "int32",
                "minimum": 1,
                "maximum": 10000,
                "default": 100
              },
              "cursor": {
                "description": "Cursor for paging through results.",
                "type": "string"
              }
            }
          }
        ]
      },
      "DocumentsAggregateAllUniqueValuesResponse": {
        "deprecated": true,
        "title": "All unique values",
        "description": "Response for allUniqueValues aggregate.",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateAllUniqueValuesItem"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "example": {
          "items": [
            {
              "count": 4,
              "values": [
                "hello"
              ]
            },
            {
              "count": 33,
              "values": [
                "world"
              ]
            }
          ]
        }
      },
      "DocumentsAggregateAllUniqueValuesItem": {
        "type": "object",
        "required": [
          "count",
          "values"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of items in this aggregation group.",
            "format": "int64"
          },
          "values": {
            "type": "array",
            "description": "A unique value found in the specified properties. Each item is a value for the specified property with same index.",
            "items": {
              "$ref": "#/components/schemas/DocumentAggregateValue"
            }
          }
        }
      },
      "DocumentsAggregateCardinalityValuesRequest": {
        "title": "CardinalityValues",
        "description": "Find approximate number of unique values.",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "required": [
              "aggregate",
              "properties"
            ],
            "properties": {
              "aggregate": {
                "type": "string",
                "enum": [
                  "cardinalityValues"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/DocumentAggregateFilter"
              },
              "properties": {
                "type": "array",
                "description": "List of properties for which you want to get the approximate number of unique values.",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "object",
                  "required": [
                    "property"
                  ],
                  "properties": {
                    "property": {
                      "description": "The property to get the approximate number of unique values for",
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/DocumentFilterProperty"
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "DocumentsAggregateCardinalityValuesResponse": {
        "title": "CardinalityValues",
        "type": "object",
        "description": "Response for cardinalityValues aggregate.",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateCardinalityValuesItem"
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 10
            }
          ]
        }
      },
      "DocumentsAggregateCardinalityValuesItem": {
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of items in this aggregation group.",
            "format": "int64"
          }
        }
      },
      "DocumentsAggregateCardinalityPropertiesRequest": {
        "title": "CardinalityProperties",
        "description": "Find approximate number of unique properties.",
        "type": "object",
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentSearchInAggregate"
          },
          {
            "$ref": "#/components/schemas/DocumentSearchFilter"
          },
          {
            "type": "object",
            "required": [
              "aggregate",
              "path"
            ],
            "properties": {
              "aggregate": {
                "type": "string",
                "enum": [
                  "cardinalityProperties"
                ]
              },
              "aggregateFilter": {
                "$ref": "#/components/schemas/DocumentAggregateFilter"
              },
              "path": {
                "description": "The scope within which properties should be aggregated. The only value that is currently allowed is `[\"metadata\"]`, which will aggregate metadata keys.",
                "type": "array",
                "minItems": 1,
                "maxItems": 1,
                "items": {
                  "type": "string",
                  "enum": [
                    "metadata"
                  ]
                }
              }
            }
          }
        ]
      },
      "DocumentsAggregateCardinalityPropertiesResponse": {
        "title": "CardinalityProperties",
        "type": "object",
        "description": "Response for cardinalityProperties aggregate.",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentsAggregateCardinalityPropertiesItem"
            }
          }
        },
        "example": {
          "items": [
            {
              "count": 10
            }
          ]
        }
      },
      "DocumentsAggregateCardinalityPropertiesItem": {
        "type": "object",
        "required": [
          "count"
        ],
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of items in this aggregation group.",
            "format": "int64"
          }
        }
      },
      "DocumentElements": {
        "type": "array",
        "items": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/DocumentElementWithElementGranularity"
            },
            {
              "$ref": "#/components/schemas/DocumentElementWithLineGranularity"
            },
            {
              "$ref": "#/components/schemas/DocumentElementWithWordGranularity"
            }
          ]
        }
      },
      "DocumentElementWithElementGranularity": {
        "type": "object",
        "title": "DocumentElementWithElementGranularity",
        "description": "A single document layout element. Can be a title, a paragraph or a table.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentTitleElementWithElementGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentParagraphElementWithElementGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentListElementWithElementGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentTableOfContentsElementWithElementGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentTableElementWithElementGranularity"
          }
        ]
      },
      "DocumentElementWithLineGranularity": {
        "type": "object",
        "title": "DocumentElementWithLineGranularity",
        "description": "A single document layout element. Can be a title, a paragraph or a table.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentTitleElementWithLineGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentParagraphElementWithLineGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentListElementWithLineGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentTableOfContentsElementWithLineGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentTableElementWithLineGranularity"
          }
        ]
      },
      "DocumentElementWithWordGranularity": {
        "type": "object",
        "title": "DocumentElementWithWordGranularity",
        "description": "A single document layout element. Can be a title, a paragraph or a table.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/DocumentTitleElementWithWordGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentParagraphElementWithWordGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentListElementWithWordGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentTableOfContentsElementWithWordGranularity"
          },
          {
            "$ref": "#/components/schemas/DocumentTableElementWithWordGranularity"
          }
        ]
      },
      "DocumentTitleElementWithElementGranularity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "A title in a document. A title can consist of one or more lines of text."
          }
        ]
      },
      "DocumentTitleElementWithLineGranularity": {
        "type": "object",
        "description": "A title in a document. A title can consist of one or more lines of text.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "title"
            ]
          },
          "level": {
            "type": "number",
            "description": "The level of this header, from 1 to 3, where smaller numbers mean larger headers.",
            "minimum": 1,
            "maximum": 3
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithLineGranularity"
            }
          }
        }
      },
      "DocumentTitleElementWithWordGranularity": {
        "type": "object",
        "description": "A title in a document. A title can consist of one or more lines of text.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "title"
            ]
          },
          "level": {
            "type": "number",
            "description": "The level of this header, from 1 to 3, where smaller numbers mean larger headers.",
            "minimum": 1,
            "maximum": 3
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithWordGranularity"
            }
          }
        }
      },
      "DocumentParagraphElementWithElementGranularity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "A paragraph in a document. A paragraph can consist of one or more lines of text."
          }
        ]
      },
      "DocumentParagraphElementWithLineGranularity": {
        "type": "object",
        "description": "A paragraph in a document. A paragraph can consist of one or more lines of text.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "paragraph"
            ]
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithLineGranularity"
            }
          }
        }
      },
      "DocumentParagraphElementWithWordGranularity": {
        "type": "object",
        "description": "A paragraph in a document. A paragraph can consist of one or more lines of text.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "paragraph"
            ]
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithWordGranularity"
            }
          }
        }
      },
      "DocumentListElementWithElementGranularity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "An ordered or unordered list."
          }
        ]
      },
      "DocumentListElementWithLineGranularity": {
        "type": "object",
        "description": "An ordered or unordered list.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "list"
            ]
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithLineGranularity"
            }
          }
        }
      },
      "DocumentListElementWithWordGranularity": {
        "type": "object",
        "description": "An ordered or unordered list.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "list"
            ]
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithWordGranularity"
            }
          }
        }
      },
      "DocumentTableOfContentsElementWithElementGranularity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "A table of contents."
          }
        ]
      },
      "DocumentTableOfContentsElementWithLineGranularity": {
        "type": "object",
        "description": "A table of contents.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "toc"
            ]
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithLineGranularity"
            }
          }
        }
      },
      "DocumentTableOfContentsElementWithWordGranularity": {
        "type": "object",
        "description": "A table of contents.",
        "required": [
          "type",
          "lines"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "toc"
            ]
          },
          "lines": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithWordGranularity"
            }
          }
        }
      },
      "DocumentTableElementWithElementGranularity": {
        "type": "object",
        "description": "A table in a document. A table consists of a list of rows where each row is a list of\ncells.",
        "required": [
          "type",
          "rows"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "table"
            ]
          },
          "columnHeaderCount": {
            "type": "number",
            "description": "Number of header rows (column headers) at the top of the table."
          },
          "rowHeaderCount": {
            "type": "number",
            "description": "Number of header columns (row headers) at the left of the table."
          },
          "rows": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "array",
              "minItems": 1,
              "items": {
                "$ref": "#/components/schemas/DocumentCellElementWithElementGranularity"
              }
            }
          }
        }
      },
      "DocumentTableElementWithLineGranularity": {
        "type": "object",
        "description": "A table in a document. A table consists of a list of rows where each row is a list of\ncells.",
        "required": [
          "type",
          "rows"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "table"
            ]
          },
          "columnHeaderCount": {
            "type": "number",
            "description": "Number of header rows (column headers) at the top of the table."
          },
          "rowHeaderCount": {
            "type": "number",
            "description": "Number of header columns (row headers) at the left of the table."
          },
          "rows": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "array",
              "minItems": 1,
              "items": {
                "$ref": "#/components/schemas/DocumentCellElementWithLineGranularity"
              }
            }
          }
        }
      },
      "DocumentTableElementWithWordGranularity": {
        "type": "object",
        "description": "A table in a document. A table consists of a list of rows where each row is a list of\ncells.",
        "required": [
          "type",
          "rows"
        ],
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "table"
            ]
          },
          "columnHeaderCount": {
            "type": "number",
            "description": "Number of header rows (column headers) at the top of the table."
          },
          "rowHeaderCount": {
            "type": "number",
            "description": "Number of header columns (row headers) at the left of the table."
          },
          "rows": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "array",
              "minItems": 1,
              "items": {
                "$ref": "#/components/schemas/DocumentCellElementWithWordGranularity"
              }
            }
          }
        }
      },
      "DocumentCellElementWithElementGranularity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "A cell in a table. A cell contains zero or more lines of text."
          }
        ]
      },
      "DocumentCellElementWithLineGranularity": {
        "type": "object",
        "description": "A cell in a table. A cell contains zero or more lines of text.",
        "required": [
          "lines"
        ],
        "properties": {
          "lines": {
            "type": "array",
            "minItems": 0,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithLineGranularity"
            }
          }
        }
      },
      "DocumentCellElementWithWordGranularity": {
        "type": "object",
        "description": "A cell in a table. A cell contains zero or more lines of text.",
        "required": [
          "lines"
        ],
        "properties": {
          "lines": {
            "type": "array",
            "minItems": 0,
            "items": {
              "$ref": "#/components/schemas/DocumentLineElementWithWordGranularity"
            }
          }
        }
      },
      "DocumentLineElementWithLineGranularity": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "A single line containing a list of words"
          }
        ]
      },
      "DocumentLineElementWithWordGranularity": {
        "type": "object",
        "description": "A single line containing a list of words",
        "required": [
          "words"
        ],
        "properties": {
          "words": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/DocumentWordElement"
            }
          }
        }
      },
      "DocumentWordElement": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DocumentLeafElement"
          },
          {
            "type": "object",
            "description": "A single word. Contains a reference to the relevant page, and a bounding box.",
            "example": {
              "title": "Pump",
              "page": 7,
              "left": 68.78,
              "right": 178.56,
              "top": 75.04,
              "bottom": 96.1
            }
          }
        ]
      },
      "DocumentLeafElement": {
        "type": "object",
        "required": [
          "text",
          "page",
          "left",
          "right",
          "top",
          "bottom"
        ],
        "properties": {
          "text": {
            "description": "The text contained in this element.",
            "type": "string"
          },
          "page": {
            "description": "The page number where the element can be found. Pages start at 1.",
            "type": "integer"
          },
          "left": {
            "type": "number"
          },
          "right": {
            "type": "number"
          },
          "top": {
            "type": "number"
          },
          "bottom": {
            "type": "number"
          }
        }
      },
      "GeospatialError": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 401
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Could not authenticate."
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "string"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ],
              "additionalProperties": true
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "string"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ],
              "additionalProperties": true
            }
          },
          "invalid": {
            "type": "array",
            "description": "List of objects that are not valid.",
            "items": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "string"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ],
              "additionalProperties": true
            }
          },
          "dependencies": {
            "type": "array",
            "description": "List of dependencies.",
            "items": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "string"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ],
              "additionalProperties": true
            }
          }
        }
      },
      "GeospatialFeatureTypeExternalId": {
        "type": "string",
        "maxLength": 32,
        "pattern": "^[A-Za-z][A-Za-z0-9_]{0,31}$",
        "example": "ocean_measures"
      },
      "GeospatialPropertyName": {
        "type": "string",
        "maxLength": 32,
        "pattern": "^[A-Za-z0-9_]{0,31}$"
      },
      "GeospatialFeatureTypeProperty": {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "$ref": "#/components/schemas/GeospatialPropertyType"
          },
          "description": {
            "type": "string",
            "description": "The description of the property",
            "maxLength": 500
          },
          "srid": {
            "$ref": "#/components/schemas/GeospatialReferenceId"
          },
          "size": {
            "type": "integer",
            "description": "Maximal length of string. Only valid for string type.",
            "minimum": 1,
            "maximum": 65536
          },
          "optional": {
            "type": "boolean",
            "description": "Indicate if property is nullable. Default is false."
          }
        }
      },
      "GeospatialIndexSpec": {
        "type": "object",
        "required": [
          "properties"
        ],
        "properties": {
          "properties": {
            "type": "array",
            "minItems": 1,
            "maxItems": 5,
            "items": {
              "$ref": "#/components/schemas/GeospatialPropertyName"
            }
          }
        }
      },
      "GeospatialFeatureTypeSpec": {
        "type": "object",
        "required": [
          "externalId",
          "properties"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/GeospatialFeatureTypeExternalId"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetId"
          },
          "properties": {
            "type": "object",
            "description": "Each property name has to match the following regexp pattern `/^[A-Za-z][A-Za-z0-9_]{0,31}$/`.\\ The number of properties is limited to 200 per feature type.",
            "additionalProperties": {
              "$ref": "#/components/schemas/GeospatialFeatureTypeProperty"
            },
            "maxProperties": 200
          },
          "searchSpec": {
            "type": "object",
            "description": "Each index name has to match the following regexp pattern `/^[A-Za-z][A-Za-z0-9_]{0,31}$/`.\\ The number of indexes is limited to 10 per feature type.",
            "additionalProperties": {
              "$ref": "#/components/schemas/GeospatialIndexSpec"
            },
            "maxProperties": 10
          }
        }
      },
      "GeospatialFeatureType": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialFeatureTypeSpec"
          },
          {
            "type": "object",
            "required": [
              "createdTime",
              "lastUpdatedTime"
            ],
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        ]
      },
      "GeospatialUpdateFeatureTypeSpec": {
        "type": "object",
        "required": [
          "externalId",
          "update"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/GeospatialFeatureTypeExternalId"
          },
          "update": {
            "type": "object",
            "properties": {
              "dataSetId": {
                "$ref": "#/components/schemas/SinglePatchLong"
              },
              "properties": {
                "type": "object",
                "description": "List of properties to be added, deleted or modified in an existing feature type. Each property name has to match the following regexp pattern `/^[A-Za-z][A-Za-z0-9_]{0,31}$/`.\\ The total number of properties is limited to 100 per feature type. There must not be any property name overlap in `add`, `remove` and `modify` fields.",
                "properties": {
                  "add": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/GeospatialFeatureTypeProperty"
                    }
                  },
                  "remove": {
                    "type": "array",
                    "description": "List of properties to remove.",
                    "items": {
                      "$ref": "#/components/schemas/GeospatialPropertyName"
                    }
                  }
                }
              },
              "searchSpec": {
                "type": "object",
                "description": "Each index name has to match the following regexp pattern `/^[A-Za-z][A-Za-z0-9_]{0,31}$/`.\\ The total number of indexes is limited to 5 per feature type.",
                "properties": {
                  "add": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/GeospatialIndexSpec"
                    }
                  },
                  "remove": {
                    "type": "array",
                    "description": "List of indexes to remove.",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "GeospatialFeatureTypeSpecs": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/GeospatialFeatureTypeSpec"
            }
          }
        }
      },
      "GeospatialFeatureTypes": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/GeospatialFeatureType"
            }
          }
        }
      },
      "GeospatialUpdateFeatureTypeSpecs": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/GeospatialUpdateFeatureTypeSpec"
            }
          }
        }
      },
      "GeospatialFeatureSpec": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialFeatureProperties"
          },
          {
            "type": "object",
            "required": [
              "externalId"
            ],
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            }
          }
        ]
      },
      "GeospatialFeature": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialFeatureProperties"
          },
          {
            "type": "object",
            "properties": {
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        ]
      },
      "GeospatialFeatureAggregates": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeospatialAggregate"
            }
          }
        }
      },
      "GeospatialAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialFeatureProperties"
          }
        ]
      },
      "GeospatialFeatureSpecs": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "allowCrsTransformation": {
                "$ref": "#/components/schemas/GeospatialAllowCrsTransformation"
              },
              "items": {
                "type": "array",
                "minItems": 1,
                "maxItems": 1000,
                "items": {
                  "$ref": "#/components/schemas/GeospatialFeatureSpec"
                }
              }
            }
          }
        ]
      },
      "GeospatialFeatures": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "minItems": 1,
                "maxItems": 1000,
                "items": {
                  "$ref": "#/components/schemas/GeospatialFeature"
                }
              }
            }
          }
        ]
      },
      "GeospatialFeatureIdsWithOutput": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "minItems": 1,
                "maxItems": 1000,
                "items": {
                  "$ref": "#/components/schemas/GeospatialItemExternalId"
                }
              },
              "output": {
                "$ref": "#/components/schemas/GeospatialOutput"
              }
            }
          }
        ]
      },
      "GeospatialFeaturesWithCursor": {
        "allOf": [
          {
            "type": "object",
            "required": [
              "items"
            ],
            "properties": {
              "items": {
                "type": "array",
                "minItems": 1,
                "maxItems": 1000,
                "items": {
                  "$ref": "#/components/schemas/GeospatialFeature"
                }
              },
              "nextCursor": {
                "type": "string",
                "description": "Cursor to get the next page of results (if available)."
              }
            }
          }
        ],
        "description": "A list of objects along with possible cursors to get the next page of results"
      },
      "GeospatialFeatureIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/GeospatialItemExternalId"
            }
          }
        }
      },
      "GeospatialCreatedFeature": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialFeatureSpec"
          }
        ]
      },
      "GeospatialCustomCoordinateReferenceSystemSpecs": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeospatialCoordinateReferenceSystem"
            }
          }
        }
      },
      "GeospatialCoordinateReferenceSystems": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeospatialCoordinateReferenceSystem"
            }
          }
        }
      },
      "GeospatialCoordinateReferenceSystem": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "srid",
          "wkt",
          "projString"
        ],
        "properties": {
          "srid": {
            "$ref": "#/components/schemas/GeospatialReferenceId"
          },
          "wkt": {
            "$ref": "#/components/schemas/GeospatialWellKnownText"
          },
          "projString": {
            "$ref": "#/components/schemas/GeospatialProjString"
          }
        }
      },
      "GeospatialCoordinateReferenceSystemList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/GeospatialCustomCoordinateReferenceSystem"
                },
                {
                  "$ref": "#/components/schemas/GeospatialCoordinateReferenceSystem"
                }
              ]
            }
          }
        }
      },
      "GeospatialCustomCoordinateReferenceSystem": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "srid",
          "wkt",
          "projString",
          "createdTime",
          "lastUpdatedTime"
        ],
        "properties": {
          "srid": {
            "$ref": "#/components/schemas/GeospatialReferenceId"
          },
          "wkt": {
            "$ref": "#/components/schemas/GeospatialWellKnownText"
          },
          "projString": {
            "$ref": "#/components/schemas/GeospatialProjString"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "GeospatialFeatureProperties": {
        "type": "object",
        "maxProperties": 200,
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "type": "object"
            },
            {
              "type": "boolean"
            },
            {
              "type": "array",
              "items": {
                "type": "integer"
              }
            }
          ]
        }
      },
      "GeospatialProjString": {
        "type": "string",
        "description": "The projection specification string as described in https://proj.org/usage/quickstart.html"
      },
      "GeospatialPropertyType": {
        "type": "string",
        "description": "Property type",
        "enum": [
          "STRING",
          "LONG",
          "DOUBLE",
          "BOOLEAN",
          "TIMESTAMP",
          "TIMESTAMPTZ",
          "GEOMETRY",
          "POINT",
          "LINESTRING",
          "POLYGON",
          "MULTIPOINT",
          "MULTILINESTRING",
          "MULTIPOLYGON",
          "GEOMETRYCOLLECTION",
          "GEOMETRYZ",
          "POINTZ",
          "LINESTRINGZ",
          "POLYGONZ",
          "MULTIPOINTZ",
          "MULTILINESTRINGZ",
          "MULTIPOLYGONZ",
          "GEOMETRYM",
          "POINTM",
          "LINESTRINGM",
          "POLYGONM",
          "MULTIPOINTM",
          "MULTILINESTRINGM",
          "MULTIPOLYGONM",
          "GEOMETRYCOLLECTIONM",
          "GEOMETRYZM",
          "POINTZM",
          "LINESTRINGZM",
          "POLYGONZM",
          "MULTIPOINTZM",
          "MULTILINESTRINGZM",
          "MULTIPOLYGONZM",
          "GEOMETRYCOLLECTIONZM",
          "RASTER",
          "JSON",
          "LONGARRAY"
        ]
      },
      "GeospatialFeatureSearchResult": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/GeospatialFeature"
            }
          }
        }
      },
      "GeospatialRangeCondition": {
        "type": "object",
        "description": "Range condition can be open (i.e. having one of the properties) or closed (i.e. having two opposite properties). Can be applied to numeric types as well as string.",
        "properties": {
          "gt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ]
          },
          "lt": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ]
          },
          "gte": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ]
          },
          "lte": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ]
          }
        },
        "example": {
          "properties": {
            "gt": 12.4,
            "lte": 20.1
          }
        }
      },
      "GeospatialRange": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialRangeCondition"
          },
          {
            "type": "object",
            "properties": {
              "property": {
                "$ref": "#/components/schemas/GeospatialPropertyReference"
              }
            }
          }
        ]
      },
      "GeospatialProperty": {
        "type": "object",
        "properties": {
          "property": {
            "type": "string"
          }
        }
      },
      "GeospatialPropertyReference": {
        "type": "object",
        "description": "References a feature property in the context of a filter The support for arrays is forward looking for when the geospatial api will have complex properties.",
        "properties": {
          "property": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          }
        }
      },
      "GeospatialPropertyAndPattern": {
        "type": "object",
        "properties": {
          "property": {
            "$ref": "#/components/schemas/GeospatialPropertyReference"
          },
          "pattern": {
            "type": "string"
          }
        }
      },
      "GeospatialPropertyAndValue": {
        "type": "object",
        "properties": {
          "property": {
            "$ref": "#/components/schemas/GeospatialPropertyReference"
          },
          "value": {}
        }
      },
      "GeospatialPropertyAndValues": {
        "type": "object",
        "properties": {
          "property": {
            "$ref": "#/components/schemas/GeospatialPropertyReference"
          },
          "values": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "type": "object"
                },
                {
                  "type": "string"
                },
                {
                  "type": "boolean"
                },
                {
                  "type": "number"
                }
              ]
            }
          }
        }
      },
      "GeospatialPropertyValueAndDistance": {
        "type": "object",
        "properties": {
          "property": {
            "$ref": "#/components/schemas/GeospatialPropertyReference"
          },
          "value": {},
          "distance": {
            "type": "number"
          }
        }
      },
      "GeospatialFeatureFilter": {
        "anyOf": [
          {
            "$ref": "#/components/schemas/GeospatialFeatureNotFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureAndFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureOrFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureEqualsFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureMissingFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureLikeFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureRegexFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureRangeFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureContainsAnyFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureInFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStIntersectsFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStIntersects3dFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStWithinFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStWithinProperlyFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStContainsFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStContainsProperlyFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStWithinDistanceFilter"
          },
          {
            "$ref": "#/components/schemas/GeospatialFeatureStWithinDistance3dFilter"
          }
        ]
      },
      "GeospatialFeatureNotFilter": {
        "type": "object",
        "properties": {
          "not": {
            "$ref": "#/components/schemas/GeospatialFeatureFilter"
          }
        }
      },
      "GeospatialFeatureAndFilter": {
        "type": "object",
        "properties": {
          "and": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeospatialFeatureFilter"
            }
          }
        }
      },
      "GeospatialFeatureOrFilter": {
        "type": "object",
        "properties": {
          "or": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GeospatialFeatureFilter"
            }
          }
        }
      },
      "GeospatialFeatureEqualsFilter": {
        "type": "object",
        "properties": {
          "equals": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureMissingFilter": {
        "type": "object",
        "properties": {
          "missing": {
            "$ref": "#/components/schemas/GeospatialPropertyReference"
          }
        }
      },
      "GeospatialFeatureLikeFilter": {
        "type": "object",
        "description": "Simple pattern maching. Use `_` for single character and `%` for string of any length. Backslash `\\` is an escape character.",
        "properties": {
          "like": {
            "$ref": "#/components/schemas/GeospatialPropertyAndPattern"
          }
        }
      },
      "GeospatialFeatureRegexFilter": {
        "type": "object",
        "description": "Regular expression pattern matching.",
        "properties": {
          "regex": {
            "$ref": "#/components/schemas/GeospatialPropertyAndPattern"
          }
        }
      },
      "GeospatialFeatureRangeFilter": {
        "type": "object",
        "properties": {
          "range": {
            "$ref": "#/components/schemas/GeospatialRange"
          }
        }
      },
      "GeospatialFeatureContainsAnyFilter": {
        "type": "object",
        "properties": {
          "containsAny": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValues"
          }
        }
      },
      "GeospatialFeatureInFilter": {
        "type": "object",
        "properties": {
          "in": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValues"
          }
        }
      },
      "GeospatialFeatureStWithinFilter": {
        "type": "object",
        "properties": {
          "stWithin": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureStIntersectsFilter": {
        "type": "object",
        "properties": {
          "stIntersects": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureStIntersects3dFilter": {
        "type": "object",
        "properties": {
          "stIntersects3d": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureStWithinProperlyFilter": {
        "type": "object",
        "properties": {
          "stWithinProperly": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureStContainsFilter": {
        "type": "object",
        "properties": {
          "stContains": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureStContainsProperlyFilter": {
        "type": "object",
        "properties": {
          "stContainsProperly": {
            "$ref": "#/components/schemas/GeospatialPropertyAndValue"
          }
        }
      },
      "GeospatialFeatureStWithinDistanceFilter": {
        "type": "object",
        "properties": {
          "stWithinDistance": {
            "$ref": "#/components/schemas/GeospatialPropertyValueAndDistance"
          }
        }
      },
      "GeospatialFeatureStWithinDistance3dFilter": {
        "type": "object",
        "properties": {
          "stWithinDistance3d": {
            "$ref": "#/components/schemas/GeospatialPropertyValueAndDistance"
          }
        }
      },
      "GeospatialFeatureListRequest": {
        "description": "Feature List Request",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "allowCrsTransformation": {
                "$ref": "#/components/schemas/GeospatialAllowCrsTransformation"
              },
              "allowDimensionalityMismatch": {
                "$ref": "#/components/schemas/GeospatialAllowDimensionalityMismatch"
              },
              "filter": {
                "$ref": "#/components/schemas/GeospatialFeatureFilter"
              },
              "limit": {
                "$ref": "#/components/schemas/SearchLimit"
              },
              "output": {
                "$ref": "#/components/schemas/GeospatialOutput"
              }
            }
          },
          {
            "$ref": "#/components/schemas/Cursor"
          }
        ]
      },
      "GeospatialFeatureSearchRequest": {
        "description": "Feature Search Request",
        "type": "object",
        "properties": {
          "allowCrsTransformation": {
            "$ref": "#/components/schemas/GeospatialAllowCrsTransformation"
          },
          "allowDimensionalityMismatch": {
            "$ref": "#/components/schemas/GeospatialAllowDimensionalityMismatch"
          },
          "filter": {
            "$ref": "#/components/schemas/GeospatialFeatureFilter"
          },
          "limit": {
            "$ref": "#/components/schemas/SearchLimit"
          },
          "output": {
            "$ref": "#/components/schemas/GeospatialOutput"
          },
          "sort": {
            "type": "array",
            "description": "Sort result by selected fields. Syntax: sort:[\"field_1\",\"field_2:ASC\",\"field_3:DESC\"]. Default sort order is ascending if not specified. Available sort direction: ASC, DESC, ASC_NULLS_FIRST, DESC_NULLS_FIRST, ASC_NULLS_LAST, DESC_NULLS_LAST.\n",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GeospatialFeatureSearchStreamingRequest": {
        "description": "Search and streaming feature request",
        "type": "object",
        "properties": {
          "allowCrsTransformation": {
            "$ref": "#/components/schemas/GeospatialAllowCrsTransformation"
          },
          "allowDimensionalityMismatch": {
            "$ref": "#/components/schemas/GeospatialAllowDimensionalityMismatch"
          },
          "filter": {
            "$ref": "#/components/schemas/GeospatialFeatureFilter"
          },
          "limit": {
            "type": "number"
          },
          "output": {
            "$ref": "#/components/schemas/GeospatialOutputStreaming"
          }
        }
      },
      "GeospatialFeatureAggregateRequest": {
        "description": "Feature Aggregation Request",
        "type": "object",
        "properties": {
          "allowDimensionalityMismatch": {
            "$ref": "#/components/schemas/GeospatialAllowDimensionalityMismatch"
          },
          "filter": {
            "$ref": "#/components/schemas/GeospatialFeatureFilter"
          },
          "aggregates": {
            "type": "array",
            "description": "This parameter is deprecated. Use `output` instead. Names of aggregate functions that are requested.",
            "deprecated": true,
            "items": {
              "type": "string",
              "enum": [
                "avg",
                "count",
                "max",
                "min",
                "stCentroid",
                "stCollect",
                "stConvexHull",
                "stIntersection",
                "stUnion",
                "sum",
                "variance"
              ]
            }
          },
          "property": {
            "type": "string",
            "description": "This parameter is deprecated. Use `output` instead. Property name.",
            "deprecated": true
          },
          "outputSrid": {
            "$ref": "#/components/schemas/GeospatialReferenceId"
          },
          "groupBy": {
            "type": "array",
            "description": "names of properties to be used for grouping by",
            "items": {
              "type": "string"
            }
          },
          "sort": {
            "type": "array",
            "description": "Sort result by the selected fields (properties or aggregates). Default sort order is ascending if not specified. Available sort direction: ASC, DESC, ASC_NULLS_FIRST, DESC_NULLS_FIRST, ASC_NULLS_LAST, DESC_NULLS_LAST.",
            "items": {
              "type": "string"
            }
          },
          "output": {
            "$ref": "#/components/schemas/GeospatialAggregateOutput"
          }
        }
      },
      "GeospatialRasterOutputSpec": {
        "allOf": [
          {
            "$ref": "#/components/schemas/GeospatialRasterCommonOutputSpec"
          },
          {
            "oneOf": [
              {
                "$ref": "#/components/schemas/GeospatialRasterXyzOutputSpec"
              },
              {
                "$ref": "#/components/schemas/GeospatialRasterGtiffOutputSpec"
              }
            ]
          }
        ]
      },
      "GeospatialRasterCommonOutputSpec": {
        "type": "object",
        "properties": {
          "srid": {
            "$ref": "#/components/schemas/GeospatialReferenceId"
          },
          "scaleX": {
            "type": "number",
            "format": "double"
          },
          "scaleY": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "GeospatialRasterXyzOutputSpec": {
        "type": "object",
        "description": "XYZ specification for the output raster",
        "required": [
          "format"
        ],
        "properties": {
          "format": {
            "type": "string",
            "enum": [
              "XYZ"
            ]
          },
          "options": {
            "type": "object",
            "properties": {
              "SIGNIFICANT_DIGITS": {
                "type": "integer"
              },
              "DECIMAL_PRECISION": {
                "type": "integer"
              }
            }
          }
        }
      },
      "GeospatialRasterGtiffOutputSpec": {
        "type": "object",
        "description": "GTiff specification for the output raster",
        "required": [
          "format"
        ],
        "properties": {
          "format": {
            "type": "string",
            "enum": [
              "GTiff"
            ]
          },
          "options": {
            "type": "object",
            "properties": {
              "JPEG_QUALITY": {
                "type": "integer",
                "minimum": 1,
                "maximum": 100
              }
            }
          }
        }
      },
      "GeospatialAggregateOutput": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/GeospatialAggregateOutputSpec"
        },
        "description": "A list of aggregations which are requested."
      },
      "GeospatialAggregateOutputSpec": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/GeospatialMaxAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialMinAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialSumAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialCountAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialAvgAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialVarianceAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialCentroidAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialCollectAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialConvexHullAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialIntersectionAggregationOutput"
          },
          {
            "$ref": "#/components/schemas/GeospatialUnionAggregationOutput"
          }
        ]
      },
      "GeospatialMaxAggregationOutput": {
        "type": "object",
        "required": [
          "max"
        ],
        "additionalProperties": false,
        "properties": {
          "max": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialMinAggregationOutput": {
        "type": "object",
        "required": [
          "min"
        ],
        "additionalProperties": false,
        "properties": {
          "min": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialSumAggregationOutput": {
        "type": "object",
        "required": [
          "sum"
        ],
        "additionalProperties": false,
        "properties": {
          "sum": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialCountAggregationOutput": {
        "type": "object",
        "required": [
          "count"
        ],
        "additionalProperties": false,
        "properties": {
          "count": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialAvgAggregationOutput": {
        "type": "object",
        "required": [
          "avg"
        ],
        "additionalProperties": false,
        "properties": {
          "avg": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialVarianceAggregationOutput": {
        "type": "object",
        "required": [
          "variance"
        ],
        "additionalProperties": false,
        "properties": {
          "variance": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialCentroidAggregationOutput": {
        "type": "object",
        "required": [
          "stCentroid"
        ],
        "additionalProperties": false,
        "properties": {
          "stCentroid": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialCollectAggregationOutput": {
        "type": "object",
        "required": [
          "stCollect"
        ],
        "additionalProperties": false,
        "properties": {
          "stCollect": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialConvexHullAggregationOutput": {
        "type": "object",
        "required": [
          "stConvexHull"
        ],
        "additionalProperties": false,
        "properties": {
          "stConvexHull": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialIntersectionAggregationOutput": {
        "type": "object",
        "required": [
          "stIntersection"
        ],
        "additionalProperties": false,
        "properties": {
          "stIntersection": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialUnionAggregationOutput": {
        "type": "object",
        "required": [
          "stUnion"
        ],
        "additionalProperties": false,
        "properties": {
          "stUnion": {
            "$ref": "#/components/schemas/GeospatialProperty"
          }
        }
      },
      "GeospatialOutput": {
        "type": "object",
        "description": "Desired output specification.",
        "properties": {
          "geometryFormat": {
            "type": "string",
            "enum": [
              "WKT",
              "GEOJSON"
            ],
            "description": "Desired format for geometry output. If GEOJSON is the output format, SRID 4326 must be specified explicitly for all geometrical properties. Defaults to WKT."
          },
          "properties": {
            "type": "object",
            "description": "A property selection with specification of output format (e.g. desired output Coordinate Reference System into which geometries should be transformed). All properties will be returned when the selection is empty or contains the wildcard `*` character. When the selection contains only some of the properties, the result will contain only requested properties.",
            "maxProperties": 200
          }
        },
        "example": {
          "properties": {
            "*": {},
            "geometry1": {
              "srid": 4326
            },
            "geometry2": {
              "srid": 3857
            }
          }
        }
      },
      "GeospatialOutputStreaming": {
        "type": "object",
        "description": "Desired output specification for streaming.",
        "properties": {
          "geometryFormat": {
            "type": "string",
            "enum": [
              "WKT",
              "GEOJSON"
            ],
            "description": "Desired format for geometry output. If GEOJSON is the output format, SRID 4326 must be specified explicitly for all geometrical properties. Defaults to WKT."
          },
          "jsonStreamFormat": {
            "type": "string",
            "enum": [
              "LENGTH_PREFIXED",
              "NEW_LINE_DELIMITED",
              "CONCATENATED",
              "RECORD_SEPARATOR_DELIMITED"
            ],
            "description": "optional parameter to indicate response format in search streaming endpoint. Defaults to LENGTH_PREFIXED"
          },
          "properties": {
            "type": "object",
            "description": "A property selection with specification of output format (e.g. desired output Coordinate Reference System to which geometries should be transformed). All properties will be returned when the selection is empty or contains the wildcard `*` character. When the selection contains only some of the properties, the result will contain only requested properties.",
            "maxProperties": 200
          }
        },
        "example": {
          "jsonStreamFormat": "LENGTH_PREFIXED",
          "properties": {
            "*": {},
            "geometry1": {
              "srid": 4326
            },
            "geometry2": {
              "srid": 3857
            }
          }
        }
      },
      "GeospatialItemExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "GeospatialWellKnownText": {
        "type": "string",
        "description": "Well-known text of the geometry, see https://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html",
        "example": "POINT (0 0)"
      },
      "GeospatialExtendedWellKnownText": {
        "type": "string",
        "description": "Well-known text of the geometry prefixed with a spatial reference identifier, see https://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html",
        "example": "SRID=4326;POINT(0 0)"
      },
      "GeospatialFeatureTypeExternalIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/GeospatialFeatureTypeExternalId"
                }
              }
            },
            "maxItems": 100,
            "minItems": 1
          }
        }
      },
      "GeospatialReferenceIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "srid"
              ],
              "properties": {
                "srid": {
                  "$ref": "#/components/schemas/GeospatialReferenceId"
                }
              }
            },
            "maxItems": 1000,
            "minItems": 1
          }
        }
      },
      "GeospatialReferenceId": {
        "description": "EPSG code, e.g. 4326. Only valid for geometry types. See https://en.wikipedia.org/wiki/Spatial_reference_system",
        "type": "integer",
        "minimum": 0,
        "maximum": 1000000,
        "example": 4326
      },
      "GeospatialDeleteFeatureType": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "recursive": {
            "$ref": "#/components/schemas/GeospatialRecursiveDelete"
          },
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/GeospatialFeatureTypeExternalId"
                }
              }
            },
            "maxItems": 10,
            "minItems": 1
          }
        }
      },
      "GeospatialRecursiveDelete": {
        "type": "boolean",
        "example": true,
        "description": "Indicates if feature types should be deleted together with all related features. Optional parameter, defaults to false."
      },
      "GeospatialAllowCrsTransformation": {
        "type": "boolean",
        "example": true,
        "description": "Optional parameter indicating if input geometry properties should be transformed into the respective Coordinate Reference Systems defined in the feature type specification. If the parameter is true, then input geometries will be transformed when the input and output Coordinate Reference Systems differ. When it is false, then requests with geometries in Coordinate Reference System different from the ones defined in the feature type will result in bad request response code. Transformations apply to property geometries in case of create and update feature, as well as to geometries in spatial filters in search endpoints."
      },
      "GeospatialComputeRequest": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/GeospatialJsonComputeOutput"
          }
        ]
      },
      "GeospatialJsonComputeOutput": {
        "type": "object",
        "required": [
          "output"
        ],
        "additionalProperties": false,
        "properties": {
          "output": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/GeospatialComputeFunction"
            }
          }
        }
      },
      "GeospatialComputeFunction": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/GeospatialGeometryTransformComputeFunction"
          }
        ]
      },
      "GeospatialGeometryComputeFunction": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/GeospatialGeometryValueComputeFunction"
          }
        ]
      },
      "GeospatialGeometryValueComputeFunction": {
        "type": "object",
        "required": [
          "ewkt"
        ],
        "additionalProperties": false,
        "properties": {
          "ewkt": {
            "$ref": "#/components/schemas/GeospatialExtendedWellKnownText"
          }
        }
      },
      "GeospatialGeometryTransformComputeFunction": {
        "type": "object",
        "required": [
          "stTransform"
        ],
        "additionalProperties": false,
        "properties": {
          "stTransform": {
            "type": "object",
            "required": [
              "geometry",
              "srid"
            ],
            "additionalProperties": false,
            "properties": {
              "geometry": {
                "$ref": "#/components/schemas/GeospatialGeometryComputeFunction"
              },
              "srid": {
                "$ref": "#/components/schemas/GeospatialReferenceId"
              }
            }
          }
        }
      },
      "GeospatialComputedItems": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/GeospatialComputedItem"
            }
          }
        }
      },
      "GeospatialComputedItem": {
        "type": "object",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "type": "object"
            },
            {
              "type": "boolean"
            }
          ]
        }
      },
      "GeospatialRasterMetadata": {
        "type": "object",
        "properties": {
          "srid": {
            "type": "integer"
          },
          "width": {
            "type": "integer"
          },
          "height": {
            "type": "integer"
          },
          "numBands": {
            "type": "integer"
          },
          "scaleX": {
            "type": "number",
            "format": "double"
          },
          "scaleY": {
            "type": "number",
            "format": "double"
          },
          "skewX": {
            "type": "number",
            "format": "double"
          },
          "skewY": {
            "type": "number",
            "format": "double"
          },
          "upperLeftX": {
            "type": "number",
            "format": "double"
          },
          "upperLeftY": {
            "type": "number",
            "format": "double"
          }
        }
      },
      "GeospatialAllowDimensionalityMismatch": {
        "type": "boolean",
        "example": true,
        "description": "Optional parameter indicating if the spatial filter operators allow input geometries with a different dimensionality than the properties they are applied to. For instance, when set to true, if a feature type has a property of type POLYGONZM (4D), its features can be filtered using the `stContains` operator and a POLYGON (2D) value. This option defaults to false if not specified."
      },
      "SearchLimit": {
        "description": "Limits the number of results to be returned.",
        "type": "integer",
        "default": 1000,
        "minimum": 1,
        "maximum": 1000
      },
      "ProjectDeletionReportState": {
        "description": "The state field indicates the state of deletion.\n\n- `RECEIVED`: The service acknowledges it has received a notification about the projects deletion.\n- `STARTED`: The service has started to delete data for the resource in the project.\n- `COMPLETED`: The service has deleted all data for the resource in the project.\n- `FAILED`: The service failed to delete all data for the resource in the project. The failure field should also be set containing additional details.\n- `NOT_APPLICABLE`: No data deletion is needed for the resource in the project.\n\n",
        "type": "string",
        "enum": [
          "RECEIVED",
          "STARTED",
          "COMPLETED",
          "FAILED",
          "NOT_APPLICABLE"
        ]
      },
      "ProjectDeletionReportStateNotCompleted": {
        "description": "The state field indicates the state of deletion.\n\n- `RECEIVED`: The service acknowledges it has received a notification about the projects deletion.\n- `STARTED`: The service has started to delete data for the resource in the project.\n- `FAILED`: The service failed to delete all data for the resource in the project. The failure field should also be set containing additional details.\n\n",
        "type": "string",
        "enum": [
          "RECEIVED",
          "STARTED",
          "FAILED"
        ]
      },
      "DeletionReportsResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeletionReport"
            }
          }
        },
        "description": "Deletion Report"
      },
      "DeletionReportsWithCursorResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeletionReport"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "A list of objects along with possible cursors to get the next page of results"
      },
      "DeletionReport": {
        "required": [
          "projectId",
          "resource",
          "state",
          "createdTime"
        ],
        "type": "object",
        "properties": {
          "projectId": {
            "type": "integer",
            "description": "Project id of the report",
            "format": "int64"
          },
          "resource": {
            "type": "string",
            "description": "Resource identifier",
            "example": "timeseries"
          },
          "state": {
            "$ref": "#/components/schemas/ProjectDeletionReportState"
          },
          "failure": {
            "type": "string",
            "description": "Optional failure reason"
          },
          "createdTime": {
            "type": "integer",
            "description": "milliseconds since epoch",
            "format": "int64",
            "example": 1697194426715
          }
        }
      },
      "DeletionReportRequestList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minLength": 1,
            "maxLength": 1,
            "items": {
              "$ref": "#/components/schemas/DeletionReportRequest"
            }
          }
        }
      },
      "DeletionReportRequest": {
        "required": [
          "projectId",
          "resource",
          "state"
        ],
        "type": "object",
        "properties": {
          "projectId": {
            "type": "integer",
            "description": "Project id of the report",
            "format": "int64"
          },
          "resource": {
            "type": "string",
            "description": "Resource identifier",
            "example": "timeseries"
          },
          "state": {
            "$ref": "#/components/schemas/ProjectDeletionReportState"
          },
          "failure": {
            "type": "string",
            "description": "Optional failure reason"
          }
        }
      },
      "ProjectsPendingDeletionResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProjectPendingDeletion"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "List of projects pending deletion along with possible cursors to get the next page of results"
      },
      "ProjectPendingDeletion": {
        "required": [
          "projectId",
          "resource"
        ],
        "type": "object",
        "properties": {
          "projectId": {
            "type": "integer",
            "description": "Project id of the report",
            "format": "int64"
          },
          "resource": {
            "type": "string",
            "description": "Resource identifier",
            "example": "timeseries"
          },
          "state": {
            "$ref": "#/components/schemas/ProjectDeletionReportStateNotCompleted"
          },
          "failure": {
            "type": "string",
            "description": "Optional failure reason"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "description": "milliseconds since epoch",
            "format": "int64",
            "example": 1697194426715
          }
        }
      },
      "ResetReportRequestList": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minLength": 1,
            "maxLength": 1,
            "items": {
              "$ref": "#/components/schemas/ResetReportRequest"
            }
          }
        }
      },
      "ResetReportRequest": {
        "type": "object",
        "required": [
          "projectIds",
          "resource"
        ],
        "properties": {
          "projectIds": {
            "type": "array",
            "minLength": 1,
            "maxLength": 10000,
            "items": {
              "type": "integer",
              "description": "Project id",
              "format": "int64"
            }
          },
          "resource": {
            "type": "string",
            "description": "Resource identifier",
            "example": "timeseries"
          }
        }
      },
      "ResetReportResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minLength": 0,
            "maxLength": 10000,
            "items": {
              "type": "integer",
              "description": "Project id",
              "format": "int64"
            }
          }
        }
      },
      "DetachSessionRequest": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "description": "ID of the session.",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "DetachSessionResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "description": "ID of the session.",
                  "type": "number"
                },
                "type": {
                  "description": "Type of the session.",
                  "type": "string",
                  "example": "TOKEN_EXCHANGE"
                },
                "status": {
                  "description": "Status of the session.",
                  "type": "string",
                  "example": "DETACHED"
                },
                "creationTime": {
                  "description": "Unix timestamp in milliseconds of when the the session is created.\n",
                  "type": "integer",
                  "example": 1638795554528
                },
                "expirationTime": {
                  "description": "Unix timestamp in milliseconds of when the session will expire.\n",
                  "example": 1638795554528
                }
              }
            }
          }
        }
      },
      "SessionTokenRequest": {
        "description": "",
        "oneOf": [
          {
            "$ref": "#/components/schemas/BindSessionRequest"
          },
          {
            "$ref": "#/components/schemas/RefreshSessionRequest"
          }
        ]
      },
      "BindSessionRequest": {
        "description": "Bind a newly created session.",
        "type": "object",
        "required": [
          "nonce"
        ],
        "properties": {
          "nonce": {
            "description": "Nonce returned by session creation endpoint",
            "type": "string"
          },
          "maxExpirationSeconds": {
            "description": "Maximum number of seconds that the session may stay valid for, from the time it's bound. Even if the session is refreshed, it may not stay valid beyond this.\n",
            "type": "integer",
            "nullable": true
          }
        }
      },
      "RefreshSessionRequest": {
        "description": "Refresh an active session.",
        "type": "object",
        "required": [
          "sessionKey",
          "sessionId"
        ],
        "properties": {
          "sessionKey": {
            "description": "Session key for the session.",
            "type": "string"
          },
          "sessionId": {
            "description": "ID of the session",
            "type": "number"
          }
        }
      },
      "BatchRefreshSessionsRequest": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 50,
            "items": {
              "$ref": "#/components/schemas/RefreshSessionRequest"
            }
          }
        }
      },
      "BatchRefreshSessionsResponse": {
        "description": "A list of refreshed sessions. If the session could not be refreshed, it will not appear in this list.",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SessionTokenResponse"
            }
          },
          "failed": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchUpdateFailure"
            }
          }
        }
      },
      "BatchUpdateFailure": {
        "description": "",
        "type": "object",
        "required": [
          "id",
          "error",
          "code"
        ],
        "properties": {
          "id": {
            "description": "ID of the session.",
            "type": "number"
          },
          "error": {
            "description": "User-friendly error description.",
            "type": "string"
          },
          "code": {
            "description": "HTTP-code corresponding to this error.",
            "type": "number"
          }
        }
      },
      "SessionTokenResponse": {
        "description": "",
        "type": "object",
        "required": [
          "id",
          "accessToken",
          "expiresIn",
          "sessionExpirationTime",
          "sessionIsExtendable"
        ],
        "properties": {
          "id": {
            "description": "ID of the session.",
            "type": "number"
          },
          "accessToken": {
            "description": "Internal access token, for use by the internal service against CDF.",
            "type": "string"
          },
          "expiresIn": {
            "description": "Expiration time for the access token, seconds into the future.",
            "type": "number"
          },
          "sessionKey": {
            "description": "Session key for the session, to be used to refresh the session. Only provided when binding a session.",
            "type": "string"
          },
          "sessionExpirationTime": {
            "description": "Unix timestamp in milliseconds of when the session will expire if it is not refreshed.\n",
            "type": "integer"
          },
          "sessionIsExtendable": {
            "description": "If true, sessionExpirationTime can be extended on refresh. If false, sessionExpirationTime will remain the same on refresh.\n"
          }
        }
      },
      "CreateSessionRequestList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1,
            "items": {
              "$ref": "#/components/schemas/CreateSessionRequest"
            }
          }
        }
      },
      "CreateSessionRequest": {
        "description": "",
        "oneOf": [
          {
            "$ref": "#/components/schemas/CreateSessionWithClientCredentialsRequest"
          },
          {
            "$ref": "#/components/schemas/CreateSessionWithTokenExchangeRequest"
          },
          {
            "$ref": "#/components/schemas/CreateSessionWithOneshotTokenExchangeRequest"
          }
        ]
      },
      "CreateSessionWithClientCredentialsRequest": {
        "description": "Credentials for a session using client credentials from an identity provider.\n",
        "type": "object",
        "required": [
          "clientId",
          "clientSecret"
        ],
        "properties": {
          "clientId": {
            "type": "string",
            "description": "Client ID in identity provider"
          },
          "clientSecret": {
            "type": "string",
            "description": "Client secret in identity provider"
          }
        }
      },
      "CreateSessionWithTokenExchangeRequest": {
        "description": "Credentials for a session using token exchange to reuse the user's credentials.\n",
        "type": "object",
        "required": [
          "tokenExchange"
        ],
        "properties": {
          "tokenExchange": {
            "type": "boolean",
            "enum": [
              true
            ],
            "description": "Use token exchange for the session. Must be `true`."
          }
        }
      },
      "CreateSessionWithOneshotTokenExchangeRequest": {
        "description": "Credentials for a session using one-shot token exchange to reuse the user's credentials.\nOne-shot sessions are short-lived sessions that are not refreshed and do not require support for token exchange from the identity provider.\n",
        "type": "object",
        "required": [
          "oneshotTokenExchange"
        ],
        "properties": {
          "oneshotTokenExchange": {
            "type": "boolean",
            "enum": [
              true
            ],
            "description": "Use one-shot token exchange for the session. Must be `true`."
          }
        }
      },
      "CreateSessionResponseList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateSessionResponse"
            }
          }
        }
      },
      "CreateSessionResponse": {
        "description": "A response with the ID, nonce and other information related to the session. The nonce\nis short-lived and should be immediately passed to the endpoint that will use\nthe session.\n",
        "type": "object",
        "required": [
          "id",
          "status",
          "nonce"
        ],
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          },
          "type": {
            "type": "string",
            "description": "Values reserved for future use",
            "anyOf": [
              {
                "enum": [
                  "CLIENT_CREDENTIALS",
                  "TOKEN_EXCHANGE",
                  "ONESHOT_TOKEN_EXCHANGE"
                ]
              }
            ]
          },
          "status": {
            "description": "Current status of the session",
            "type": "string",
            "enum": [
              "READY",
              "ACTIVE",
              "CANCELLED",
              "EXPIRED",
              "REVOKED",
              "ACCESS_LOST"
            ]
          },
          "nonce": {
            "description": "Nonce to be passed to the internal service that will bind the session",
            "type": "string"
          },
          "clientId": {
            "description": "Client ID in identity provider. Returned only if the session was created using client credentials",
            "type": "string"
          }
        }
      },
      "RevokeSessionRequestList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/RevokeSessionRequest"
            }
          }
        }
      },
      "RevokeSessionRequest": {
        "description": "",
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          }
        }
      },
      "SessionList": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Session"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          },
          "previousCursor": {
            "type": "string",
            "description": "Cursor to get the previous page of results (if available)."
          }
        }
      },
      "SessionReferenceIds": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            "maxItems": 1000,
            "minItems": 1
          }
        }
      },
      "SessionByIds": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Session"
            }
          }
        }
      },
      "Session": {
        "type": "object",
        "properties": {
          "id": {
            "description": "ID of the session",
            "type": "number"
          },
          "type": {
            "type": "string",
            "description": "Values reserved for future use",
            "anyOf": [
              {
                "enum": [
                  "CLIENT_CREDENTIALS",
                  "TOKEN_EXCHANGE",
                  "ONESHOT_TOKEN_EXCHANGE"
                ]
              }
            ]
          },
          "status": {
            "description": "Current status of the session",
            "type": "string",
            "enum": [
              "READY",
              "ACTIVE",
              "CANCELLED",
              "EXPIRED",
              "REVOKED",
              "ACCESS_LOST"
            ]
          },
          "creationTime": {
            "description": "Session creation time, in milliseconds since 1970",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "expirationTime": {
            "description": "Session expiry time, in milliseconds since 1970. This value is updated on refreshing a token",
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            ]
          },
          "clientId": {
            "description": "Client ID in identity provider. Returned only if the session was created using client credentials",
            "type": "string"
          }
        }
      },
      "RawTable": {
        "required": [
          "dbName",
          "tableName"
        ],
        "type": "object",
        "properties": {
          "dbName": {
            "minLength": 1,
            "type": "string",
            "description": "Database name"
          },
          "tableName": {
            "minLength": 1,
            "type": "string",
            "description": "Table name"
          }
        }
      },
      "Contact": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Contact name",
            "nullable": true
          },
          "email": {
            "maxLength": 254,
            "minLength": 1,
            "type": "string",
            "description": "Contact email",
            "format": "email",
            "nullable": true
          },
          "role": {
            "type": "string",
            "description": "Contact role",
            "nullable": true
          },
          "sendNotification": {
            "type": "boolean",
            "description": "True, if contact receives email notifications",
            "nullable": true
          }
        }
      },
      "ExtPipeNotificationConfiguration": {
        "type": "object",
        "properties": {
          "allowedNotSeenRangeInMinutes": {
            "minimum": 0,
            "type": "integer",
            "description": "Notifications configuration value. Time in minutes to pass without any Run. Null if extraction pipeline is not checked.",
            "format": "int64",
            "nullable": true
          }
        }
      },
      "CreateExtPipe": {
        "required": [
          "dataSetId",
          "externalId",
          "name"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          },
          "name": {
            "maxLength": 140,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Name of Extraction Pipeline"
          },
          "description": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline",
            "nullable": true
          },
          "dataSetId": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "required": [
              "true"
            ],
            "type": "integer",
            "description": "DataSet ID",
            "format": "int64"
          },
          "rawTables": {
            "type": "array",
            "description": "Raw tables",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "schedule": {
            "pattern": "^(On trigger|Continuous)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|s|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: On trigger, Continuous or cron expression. If empty then null",
            "nullable": true
          },
          "contacts": {
            "type": "array",
            "description": "Contacts list.",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "source": {
            "maxLength": 255,
            "type": "string",
            "description": "Source for Extraction Pipeline",
            "nullable": true
          },
          "documentation": {
            "maxLength": 10000,
            "type": "string",
            "description": "Documentation text field, supports Markdown for text formatting.",
            "nullable": true
          },
          "notificationConfig": {
            "$ref": "#/components/schemas/ExtPipeNotificationConfiguration"
          },
          "createdBy": {
            "maxLength": 255,
            "type": "string",
            "description": "Extraction Pipeline creator. Usually user email is expected here",
            "nullable": true
          }
        }
      },
      "ExtPipe": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateExtPipe"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "maximum": 9007199254740991,
                "minimum": 0,
                "type": "integer",
                "description": "A server-generated ID for the object.",
                "format": "int64"
              },
              "lastSuccess": {
                "type": "integer",
                "description": "Time of last successful run. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "lastFailure": {
                "type": "integer",
                "description": "Time of last failure run. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "lastMessage": {
                "type": "string",
                "description": "Last failure message."
              },
              "lastSeen": {
                "type": "integer",
                "description": "Last seen time. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
                "format": "int64"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "createdBy": {
                "type": "string",
                "description": "Extraction Pipeline creator. Usually user email is expected here"
              }
            }
          }
        ]
      },
      "ExtPipes": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipe"
            }
          }
        },
        "description": "List of extraction pipelines"
      },
      "ExtPipesWithCursor": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipe"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "List of extraction pipelines"
      },
      "DefaultError": {
        "type": "object",
        "properties": {
          "code": {
            "required": [
              "true"
            ],
            "type": "integer",
            "description": "HTTP status code",
            "format": "int32"
          },
          "message": {
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Error message"
          },
          "missing": {
            "type": "array",
            "description": "List of lookup objects that do not match any results.",
            "items": {
              "type": "object"
            }
          },
          "duplicated": {
            "type": "array",
            "description": "List of objects that are not unique.",
            "items": {
              "type": "object"
            }
          }
        },
        "description": "Cognite API error"
      },
      "ItemsRequest_CreateExtPipe_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateExtPipe"
            }
          }
        }
      },
      "ExtendedItemsRequest_ExtPipeId_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeId"
            }
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore IDs and external IDs that are not found",
            "default": false
          }
        }
      },
      "ExtPipeInternalId": {
        "required": [
          "id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          }
        }
      },
      "ExtPipeExternalId": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          }
        }
      },
      "ExtPipeId": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ExtPipeInternalId"
          },
          {
            "$ref": "#/components/schemas/ExtPipeExternalId"
          }
        ]
      },
      "ItemsRequest_ExtPipeUpdate_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeUpdate"
            }
          }
        }
      },
      "ExternalIdUpdateField": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project."
          }
        },
        "description": "Set a new value for the externalId. Must be unique for the resource type."
      },
      "NameUpdateField": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 140,
            "minLength": 1,
            "type": "string",
            "description": "Name of Extraction Pipeline"
          }
        },
        "description": "Set a new value for name."
      },
      "DescriptionUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline",
            "nullable": true
          }
        },
        "description": "Set a new value for description."
      },
      "DataSetIdUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "required": [
              "true"
            ],
            "type": "integer",
            "description": "DataSet ID",
            "format": "int64"
          }
        },
        "description": "Set a new value for dataSetId."
      },
      "ScheduleUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "pattern": "^(On trigger|Continuous)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|s|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: On trigger, Continuous or cron expression. If empty then null",
            "nullable": true
          }
        },
        "description": "Set a new value for schedule."
      },
      "RawTablesUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "nullable": true,
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          }
        }
      },
      "RawTablesUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "remove": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          }
        }
      },
      "RawTablesUpdate": {
        "type": "object",
        "description": "Updates the resource's assigned rawTables. RawTables can be added, removed or replaced (set). ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/RawTablesUpdateSet"
          },
          {
            "$ref": "#/components/schemas/RawTablesUpdateAddRemove"
          }
        ]
      },
      "ContactsUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "description": "New contacts list",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          }
        }
      },
      "ContactsUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "Contacts to add",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "remove": {
            "type": "array",
            "description": "Contacts to remove",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          }
        }
      },
      "ContactsUpdate": {
        "type": "object",
        "description": "Updates the resource's assigned contacts. Contacts can be added, removed or replaced (set). ",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ContactsUpdateSet"
          },
          {
            "$ref": "#/components/schemas/ContactsUpdateAddRemove"
          }
        ]
      },
      "MapUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "nullable": true,
            "example": {
              "property1": "string",
              "property2": "string"
            }
          }
        }
      },
      "MapUpdateAddRemove": {
        "type": "object",
        "properties": {
          "add": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Add the key-value pairs. Values for existing keys will be overwritten.",
            "nullable": true,
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "remove": {
            "type": "array",
            "description": "Remove the key-value pairs with the specified keys.",
            "nullable": true,
            "items": {
              "type": "string"
            }
          }
        }
      },
      "MapUpdate": {
        "type": "object",
        "description": "Custom, application specific metadata. String key -> String value. Limits of updated extraction pipeline: Maximum length of key is 128 bytes, value 10240 bytes, up to 256 key-value pairs, of total size at most 10240.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/MapUpdateSet"
          },
          {
            "$ref": "#/components/schemas/MapUpdateAddRemove"
          }
        ]
      },
      "SourceUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 255,
            "type": "string",
            "description": "Source for Extraction Pipeline",
            "nullable": true
          }
        },
        "description": "Set a new value for source."
      },
      "DocumentationUpdateField": {
        "type": "object",
        "properties": {
          "set": {
            "maxLength": 10000,
            "type": "string",
            "description": "Documentation text field",
            "nullable": true
          }
        },
        "description": "Set a new value for documentation."
      },
      "ConfigurationUpdateSet": {
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ExtPipeNotificationConfiguration"
          }
        }
      },
      "ExtPipeUpdateData": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/ExternalIdUpdateField"
          },
          "name": {
            "$ref": "#/components/schemas/NameUpdateField"
          },
          "description": {
            "$ref": "#/components/schemas/DescriptionUpdateField"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/DataSetIdUpdateField"
          },
          "schedule": {
            "$ref": "#/components/schemas/ScheduleUpdateField"
          },
          "rawTables": {
            "$ref": "#/components/schemas/RawTablesUpdate"
          },
          "contacts": {
            "$ref": "#/components/schemas/ContactsUpdate"
          },
          "metadata": {
            "$ref": "#/components/schemas/MapUpdate"
          },
          "source": {
            "$ref": "#/components/schemas/SourceUpdateField"
          },
          "documentation": {
            "$ref": "#/components/schemas/DocumentationUpdateField"
          },
          "notificationConfig": {
            "$ref": "#/components/schemas/ConfigurationUpdateSet"
          }
        },
        "description": "List of updates for Extraction Pipeline"
      },
      "ExtPipeUpdateById": {
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 0,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          },
          "update": {
            "$ref": "#/components/schemas/ExtPipeUpdateData"
          }
        }
      },
      "ExtPipeUpdateByExternalId": {
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "type": "string",
            "description": "External Id provided by client. Should be unique within the project.",
            "nullable": true
          },
          "update": {
            "$ref": "#/components/schemas/ExtPipeUpdateData"
          }
        }
      },
      "ExtPipeUpdate": {
        "type": "object",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ExtPipeUpdateById"
          },
          {
            "$ref": "#/components/schemas/ExtPipeUpdateByExternalId"
          }
        ]
      },
      "ExtPipesFilterRequest": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/ExtPipesFilter"
          },
          "limit": {
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "description": "Limits the number of results to return.",
            "format": "int32",
            "default": 100
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "ExtPipesFilter": {
        "type": "object",
        "properties": {
          "externalIdPrefix": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "Filter by this (case-sensitive) prefix for the external ID."
          },
          "name": {
            "maxLength": 140,
            "minLength": 1,
            "type": "string",
            "description": "Name of Extraction Pipeline"
          },
          "description": {
            "maxLength": 500,
            "type": "string",
            "description": "Description of Extraction Pipeline"
          },
          "dataSetIds": {
            "maxItems": 100,
            "minItems": 1,
            "type": "array",
            "description": "DataSetId list",
            "items": {
              "$ref": "#/components/schemas/DataSetIdEither"
            }
          },
          "schedule": {
            "pattern": "^(On trigger|Continuous|Null)|(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|s|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+([/\\-])\\d+)|\\d+|\\*(/\\d+)?) ?){5,7})$",
            "type": "string",
            "description": "Possible values: On trigger, Continuous or cron expression. If empty then Null"
          },
          "contacts": {
            "type": "array",
            "description": "Contacts list.",
            "items": {
              "$ref": "#/components/schemas/Contact"
            }
          },
          "rawTables": {
            "type": "array",
            "description": "Raw tables",
            "items": {
              "$ref": "#/components/schemas/RawTable"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Custom, application specific metadata. String key -> String value. Limits: Key are at most 128 bytes. Values are at most 10240 bytes. Up to 256 key-value pairs. Total size is at most 10240.",
            "example": {
              "property1": "string",
              "property2": "string"
            }
          },
          "source": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "Source for Extraction Pipeline"
          },
          "documentation": {
            "maxLength": 10000,
            "minLength": 1,
            "type": "string",
            "description": "Documentation text field"
          },
          "createdBy": {
            "maxLength": 255,
            "minLength": 1,
            "type": "string",
            "description": "Extraction Pipeline creator. Usually user email is expected here"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          }
        }
      },
      "ConfigResponse": {
        "required": [
          "externalId",
          "revision"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "External ID of the extraction pipeline this configuration revision belongs to."
          },
          "config": {
            "type": "string",
            "description": "Configuration revision contents."
          },
          "revision": {
            "maximum": 2147483647,
            "minimum": 0,
            "type": "integer",
            "description": "Revision number of this configuration.",
            "format": "int32"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "description": {
            "type": "string",
            "description": "A description of this config revision.",
            "nullable": true
          }
        }
      },
      "CreateConfigRequest": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "External ID of the extraction pipeline this configuration revision belongs to."
          },
          "config": {
            "type": "string",
            "description": "Configuration content."
          },
          "description": {
            "type": "string",
            "description": "A description of this configuration revision.",
            "nullable": true
          }
        }
      },
      "RevertConfigRequest": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "External ID of the extraction pipeline to revert configurations for."
          },
          "revision": {
            "maximum": 2147483647,
            "minimum": 0,
            "type": "integer",
            "description": "Revision number of this configuration.",
            "format": "int32"
          }
        }
      },
      "ItemsRequest_ExtPipeRunRequest_": {
        "required": [
          "items"
        ],
        "type": "object",
        "properties": {
          "items": {
            "maxItems": 1000,
            "minItems": 1,
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunRequest"
            }
          }
        }
      },
      "ExtPipeRunStatus": {
        "type": "string",
        "enum": [
          "success",
          "failure",
          "seen"
        ]
      },
      "ExtPipeRunRequest": {
        "required": [
          "externalId",
          "status"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Extraction pipeline external Id provided by client. Should be unique within the project."
          },
          "status": {
            "$ref": "#/components/schemas/ExtPipeRunStatus"
          },
          "message": {
            "maxLength": 1000,
            "type": "string",
            "description": "Error message.",
            "nullable": true
          },
          "createdTime": {
            "type": "integer",
            "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64",
            "nullable": true
          }
        },
        "description": "Status of the extraction pipeline."
      },
      "RunsFilterRequest": {
        "required": [
          "filter"
        ],
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/RunsFilter"
          },
          "limit": {
            "maximum": 1000,
            "minimum": 1,
            "type": "integer",
            "description": "Limits the number of results to return.",
            "format": "int32",
            "default": 100
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "RunsFilter": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Extraction pipeline external Id provided by client."
          },
          "statuses": {
            "type": "array",
            "description": "Extraction pipeline statuses list. Expected values: success, failure, seen.",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunStatus"
            }
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestampRange"
          },
          "message": {
            "$ref": "#/components/schemas/StringFilter"
          }
        }
      },
      "StringFilter": {
        "type": "object",
        "properties": {
          "substring": {
            "type": "string",
            "description": "Substring to find strings, that contains it ignoring case."
          }
        }
      },
      "ExtPipeRunResponse": {
        "required": [
          "status"
        ],
        "type": "object",
        "properties": {
          "id": {
            "maximum": 9007199254740991,
            "minimum": 1,
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int64"
          },
          "status": {
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "Extraction Pipeline status."
          },
          "message": {
            "type": "string",
            "description": "Error message."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "description": "Extraction Pipeline Run. Contains extraction pipeline status and message for a moment of time"
      },
      "ItemsResponse_ExtPipeRunResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExtPipeRunResponse"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "The cursor to get the next page of results (if available)."
          }
        },
        "description": "Response with a list of elements."
      },
      "CreateExtPipeRunResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ExtPipeRunResponse"
          },
          {
            "type": "object",
            "properties": {
              "externalId": {
                "type": "string",
                "description": "Extraction Pipeline external Id."
              }
            },
            "description": "Create Extraction Pipeline Runs response."
          }
        ]
      },
      "ItemsResponse_CreateExtPipeRunResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateExtPipeRunResponse"
            }
          }
        }
      },
      "ListConfigResponse": {
        "required": [
          "externalId",
          "revision"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "maxLength": 255,
            "minLength": 1,
            "required": [
              "true"
            ],
            "type": "string",
            "description": "External ID of the extraction pipeline this configuration revision belongs to."
          },
          "revision": {
            "maximum": 2147483647,
            "minimum": 0,
            "type": "integer",
            "description": "Revision number of this configuration.",
            "format": "int32"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "description": {
            "type": "string",
            "description": "A description of this configuration revision.",
            "nullable": true
          }
        }
      },
      "ItemsResponse_ListConfigResponse_": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ListConfigResponse"
            }
          }
        }
      },
      "CogniteExtId": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string"
          }
        },
        "description": "The external ID provided by the client. Must be unique for the resource type."
      },
      "CogniteIntId": {
        "required": [
          "id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          }
        },
        "description": "A server-generated ID for the object."
      },
      "ColumnType": {
        "required": [
          "name",
          "sqlType",
          "type",
          "nullable"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Column name."
          },
          "sqlType": {
            "type": "string",
            "description": "Type of the column in sql format."
          },
          "type": {
            "description": "Type of the column in json format.",
            "oneOf": [
              {
                "required": [
                  "type"
                ],
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string"
                  }
                }
              },
              {
                "type": "string"
              }
            ]
          },
          "nullable": {
            "type": "boolean",
            "description": "Values for the column can be null or not."
          }
        },
        "description": "Details of a column in a given schema."
      },
      "ConflictMode": {
        "type": "string",
        "description": "Behavior when the data already exists.`upsert` - Create or Update,`abort` - Create and fail when already exists,`update` - update and fail if it does not exist,`delete` - delete the matched rows.",
        "enum": [
          "abort",
          "delete",
          "update",
          "upsert"
        ]
      },
      "ContainsAny": {
        "type": "object",
        "properties": {
          "containsAny": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Filter the transformations having any of these tags."
          }
        }
      },
      "AssetCentricDataSource": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of the destination resource.",
            "enum": [
              "assets",
              "events",
              "asset_hierarchy",
              "datapoints",
              "string_datapoints",
              "timeseries",
              "sequences",
              "files",
              "labels",
              "relationships",
              "data_sets"
            ]
          }
        }
      },
      "EdgeType": {
        "required": [
          "space",
          "externalId"
        ],
        "type": "object",
        "properties": {
          "space": {
            "type": "string",
            "description": "Space of the type"
          },
          "externalId": {
            "type": "string",
            "description": "External ID of the type"
          }
        },
        "description": "Target type of the connection definition"
      },
      "FlatOidcCredentials": {
        "required": [
          "clientId",
          "clientSecret",
          "tokenUri",
          "cdfProjectName"
        ],
        "type": "object",
        "properties": {
          "clientId": {
            "type": "string"
          },
          "clientSecret": {
            "type": "string"
          },
          "scopes": {
            "type": "string"
          },
          "tokenUri": {
            "type": "string"
          },
          "cdfProjectName": {
            "type": "string"
          },
          "audience": {
            "type": "string"
          }
        }
      },
      "FlatOidcCredentialsUpdate": {
        "type": "object",
        "properties": {
          "clientId": {
            "type": "string"
          },
          "clientSecret": {
            "type": "string"
          },
          "scopes": {
            "type": "string"
          },
          "tokenUri": {
            "type": "string"
          },
          "cdfProjectName": {
            "type": "string"
          },
          "audience": {
            "type": "string"
          }
        }
      },
      "ViewDataSource": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of the destination resource indicating the instance type that the transformation will write to flexible data models.",
            "enum": [
              "nodes",
              "edges"
            ]
          },
          "view": {
            "$ref": "#/components/schemas/ViewInfo"
          },
          "edgeType": {
            "$ref": "#/components/schemas/EdgeType"
          },
          "instanceSpace": {
            "type": "string",
            "description": "The space where the instances(nodes/edges) will be created."
          }
        }
      },
      "DataModelSource": {
        "required": [
          "type",
          "dataModel"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of the destination resource indicating that the transformation will write to data models",
            "enum": [
              "instances"
            ]
          },
          "dataModel": {
            "$ref": "#/components/schemas/DataModelInfo"
          },
          "instanceSpace": {
            "type": "string",
            "description": "The space where the instances will be created."
          }
        }
      },
      "ItemsWithByIdsFlags_CogniteId": {
        "required": [
          "withJobDetails"
        ],
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransformationCogniteExternalId"
                },
                {
                  "$ref": "#/components/schemas/TransformationCogniteInternalId"
                }
              ]
            },
            "maxItems": 1000
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore IDs and external IDs that are not found. Defaults to false."
          },
          "withJobDetails": {
            "type": "boolean",
            "description": "Whether the transformations will be returned with running job and last created job details."
          }
        },
        "description": "All provided IDs and external IDs must be unique."
      },
      "ItemsWithCursor_JobRead": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/JobRead"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "ItemsWithCursor_NotificationRead": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationRead"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "ItemsWithCursor_Schedule": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Schedule"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "ItemsWithCursor_TransformationRead": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransformationRead"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        },
        "description": "Array of objects (Transformation)."
      },
      "ItemsWithIgnoreUnknownIds_CogniteId": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/TransformationCogniteExternalId"
                },
                {
                  "$ref": "#/components/schemas/TransformationCogniteInternalId"
                }
              ]
            },
            "maxItems": 1000
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore IDs and external IDs that are not found. Defaults to false."
          }
        },
        "description": "All provided IDs and external IDs must be unique."
      },
      "ItemsWithIgnoreUnknownIds_CogniteInternalId": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransformationCogniteInternalId"
            }
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore IDs and external IDs that are not found. Defaults to false."
          }
        },
        "description": "All provided IDs and external IDs must be unique."
      },
      "Items_CogniteInternalId": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransformationCogniteInternalId"
            }
          }
        }
      },
      "Items_ColumnType": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ColumnType"
            }
          }
        }
      },
      "Items_JobRead": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/JobRead"
            }
          }
        }
      },
      "Items_JsonObject": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        "description": "Query result in json format."
      },
      "Items_MetricCounter": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MetricCounter"
            }
          }
        }
      },
      "Items_NotificationCreate": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/NotificationCreateWithExternalId"
                },
                {
                  "$ref": "#/components/schemas/NotificationCreateWithId"
                }
              ]
            },
            "maxItems": 1000
          }
        }
      },
      "Items_NotificationRead": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/NotificationRead"
            }
          }
        }
      },
      "Items_Schedule": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Schedule"
            }
          }
        }
      },
      "Items_ScheduleParameters": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/ScheduleParametersWithExternalId"
                },
                {
                  "$ref": "#/components/schemas/ScheduleParametersWithId"
                }
              ]
            }
          }
        }
      },
      "Items_TransformationCreate": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransformationCreate"
            },
            "maxItems": 1000
          }
        }
      },
      "Items_TransformationRead": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TransformationRead"
            }
          }
        },
        "description": "Array of objects (Transformation)."
      },
      "Items_UpdateItem_ScheduleUpdate": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UpdateItemWithExternalId_ScheduleUpdate"
                },
                {
                  "$ref": "#/components/schemas/UpdateItemWithId_ScheduleUpdate"
                }
              ]
            }
          }
        }
      },
      "Items_UpdateItem_TransformationUpdate": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UpdateItemWithExternalId_TransformationUpdate"
                },
                {
                  "$ref": "#/components/schemas/UpdateItemWithId_TransformationUpdate"
                }
              ]
            },
            "maxItems": 1000
          }
        }
      },
      "JobRead": {
        "required": [
          "id",
          "uuid",
          "transformationId",
          "transformationExternalId",
          "sourceProject",
          "destinationProject",
          "destination",
          "conflictMode",
          "query",
          "ignoreNullFields",
          "status"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Job numeric ID.",
            "format": "int32"
          },
          "uuid": {
            "type": "string",
            "description": "UUID id of the job."
          },
          "transformationId": {
            "type": "integer",
            "description": "ID of the transformation that created this job.",
            "format": "int32"
          },
          "transformationExternalId": {
            "type": "string",
            "description": "External ID of the transformation that created this job."
          },
          "sourceProject": {
            "type": "string",
            "description": "CDF project which is used as source for reading data."
          },
          "destinationProject": {
            "type": "string",
            "description": "CDF project which is used as destination for writing data."
          },
          "destination": {
            "description": "Destination data type.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssetCentricDataSource"
              },
              {
                "$ref": "#/components/schemas/DataModelSource"
              },
              {
                "$ref": "#/components/schemas/ViewDataSource"
              },
              {
                "$ref": "#/components/schemas/RawDataSource"
              },
              {
                "$ref": "#/components/schemas/SequenceRowDataSource"
              }
            ]
          },
          "conflictMode": {
            "$ref": "#/components/schemas/ConflictMode"
          },
          "query": {
            "type": "string",
            "description": "The SQL query being executed."
          },
          "createdTime": {
            "type": "integer",
            "description": "Time when the job was created: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "startedTime": {
            "type": "integer",
            "description": "Time when this job started executing: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "finishedTime": {
            "type": "integer",
            "description": "Time when this job finished running: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "lastSeenTime": {
            "type": "integer",
            "description": "Time when this job last registered running: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "error": {
            "type": "string",
            "description": "If the job failed, this will be a string describing why. When null, the job did not fail."
          },
          "ignoreNullFields": {
            "type": "boolean",
            "description": "How NULL values are handled on updates: ignore or setNull."
          },
          "status": {
            "$ref": "#/components/schemas/TransformationJobStatus"
          }
        },
        "description": "Details for the last finished job of this transformation"
      },
      "MetricCounter": {
        "required": [
          "timestamp",
          "name",
          "count"
        ],
        "type": "object",
        "properties": {
          "timestamp": {
            "type": "integer",
            "description": "Time when this metric was recorded: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "name": {
            "type": "string",
            "description": "Name of the metric. Metrics like `assets.read` mean how many items were fetched from CDF;`assets.create` and `assets.update` inform how many resources were created or updated (note that we count objects as updated even when no field is changed). `requests` says how many HTTP request were made to CDF to complete the job. `requestWithoutRetries` does not count retried requests. Normally, these two metrics should be almost equal, if there is a big difference, it may indicate a problem with rate-limiting.",
            "example": "assets.read"
          },
          "count": {
            "type": "integer",
            "description": "The value of this metric",
            "format": "int64"
          }
        }
      },
      "MinMax": {
        "type": "object",
        "properties": {
          "min": {
            "type": "integer",
            "description": "Minimum timestamp (inclusive).\nThe number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "max": {
            "type": "integer",
            "description": "Maximum timestamp (inclusive).\nThe number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          }
        },
        "description": "Range between two timestamps (inclusive)."
      },
      "NonceCredentials": {
        "required": [
          "sessionId",
          "nonce",
          "cdfProjectName"
        ],
        "type": "object",
        "properties": {
          "sessionId": {
            "type": "integer",
            "format": "int64"
          },
          "nonce": {
            "type": "string"
          },
          "cdfProjectName": {
            "type": "string"
          },
          "clientId": {
            "type": "string"
          }
        }
      },
      "NotificationCreateWithExternalId": {
        "required": [
          "destination",
          "transformationExternalId"
        ],
        "type": "object",
        "properties": {
          "destination": {
            "type": "string",
            "description": "Email address where notifications should be sent."
          },
          "transformationExternalId": {
            "type": "string",
            "description": "Transformation external ID to subscribe."
          }
        }
      },
      "NotificationCreateWithId": {
        "required": [
          "destination",
          "transformationId"
        ],
        "type": "object",
        "properties": {
          "destination": {
            "type": "string",
            "description": "Email address where notifications should be sent."
          },
          "transformationId": {
            "type": "integer",
            "description": "Transformation ID to subscribe.",
            "format": "int32"
          }
        }
      },
      "NotificationRead": {
        "required": [
          "id",
          "createdTime",
          "lastUpdatedTime",
          "transformationId",
          "destination"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Id of the notification subscription. Required for deleting the subscription.",
            "format": "int32"
          },
          "createdTime": {
            "type": "integer",
            "description": "Time when the notification subscription was created: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "description": "Time when the notification subscription was last updated: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "transformationId": {
            "type": "integer",
            "description": "Id of the transformation for which the notifications are sent.",
            "format": "int32"
          },
          "destination": {
            "type": "string",
            "description": "Email address where notifications should be sent."
          }
        }
      },
      "QueryRequestBody": {
        "required": [
          "query",
          "convertToString"
        ],
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "SQL query to run for preview."
          },
          "convertToString": {
            "type": "boolean",
            "description": "Stringify values in the query results."
          },
          "limit": {
            "type": "integer",
            "description": "End-result limit of the query.",
            "format": "int32"
          },
          "sourceLimit": {
            "type": "integer",
            "description": "Limit for how many rows to download from the data sources.",
            "format": "int32"
          },
          "inferSchemaLimit": {
            "type": "integer",
            "description": "Limit for how many rows that are used for inferring schema. Default is 10,000.",
            "format": "int32"
          },
          "timeout": {
            "type": "integer",
            "description": "Number of seconds to wait before cancelling a query. The default, and maximum, is 240.",
            "format": "int32"
          }
        },
        "description": "Query object to run a query to preview results."
      },
      "QueryResultsBody": {
        "required": [
          "schema",
          "results"
        ],
        "type": "object",
        "properties": {
          "schema": {
            "$ref": "#/components/schemas/Items_ColumnType"
          },
          "results": {
            "$ref": "#/components/schemas/Items_JsonObject"
          }
        },
        "description": "Response object containing result schema and data."
      },
      "RawDataSource": {
        "required": [
          "type",
          "database",
          "table"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of the destination resource indicating that the transformation will write to RAW.",
            "enum": [
              "raw"
            ]
          },
          "database": {
            "type": "string",
            "description": "The database name."
          },
          "table": {
            "type": "string",
            "description": "The table name."
          }
        }
      },
      "Schedule": {
        "required": [
          "id",
          "externalId",
          "createdTime",
          "lastUpdatedTime",
          "interval",
          "isPaused"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Transformation ID",
            "format": "int32"
          },
          "externalId": {
            "type": "string",
            "description": "Transformation externalId"
          },
          "createdTime": {
            "type": "integer",
            "description": "Time when the schedule was created: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "description": "Time when the schedule was last updated: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "interval": {
            "$ref": "#/components/schemas/CronValue"
          },
          "isPaused": {
            "type": "boolean",
            "description": "If true, the transformation is not scheduled."
          }
        },
        "description": "Details for the schedule if the transformation is scheduled"
      },
      "ScheduleParametersWithExternalId": {
        "required": [
          "interval",
          "externalId"
        ],
        "type": "object",
        "properties": {
          "interval": {
            "$ref": "#/components/schemas/CronValue"
          },
          "isPaused": {
            "type": "boolean",
            "description": "If true, the transformation is not scheduled."
          },
          "externalId": {
            "type": "string",
            "description": "External ID of the scheduled transformation"
          }
        }
      },
      "ScheduleParametersWithId": {
        "required": [
          "interval",
          "id"
        ],
        "type": "object",
        "properties": {
          "interval": {
            "$ref": "#/components/schemas/CronValue"
          },
          "isPaused": {
            "type": "boolean",
            "description": "If true, the transformation is not scheduled."
          },
          "id": {
            "type": "integer",
            "description": "ID of the scheduled transformation",
            "format": "int32"
          }
        }
      },
      "ScheduleUpdate": {
        "type": "object",
        "properties": {
          "interval": {
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/CronValue"
              }
            }
          },
          "isPaused": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SetBooleanField"
              }
            ],
            "description": "If true, the transformation is not scheduled."
          }
        }
      },
      "SequenceRowDataSource": {
        "required": [
          "type",
          "externalId"
        ],
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The type of the destination resource indicating that the transformation will write to Sequence Rows.",
            "enum": [
              "sequence_rows"
            ]
          },
          "externalId": {
            "type": "string",
            "description": "The externalId of sequence"
          }
        }
      },
      "SessionInfo": {
        "type": "object",
        "properties": {
          "clientId": {
            "type": "string",
            "description": "Idp client ID"
          },
          "sessionId": {
            "type": "integer",
            "description": "CDF session ID",
            "format": "int64"
          },
          "projectName": {
            "type": "string",
            "description": "CDF project name"
          }
        },
        "description": "Details for the session used to read from the source project."
      },
      "CronValue": {
        "type": "string",
        "example": "0 0 * * *",
        "description": "Cron expression describes when the job should run."
      },
      "SetNull_FlatOidcCredentialsUpdate": {
        "required": [
          "setNull"
        ],
        "type": "object",
        "properties": {
          "setNull": {
            "type": "boolean"
          }
        }
      },
      "SetNull_Long": {
        "required": [
          "setNull"
        ],
        "type": "object",
        "properties": {
          "setNull": {
            "type": "boolean"
          }
        }
      },
      "SetNull_NonceCredentials": {
        "required": [
          "setNull"
        ],
        "type": "object",
        "properties": {
          "setNull": {
            "type": "boolean"
          }
        }
      },
      "SetValue_ConflictMode": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/ConflictMode"
          }
        },
        "description": "Set a new value for the transformation conflictMode (action)."
      },
      "SetValue_DataSource": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssetCentricDataSource"
              },
              {
                "$ref": "#/components/schemas/DataModelSource"
              },
              {
                "$ref": "#/components/schemas/ViewDataSource"
              },
              {
                "$ref": "#/components/schemas/RawDataSource"
              },
              {
                "$ref": "#/components/schemas/SequenceRowDataSource"
              }
            ]
          }
        },
        "description": "Set a new value for the transformation destination type. Indicates result resource type."
      },
      "SetValue_FlatOidcCredentialsUpdate": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/FlatOidcCredentialsUpdate"
          }
        }
      },
      "SetValue_Long": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "SetValue_NonceCredentials": {
        "required": [
          "set"
        ],
        "type": "object",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/NonceCredentials"
          }
        }
      },
      "SetValue_Seq_String": {
        "type": "object",
        "properties": {
          "set": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 35
            },
            "description": "List of tags for the Transformation.",
            "minItems": 1,
            "maxItems": 5
          }
        }
      },
      "TransformBlockedInfo": {
        "required": [
          "reason",
          "createdTime"
        ],
        "type": "object",
        "properties": {
          "reason": {
            "type": "string",
            "description": "Indicates the reason if the transformation is blocked."
          },
          "createdTime": {
            "type": "integer",
            "description": "Indicates the blocked time if the transformation is blocked: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          }
        },
        "description": "Provides reason and time if the transformation is blocked."
      },
      "TransformationAdvancedList": {
        "required": [
          "filter"
        ],
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/TransformationFilter"
          },
          "limit": {
            "type": "integer",
            "format": "int32"
          },
          "cursor": {
            "type": "string"
          }
        }
      },
      "TransformationCogniteExternalId": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type."
          }
        }
      },
      "TransformationCogniteInternalId": {
        "required": [
          "id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int32"
          }
        }
      },
      "TransformationCreate": {
        "required": [
          "name",
          "externalId",
          "ignoreNullFields"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "query": {
            "type": "string"
          },
          "destination": {
            "description": "Destination data type.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssetCentricDataSource"
              },
              {
                "$ref": "#/components/schemas/DataModelSource"
              },
              {
                "$ref": "#/components/schemas/ViewDataSource"
              },
              {
                "$ref": "#/components/schemas/RawDataSource"
              },
              {
                "$ref": "#/components/schemas/SequenceRowDataSource"
              }
            ]
          },
          "conflictMode": {
            "$ref": "#/components/schemas/ConflictMode"
          },
          "isPublic": {
            "type": "boolean"
          },
          "sourceOidcCredentials": {
            "$ref": "#/components/schemas/FlatOidcCredentials"
          },
          "destinationOidcCredentials": {
            "$ref": "#/components/schemas/FlatOidcCredentials"
          },
          "sourceNonce": {
            "$ref": "#/components/schemas/NonceCredentials"
          },
          "destinationNonce": {
            "$ref": "#/components/schemas/NonceCredentials"
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type."
          },
          "ignoreNullFields": {
            "type": "boolean",
            "description": "How NULL values are handled on updates: ignore or setNull."
          },
          "dataSetId": {
            "type": "integer",
            "format": "int64"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 35
            },
            "description": "List of tags for the Transformation.",
            "minItems": 1,
            "maxItems": 5
          }
        }
      },
      "TransformationFilter": {
        "type": "object",
        "properties": {
          "isPublic": {
            "type": "boolean",
            "description": "Whether public transformations should be included in the results. The default is true."
          },
          "nameRegex": {
            "type": "string",
            "description": "Regex expression to match the transformation name."
          },
          "queryRegex": {
            "type": "string",
            "description": "Regex expression to match the transformation query."
          },
          "destinationType": {
            "type": "string",
            "description": "Transformation destination resource name to filter by."
          },
          "conflictMode": {
            "$ref": "#/components/schemas/ConflictMode"
          },
          "hasBlockedError": {
            "type": "boolean",
            "description": "Whether only the blocked transformations should be included in the results."
          },
          "cdfProjectName": {
            "type": "string",
            "description": "Project name to filter by configured source and destination project."
          },
          "createdTime": {
            "$ref": "#/components/schemas/MinMax"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/MinMax"
          },
          "dataSetIds": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CogniteExtId"
                },
                {
                  "$ref": "#/components/schemas/CogniteIntId"
                }
              ]
            },
            "description": "Return only transformations in the specified data sets."
          },
          "tags": {
            "description": "Return the transformations depending on the tags filter provided.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ContainsAny"
              }
            ]
          }
        }
      },
      "TransformationJobStatus": {
        "type": "string",
        "description": "Status of the job at the request time.",
        "enum": [
          "Completed",
          "Created",
          "Failed",
          "Running"
        ]
      },
      "TransformationRead": {
        "required": [
          "id",
          "name",
          "query",
          "destination",
          "conflictMode",
          "isPublic",
          "createdTime",
          "lastUpdatedTime",
          "owner",
          "ownerIsCurrentUser",
          "hasSourceOidcCredentials",
          "hasDestinationOidcCredentials",
          "externalId",
          "ignoreNullFields"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "description": "Transformation ID.",
            "format": "int32"
          },
          "name": {
            "type": "string",
            "description": "Transformation name."
          },
          "query": {
            "type": "string",
            "description": "Transformation query."
          },
          "destination": {
            "description": "Destination data type.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/AssetCentricDataSource"
              },
              {
                "$ref": "#/components/schemas/DataModelSource"
              },
              {
                "$ref": "#/components/schemas/ViewDataSource"
              },
              {
                "$ref": "#/components/schemas/RawDataSource"
              },
              {
                "$ref": "#/components/schemas/SequenceRowDataSource"
              }
            ]
          },
          "conflictMode": {
            "$ref": "#/components/schemas/ConflictMode"
          },
          "isPublic": {
            "type": "boolean",
            "description": "Indicates if the transformation is visible to all in project or only to the owner."
          },
          "blocked": {
            "$ref": "#/components/schemas/TransformBlockedInfo"
          },
          "createdTime": {
            "type": "integer",
            "description": "Time when the transformation was created: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "description": "Time when the transformation was last updated: The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
            "format": "int64"
          },
          "owner": {
            "type": "string",
            "description": "Owner of the transformation: requester's identity."
          },
          "ownerIsCurrentUser": {
            "type": "boolean",
            "description": "Indicates if the transformation belongs to the current user."
          },
          "hasSourceOidcCredentials": {
            "type": "boolean",
            "description": "Indicates if the transformation is configured with a source oidc credentials set."
          },
          "hasDestinationOidcCredentials": {
            "type": "boolean",
            "description": "Indicates if the transformation is configured with a destination oidc credentials set."
          },
          "sourceSession": {
            "$ref": "#/components/schemas/SessionInfo"
          },
          "destinationSession": {
            "$ref": "#/components/schemas/SessionInfo"
          },
          "lastFinishedJob": {
            "$ref": "#/components/schemas/JobRead"
          },
          "runningJob": {
            "$ref": "#/components/schemas/JobRead"
          },
          "schedule": {
            "$ref": "#/components/schemas/Schedule"
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type."
          },
          "ignoreNullFields": {
            "type": "boolean",
            "description": "How NULL values are handled on updates: ignore or setNull."
          },
          "dataSetId": {
            "type": "integer",
            "description": "Gets the transformation dataset id which can be used for access control.",
            "format": "int64"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 35
            },
            "description": "List of tags for the Transformation.",
            "minItems": 1,
            "maxItems": 5
          }
        }
      },
      "TransformationRunWithExternalId": {
        "required": [
          "externalId"
        ],
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string"
          },
          "nonce": {
            "$ref": "#/components/schemas/NonceCredentials"
          }
        }
      },
      "TransformationRunWithId": {
        "required": [
          "id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int32"
          },
          "nonce": {
            "$ref": "#/components/schemas/NonceCredentials"
          }
        }
      },
      "TransformationUpdate": {
        "type": "object",
        "properties": {
          "name": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SetStringField"
              }
            ],
            "description": "Set a new value for the transformation name."
          },
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SetExternalId"
              }
            ],
            "description": "Set a new value for the transformation External ID."
          },
          "destination": {
            "$ref": "#/components/schemas/SetValue_DataSource"
          },
          "conflictMode": {
            "$ref": "#/components/schemas/SetValue_ConflictMode"
          },
          "query": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SetStringField"
              }
            ],
            "description": "Set a new value for the transformation query."
          },
          "sourceOidcCredentials": {
            "description": "Set a new value for the transformation source OIDC credentials, or remove it.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SetNull_FlatOidcCredentialsUpdate"
              },
              {
                "$ref": "#/components/schemas/SetValue_FlatOidcCredentialsUpdate"
              }
            ]
          },
          "destinationOidcCredentials": {
            "description": "Set a new value for the transformation destination OIDC credentials, or remove it.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SetNull_FlatOidcCredentialsUpdate"
              },
              {
                "$ref": "#/components/schemas/SetValue_FlatOidcCredentialsUpdate"
              }
            ]
          },
          "sourceNonce": {
            "description": "Bind to a new source CDF session, or remove it",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SetNull_NonceCredentials"
              },
              {
                "$ref": "#/components/schemas/SetValue_NonceCredentials"
              }
            ]
          },
          "destinationNonce": {
            "description": "Bind to a new destination session, or remove it",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SetNull_NonceCredentials"
              },
              {
                "$ref": "#/components/schemas/SetValue_NonceCredentials"
              }
            ]
          },
          "isPublic": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SetBooleanField"
              }
            ],
            "description": "Set a new value for the transformation isPublic flag to change who can see the transformation."
          },
          "ignoreNullFields": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SetBooleanField"
              }
            ],
            "description": "Set a new value for the transformation ignoreNullFields flag to change to change how nulls are handled on updates."
          },
          "dataSetId": {
            "description": "Set a new value for the transformation dataset id which is used for access control.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SetNull_Long"
              },
              {
                "$ref": "#/components/schemas/SetValue_Long"
              }
            ]
          },
          "tags": {
            "description": "List of tags for the Transformation.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/SetValue_Seq_String"
              },
              {
                "$ref": "#/components/schemas/UpdateArray_String"
              }
            ]
          }
        }
      },
      "UpdateArray_String": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 35
            },
            "description": "List of tags to add to the Transformation."
          },
          "remove": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 35
            },
            "description": "List of tags to remove from the Transformation."
          }
        }
      },
      "UpdateItemWithExternalId_ScheduleUpdate": {
        "required": [
          "update",
          "externalId"
        ],
        "type": "object",
        "properties": {
          "update": {
            "$ref": "#/components/schemas/ScheduleUpdate"
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type."
          }
        }
      },
      "UpdateItemWithExternalId_TransformationUpdate": {
        "required": [
          "update",
          "externalId"
        ],
        "type": "object",
        "properties": {
          "update": {
            "$ref": "#/components/schemas/TransformationUpdate"
          },
          "externalId": {
            "type": "string",
            "description": "The external ID provided by the client. Must be unique for the resource type."
          }
        }
      },
      "UpdateItemWithId_ScheduleUpdate": {
        "required": [
          "update",
          "id"
        ],
        "type": "object",
        "properties": {
          "update": {
            "$ref": "#/components/schemas/ScheduleUpdate"
          },
          "id": {
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int32"
          }
        }
      },
      "UpdateItemWithId_TransformationUpdate": {
        "required": [
          "update",
          "id"
        ],
        "type": "object",
        "properties": {
          "update": {
            "$ref": "#/components/schemas/TransformationUpdate"
          },
          "id": {
            "type": "integer",
            "description": "A server-generated ID for the object.",
            "format": "int32"
          }
        }
      },
      "ViewInfo": {
        "required": [
          "space",
          "externalId",
          "version"
        ],
        "type": "object",
        "properties": {
          "space": {
            "type": "string",
            "description": "Space of the View"
          },
          "externalId": {
            "type": "string",
            "description": "External ID of the View"
          },
          "version": {
            "type": "string",
            "description": "Version of the View"
          }
        },
        "description": "Target view info"
      },
      "DataModelInfo": {
        "required": [
          "space",
          "externalId",
          "version",
          "destinationType"
        ],
        "type": "object",
        "properties": {
          "space": {
            "type": "string",
            "description": "Space of the Data Model"
          },
          "externalId": {
            "type": "string",
            "description": "External ID of the Data Model"
          },
          "version": {
            "type": "string",
            "description": "Version of the Data Model"
          },
          "destinationType": {
            "type": "string",
            "description": "External ID of the type(view) in the data model"
          },
          "destinationRelationshipFromType": {
            "type": "string",
            "description": "Property Identifier of the connection definition in destinationType"
          }
        },
        "description": "Target data model info"
      },
      "AnnotationsV2SuggestSchema": {
        "type": "object",
        "required": [
          "annotatedResourceType",
          "annotatedResourceId",
          "annotationType",
          "creatingApp",
          "creatingAppVersion",
          "creatingUser",
          "data"
        ],
        "properties": {
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotatedResourceId": {
            "$ref": "#/components/schemas/AnnotatedResourceId"
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "data": {
            "$ref": "#/components/schemas/AnnotationData"
          }
        }
      },
      "AnnotationsV2CreateSchema": {
        "allOf": [
          {
            "$ref": "#/components/schemas/AnnotationsV2SuggestSchema"
          },
          {
            "type": "object",
            "required": [
              "status"
            ],
            "properties": {
              "status": {
                "$ref": "#/components/schemas/Status"
              }
            }
          }
        ]
      },
      "AnnotationsV2ListResponseSchema": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "A list of annotations",
            "items": {
              "$ref": "#/components/schemas/AnnotationsV2ResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ResponseSchema": {
        "type": "object",
        "required": [
          "id",
          "createdTime",
          "lastUpdatedTime",
          "annotatedResourceType",
          "annotationType",
          "creatingApp",
          "creatingAppVersion",
          "creatingUser",
          "data",
          "status"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/AnnotationId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotatedResourceId": {
            "$ref": "#/components/schemas/AnnotatedResourceId"
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "data": {
            "$ref": "#/components/schemas/AnnotationData"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          }
        }
      },
      "AnnotationsV2ReverseLookupResponseSchema": {
        "type": "object",
        "required": [
          "items",
          "annotatedResourceType"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ReverseLookupResourceReference"
            }
          },
          "nextCursor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StrCursor"
              }
            ],
            "nullable": true,
            "type": "string",
            "example": null
          },
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          }
        }
      },
      "AnnotationsV2ReferenceSchema": {
        "type": "object",
        "description": "A reference to an existing annotation",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/AnnotationId"
          }
        }
      },
      "AnnotationsV2FilterSchema": {
        "type": "object",
        "description": "A filter to apply on annotations",
        "required": [
          "annotatedResourceType",
          "annotatedResourceIds"
        ],
        "properties": {
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotatedResourceIds": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResourceReference"
            },
            "minItems": 1,
            "maxItems": 1000
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          },
          "data": {
            "description": "Filter annotations by their data keys and values (case-sensitive). Concretely, by providing this field, we check for all annotations that contains the data filter as a subset.\nIf `annotationType` is not specified, the data filter will applied across all annotation types.",
            "example": {
              "label": "cat",
              "fileRef": {
                "externalId": "abc"
              }
            },
            "type": "object"
          }
        },
        "example": {
          "annotatedResourceType": "file",
          "annotatedResourceIds": [
            {
              "id": 1066
            },
            {
              "id": 1067
            }
          ],
          "status": "approved",
          "data": {
            "label": "cat"
          }
        }
      },
      "AnnotationsV2ReverseLookupFilterSchema": {
        "type": "object",
        "description": "A filter for reverse lookups",
        "required": [
          "annotatedResourceType"
        ],
        "properties": {
          "annotatedResourceType": {
            "$ref": "#/components/schemas/AnnotatedResourceType"
          },
          "annotationType": {
            "$ref": "#/components/schemas/AnnotationType"
          },
          "creatingApp": {
            "$ref": "#/components/schemas/Application"
          },
          "creatingAppVersion": {
            "$ref": "#/components/schemas/SemanticVersion"
          },
          "creatingUser": {
            "$ref": "#/components/schemas/User"
          },
          "status": {
            "$ref": "#/components/schemas/Status"
          },
          "data": {
            "description": "Filter annotations by their data keys and values (case-sensitive). Concretely, by providing this field, we check for all annotations that contains the data filter as a subset.\nIf `annotationType` is not specified, the data filter will applied across all annotation types.",
            "example": {
              "label": "cat",
              "fileRef": {
                "externalId": "abc"
              }
            },
            "type": "object"
          }
        },
        "example": {
          "annotatedResourceType": "file",
          "status": "approved",
          "data": {
            "label": "cat",
            "fileRef": {
              "externalId": "abc"
            }
          }
        }
      },
      "AnnotationsV2CursoredListResponseSchema": {
        "type": "object",
        "description": "A cursored list of existing annotations",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AnnotationsV2ResponseSchema"
            }
          },
          "nextCursor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StrCursor"
              }
            ],
            "nullable": true,
            "type": "string",
            "example": null
          }
        }
      },
      "AnnotationsV2UpdateItemSchema": {
        "type": "object",
        "description": "An update object to apply to an annotation",
        "required": [
          "id",
          "update"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/AnnotationId"
          },
          "update": {
            "$ref": "#/components/schemas/AnnotationsV2UpdateDataSchema"
          }
        }
      },
      "AnnotationsV2UpdateDataSchema": {
        "type": "object",
        "description": "Each fields represent a \"delta\" that will be applied onto the corresponding field of the original\nannotation.\n\n\n### Updating Annotation Type or Data\nEnsure that the new annotation data conforms to the new annotation type, otherwise the call will fail.",
        "properties": {
          "annotationType": {
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/AnnotationType"
              }
            }
          },
          "data": {
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/AnnotationData"
              }
            }
          },
          "status": {
            "type": "object",
            "required": [
              "set"
            ],
            "properties": {
              "set": {
                "$ref": "#/components/schemas/Status"
              }
            }
          }
        },
        "example": {
          "data": {
            "set": {
              "assetRef": {
                "externalId": "abc"
              },
              "symbolRegion": {
                "xMin": 0.1,
                "xMax": 0.2,
                "yMin": 0.1,
                "yMax": 0.2
              },
              "textRegion": {
                "xMin": 0.4,
                "xMax": 0.5,
                "yMin": 0.4,
                "yMax": 0.5
              },
              "pageNumber": 43
            }
          }
        }
      },
      "AnnotatedResourceType": {
        "type": "string",
        "description": "The annotated CDF resource type. Files as well as 3d-Models are supported.",
        "enum": [
          "file",
          "threedmodel"
        ],
        "example": "file"
      },
      "AnnotatedResourceId": {
        "description": "The internal ID of the annotated resource.",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ],
        "example": 1337
      },
      "Application": {
        "type": "string",
        "description": "The application name or identifier. This is neither checked nor enforced.",
        "example": "cognite-vision",
        "minLength": 1,
        "maxLength": 255
      },
      "User": {
        "type": "string",
        "description": "A username, or email, or name. This is not checked nor enforced. If the value is null, it means the\nannotation was created by a service.",
        "nullable": true,
        "example": "john.doe@cognite.com",
        "minLength": 1,
        "maxLength": 255
      },
      "SemanticVersion": {
        "type": "string",
        "description": "A version number in the SemVer sense. See [semver.org](https://semver.org/) for the specification.",
        "example": "1.2.1",
        "minLength": 1,
        "maxLength": 255
      },
      "AnnotationId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ],
        "description": "Server-generated identifier for the annotation",
        "example": 4096
      },
      "AnnotationType": {
        "type": "string",
        "description": "The type of the annotation. This uniquely decides what the structure of the `data` block will be.",
        "enum": [
          "pointcloud.BoundingVolume",
          "images.Classification",
          "forms.Detection",
          "documents.ExtractedText",
          "diagrams.FileLink",
          "isoplan.IsoPlanAnnotation",
          "diagrams.Junction",
          "images.KeypointCollection",
          "diagrams.Line",
          "images.ObjectDetection",
          "images.TextRegion",
          "diagrams.UnhandledSymbolObject",
          "diagrams.UnhandledTextObject",
          "diagrams.AssetLink",
          "diagrams.InstanceLink",
          "images.AssetLink",
          "images.InstanceLink"
        ],
        "example": "pointcloud.BoundingVolume"
      },
      "AnnotationData": {
        "description": "The annotation information. The format of this object is decided by and validated against the `annotationType`\nattribute.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/Annotations.BoundingVolume"
          },
          {
            "$ref": "#/components/schemas/Annotations.Classification"
          },
          {
            "$ref": "#/components/schemas/Annotations.Detection"
          },
          {
            "$ref": "#/components/schemas/Annotations.ExtractedText"
          },
          {
            "$ref": "#/components/schemas/Annotations.FileLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.IsoPlanAnnotation"
          },
          {
            "$ref": "#/components/schemas/Annotations.Junction"
          },
          {
            "$ref": "#/components/schemas/Annotations.KeypointCollection"
          },
          {
            "$ref": "#/components/schemas/Annotations.Line"
          },
          {
            "$ref": "#/components/schemas/Annotations.ObjectDetection"
          },
          {
            "$ref": "#/components/schemas/Annotations.TextRegion"
          },
          {
            "$ref": "#/components/schemas/Annotations.UnhandledSymbolObject"
          },
          {
            "$ref": "#/components/schemas/Annotations.UnhandledTextObject"
          },
          {
            "$ref": "#/components/schemas/Annotations.annotation_types__diagrams__AssetLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.annotation_types__diagrams__InstanceLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.annotation_types__images__AssetLink"
          },
          {
            "$ref": "#/components/schemas/Annotations.annotation_types__images__InstanceLink"
          }
        ],
        "example": {
          "assetRef": {
            "externalId": "abc"
          },
          "symbolRegion": {
            "xMin": 0.1,
            "xMax": 0.2,
            "yMin": 0.1,
            "yMax": 0.2
          },
          "textRegion": {
            "xMin": 0.2,
            "xMax": 0.3,
            "yMin": 0.2,
            "yMax": 0.3
          },
          "pageNumber": 43
        }
      },
      "ResourceReference": {
        "type": "object",
        "description": "A reference to another CDF resource. _Either_ the internal _or_ the external ID _must_ be provided (not both).",
        "properties": {
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "example": null
          },
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ],
            "example": "abc-1066"
          }
        }
      },
      "ReverseLookupResourceReference": {
        "type": "object",
        "description": "A reference to another CDF resource. Internal and external ID are both provided if available.",
        "properties": {
          "id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "example": 123
          },
          "externalId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteExternalId"
              }
            ],
            "example": "abc-1066"
          }
        }
      },
      "Status": {
        "type": "string",
        "description": "The status of the annotation",
        "enum": [
          "suggested",
          "approved",
          "rejected"
        ],
        "example": "approved"
      },
      "StrCursor": {
        "type": "string",
        "description": "A cursor pointing to another page of results",
        "minLength": 1,
        "maxLength": 255,
        "example": "MzE1NjAwMDcxNzQ0ODI5"
      },
      "Annotations.AssetRef": {
        "additionalProperties": false,
        "description": "A reference to an asset. Either the internal ID or the external ID must be provided (exactly one).",
        "oneOf": [
          {
            "required": [
              "id"
            ]
          },
          {
            "required": [
              "externalId"
            ]
          }
        ],
        "properties": {
          "id": {
            "default": null,
            "description": "The internal ID of the referenced resource",
            "type": "integer"
          },
          "externalId": {
            "default": null,
            "description": "The external ID of the referenced resource",
            "maxLength": 256,
            "type": "string"
          }
        },
        "title": "primitives.references.AssetRef",
        "type": "object"
      },
      "Annotations.AttributesMixin": {
        "additionalProperties": false,
        "description": "Mixin that can be used to add attributes to a thing",
        "properties": {
          "attributes": {
            "additionalProperties": {
              "discriminator": {
                "mapping": {
                  "boolean": "#/components/schemas/Annotations.Boolean",
                  "numerical": "#/components/schemas/Annotations.Numerical"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            },
            "default": null,
            "description": "Additional attributes data for a compound.",
            "type": "object"
          }
        },
        "title": "primitives.attributes.AttributesMixin",
        "type": "object"
      },
      "Annotations.Boolean": {
        "additionalProperties": false,
        "description": "The boolean value of something",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "type": {
            "const": "boolean",
            "type": "string"
          },
          "value": {
            "description": "The boolean value",
            "type": "boolean"
          }
        },
        "required": [
          "type",
          "value"
        ],
        "title": "primitives.attributes.Boolean",
        "type": "object"
      },
      "Annotations.BoundingBox": {
        "additionalProperties": false,
        "description": "A plain rectangle",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "xMin": {
            "description": "Minimum abscissa of the bounding box (left edge). Must be strictly less than x_max.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "xMax": {
            "description": "Maximum abscissa of the bounding box (right edge). Must be strictly more than x_min.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "yMin": {
            "description": "Minimum ordinate of the bounding box (bottom edge). Must be strictly less than y_max.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "yMax": {
            "description": "Maximum ordinate of the bounding box (top edge). Must be strictly more than y_min.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "xMin",
          "xMax",
          "yMin",
          "yMax"
        ],
        "title": "primitives.geometry2d.BoundingBox",
        "type": "object"
      },
      "Annotations.Box": {
        "additionalProperties": false,
        "description": "A box in 3D space, defined by a 4x4 row-major homogeneous transformation matrix that rotates,\ntranslates and scales a box centered at the origin to its location and orientation in 3D space.\nThe box that is transformed is the axis-aligned cube spanning the volume between\nthe points (-1, -1, -1) and (1, 1, 1).",
        "properties": {
          "label": {
            "default": null,
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "matrix": {
            "description": "The homogeneous transformation matrix",
            "items": {
              "type": "number"
            },
            "maxItems": 16,
            "minItems": 16,
            "type": "array"
          }
        },
        "required": [
          "matrix"
        ],
        "title": "primitives.geometry3d.Box",
        "type": "object"
      },
      "Annotations.ConfidenceMixin": {
        "additionalProperties": false,
        "description": "Mixin that can be used to add confidence score to a thing",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          }
        },
        "title": "primitives.confidence.ConfidenceMixin",
        "type": "object"
      },
      "Annotations.Cylinder": {
        "additionalProperties": false,
        "description": "A cylinder in 3D space, defined by the centers of the two end surfaces and the radius.",
        "properties": {
          "label": {
            "default": null,
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "centerA": {
            "description": "The center of the first cap.",
            "items": {
              "type": "number"
            },
            "maxItems": 3,
            "minItems": 3,
            "type": "array"
          },
          "centerB": {
            "description": "The center of the second cap.",
            "items": {
              "type": "number"
            },
            "maxItems": 3,
            "minItems": 3,
            "type": "array"
          },
          "radius": {
            "description": "The radius of the cylinder.",
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "centerA",
          "centerB",
          "radius"
        ],
        "title": "primitives.geometry3d.Cylinder",
        "type": "object"
      },
      "Annotations.DescriptionMixin": {
        "additionalProperties": false,
        "description": "Mixin that can be used to add a description to a thing",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          }
        },
        "title": "primitives.description.DescriptionMixin",
        "type": "object"
      },
      "Annotations.FileRef": {
        "additionalProperties": false,
        "description": "A reference to a file. Either the internal ID or the external ID must be provided (exactly one).",
        "oneOf": [
          {
            "required": [
              "id"
            ]
          },
          {
            "required": [
              "externalId"
            ]
          }
        ],
        "properties": {
          "id": {
            "default": null,
            "description": "The internal ID of the referenced resource",
            "type": "integer"
          },
          "externalId": {
            "default": null,
            "description": "The external ID of the referenced resource",
            "maxLength": 256,
            "type": "string"
          }
        },
        "title": "primitives.references.FileRef",
        "type": "object"
      },
      "Annotations.GeometryMixin": {
        "additionalProperties": false,
        "description": "A mixin that can be used to add a geometry to a thing.\nA is geometry represented by exactly *one of* ` bounding_box`, `polygon` and\n`polyline` which, respectively, represents a BoundingBox, Polygon and\nPolyLine.",
        "properties": {
          "boundingBox": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null
          },
          "polygon": {
            "$ref": "#/components/schemas/Annotations.Polygon",
            "default": null
          },
          "polyline": {
            "$ref": "#/components/schemas/Annotations.PolyLine",
            "default": null
          }
        },
        "title": "primitives.geometry2d.GeometryMixin",
        "type": "object"
      },
      "Annotations.InstanceRef": {
        "additionalProperties": false,
        "description": "A reference to an DMS instance,\ndefined by the instance itself and the sources (views)\nthat define how the data should be interpreted",
        "properties": {
          "sources": {
            "description": "References to views",
            "items": {
              "discriminator": {
                "mapping": {
                  "view": "#/components/schemas/Annotations.View"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/Annotations.View"
                }
              ]
            },
            "maxItems": 10,
            "type": "array"
          },
          "instanceType": {
            "description": "The type of instance, an edge or a node.",
            "enum": [
              "node",
              "edge"
            ],
            "type": "string"
          },
          "externalId": {
            "description": "External id of the instance",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[^\\x00]{1,255}$",
            "type": "string"
          },
          "space": {
            "description": "Id of the space that the instance belongs to",
            "maxLength": 43,
            "minLength": 1,
            "pattern": "^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$",
            "type": "string"
          }
        },
        "required": [
          "sources",
          "instanceType",
          "externalId",
          "space"
        ],
        "title": "primitives.references.InstanceRef",
        "type": "object"
      },
      "Annotations.Keypoint": {
        "additionalProperties": false,
        "description": "A point attached with additional information such as a confidence value and\nvarious attribute(s).",
        "properties": {
          "attributes": {
            "additionalProperties": {
              "discriminator": {
                "mapping": {
                  "boolean": "#/components/schemas/Annotations.Boolean",
                  "numerical": "#/components/schemas/Annotations.Numerical"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            },
            "default": null,
            "description": "Additional attributes data for a compound.",
            "type": "object"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "point": {
            "$ref": "#/components/schemas/Annotations.Point",
            "description": "The position of the keypoint"
          }
        },
        "required": [
          "point"
        ],
        "title": "primitives.geometry2d.Keypoint",
        "type": "object"
      },
      "Annotations.Numerical": {
        "additionalProperties": false,
        "description": "The numerical value of something",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "type": {
            "const": "numerical",
            "type": "string"
          },
          "value": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "number"
              }
            ],
            "description": "The numerical value"
          }
        },
        "required": [
          "type",
          "value"
        ],
        "title": "primitives.attributes.Numerical",
        "type": "object"
      },
      "Annotations.OptionalLabelMixin": {
        "additionalProperties": false,
        "description": "Mixin that can be used to add an *optional* label string to a thing",
        "properties": {
          "label": {
            "default": null,
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "title": "primitives.label.OptionalLabelMixin",
        "type": "object"
      },
      "Annotations.PageInformationMixin": {
        "additionalProperties": false,
        "description": "Mixin that can be used to add page number information",
        "properties": {
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          }
        },
        "title": "primitives.page.PageInformationMixin",
        "type": "object"
      },
      "Annotations.Point": {
        "additionalProperties": false,
        "description": "Point in a 2D-Cartesian coordinate system with origin at the top-left corner of the page",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "x": {
            "description": "The abscissa of the point in a coordinate system with origin at the top-left corner of the page. Normalized in (0,1).",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "y": {
            "description": "The ordinate of the point in a coordinate system with origin at the top-left corner of the page. Normalized in (0,1).",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "x",
          "y"
        ],
        "title": "primitives.geometry2d.Point",
        "type": "object"
      },
      "Annotations.PolyLine": {
        "additionalProperties": false,
        "description": "A polygonal chain consisting of _n_ vertices",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "vertices": {
            "items": {
              "$ref": "#/components/schemas/Annotations.Point"
            },
            "maxItems": 1000,
            "minItems": 2,
            "type": "array"
          }
        },
        "required": [
          "vertices"
        ],
        "title": "primitives.geometry2d.PolyLine",
        "type": "object"
      },
      "Annotations.Polygon": {
        "additionalProperties": false,
        "description": "A _closed_ polygon represented by _n_ vertices. In other words, we assume\nthat the first and last vertex are connected.",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "vertices": {
            "items": {
              "$ref": "#/components/schemas/Annotations.Point"
            },
            "maxItems": 1000,
            "minItems": 3,
            "type": "array"
          }
        },
        "required": [
          "vertices"
        ],
        "title": "primitives.geometry2d.Polygon",
        "type": "object"
      },
      "Annotations.RequiredLabelMixin": {
        "additionalProperties": false,
        "description": "Mixin that can be used to add a *required* label string to a thing",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "label"
        ],
        "title": "primitives.label.RequiredLabelMixin",
        "type": "object"
      },
      "Annotations.SizeAndClassType": {
        "additionalProperties": false,
        "description": "Store the dimension, units and class of a given annotation",
        "properties": {
          "size": {
            "default": null,
            "description": "The size of the valve or spade",
            "type": "number"
          },
          "unit": {
            "default": null,
            "description": "The units of the size (mm/inches)",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "classType": {
            "default": null,
            "description": "The class type of the valve or spade",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "title": "primitives.dimensions.SizeAndClassType",
        "type": "object"
      },
      "Annotations.View": {
        "additionalProperties": false,
        "description": "Defines a DMS source (e.g. view)",
        "properties": {
          "type": {
            "const": "view",
            "type": "string"
          },
          "space": {
            "description": "Id of the space that the view belongs to",
            "maxLength": 43,
            "minLength": 1,
            "pattern": "^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$",
            "type": "string"
          },
          "externalId": {
            "description": "External id of the view",
            "maxLength": 255,
            "minLength": 1,
            "pattern": "^[a-zA-Z]([a-zA-Z0-9_]{0,253}[a-zA-Z0-9])?$",
            "type": "string"
          },
          "version": {
            "description": "Version of the view",
            "maxLength": 43,
            "minLength": 1,
            "pattern": "^[a-zA-Z0-9]([a-zA-Z0-9_-]{0,41}[a-zA-Z0-9])?$",
            "type": "string"
          }
        },
        "required": [
          "type",
          "space",
          "externalId",
          "version"
        ],
        "title": "primitives.references.View",
        "type": "object"
      },
      "Annotations.annotation_types__primitives__geometry2d__Geometry": {
        "additionalProperties": false,
        "description": "A geometry represented by exactly *one of* ` bounding_box`, `polygon` and\n`polyline` which, respectively, represents a BoundingBox, Polygon and\nPolyLine.",
        "properties": {
          "boundingBox": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null
          },
          "polygon": {
            "$ref": "#/components/schemas/Annotations.Polygon",
            "default": null
          },
          "polyline": {
            "$ref": "#/components/schemas/Annotations.PolyLine",
            "default": null
          }
        },
        "title": "primitives.geometry2d.Geometry",
        "type": "object"
      },
      "Annotations.annotation_types__primitives__geometry3d__Geometry": {
        "additionalProperties": false,
        "description": "A 3D geometry model represented by exactly *one of* `cylinder` and `box`.",
        "properties": {
          "cylinder": {
            "$ref": "#/components/schemas/Annotations.Cylinder",
            "default": null
          },
          "box": {
            "$ref": "#/components/schemas/Annotations.Box",
            "default": null
          }
        },
        "title": "primitives.geometry3d.Geometry",
        "type": "object"
      },
      "Annotations.BoundingVolume": {
        "additionalProperties": false,
        "description": "A bounding volume represents a region in a point cloud",
        "properties": {
          "label": {
            "default": null,
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "assetRef": {
            "$ref": "#/components/schemas/Annotations.AssetRef",
            "default": null,
            "description": "The asset this annotation is pointing to"
          },
          "region": {
            "description": "The region of the annotation defined by a list of geometry primitives (cylinder and box).",
            "items": {
              "$ref": "#/components/schemas/Annotations.annotation_types__primitives__geometry3d__Geometry"
            },
            "maxItems": 1000,
            "minItems": 1,
            "type": "array"
          }
        },
        "required": [
          "region"
        ],
        "title": "pointcloud.BoundingVolume",
        "type": "object"
      },
      "Annotations.Classification": {
        "additionalProperties": false,
        "description": "Models an image classification represented by a label, and optionally a\nconfidence value.",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "label"
        ],
        "title": "images.Classification",
        "type": "object"
      },
      "Annotations.Detection": {
        "additionalProperties": false,
        "description": "Represents a detection of a field value in a form.\nA field is identified by a field_name, optionally component_name and component_type if the field belongs to a subcomponent.\nThe bounding_box indicates the position of the detection. The content of the field is given by the value, and optionally\nan unnormalized_value and the unit.",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "Bounding box of the detection area"
          },
          "componentType": {
            "default": null,
            "description": "Type of subcomponent that the detection belongs to",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "componentName": {
            "default": null,
            "description": "Name of subcomponent that the detection belongs to",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "fieldName": {
            "description": "Name of field that has been detected",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "value": {
            "description": "The value that has been detected",
            "maxLength": 128,
            "type": "string"
          },
          "valueUnnormalized": {
            "default": null,
            "description": "The value that has been detected, before normalization. Optional.",
            "maxLength": 128,
            "type": "string"
          },
          "unit": {
            "default": null,
            "description": "The unit of the value field. Optional.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "boundingBox",
          "fieldName",
          "value"
        ],
        "title": "forms.Detection",
        "type": "object"
      },
      "Annotations.ExtractedText": {
        "additionalProperties": false,
        "description": "Represents text extracted from a document. Annotations of this type are low-level and not specific to any domain.",
        "properties": {
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the extracted text"
          },
          "extractedText": {
            "description": "The extracted text",
            "maxLength": 1024,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "textRegion",
          "extractedText"
        ],
        "title": "documents.ExtractedText",
        "type": "object"
      },
      "Annotations.FileLink": {
        "additionalProperties": false,
        "description": "Models a link to a CDF File referenced in an engineering diagram",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "fileRef": {
            "$ref": "#/components/schemas/Annotations.FileRef",
            "description": "The file this annotation is pointing to"
          },
          "symbolRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null,
            "description": "The location of the symbol representing the file"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the text mentioning the file"
          },
          "text": {
            "default": null,
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "default": null,
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "fileRef",
          "textRegion"
        ],
        "title": "diagrams.FileLink",
        "type": "object"
      },
      "Annotations.IsoPlanAnnotation": {
        "additionalProperties": false,
        "description": "Model a custom link in a engineering diagram where it capture details from the texts and linked to assets when necessary",
        "properties": {
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "fileRef": {
            "$ref": "#/components/schemas/Annotations.FileRef",
            "default": null,
            "description": "The asset this annotation is pointing at. Store the id of the file assets to generate downloadable URL."
          },
          "text": {
            "default": null,
            "description": "The pattern identified by the detection API results.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null,
            "description": "The location of the hotspot represented with a bounding box."
          },
          "indirectRelation": {
            "default": null,
            "description": "Relation connecting this hotspot to a tag in case the hotspot has no tag. E.g. 'second valve upstreams of'. This references the 'indirectExternalId'.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "indirectExternalId": {
            "$ref": "#/components/schemas/Annotations.AssetRef",
            "default": null,
            "description": "The indirectExternalId is the external id of the equipment used to identify the hotspot indirectly. Exa. this is the <indirectRelation> of <indirectExternalId>."
          },
          "lineExternalId": {
            "$ref": "#/components/schemas/Annotations.AssetRef",
            "default": null,
            "description": "The id of the Pipe that the hotspot belongs to."
          },
          "detail": {
            "default": null,
            "description": "Detail describing the equipment.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "subDetail": {
            "default": null,
            "description": "Use to save the fluid code of pipes Exa. LO for Lube oil and etc.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "sourceType": {
            "default": null,
            "description": "Use to identify whether the annotation is user created one or ditected via pipeline.",
            "enum": [
              "pipeline",
              "user"
            ],
            "type": "string"
          },
          "linkedResourceInternalId": {
            "default": null,
            "description": "Stores Functional Locations' (FLOC) ID linked to the annotation.",
            "type": "integer"
          },
          "linkedResourceExternalId": {
            "default": null,
            "description": "Stores Functional Locations (FLOC) external ID linked to the annotation.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "linkedResourceType": {
            "default": null,
            "description": "Stores Functional Location (FLOC) type the annotation linked to.",
            "enum": [
              "asset",
              "file"
            ],
            "type": "string"
          },
          "type": {
            "default": null,
            "description": "Type of equipment, valve, pump etc.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "relativePosition": {
            "default": null,
            "description": "Indicate the relative position of an annotation.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "revision": {
            "default": null,
            "description": "Keeps track of the modification to an annotation.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "sizeAndClass": {
            "$ref": "#/components/schemas/Annotations.SizeAndClassType",
            "default": null,
            "description": "Stores the dimensions of a valve or spade."
          },
          "oldAnnotationId": {
            "default": null,
            "description": "Keep track of data link with old annotations.",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "vertices": {
            "$ref": "#/components/schemas/Annotations.PolyLine",
            "default": null,
            "description": "Stores the (x,y) coordinate pairs of a line or polyline."
          }
        },
        "title": "isoplan.IsoPlanAnnotation",
        "type": "object"
      },
      "Annotations.Junction": {
        "additionalProperties": false,
        "description": "Models a junction between lines in an engineering diagram",
        "properties": {
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "position": {
            "$ref": "#/components/schemas/Annotations.Point",
            "description": "The point representing the junction"
          }
        },
        "required": [
          "position"
        ],
        "title": "diagrams.Junction",
        "type": "object"
      },
      "Annotations.KeypointCollection": {
        "additionalProperties": false,
        "description": "Models a collection of keypoints represented by a label, a dictionary of\nkeypoints (mapping from a (unique) label name to a keypoint), and\noptionally a confidence value and an attributes dictionary.",
        "properties": {
          "attributes": {
            "additionalProperties": {
              "discriminator": {
                "mapping": {
                  "boolean": "#/components/schemas/Annotations.Boolean",
                  "numerical": "#/components/schemas/Annotations.Numerical"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            },
            "default": null,
            "description": "Additional attributes data for a compound.",
            "type": "object"
          },
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "keypoints": {
            "additionalProperties": {
              "$ref": "#/components/schemas/Annotations.Keypoint"
            },
            "description": "The detected keypoints",
            "type": "object"
          }
        },
        "required": [
          "label",
          "keypoints"
        ],
        "title": "images.KeypointCollection",
        "type": "object"
      },
      "Annotations.Line": {
        "additionalProperties": false,
        "description": "Models a line in an engineering diagram",
        "properties": {
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "polyline": {
            "$ref": "#/components/schemas/Annotations.PolyLine",
            "description": "The polyline representing the line"
          }
        },
        "required": [
          "label",
          "polyline"
        ],
        "title": "diagrams.Line",
        "type": "object"
      },
      "Annotations.ObjectDetection": {
        "additionalProperties": false,
        "description": "Models an image object detection represented by a label, a geometry, and\noptionally a confidence value.",
        "properties": {
          "attributes": {
            "additionalProperties": {
              "discriminator": {
                "mapping": {
                  "boolean": "#/components/schemas/Annotations.Boolean",
                  "numerical": "#/components/schemas/Annotations.Numerical"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/Annotations.Boolean"
                },
                {
                  "$ref": "#/components/schemas/Annotations.Numerical"
                }
              ]
            },
            "default": null,
            "description": "Additional attributes data for a compound.",
            "type": "object"
          },
          "boundingBox": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null
          },
          "polygon": {
            "$ref": "#/components/schemas/Annotations.Polygon",
            "default": null
          },
          "polyline": {
            "$ref": "#/components/schemas/Annotations.PolyLine",
            "default": null
          },
          "label": {
            "description": "The label describing what type of object it is",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          }
        },
        "required": [
          "label"
        ],
        "title": "images.ObjectDetection",
        "type": "object"
      },
      "Annotations.TextRegion": {
        "additionalProperties": false,
        "description": "Models an extracted text region in an image",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the extracted text"
          }
        },
        "required": [
          "text",
          "textRegion"
        ],
        "title": "images.TextRegion",
        "type": "object"
      },
      "Annotations.UnhandledSymbolObject": {
        "additionalProperties": false,
        "description": "Models an extracted symbol region in an engineering diagram",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "symbolRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the symbol"
          },
          "symbol": {
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "symbolRegion",
          "symbol"
        ],
        "title": "diagrams.UnhandledSymbolObject",
        "type": "object"
      },
      "Annotations.UnhandledTextObject": {
        "additionalProperties": false,
        "description": "Models an extracted text region in an engineering diagram",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the text"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "textRegion",
          "text"
        ],
        "title": "diagrams.UnhandledTextObject",
        "type": "object"
      },
      "Annotations.annotation_types__diagrams__AssetLink": {
        "additionalProperties": false,
        "description": "Models a link to a CDF Asset referenced in an engineering diagram",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "assetRef": {
            "$ref": "#/components/schemas/Annotations.AssetRef",
            "description": "The asset this annotation is pointing to"
          },
          "symbolRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null,
            "description": "The location of the symbol representing the asset"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the text mentioning the asset"
          },
          "text": {
            "default": null,
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "symbol": {
            "default": null,
            "description": "The symbol representing the asset",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          }
        },
        "required": [
          "assetRef",
          "textRegion"
        ],
        "title": "diagrams.AssetLink",
        "type": "object"
      },
      "Annotations.annotation_types__diagrams__InstanceLink": {
        "additionalProperties": false,
        "description": "Models a link to an FDM instance referenced in an engineering diagram",
        "properties": {
          "description": {
            "default": null,
            "description": "The description of a primitive",
            "maxLength": 500,
            "type": "string"
          },
          "pageNumber": {
            "default": 1,
            "description": "The number of the page on which this annotation is located. The first page has number 1.",
            "maximum": 100000,
            "minimum": 1,
            "type": "integer"
          },
          "instanceRef": {
            "$ref": "#/components/schemas/Annotations.InstanceRef",
            "description": "The FDM instance this annotation is pointing to"
          },
          "symbolRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "default": null,
            "description": "Optional location of a symbol"
          },
          "symbol": {
            "default": null,
            "description": "The symbol found in the file",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the text mentioning the file"
          }
        },
        "required": [
          "instanceRef",
          "text",
          "textRegion"
        ],
        "title": "diagrams.InstanceLink",
        "type": "object"
      },
      "Annotations.annotation_types__images__AssetLink": {
        "additionalProperties": false,
        "description": "Models a link to a CDF Asset referenced in an image",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "assetRef": {
            "$ref": "#/components/schemas/Annotations.AssetRef",
            "description": "The asset this annotation is pointing to"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the text mentioning the asset"
          },
          "objectRegion": {
            "$ref": "#/components/schemas/Annotations.annotation_types__primitives__geometry2d__Geometry",
            "default": null,
            "description": "The region of the object representing the asset"
          }
        },
        "required": [
          "assetRef",
          "text",
          "textRegion"
        ],
        "title": "images.AssetLink",
        "type": "object"
      },
      "Annotations.annotation_types__images__InstanceLink": {
        "additionalProperties": false,
        "description": "Models a link to an FDM instance referenced in an image",
        "properties": {
          "confidence": {
            "default": null,
            "description": "The confidence score for the primitive. It should be between 0 and 1.",
            "maximum": 1,
            "minimum": 0,
            "type": "number"
          },
          "instanceRef": {
            "$ref": "#/components/schemas/Annotations.InstanceRef",
            "description": "The FDM instance this annotation is pointing to"
          },
          "text": {
            "description": "The extracted text",
            "maxLength": 128,
            "minLength": 1,
            "type": "string"
          },
          "textRegion": {
            "$ref": "#/components/schemas/Annotations.BoundingBox",
            "description": "The location of the text mentioning the FDM instance"
          }
        },
        "required": [
          "instanceRef",
          "text",
          "textRegion"
        ],
        "title": "images.InstanceLink",
        "type": "object"
      },
      "BatchDownloadRequestSeismic": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "description": "The list of seismic objects to include in the ZIP archive, specified by internal id.",
            "items": {
              "$ref": "#/components/schemas/CogniteInternalId"
            }
          }
        }
      },
      "BatchDownloadRequestFilter": {
        "type": "object",
        "properties": {
          "surveyId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "A survey's internal ID. All seismic objects included will be part of this survey."
          },
          "partitionId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "A partition's internal ID. All seismic objects included will be part of this partition."
          },
          "metadataFilter": {
            "type": "object",
            "description": "All seismic objects included will have metadata that is a superset of the specified metadata filter.",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "UserIdentifier": {
        "type": "object",
        "required": [
          "userIdentifier"
        ],
        "properties": {
          "userIdentifier": {
            "type": "string",
            "example": "abcd"
          }
        }
      },
      "UserProfileItem": {
        "type": "object",
        "required": [
          "userIdentifier",
          "lastUpdatedTime"
        ],
        "properties": {
          "userIdentifier": {
            "type": "string",
            "description": "Uniquely identifies the principal the profile is associated with.\nThis property is _guaranteed_ to be immutable.\n",
            "nullable": false,
            "example": "abcd"
          },
          "givenName": {
            "type": "string",
            "description": "The user's first name.",
            "nullable": true,
            "example": "Jane"
          },
          "surname": {
            "type": "string",
            "description": "The user's last name.",
            "nullable": true,
            "example": "Doe"
          },
          "email": {
            "type": "string",
            "description": "The user's email address (if any). The email address is is returned directly from\nthe identity provider and not guaranteed to be verified.\nNote that the email is mutable and can be updated in the identity provider. It should\n_not_ be used to uniquely identify as a user. Use the `userIdentifier` property instead.\n",
            "nullable": true,
            "example": "jane.doe@example.com"
          },
          "displayName": {
            "type": "string",
            "description": "The display name for the user.",
            "nullable": true,
            "example": "Jane Doe"
          },
          "jobTitle": {
            "type": "string",
            "description": "The user's job title.",
            "nullable": true,
            "example": "Software Engineer"
          },
          "identityType": {
            "$ref": "#/components/schemas/IdentityType"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "UserProfilesByIdsRequest": {
        "description": "Array of user identifiers",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserIdentifier"
            }
          }
        }
      },
      "UserProfilesSearchRequest": {
        "type": "object",
        "properties": {
          "search": {
            "type": "object",
            "properties": {
              "name": {
                "description": "Prefix search on name.",
                "type": "string"
              }
            }
          },
          "limit": {
            "description": "<- Limits the maximum number of results to be returned by single request. The default is 25.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 25
          }
        }
      },
      "UserProfilesListResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserProfileItem"
            }
          },
          "nextCursor": {
            "type": "string",
            "description": "Cursor to get the next page of results (if available)."
          }
        }
      },
      "UserProfilesByIdsResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserProfileItem"
            }
          }
        }
      },
      "UserProfilesSearchResponse": {
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UserProfileItem"
            }
          }
        }
      },
      "UserProfilesErrorResponse": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "error": {
            "required": [
              "code",
              "message"
            ],
            "type": "object",
            "properties": {
              "code": {
                "type": "integer",
                "description": "HTTP status code."
              },
              "message": {
                "type": "string",
                "description": "Error message."
              },
              "missing": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UserIdentifier"
                },
                "description": "List of lookup objects that do not match any results."
              },
              "duplicated": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/UserIdentifier"
                },
                "description": "List of objects that are not unique."
              }
            }
          }
        }
      },
      "UserProfilesNotFoundResponse": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "error": {
            "required": [
              "code",
              "message"
            ],
            "type": "object",
            "properties": {
              "code": {
                "type": "integer",
                "description": "HTTP status code."
              },
              "message": {
                "type": "string",
                "description": "Error message."
              }
            }
          }
        }
      },
      "IdentityType": {
        "description": "The identity type field indicates the type of principal.\n- `USER`: Human user.\n- `SERVICE_PRINCIPAL`: Service account.\n- `INTERNAL_SERVICE`: Internal CDF service.\n",
        "type": "string",
        "enum": [
          "USER",
          "SERVICE_PRINCIPAL",
          "INTERNAL_SERVICE"
        ]
      },
      "IdentityTypeFilter": {
        "description": "The identity type filter field indicates the type of principal the request should be filtered to show.\nIf no value is specified, the default value is `USER`.\n- `ALL`: All types of principals.\n- `USER`: Human user.\n- `SERVICE_PRINCIPAL`: Service account.\n- `INTERNAL_SERVICE`: Internal CDF service.\n",
        "type": "string",
        "enum": [
          "ALL",
          "USER",
          "SERVICE_PRINCIPAL",
          "INTERNAL_SERVICE"
        ]
      },
      "UserListResponse": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/OrgUser"
            }
          },
          "nextCursor": {
            "allOf": [
              {
                "description": {
                  "$ref": "#/components/schemas/Cursor/description"
                }
              },
              {
                "$ref": "#/components/schemas/Cursor/properties/cursor"
              }
            ]
          }
        }
      },
      "UserPrincipal": {
        "type": "object",
        "required": [
          "userIdentifier",
          "displayName",
          "lastUpdatedTime",
          "pictureUrl",
          "identityType"
        ],
        "properties": {
          "userIdentifier": {
            "type": "string",
            "description": "Uniquely identifies the principal the profile is associated with.\n",
            "example": "-cFNuYkHgnn5q8pnlVlCRg"
          },
          "displayName": {
            "type": "string",
            "description": "The display name for the user.",
            "example": "Jane Doe"
          },
          "givenName": {
            "type": "string",
            "description": "The user's first name.",
            "example": "Jane"
          },
          "surname": {
            "type": "string",
            "description": "The user's last name.",
            "example": "Doe"
          },
          "email": {
            "type": "string",
            "description": "The user's email address (if any). The email address is is returned directly from the identity provider and not guaranteed to be verified.\nIt should\n_not_ be used to uniquely identify as a user. Use the `userIdentifier` property instead.\n",
            "example": "jane.doe@example.com"
          },
          "pictureUrl": {
            "type": "string",
            "description": "The avatar of the service account",
            "format": "url",
            "example": "https://auth.cognite.com/api/v1/orgs/cog-cognite/principals/HByt5JcYe1jYgnN5kFSGikthqcFHJjg4kxciGBFUWbBFv4unyt/picture?_n=1730959200&_e=1731067200&_k=EdCqRojhpCzDNF6JrrpfZgp"
          },
          "identityType": {
            "title": "Principal identity type",
            "type": "string",
            "enum": [
              "USER"
            ]
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "ServicePrincipal": {
        "type": "object",
        "required": [
          "userIdentifier",
          "displayName",
          "lastUpdatedTime",
          "pictureUrl",
          "identityType"
        ],
        "properties": {
          "userIdentifier": {
            "type": "string",
            "description": "Uniquely identifies the principal the profile is associated with.\n",
            "example": "HByt5JcYe1jYgnN5kFSGikthqcFHJjg4kxciGBFUWbBFv4unyt"
          },
          "displayName": {
            "type": "string",
            "description": "The display name for the service account",
            "example": "Industrial Ops Acct 5"
          },
          "pictureUrl": {
            "type": "string",
            "description": "The avatar of the service account",
            "format": "url",
            "example": "https://auth.cognite.com/api/v1/orgs/cog-cognite/principals/HByt5JcYe1jYgnN5kFSGikthqcFHJjg4kxciGBFUWbBFv4unyt/picture?_n=1730959200&_e=1731067200&_k=EdCqRojhpCzDNF6JrrpfZgp"
          },
          "identityType": {
            "title": "Principal identity type",
            "type": "string",
            "enum": [
              "SERVICE_PRINCIPAL"
            ]
          }
        }
      },
      "OrgUser": {
        "type": "object",
        "required": [
          "id",
          "pictureUrl"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/UserId"
          },
          "email": {
            "type": "string",
            "format": "email"
          },
          "name": {
            "type": "string",
            "example": "John N. Doe"
          },
          "givenName": {
            "type": "string",
            "example": "John"
          },
          "middleName": {
            "type": "string",
            "example": "N."
          },
          "familyName": {
            "type": "string",
            "example": "Doe"
          },
          "pictureUrl": {
            "type": "string",
            "format": "url",
            "example": "https://example.com/picture.png"
          }
        }
      },
      "UserId": {
        "type": "string",
        "description": "The ID of an organization user",
        "minLength": 22,
        "maxLength": 22,
        "example": "-user-string-id-aBc123",
        "pattern": "^[-_a-zA-Z0-9]{22}$"
      },
      "WorkflowView": {
        "title": "Workflow",
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          },
          "description": {
            "type": "string",
            "maxLength": 500
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "dataSetId": {
            "$ref": "#/components/schemas/dataSetIdWorkflows"
          }
        },
        "required": [
          "externalId",
          "createdTime",
          "lastUpdatedTime"
        ]
      },
      "WorkflowDefinition": {
        "title": "Workflow Definition",
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "maxLength": 500
          },
          "tasks": {
            "type": "array",
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/TaskDefinition"
            }
          }
        },
        "required": [
          "tasks"
        ]
      },
      "TaskDefinition": {
        "title": "Task Definition",
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/TaskExternalId"
          },
          "type": {
            "$ref": "#/components/schemas/TaskType"
          },
          "name": {
            "type": "string",
            "maxLength": 255,
            "description": "Readable name meant for use in UIs"
          },
          "description": {
            "type": "string",
            "maxLength": 500,
            "description": "Description of the intention of the task"
          },
          "parameters": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FunctionTaskParameters"
              },
              {
                "$ref": "#/components/schemas/TransformationTaskParameters"
              },
              {
                "$ref": "#/components/schemas/CdfTaskParameters"
              },
              {
                "$ref": "#/components/schemas/DynamicTaskParameters"
              },
              {
                "$ref": "#/components/schemas/SubworkflowTaskParameters"
              },
              {
                "$ref": "#/components/schemas/SimulatorTaskParameters"
              }
            ]
          },
          "retries": {
            "type": "number",
            "default": 3,
            "minimum": 0,
            "maximum": 10,
            "description": "Number of times to retry the task if it fails. If set to 0, the task will not be retried. The behavior for timeouts and retries is defined by the `onFailure` parameter, refer to it for more information."
          },
          "timeout": {
            "type": "number",
            "default": 3600,
            "minimum": 100,
            "maximum": 43200,
            "description": "Timeout in seconds. After this time, the task will be marked as `TIMED_OUT`. By default, the task won't be retried upon timeout. Use the `onFailure` parameter to change this behavior."
          },
          "onFailure": {
            "type": "string",
            "enum": [
              "abortWorkflow",
              "skipTask"
            ],
            "default": "abortWorkflow",
            "description": "Defines the policy to handle failures and timeouts.\n- `skipTask`: For both failures and timeouts, it will retry until the retries are exhausted. After that, the Task is marked as COMPLETED_WITH_ERRORS and the subsequent tasks are executed.\n- `abortWorkflow`:\n  - In case of failures, retries will be performed until exhausted, after which the task is marked as FAILED and the Workflow is marked the same.\n  - In the event of a timeout, no retries are undertaken; the task is marked as TIMED_OUT and the Workflow is marked as FAILED.\n"
          },
          "dependsOn": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskDepends"
            },
            "minItems": 0,
            "maxItems": 100,
            "description": "The tasks that must be completed before this task can be executed."
          }
        },
        "required": [
          "externalId",
          "type",
          "parameters"
        ]
      },
      "TaskDepends": {
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "TaskType": {
        "type": "string",
        "enum": [
          "function",
          "transformation",
          "cdf",
          "dynamic",
          "subworkflow",
          "simulation"
        ]
      },
      "WorkflowExecution": {
        "title": "Workflow Execution",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/WorkflowExecutionId"
          },
          "workflowExternalId": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          },
          "workflowDefinition": {
            "$ref": "#/components/schemas/WorkflowDefinitionResponse"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          },
          "status": {
            "$ref": "#/components/schemas/WorkflowStatus"
          },
          "engineExecutionId": {
            "$ref": "#/components/schemas/EngineExecutionId"
          },
          "executedTasks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskExecution"
            }
          },
          "input": {
            "$ref": "#/components/schemas/ExecutionInput"
          },
          "metadata": {
            "$ref": "#/components/schemas/metadata"
          }
        },
        "required": [
          "id",
          "workflowExternalId",
          "workflowDefinition",
          "status",
          "engineExecutionId",
          "createdTime",
          "executedTasks",
          "metadata"
        ]
      },
      "TransformationTaskParameters": {
        "title": "Transformation Task Parameters",
        "type": "object",
        "properties": {
          "transformation": {
            "type": "object",
            "description": "Parameters for the CDF Transformation task type.",
            "properties": {
              "externalId": {
                "description": "The external id of the Transformation in the project.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              },
              "concurrencyPolicy": {
                "type": "string",
                "enum": [
                  "fail",
                  "waitForCurrent",
                  "restartAfterCurrent"
                ],
                "default": "fail",
                "description": "Determines the behavior of the task if the Transformation is already running.\n- fail: The task fails if another instance of the Transformation is currently running.\n- waitForCurrent: The task will pause and wait for the already running Transformation to complete. Once completed, the task is completed. This mode is useful for preventing redundant Transformation runs.\n- restartAfterCurrent: The task waits for the ongoing Transformation to finish. After completion, the task restarts the Transformation. This mode ensures that the most recent data can be used by following tasks.\n"
              },
              "useTransformationCredentials": {
                "type": "boolean",
                "default": false,
                "description": "If set to `true`, the transformation will run using the client credentials configured on the transformation.\nIf set to `false`, the transformation will run using the client credentials used to trigger the workflow.\n"
              }
            },
            "required": [
              "externalId"
            ]
          }
        }
      },
      "FunctionTaskParameters": {
        "title": "Function Task Parameters",
        "type": "object",
        "description": "Parameters for the Cognite Function task type.",
        "properties": {
          "function": {
            "type": "object",
            "properties": {
              "externalId": {
                "description": "The external id of the Cognite Function in the project.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              },
              "data": {
                "description": "Input data that will be passed to the Cognite Function. Limited to 100KB in size.",
                "oneOf": [
                  {
                    "type": "object",
                    "example": {
                      "key1": "value1",
                      "key2": "value2"
                    },
                    "maxLength": 100000
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              }
            },
            "required": [
              "externalId"
            ]
          },
          "isAsyncComplete": {
            "type": "boolean",
            "default": false,
            "description": "Defines if the execution of the task should be completed asynchronously.\n\n  - If `false`, the status of the task will be set to `COMPLETED` when the Cognite Function call completes successfully.\\\n  - If `true`, the task status will remain `IN_PROGRESS` even when the Cognite Function call completes successfully.\\\n  It will then wait for an external process to update the task status directly using the task update endpoint.\\\n  The task id required for the callback to update the task status is included in the input data of the Function with key \"cogniteOrchestrationTaskId\"."
          }
        }
      },
      "SimulatorTaskParameters": {
        "title": "Simulation Task Parameters",
        "type": "object",
        "description": "Parameters for the Simulation run task type.",
        "properties": {
          "simulation": {
            "type": "object",
            "properties": {
              "routineExternalId": {
                "description": "The external id of the routine to be executed.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                ]
              },
              "runTime": {
                "anyOf": [
                  {
                    "type": "integer"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "RunTime",
                "description": "Run time in milliseconds. Reference timestamp used for data pre-processing and data sampling."
              },
              "inputs": {
                "type": "array",
                "maxItems": 200,
                "minItems": 0,
                "description": "List of input overrides",
                "items": {
                  "$ref": "#/components/schemas/SimulatorInput"
                }
              }
            },
            "required": [
              "routineExternalId"
            ]
          }
        }
      },
      "CdfTaskParameters": {
        "title": "CDF Task Parameters",
        "type": "object",
        "description": "Parameters for the CDF Request task type, which can be used to make a request to any CDF API.",
        "properties": {
          "cdfRequest": {
            "type": "object",
            "properties": {
              "resourcePath": {
                "description": "The path of the request. The path should be prefixed by `{cluster}.cognitedata.com/api/v1/project/{project}` based on the relevant cluster and project.\n\nExample: to list TimeSeries, the resourcePath would be `{cluster}.cognitedata.com/api/v1/project/{project}/timeseries/list`.\n",
                "oneOf": [
                  {
                    "type": "string",
                    "maxLength": 128
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              },
              "queryParameters": {
                "oneOf": [
                  {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string",
                      "maxLength": 50
                    },
                    "maxItems": 5
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              },
              "method": {
                "oneOf": [
                  {
                    "type": "string",
                    "enum": [
                      "POST",
                      "GET",
                      "PUT"
                    ]
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              },
              "body": {
                "description": "The body of the request. Limited to 100KB in size.",
                "oneOf": [
                  {
                    "type": "object",
                    "maxLength": 100000
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              },
              "requestTimeoutInMillis": {
                "oneOf": [
                  {
                    "type": "number",
                    "default": 10000,
                    "minimum": 100
                  },
                  {
                    "$ref": "#/components/schemas/Reference"
                  }
                ]
              }
            },
            "required": [
              "resourcePath",
              "method"
            ]
          }
        }
      },
      "DynamicTaskParameters": {
        "title": "Dynamic Task Parameters",
        "type": "object",
        "description": "Dynamic tasks allow the dynamic creation of additional tasks during a workflow execution.\n\nThere are two things needed to execute a dynamic task.\n- A list of task definitions (similar to the way tasks are defined in the workflow definition when creating a workflow version).\n- A workflow task prior to the dynamic task that outputs the above list\n",
        "properties": {
          "dynamic": {
            "type": "object",
            "description": "Tasks should reference a list of task definitions, defined exactly like they are during version creation.",
            "properties": {
              "tasks": {
                "$ref": "#/components/schemas/Reference"
              }
            }
          }
        }
      },
      "SubworkflowTaskParameters": {
        "title": "Subworkflow Task Parameters",
        "type": "object",
        "properties": {
          "subworkflow": {
            "oneOf": [
              {
                "type": "object",
                "properties": {
                  "tasks": {
                    "description": "A list of tasks with their inputs and interdependencies. Similar to the way tasks are defined in a workflow definition.\n",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/TaskDefinition"
                    },
                    "maxItems": 100,
                    "minItems": 1
                  }
                },
                "required": [
                  "tasks"
                ]
              },
              {
                "type": "object",
                "description": "Run another workflow embedded as a subworkflow. The tasks within the subworkflow will count towards the limit on total number of tasks in a workflow.\n",
                "properties": {
                  "workflowExternalId": {
                    "type": "string",
                    "description": "External ID of the referenced workflow"
                  },
                  "version": {
                    "type": "string",
                    "description": "Version of the referenced workflow"
                  }
                },
                "required": [
                  "workflowExternalId",
                  "version"
                ]
              }
            ]
          }
        }
      },
      "TransformationTaskOutput": {
        "title": "Transformation Task Output",
        "type": "object",
        "properties": {
          "jobId": {
            "type": "integer",
            "format": "int64",
            "description": "Job ID of the Transformation called."
          }
        }
      },
      "FunctionTaskOutput": {
        "title": "Function Task Output",
        "type": "object",
        "properties": {
          "callId": {
            "type": "integer",
            "format": "int64",
            "description": "The callId of the Cognite Function call instance."
          },
          "functionId": {
            "type": "integer",
            "format": "int64",
            "description": "The functionId of the Cognite Function called."
          },
          "response": {
            "type": "object",
            "description": "The response of the function call. Limited to 100KB in size."
          }
        }
      },
      "SimulatorTaskOutput": {
        "title": "Simulator Task Output",
        "description": "Simulation run execution results.",
        "type": "object",
        "properties": {
          "runId": {
            "type": "integer",
            "format": "int64",
            "description": "The ID of the simulation run instance."
          },
          "logId": {
            "type": "integer",
            "format": "int64",
            "description": "The log ID of the simulation run."
          },
          "statusMessage": {
            "type": "string",
            "description": "The status message of the simulation run instance."
          }
        }
      },
      "CdfTaskOutput": {
        "title": "CDF Task Output",
        "type": "object",
        "properties": {
          "response": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "object"
              }
            ],
            "description": "The body of the response. Will be a a JSON object if content-type is application/json, otherwise it will be a string."
          },
          "statusCode": {
            "type": "integer",
            "description": "The HTTP status code of the response."
          }
        }
      },
      "DynamicTaskOutput": {
        "title": "Dynamic Task Output",
        "type": "object",
        "properties": {
          "dynamicTasks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskDefinition"
            },
            "minItems": 0,
            "maxItems": 100
          }
        }
      },
      "WorkflowDefinitionResponse": {
        "title": "Workflow Definition",
        "type": "object",
        "properties": {
          "hash": {
            "type": "string"
          },
          "description": {
            "type": "string",
            "maxLength": 500
          },
          "tasks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskDefinition"
            }
          }
        },
        "required": [
          "hash",
          "tasks"
        ]
      },
      "WorkflowVersionView": {
        "title": "Workflow Version",
        "type": "object",
        "properties": {
          "workflowExternalId": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          },
          "workflowDefinition": {
            "$ref": "#/components/schemas/WorkflowDefinitionResponse"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "Version": {
        "type": "string",
        "description": "Identifier for a version. Must be unique for the workflow. No trailing or leading whitespace and no null characters allowed.",
        "maxLength": 255
      },
      "WorkflowExternalId": {
        "type": "string",
        "description": "Identifier for a workflow. Must be unique for the project. No trailing or leading whitespace and no null characters allowed.",
        "maxLength": 255
      },
      "TaskExternalId": {
        "type": "string",
        "description": "Identifier for the task. Must be unique within the version. No trailing or leading whitespace and no null characters allowed.",
        "maxLength": 255
      },
      "WorkflowExecutionId": {
        "type": "string",
        "description": "UUIDv4 identifier for a workflow execution.",
        "maxLength": 36,
        "minLength": 36,
        "example": "059edaa4-a17a-4102-910e-2c3591500cce"
      },
      "WorkflowFilter": {
        "type": "object",
        "description": "If the version is not specified, all versions for the workflow will be included, ordered by createdTime.",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        },
        "required": [
          "externalId"
        ]
      },
      "ListExecutionsFilter": {
        "title": "List Executions Filter",
        "type": "object",
        "properties": {
          "workflowFilters": {
            "type": "array",
            "description": "Allows filtering executions by their workflows (and optionally version identifiers). If no workflowFilters are specified, all executions for all workflows will be included, ordered by createdTime.",
            "items": {
              "$ref": "#/components/schemas/WorkflowFilter"
            },
            "maxItems": 100
          },
          "createdTimeStart": {
            "type": "integer",
            "minimum": 0,
            "description": "epoch timestamp in milliseconds"
          },
          "createdTimeEnd": {
            "type": "integer",
            "minimum": 0,
            "description": "epoch timestamp in milliseconds"
          },
          "status": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowStatus"
            },
            "description": "workflow execution status",
            "uniqueItems": true
          }
        }
      },
      "ListExecutionsQuery": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/ListExecutionsFilter"
          },
          "limit": {
            "$ref": "#/components/schemas/limit"
          },
          "cursor": {
            "$ref": "#/components/schemas/cursor"
          }
        }
      },
      "ListVersionsFilter": {
        "type": "object",
        "properties": {
          "workflowFilters": {
            "type": "array",
            "maxItems": 100,
            "description": "Allows filtering versions by their specific workflows (and optionally version identifiers). If no workflowFilters are specified, all versions for all workflows will be included, ordered by createdTime.",
            "items": {
              "$ref": "#/components/schemas/WorkflowFilter"
            }
          }
        }
      },
      "ListVersionsQuery": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/ListVersionsFilter"
          },
          "limit": {
            "$ref": "#/components/schemas/limit"
          },
          "cursor": {
            "$ref": "#/components/schemas/cursor"
          }
        }
      },
      "Reference": {
        "type": "string",
        "description": "A Reference is an expression that allows dynamically injecting input to a task during execution. References can be used to reference the input of the Workflow, the output of a previous task in the Workflow, or the input of a previous task in the Workflow. Note that the injected value must be valid in the context of the property it is injected into.\nExample Task reference: ${myTaskExternalId.output.someKey} Example Workflow input reference: ${workflow.input.myKey}"
      },
      "WorkflowStatus": {
        "type": "string",
        "enum": [
          "RUNNING",
          "COMPLETED",
          "FAILED",
          "TIMED_OUT",
          "TERMINATED"
        ]
      },
      "WorkflowExecutionResponse": {
        "title": "Workflow Definition Execution Response",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/WorkflowExecutionId"
          },
          "workflowExternalId": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          },
          "status": {
            "$ref": "#/components/schemas/WorkflowStatus"
          },
          "engineExecutionId": {
            "$ref": "#/components/schemas/EngineExecutionId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "reasonForIncompletion": {
            "$ref": "#/components/schemas/ReasonForIncompletion"
          },
          "metadata": {
            "$ref": "#/components/schemas/metadata"
          }
        },
        "required": [
          "id",
          "workflowExternalId",
          "status",
          "engineExecutionId",
          "createdTime",
          "metadata"
        ]
      },
      "TaskExecutionId": {
        "type": "string",
        "description": "UUIDv4 identifier for the execution of a workflow task.",
        "minLength": 36,
        "maxLength": 36
      },
      "EngineExecutionId": {
        "type": "string",
        "description": "Additional UUIDv4 identifier for an execution. Useful for Cognite support to diagnose issues.",
        "minLength": 36,
        "maxLength": 36
      },
      "TaskExecution": {
        "title": "Task Execution",
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/TaskExecutionId"
          },
          "externalId": {
            "$ref": "#/components/schemas/TaskExternalId"
          },
          "status": {
            "type": "string",
            "enum": [
              "IN_PROGRESS",
              "CANCELED",
              "FAILED",
              "FAILED_WITH_TERMINAL_ERROR",
              "COMPLETED",
              "COMPLETED_WITH_ERRORS",
              "SCHEDULED",
              "TIMED_OUT",
              "SKIPPED"
            ]
          },
          "taskType": {
            "type": "string",
            "enum": [
              "function",
              "transformation",
              "cdf",
              "dynamic",
              "subworkflow"
            ]
          },
          "startTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "endTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "input": {
            "description": "The input to the task with the references present in the definition resolved.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/FunctionTaskParameters"
              },
              {
                "$ref": "#/components/schemas/TransformationTaskParameters"
              },
              {
                "$ref": "#/components/schemas/CdfTaskParameters"
              },
              {
                "$ref": "#/components/schemas/DynamicTaskParameters"
              },
              {
                "$ref": "#/components/schemas/SimulatorInput"
              }
            ]
          },
          "output": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FunctionTaskOutput"
              },
              {
                "$ref": "#/components/schemas/TransformationTaskOutput"
              },
              {
                "$ref": "#/components/schemas/CdfTaskOutput"
              },
              {
                "$ref": "#/components/schemas/DynamicTaskOutput"
              },
              {
                "$ref": "#/components/schemas/SimulatorTaskOutput"
              }
            ]
          },
          "reasonForIncompletion": {
            "$ref": "#/components/schemas/ReasonForIncompletion"
          }
        },
        "required": [
          "id",
          "externalId",
          "status",
          "taskType",
          "input",
          "output"
        ]
      },
      "nextCursor": {
        "description": "Cursor to get the next page of results. If not present, no more results are available.",
        "type": "string",
        "example": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo"
      },
      "cursor": {
        "type": "string",
        "example": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo",
        "description": "Cursor to use for paging through results. This cursor is returned in the response of a previous request as `nextCursor`. If not specified, start from the first page of results."
      },
      "limit": {
        "type": "integer",
        "minimum": 1,
        "maximum": 1000,
        "default": 100,
        "description": "The maximum number of results to return."
      },
      "metadata": {
        "type": "object",
        "maxProperties": 10,
        "additionalProperties": {
          "type": "string",
          "maxLength": 255
        },
        "description": "Custom, application-specific metadata. String key -> String value.\nKeys have a maximum length of 32 characters, values a maximum of 255,\nand there can be a maximum of 10 key-value pairs.\n"
      },
      "ReasonForIncompletion": {
        "type": "string",
        "description": "Human-readable reason for terminal failure of a workflow task."
      },
      "ExecutionInput": {
        "type": "object",
        "example": {
          "key1": "value1",
          "key2": "value2"
        },
        "description": "Input data to the workflow. The content of the input data can be used as input to the workflow tasks using references. The input data should be in JSON format, and is limited to 100KB in size."
      },
      "CancelExecution": {
        "title": "Workflow cancellation request",
        "type": "object",
        "properties": {
          "reason": {
            "type": "string",
            "description": "Human-readable reason for the cancellation.",
            "default": "cancelled",
            "maxLength": 500
          }
        }
      },
      "RetryExecution": {
        "title": "Workflow retry request",
        "type": "object",
        "properties": {
          "authentication": {
            "$ref": "#/components/schemas/Authentication"
          }
        },
        "required": [
          "authentication"
        ]
      },
      "SimulatorInputsUnit": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the unit."
          }
        }
      },
      "SimulatorInput": {
        "type": "object",
        "properties": {
          "referenceId": {
            "type": "string",
            "description": "Reference id of the value to override"
          },
          "value": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1024,
                "minLength": 1
              },
              {
                "type": "number"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 200,
                "minItems": 1
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array",
                "maxItems": 200,
                "minItems": 1
              }
            ],
            "title": "Value",
            "description": "Override the value used for a simulation run"
          },
          "unit": {
            "description": "Override the unit of the value",
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorInputsUnit"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "required": [
          "referenceId",
          "value"
        ]
      },
      "Authentication": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "string",
            "description": "The nonce of a sessions token, which can be obtained using client credentials authentication flow. The nonce's session must be a root session, i.e. it must not be a child of another session. See [Sessions API](https://api-docs.cognite.com/20230101/tag/Sessions) documentation for more information.",
            "example": "hOfy4Zop4N2SPRfl"
          }
        },
        "required": [
          "nonce"
        ]
      },
      "TriggerExternalId": {
        "type": "string",
        "description": "Identifier for a trigger. Must be unique for the project. No trailing or leading whitespace and no null characters allowed.",
        "maxLength": 255
      },
      "TriggerView": {
        "title": "Trigger response",
        "type": "object",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/TriggerExternalId"
          },
          "triggerRule": {
            "$ref": "#/components/schemas/TriggerRule"
          },
          "input": {
            "$ref": "#/components/schemas/ExecutionInput"
          },
          "metadata": {
            "$ref": "#/components/schemas/metadata"
          },
          "workflowExternalId": {
            "$ref": "#/components/schemas/WorkflowExternalId"
          },
          "workflowVersion": {
            "$ref": "#/components/schemas/Version"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "TriggerRule": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/CronTrigger"
          }
        ]
      },
      "CronTrigger": {
        "type": "object",
        "required": [
          "triggerType",
          "cronExpression"
        ],
        "properties": {
          "triggerType": {
            "type": "string",
            "enum": [
              "schedule"
            ]
          },
          "cronExpression": {
            "type": "string",
            "description": "A cron expression (UNIX format) specifying when the trigger should be executed. Use https://crontab.guru/ to create a cron expression. The API may adjust the exact timing of cron job executions to distribute the backend load more evenly. However, it will aim to maintain the overall frequency of executions as specified in the cron expression."
          }
        }
      },
      "dataSetIdWorkflows": {
        "description": "The unique identifier (ID) of the dataset that this workflow is associated with. \\\nA user must have access to this dataset to perform any actions on the workflow, such as viewing, updating, or deleting it. \\\nAdditionally, to manage any resources connected to the workflow (such as triggers, versions, or executions), the user must also have access to the dataset for viewing, updating, creating, and deleting these resources.\n",
        "allOf": [
          {
            "$ref": "#/components/schemas/CogniteInternalId"
          }
        ]
      },
      "DataModelingTrigger": {
        "type": "object",
        "required": [
          "triggerType",
          "dataModelingQuery",
          "batchSize",
          "batchTimeout"
        ],
        "properties": {
          "triggerType": {
            "type": "string",
            "enum": [
              "dataModeling"
            ],
            "description": "A trigger that starts a workflow execution based on the result of a data modeling query. The query is executed at regular interval and its output is handled incrementally. The batchSize controls the maximum number of items to pass as input to a workflow execution. The batchTimeout controls the maximum time to wait for the batch to be filled before passing it to a workflow execution. A partial batch will be passed to the workflow execution after the batchTimeout has passed. A full batch will be passed to the workflow execution without further delay."
          },
          "dataModelingQuery": {
            "type": "object",
            "required": [
              "with",
              "select"
            ],
            "properties": {
              "with": {
                "type": "object",
                "minProperties": 1,
                "maxProperties": 50,
                "additionalProperties": {
                  "$ref": "#/components/schemas/SyncTableExpressionV3"
                }
              },
              "select": {
                "minProperties": 1,
                "maxProperties": 50,
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/SyncSelectV3"
                }
              }
            }
          },
          "batchSize": {
            "type": "integer",
            "minimum": 100,
            "maximum": 1000,
            "description": "The maximum number of items to pass to a workflow execution."
          },
          "batchTimeout": {
            "type": "integer",
            "minimum": 60,
            "maximum": 86400,
            "description": "The maximum time in seconds to wait for the batch to be filled before passing it to a workflow execution."
          }
        }
      },
      "CertificateDetails": {
        "additionalProperties": false,
        "title": "CertificatDetails",
        "type": "object",
        "description": "Excerpt of certificate details",
        "properties": {
          "thumbprint": {
            "title": "Thumbprint",
            "type": "string",
            "description": "A thumbprint of the certificate provided",
            "maxLength": 50
          },
          "expiresAt": {
            "title": "ExpiresAt",
            "type": "integer",
            "description": "The expiry date of the certificate"
          }
        },
        "required": [
          "thumbprint",
          "expiresAt"
        ]
      },
      "AuthCertificate": {
        "additionalProperties": false,
        "title": "AuthenticationCertificate",
        "type": "object",
        "description": "Authentication certificate (if configured) used to authenticate to source.",
        "properties": {
          "key": {
            "title": "Certificate key",
            "type": "string",
            "description": "The key for the certificate",
            "maxLength": 100000
          },
          "keyPassword": {
            "title": "Certificate key password",
            "type": "string",
            "description": "The password for the certificate key",
            "minLength": 1,
            "maxLength": 255
          },
          "type": {
            "$ref": "#/components/schemas/CertificateType"
          },
          "certificate": {
            "title": "Certificate",
            "type": "string",
            "description": "Base 64 encoded der certificate, or a pem certificate with headers.",
            "maxLength": 100000
          }
        },
        "required": [
          "type",
          "certificate",
          "key"
        ]
      },
      "CACertificate": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "$ref": "#/components/schemas/CertificateType"
          },
          "certificate": {
            "title": "Certificate",
            "type": "string",
            "description": "Base 64 encoded der certificate, or a pem certificate with headers.",
            "maxLength": 100000
          }
        },
        "required": [
          "certificate",
          "type"
        ],
        "title": "CACertificate",
        "type": "object",
        "description": "Custom certificate authority certificate to let the source use a self signed certificate."
      },
      "CertificateType": {
        "enum": [
          "der",
          "pem"
        ],
        "title": "CertificateType",
        "type": "string",
        "description": "Type of certificate in the `certificate` field."
      },
      "DataModels": {
        "type": "object",
        "additionalProperties": false,
        "title": "DataModels",
        "description": "Data models configuration to specify the space for all instances.",
        "properties": {
          "space": {
            "type": "string",
            "title": "Space",
            "description": "The data models space where time series will be created."
          }
        },
        "required": [
          "space"
        ]
      },
      "CogniteFormat": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "cognite"
            ],
            "title": "Type",
            "type": "string",
            "description": "Format type."
          },
          "encoding": {
            "$ref": "#/components/schemas/EncodingType"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType"
          },
          "prefix": {
            "$ref": "#/components/schemas/PrefixConfig"
          },
          "dataModels": {
            "$ref": "#/components/schemas/DataModels"
          }
        },
        "required": [
          "type"
        ],
        "title": "CogniteFormat",
        "type": "object",
        "description": "Convert from the special cognite format to CDF datapoints."
      },
      "CreateDestination": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "title": "External ID",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "credentials": {
            "$ref": "#/components/schemas/SessionCredentials"
          },
          "targetDataSetId": {
            "type": "integer",
            "title": "Data Set ID",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "Data set ID the created items are inserted into, if applicable."
          }
        },
        "required": [
          "externalId"
        ],
        "title": "CreateDestination",
        "type": "object"
      },
      "CreateEventHubSource": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "eventhub"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host name or IP address of the event hub consumer endpoint.",
            "example": "iothub-ns-myhub-12345678-12345abcde.servicebus.windows.net",
            "maxLength": 200
          },
          "eventHubName": {
            "title": "Eventhubname",
            "type": "string",
            "description": "Name of the event hub",
            "example": "myhub",
            "maxLength": 200
          },
          "keyName": {
            "title": "KeyName",
            "type": "string",
            "description": "The name of the Event Hub key to use for authentication.",
            "example": "iothubowner",
            "maxLength": 200
          },
          "keyValue": {
            "title": "KeyValue",
            "type": "string",
            "description": "Value of the Event Hub key to use for authentication.",
            "maxLength": 200
          },
          "consumerGroup": {
            "type": "string",
            "title": "ConsumerGroup",
            "description": "The event hub consumer group to use. Microsoft recommends having a distinct consumer group for each application consuming data from event hub. If left out, this uses the default consumer group.",
            "maxLength": 200
          }
        },
        "required": [
          "type",
          "externalId",
          "host",
          "keyName",
          "eventHubName",
          "keyValue"
        ],
        "title": "CreateEventHubSource",
        "type": "object"
      },
      "MQTTJobConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "MQTT",
        "required": [
          "topicFilter"
        ],
        "properties": {
          "topicFilter": {
            "title": "TopicFilter",
            "type": "string",
            "description": "Topic filter.",
            "maxLength": 200
          }
        }
      },
      "KafkaJobConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "Kafka",
        "required": [
          "topic"
        ],
        "properties": {
          "topic": {
            "title": "Topic",
            "type": "string",
            "description": "Kafka topic to connect to",
            "maxLength": 200
          },
          "partitions": {
            "title": "Partitions",
            "type": "integer",
            "minimum": 1,
            "maximum": 10,
            "default": 1,
            "description": "Number of partitions on the topic."
          }
        }
      },
      "QueryParameterConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "QueryParameterConfig",
        "required": [
          "key",
          "value",
          "type"
        ],
        "properties": {
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "queryParam"
            ]
          },
          "key": {
            "title": "Key",
            "type": "string",
            "description": "Key to insert the generated value into"
          },
          "value": {
            "title": "Value",
            "type": "string",
            "description": "Expression that will be evaluated, and its result used as a query parameter"
          }
        }
      },
      "HeaderValueConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "HeaderValueConfig",
        "required": [
          "key",
          "value",
          "type"
        ],
        "properties": {
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "headerValue"
            ]
          },
          "key": {
            "title": "Key",
            "type": "string",
            "description": "Key to insert the generated value into"
          },
          "value": {
            "title": "Value",
            "type": "string",
            "description": "Expression that will be evaluated, and its result used as a header value"
          }
        }
      },
      "NextUrlConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "HeaderValueConfig",
        "required": [
          "type",
          "value"
        ],
        "properties": {
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "nextUrl"
            ]
          },
          "value": {
            "title": "Value",
            "type": "string",
            "description": "Expression yielding the next URL to call"
          }
        }
      },
      "BodyPaginationConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "BodyPaginationConfig",
        "required": [
          "type",
          "value"
        ],
        "properties": {
          "type": {
            "title": "Type",
            "type": "string",
            "enum": [
              "body"
            ]
          },
          "value": {
            "title": "Value",
            "type": "string",
            "description": "Expression yielding next message body. Note that body-based pagination is not allowed to be used if `method` is not set to `post`.\n"
          }
        }
      },
      "RestJobConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "Rest",
        "properties": {
          "interval": {
            "$ref": "#/components/schemas/RestInterval"
          },
          "path": {
            "type": "string",
            "title": "Path",
            "description": "Path of resource to access on the server, without query.",
            "minLength": 1,
            "maxLength": 2048
          },
          "method": {
            "type": "string",
            "title": "Method",
            "description": "HTTP method to use for each request.",
            "enum": [
              "get",
              "post"
            ],
            "default": "get"
          },
          "body": {
            "title": "Body",
            "description": "Initial JSON body to send with request. Only applicable if method is `post`. Maximum of 10000 bytes total.\n"
          },
          "query": {
            "type": "object",
            "title": "Query",
            "description": "Query parameters to include in request. String key -> String value. Limits: Maximum 255 characters per key, 2048 per value, and at most 32 pairs.\n",
            "x-maxKeyLength": 255,
            "maxProperties": 32,
            "additionalProperties": {
              "type": "string",
              "maxLength": 2048
            }
          },
          "headers": {
            "type": "object",
            "title": "Query",
            "description": "Headers to include in request. String key -> String value. Limits: Maximum 255 characters per key, 2048 per value, and at most 32 pairs.\n",
            "x-maxKeyLength": 255,
            "maxProperties": 32,
            "additionalProperties": {
              "type": "string",
              "maxLength": 2048
            }
          },
          "incrementalLoad": {
            "type": "object",
            "discriminator": {
              "mapping": {
                "queryParam": "#/components/schemas/QueryParameterConfig",
                "headerValue": "#/components/schemas/HeaderValueConfig",
                "body": "#/components/schemas/BodyPaginationConfig"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/QueryParameterConfig"
              },
              {
                "$ref": "#/components/schemas/HeaderValueConfig"
              },
              {
                "$ref": "#/components/schemas/BodyPaginationConfig"
              }
            ],
            "title": "Incremental load",
            "description": "The format of the messages from the source. This is used to convert messages coming from the source system to a format that can be inserted into CDF."
          },
          "pagination": {
            "type": "object",
            "discriminator": {
              "mapping": {
                "queryParam": "#/components/schemas/QueryParameterConfig",
                "headerValue": "#/components/schemas/HeaderValueConfig",
                "nextUrl": "#/components/schemas/NextUrlConfig",
                "body": "#/components/schemas/BodyPaginationConfig"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/QueryParameterConfig"
              },
              {
                "$ref": "#/components/schemas/HeaderValueConfig"
              },
              {
                "$ref": "#/components/schemas/NextUrlConfig"
              },
              {
                "$ref": "#/components/schemas/BodyPaginationConfig"
              }
            ],
            "title": "Incremental load",
            "description": "The format of the messages from the source. This is used to convert messages coming from the source system to a format that can be inserted into CDF."
          }
        },
        "required": [
          "interval",
          "path"
        ]
      },
      "JobConfig": {
        "description": "Source specific job configuration. The type depends on the type of source, and is required for some sources.\n",
        "title": "Job Config",
        "oneOf": [
          {
            "$ref": "#/components/schemas/MQTTJobConfig"
          },
          {
            "$ref": "#/components/schemas/KafkaJobConfig"
          },
          {
            "$ref": "#/components/schemas/RestJobConfig"
          }
        ]
      },
      "UpdateItem_JobConfig_": {
        "additionalProperties": false,
        "type": "object",
        "title": "UpdateItem_JobConfig",
        "description": "Set a new source specific job config.",
        "properties": {
          "set": {
            "$ref": "#/components/schemas/JobConfig"
          }
        }
      },
      "CreateJob": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "destinationId": {
            "title": "Destination ID",
            "description": "ID of the destination this job should write to.",
            "type": "string",
            "maxLength": 255
          },
          "sourceId": {
            "title": "Source ID",
            "description": "ID of the source this job should read from.",
            "type": "string",
            "maxLength": 255
          },
          "format": {
            "discriminator": {
              "mapping": {
                "cognite": "#/components/schemas/CogniteFormat",
                "custom": "#/components/schemas/WriteCustomFormat",
                "rockwell": "#/components/schemas/RockwellFormat",
                "value": "#/components/schemas/ValueFormat"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/RockwellFormat"
              },
              {
                "$ref": "#/components/schemas/CogniteFormat"
              },
              {
                "$ref": "#/components/schemas/WriteCustomFormat"
              },
              {
                "$ref": "#/components/schemas/ValueFormat"
              }
            ],
            "title": "Format",
            "description": "The format of the messages from the source. This is used to convert messages coming from the source system to a format that can be inserted into CDF.",
            "type": "object"
          },
          "config": {
            "$ref": "#/components/schemas/JobConfig"
          }
        },
        "required": [
          "sourceId",
          "destinationId",
          "externalId",
          "format",
          "config"
        ],
        "title": "CreateJob",
        "type": "object"
      },
      "CreateMqttV3Source": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "mqtt3"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host or IP address of the MQTT broker to connect to.",
            "maxLength": 200
          },
          "port": {
            "type": "integer",
            "title": "Port",
            "default": 1883,
            "description": "Port on the MQTT broker to connect to.",
            "minimum": 1,
            "maximum": 65535
          },
          "authentication": {
            "$ref": "#/components/schemas/MqttAuthenticationWrite"
          },
          "useTls": {
            "type": "boolean",
            "title": "UseTls",
            "description": "If true, use TLS when connecting to the broker."
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CACertificate"
          },
          "authCertificate": {
            "$ref": "#/components/schemas/AuthCertificate"
          }
        },
        "required": [
          "type",
          "externalId",
          "host"
        ],
        "title": "CreateMqttV3Source",
        "type": "object"
      },
      "CreateMqttV5Source": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "mqtt5"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host or IP address of the MQTT broker to connect to.",
            "maxLength": 200
          },
          "port": {
            "type": "integer",
            "title": "Port",
            "default": 1883,
            "description": "Port on the MQTT broker to connect to.",
            "minimum": 1,
            "maximum": 65535
          },
          "authentication": {
            "$ref": "#/components/schemas/MqttAuthenticationWrite"
          },
          "useTls": {
            "type": "boolean",
            "title": "UseTls",
            "description": "If true, use TLS when connecting to the broker."
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CACertificate"
          },
          "authCertificate": {
            "$ref": "#/components/schemas/AuthCertificate"
          }
        },
        "required": [
          "type",
          "externalId",
          "host"
        ],
        "title": "CreateMqttV5Source",
        "type": "object"
      },
      "CreateRestSource": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "rest"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host or IP address to connect to.",
            "maxLength": 200
          },
          "scheme": {
            "title": "Scheme",
            "type": "string",
            "description": "Type of connection to establish",
            "enum": [
              "http",
              "https"
            ],
            "default": "https"
          },
          "port": {
            "type": "integer",
            "title": "Port",
            "description": "Port on server to connect to. Uses default ports based on the scheme if omitted.",
            "minimum": 1,
            "maximum": 65535
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CACertificate"
          },
          "authentication": {
            "discriminator": {
              "mapping": {
                "basic": "#/components/schemas/CreateBasicAuthentication",
                "header": "#/components/schemas/CreateHeaderValueAuthentication",
                "query": "#/components/schemas/CreateQueryParamAuthentication",
                "clientCredentials": "#/components/schemas/CreateClientCredentialsAuthentication"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/CreateBasicAuthentication"
              },
              {
                "$ref": "#/components/schemas/CreateHeaderValueAuthentication"
              },
              {
                "$ref": "#/components/schemas/CreateQueryParamAuthentication"
              },
              {
                "$ref": "#/components/schemas/CreateClientCredentialsAuthentication"
              }
            ],
            "title": "Authentication",
            "description": "Authentication details for source"
          }
        },
        "required": [
          "type",
          "externalId",
          "host"
        ],
        "title": "CreateRestSource",
        "type": "object"
      },
      "CreateProtoFile": {
        "additionalProperties": false,
        "description": "Definition of a protobuf file used for loading input to the mapping.",
        "properties": {
          "fileName": {
            "type": "string",
            "title": "File Name",
            "format": "[a-zA-Z0-9_-]+\\.proto",
            "maxLength": 128,
            "description": "Name of protobuf file. Must contain only letters, numbers, underscores, and hyphens, and must end with '.proto'."
          },
          "content": {
            "type": "string",
            "title": "Content",
            "description": "Protobuf file content. Must be a valid protobuf file.",
            "maxLength": 10000
          }
        },
        "required": [
          "fileName",
          "content"
        ]
      },
      "ProtoFile": {
        "additionalProperties": false,
        "description": "Description of a protobuf file used for loading input to the mapping.",
        "properties": {
          "fileName": {
            "type": "string",
            "title": "File Name",
            "format": "[a-zA-Z0-9_-]+\\.proto",
            "maxLength": 128,
            "description": "Name of protobuf file. Must contain only letters, numbers, underscores, and hyphens, and must end with '.proto'."
          }
        },
        "required": [
          "fileName"
        ]
      },
      "CreateProtobufConfig": {
        "additionalProperties": false,
        "description": "List of protobuf files used to define input to the mapping. This will be compiled to a collection of definitions which will be used to convert the input to JSON.",
        "title": "ProtoBuf",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "protobuf"
            ],
            "description": "Input type",
            "title": "Type"
          },
          "messageName": {
            "type": "string",
            "description": "Name of root message in the protobuf files.",
            "maxLength": 128,
            "title": "Message Name"
          },
          "files": {
            "type": "array",
            "maxItems": 20,
            "minItems": 1,
            "description": "List of protobuf files as text.",
            "items": {
              "$ref": "#/components/schemas/CreateProtoFile"
            }
          }
        },
        "required": [
          "messageName",
          "files",
          "type"
        ]
      },
      "CreateInputConfig": {
        "type": "object",
        "description": "Optionally set input mapping input type. This defaults to json if left out. Each input type is converted to JSON before being passed to the mapping expression.",
        "discriminator": {
          "mapping": {
            "protobuf": "#/components/schemas/CreateProtobufConfig",
            "csv": "#/components/schemas/CsvConfig",
            "xml": "#/components/schemas/XmlConfig",
            "json": "#/components/schemas/JsonConfig"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/CreateProtobufConfig"
          },
          {
            "$ref": "#/components/schemas/CsvConfig"
          },
          {
            "$ref": "#/components/schemas/XmlConfig"
          },
          {
            "$ref": "#/components/schemas/JsonConfig"
          }
        ]
      },
      "InputConfig": {
        "type": "object",
        "description": "Optionally set input mapping input type. This defaults to json if left out. Any input type is converted to JSON before being passed to the mapping expression.",
        "discriminator": {
          "mapping": {
            "protobuf": "#/components/schemas/ProtobufConfig",
            "csv": "#/components/schemas/CsvConfig",
            "xml": "#/components/schemas/XmlConfig",
            "json": "#/components/schemas/JsonConfig"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/ProtobufConfig"
          },
          {
            "$ref": "#/components/schemas/CsvConfig"
          },
          {
            "$ref": "#/components/schemas/XmlConfig"
          },
          {
            "$ref": "#/components/schemas/JsonConfig"
          }
        ]
      },
      "CsvConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "CSV",
        "description": "Transform the input from a CSV (Comma Separated Values) file to a list of JSON objects. The input to the mapping will be a list on the form `[{\\\"header1\\\": \\\"value1\\\", ...}, ...]`.\n",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "csv"
            ],
            "description": "Input type",
            "title": "Type"
          },
          "delimiter": {
            "type": "string",
            "description": "A single ASCII character used as the separator in the CSV file. Defaults to `,`",
            "maxLength": 1,
            "minLength": 1,
            "title": "Delimiter"
          },
          "customKeys": {
            "type": "array",
            "minItems": 1,
            "maxItems": 20,
            "description": "List of headers. If this is not set, the headers will be retrieved from the CSV file.",
            "items": {
              "type": "string",
              "description": "CSV file header value.",
              "title": "CSV_Header"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "XmlConfig": {
        "additionalProperties": false,
        "type": "object",
        "title": "XML",
        "description": "Transform the input from an XML file to a JSON object.\n",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "xml"
            ],
            "description": "Input type",
            "title": "Type"
          }
        },
        "required": [
          "type"
        ]
      },
      "JsonConfig": {
        "additionalProperties": false,
        "type": "object",
        "description": "Treat the input as UTF-8 encoded JSON.",
        "title": "JSON",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "json"
            ],
            "description": "Input type",
            "title": "Type"
          }
        },
        "required": [
          "type"
        ]
      },
      "ProtobufConfig": {
        "additionalProperties": false,
        "description": "List of protobuf files used to define input to the mapping. This will be compiled to a collection of definitions which will be used to convert the input to JSON.",
        "title": "ProtoBuf",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "protobuf"
            ],
            "description": "Input type",
            "title": "Type"
          },
          "messageName": {
            "type": "string",
            "description": "Name of root message in the protobuf files.",
            "maxLength": 128,
            "title": "Message Name"
          },
          "files": {
            "type": "array",
            "maxItems": 20,
            "minItems": 1,
            "items": {
              "$ref": "#/components/schemas/ProtoFile"
            }
          }
        },
        "required": [
          "messageName",
          "files",
          "type"
        ]
      },
      "UpdateItem_InputConfig_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CreateInputConfig"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_InputConfig",
        "type": "object",
        "description": "Set a new mapping input."
      },
      "CreateMapping": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "mapping": {
            "$ref": "#/components/schemas/CustomMapping"
          },
          "input": {
            "$ref": "#/components/schemas/CreateInputConfig"
          },
          "published": {
            "title": "Published",
            "type": "boolean",
            "description": "Whether this mapping is published and should be available to be used in jobs."
          }
        },
        "required": [
          "externalId",
          "mapping",
          "published"
        ],
        "title": "CreateMapping",
        "type": "object"
      },
      "CustomFormat": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "custom"
            ],
            "title": "Type",
            "type": "string",
            "description": "Format type."
          },
          "mappingId": {
            "type": "string",
            "title": "MappingId",
            "description": "The ID of the mapping used for this format.",
            "maxLength": 255
          },
          "encoding": {
            "$ref": "#/components/schemas/EncodingType"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType"
          },
          "expression": {
            "type": "string",
            "title": "Expression",
            "description": "The transformation expression of the mapping given by `mappingId`.",
            "maxLength": 2000
          }
        },
        "required": [
          "type",
          "mappingId",
          "expression"
        ],
        "title": "CustomFormat",
        "type": "object"
      },
      "Destination": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "sessionId": {
            "type": "integer",
            "title": "Session ID",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "ID of the session tied to this destination."
          },
          "targetDataSetId": {
            "type": "integer",
            "title": "Data Set ID",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "Data set ID the created items are inserted into, if applicable."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "externalId",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Destination",
        "type": "object"
      },
      "DestinationUpdateItem": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateDestination"
          }
        },
        "required": [
          "externalId",
          "update"
        ],
        "title": "DestinationUpdateItem",
        "type": "object"
      },
      "EncodingType": {
        "enum": [
          "utf8",
          "utf16",
          "utf16le",
          "latin1"
        ],
        "title": "EncodingType",
        "description": "The type of encoding to convert from.\n- `utf8`, UTF-8, default.\n- `utf16`, UTF-16 big endian.\n- `utf16le`, UTF-16 little endian.\n- `latin1`, Latin 1, Specifically Windows CP 1252.",
        "type": "string"
      },
      "CompressionType": {
        "enum": [
          "gzip"
        ],
        "title": "CompressionType",
        "description": "The compression applied to incoming messages. The messages are decompressed before being passed to transformations.\nThis is usually not relevant for REST, where this is handled automatically, but MQTT, Kafka, and EventHub have no such mechanisms.",
        "type": "string"
      },
      "EventHubSource": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "eventhub"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "URL of the event hub consumer endpoint.",
            "example": "iothub-ns-myhub-12345678-12345abcde.servicebus.windows.net",
            "maxLength": 200
          },
          "eventHubName": {
            "title": "EventHubName",
            "type": "string",
            "description": "Name of the event hub",
            "example": "myhub",
            "maxLength": 200
          },
          "keyName": {
            "title": "KeyName",
            "type": "string",
            "description": "The name of the Event Hub key to use.",
            "example": "iothubowner",
            "maxLength": 200
          },
          "consumerGroup": {
            "type": "string",
            "title": "ConsumerGroup",
            "description": "The event hub consumer group to use. Microsoft recommends having a distinct consumer group for each application consuming data from event hub. If left out, this uses the default consumer group.",
            "maxLength": 200
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "type",
          "externalId",
          "host",
          "keyName",
          "eventHubName",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "EventHubSource",
        "type": "object"
      },
      "ExternalIdWrapper": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "required": [
          "externalId"
        ],
        "title": "ExternalIdWrapper",
        "type": "object"
      },
      "ItemsWithIgnoreUnknownIds_ExternalId_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/ExternalIdWrapper"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "title": "IgnoreUnknownIds",
            "description": "Ignore IDs and external IDs that are not found"
          }
        },
        "required": [
          "items"
        ],
        "title": "ItemsWithIgnoreUnknownIds_ExternalId",
        "type": "object"
      },
      "ItemsWithIgnoreUnknownIdsAndForce_ExternalId_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/ExternalIdWrapper"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "title": "IgnoreUnknownIds",
            "description": "Ignore IDs and external IDs that are not found."
          },
          "force": {
            "type": "boolean",
            "title": "Force",
            "description": "Delete any jobs associated with each item."
          }
        },
        "required": [
          "items"
        ],
        "title": "ItemsWithIgnoreUnknownIdsAndForce_ExternalId",
        "type": "object"
      },
      "Items_CreateSource_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "discriminator": {
                "mapping": {
                  "eventhub": "#/components/schemas/CreateEventHubSource",
                  "mqtt3": "#/components/schemas/CreateMqttV3Source",
                  "mqtt5": "#/components/schemas/CreateMqttV5Source",
                  "rest": "#/components/schemas/CreateRestSource",
                  "kafka": "#/components/schemas/CreateKafkaSource"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/CreateMqttV3Source"
                },
                {
                  "$ref": "#/components/schemas/CreateMqttV5Source"
                },
                {
                  "$ref": "#/components/schemas/CreateEventHubSource"
                },
                {
                  "$ref": "#/components/schemas/CreateRestSource"
                },
                {
                  "$ref": "#/components/schemas/CreateKafkaSource"
                }
              ]
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "CreateSourceList",
        "type": "object"
      },
      "Items_Source_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "discriminator": {
                "mapping": {
                  "eventhub": "#/components/schemas/EventHubSource",
                  "mqtt3": "#/components/schemas/MqttV3Source",
                  "mqtt5": "#/components/schemas/MqttV5Source",
                  "rest": "#/components/schemas/RestSource",
                  "kafka": "#/components/schemas/KafkaSource"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/MqttV3Source"
                },
                {
                  "$ref": "#/components/schemas/MqttV5Source"
                },
                {
                  "$ref": "#/components/schemas/EventHubSource"
                },
                {
                  "$ref": "#/components/schemas/RestSource"
                },
                {
                  "$ref": "#/components/schemas/KafkaSource"
                }
              ]
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "SourceList",
        "type": "object"
      },
      "ItemsWithCursor_Source_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "discriminator": {
                "mapping": {
                  "eventhub": "#/components/schemas/EventHubSource",
                  "mqtt3": "#/components/schemas/MqttV3Source",
                  "mqtt5": "#/components/schemas/MqttV5Source",
                  "rest": "#/components/schemas/RestSource",
                  "kafka": "#/components/schemas/KafkaSource"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/MqttV3Source"
                },
                {
                  "$ref": "#/components/schemas/MqttV5Source"
                },
                {
                  "$ref": "#/components/schemas/EventHubSource"
                },
                {
                  "$ref": "#/components/schemas/RestSource"
                },
                {
                  "$ref": "#/components/schemas/KafkaSource"
                }
              ]
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "SourceListWithCursor",
        "type": "object"
      },
      "Items_UpdateSource_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "discriminator": {
                "mapping": {
                  "eventhub": "#/components/schemas/UpdateEventHubSourceItem",
                  "mqtt3": "#/components/schemas/UpdateMqttV3SourceItem",
                  "mqtt5": "#/components/schemas/UpdateMqttV5SourceItem",
                  "rest": "#/components/schemas/UpdateRestSourceItem",
                  "kafka": "#/components/schemas/UpdateKafkaSourceItem"
                },
                "propertyName": "type"
              },
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UpdateMqttV3SourceItem"
                },
                {
                  "$ref": "#/components/schemas/UpdateMqttV5SourceItem"
                },
                {
                  "$ref": "#/components/schemas/UpdateEventHubSourceItem"
                },
                {
                  "$ref": "#/components/schemas/UpdateRestSourceItem"
                },
                {
                  "$ref": "#/components/schemas/UpdateKafkaSourceItem"
                }
              ]
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "UpdateSourceList",
        "type": "object"
      },
      "Items_CreateDestination_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateDestination"
            },
            "title": "Items",
            "type": "array",
            "minLength": 1,
            "maxLength": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "CreateDestination list",
        "type": "object"
      },
      "Items_CreateJob_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateJob"
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "Items[CreateJob]",
        "type": "object"
      },
      "Items_CreateMapping_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateMapping"
            },
            "title": "Items",
            "type": "array",
            "minLength": 1,
            "maxLength": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "Items[CreateMapping]",
        "type": "object"
      },
      "Items_DestinationUpdateItem_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/DestinationUpdateItem"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 10,
            "minItems": 1
          }
        },
        "required": [
          "items"
        ],
        "title": "Items[DestinationUpdateItem]",
        "type": "object"
      },
      "Items_Destination_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Destination"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "DestinationList",
        "type": "object"
      },
      "ItemsWithCursor_Destination_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Destination"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "DestinationListWithCursor",
        "type": "object"
      },
      "Items_MinimalJob_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/MinimalJob"
            },
            "title": "Items",
            "type": "array",
            "maxLength": 100,
            "minLength": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "JobList",
        "type": "object"
      },
      "ItemsWithCursor_MinimalJob_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/MinimalJob"
            },
            "title": "Items",
            "type": "array",
            "maxLength": 100,
            "minLength": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "JobList",
        "type": "object"
      },
      "Items_MappingUpdateItem_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/MappingUpdateItem"
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "MappingUpdateList",
        "type": "object"
      },
      "Items_Mapping_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Mapping"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "MappingList",
        "type": "object"
      },
      "ItemsWithCursor_Mapping_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Mapping"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "MappingList",
        "type": "object"
      },
      "Items_JobUpdateItem_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/JobUpdateItem"
            },
            "title": "Items",
            "type": "array",
            "minLength": 1,
            "maxLength": 10
          }
        },
        "required": [
          "items"
        ],
        "title": "UpdateJobList",
        "type": "object"
      },
      "Items_JobLogEntry_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/JobLogEntry"
            },
            "title": "Items",
            "type": "array",
            "maxLength": 1000,
            "minLength": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "JobLogEntryList",
        "type": "object"
      },
      "Items_JobMetrics_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/JobMetrics"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 1000,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "JobMetricsList",
        "type": "object"
      },
      "JobLogEntry": {
        "additionalProperties": false,
        "properties": {
          "jobExternalId": {
            "type": "string",
            "description": "External ID of the job this log entry belongs to.",
            "maxLength": 255
          },
          "type": {
            "type": "string",
            "enum": [
              "paused",
              "startup_error",
              "connection_error",
              "connected",
              "transform_error",
              "cdf_write_error",
              "ok"
            ],
            "description": "Type of log entry.\n`paused` indicates that the job has been stopped manually,\n`startup_error` indicates that the job failed to start at all and requires changes to configuration,\n`connected` indicates that the job has connected to the source but did not yet receive any data,\n`transform_error` indicates that the job received data, but it failed to transform,\n`cdf_write_error` indicates that ingesting the data to CDF failed,\n`ok` means that data was successfully ingested to CDF."
          },
          "message": {
            "type": "string",
            "description": "Log message. Not all log entries have messages."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "title": "JobLogEntry",
        "type": "object",
        "required": [
          "jobExternalId",
          "type",
          "createdTime"
        ]
      },
      "JobMetrics": {
        "additionalProperties": false,
        "properties": {
          "jobExternalId": {
            "type": "string",
            "description": "External ID of the job this metrics batch belongs to.",
            "maxLength": 255
          },
          "timestamp": {
            "title": "Timestamp",
            "description": "The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.\nMetrics are from the UTC hour this timestamp is ingest. For example, if this timestamp is at 01:43:15, the metrics batch contains metrics from 01:00:00 to 01:43:15.",
            "type": "integer",
            "minimum": 0,
            "format": "int64"
          },
          "sourceMessages": {
            "title": "SourceMessages",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Messages received from the source."
          },
          "cdfInputValues": {
            "title": "CDFInputValues",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Destination resources successfully transformed and passed to CDF."
          },
          "cdfRequests": {
            "title": "CDFRequests",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Requests made to CDF containing data produced by this job."
          },
          "transformFailures": {
            "title": "TransformFailures",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Source messages that failed to transform."
          },
          "cdfWriteFailures": {
            "title": "CDFWriteFailures",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Times the destination received data from transformations, but failed to produce a valid request to CDF."
          },
          "cdfSkippedValues": {
            "title": "CDFSkippedValues",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Values the destination received from the source, then decided to skip due to data type mismatch, invalid content, or other."
          },
          "cdfFailedValues": {
            "title": "CDFFailedValues",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Values the destination was unable to upload to CDF."
          },
          "cdfUploadedValues": {
            "title": "CDFUploadedValues",
            "minimum": 0,
            "format": "int64",
            "type": "integer",
            "description": "Values the destination successfully uploaded to CDF."
          }
        },
        "required": [
          "jobExternalId",
          "timestamp",
          "sourceMessages",
          "cdfInputValues",
          "cdfRequests",
          "transformFailures",
          "cdfWriteFailures",
          "cdfSkippedValues",
          "cdfFailedValues",
          "cdfUploadedValues"
        ]
      },
      "JobTargetStatus": {
        "enum": [
          "running",
          "paused"
        ],
        "title": "JobTargetStatus",
        "description": "The target status of a job. Set this to start or stop the job.",
        "type": "string"
      },
      "JobUpdate": {
        "additionalProperties": false,
        "properties": {
          "destinationId": {
            "$ref": "#/components/schemas/UpdateItem_DestinationId_"
          },
          "format": {
            "$ref": "#/components/schemas/UpdateFormat"
          },
          "sourceId": {
            "$ref": "#/components/schemas/UpdateItem_SourceId_"
          },
          "targetStatus": {
            "$ref": "#/components/schemas/UpdateItem_JobTargetStatus_"
          },
          "config": {
            "$ref": "#/components/schemas/UpdateItem_JobConfig_"
          }
        },
        "title": "JobUpdate",
        "type": "object"
      },
      "MinimalJob": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "destinationId": {
            "title": "Destination ID",
            "description": "ID of the destination this job writes to.",
            "type": "string",
            "maxLength": 255
          },
          "sourceId": {
            "title": "Source ID",
            "description": "ID of the source this job reads from.",
            "type": "string",
            "maxLength": 255
          },
          "format": {
            "discriminator": {
              "mapping": {
                "cognite": "#/components/schemas/CogniteFormat",
                "custom": "#/components/schemas/CustomFormat",
                "rockwell": "#/components/schemas/RockwellFormat",
                "value": "#/components/schemas/ValueFormat"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/RockwellFormat"
              },
              {
                "$ref": "#/components/schemas/CogniteFormat"
              },
              {
                "$ref": "#/components/schemas/CustomFormat"
              },
              {
                "$ref": "#/components/schemas/ValueFormat"
              }
            ],
            "title": "Format",
            "description": "The format of the messages from the source. This is used to convert messages coming from the source system to a format that can be inserted into CDF.",
            "type": "object"
          },
          "targetStatus": {
            "$ref": "#/components/schemas/JobTargetStatus"
          },
          "status": {
            "title": "Status",
            "description": "Status of this job.",
            "enum": [
              "startup_error",
              "paused",
              "shutting_down",
              "connected",
              "running",
              "waiting",
              "connection_error",
              "cdf_write_error",
              "transform_error"
            ],
            "type": "string"
          },
          "config": {
            "$ref": "#/components/schemas/JobConfig"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "sourceId",
          "destinationId",
          "externalId",
          "createdTime",
          "lastUpdatedTime",
          "status",
          "targetStatus",
          "format",
          "config"
        ],
        "title": "Job",
        "type": "object"
      },
      "MqttV3Source": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "mqtt3"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host or IP address of the MQTT broker to connect to.",
            "maxLength": 200
          },
          "port": {
            "type": "integer",
            "title": "Port",
            "description": "Port to connect to on the MQTT broker.",
            "default": 1883,
            "minimum": 1,
            "maximum": 65535
          },
          "authentication": {
            "$ref": "#/components/schemas/MqttAuthentication"
          },
          "useTls": {
            "type": "boolean",
            "title": "UseTls",
            "description": "If true, use TLS when connecting to the broker."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          },
          "authCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          }
        },
        "required": [
          "type",
          "externalId",
          "host",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "MqttV3Source",
        "type": "object"
      },
      "MqttV5Source": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "mqtt5"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host or IP address of the MQTT broker to connect to.",
            "maxLength": 200
          },
          "port": {
            "type": "integer",
            "title": "Port",
            "description": "Port to connect to on the MQTT broker.",
            "default": 1883,
            "minimum": 1,
            "maximum": 65535
          },
          "authentication": {
            "$ref": "#/components/schemas/MqttAuthentication"
          },
          "useTls": {
            "type": "boolean",
            "title": "UseTls",
            "description": "If true, use TLS when connecting to the broker."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          },
          "authCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          }
        },
        "required": [
          "type",
          "externalId",
          "host",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "MqttV5Source",
        "type": "object"
      },
      "PrefixConfig": {
        "additionalProperties": false,
        "properties": {
          "fromTopic": {
            "type": "boolean",
            "title": "FromTopic",
            "description": "Generate the prefix based on the topic of the received message."
          },
          "prefix": {
            "type": "string",
            "title": "Prefix",
            "description": "A fixed prefix to the generated IDs.",
            "maxLength": 255
          }
        },
        "title": "PrefixConfig",
        "description": "Generate a prefix for resources created using this format. If both `prefix` and `fromTopic` are set, the generated ID will be on the form `[prefix][topic][id]`",
        "type": "object"
      },
      "RestInterval": {
        "enum": [
          "5m",
          "15m",
          "1h",
          "6h",
          "12h",
          "1d"
        ],
        "title": "RestInterval",
        "type": "string"
      },
      "RestSource": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "rest"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host or IP address to connect to.",
            "maxLength": 200
          },
          "scheme": {
            "title": "Scheme",
            "type": "string",
            "description": "Type of connection to establish",
            "enum": [
              "http",
              "https"
            ]
          },
          "port": {
            "type": "integer",
            "title": "Port",
            "description": "Port on server to connect to. Uses default ports based on the scheme if omitted.",
            "minimum": 1,
            "maximum": 65535
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          },
          "authentication": {
            "discriminator": {
              "mapping": {
                "basic": "#/components/schemas/BasicAuthentication",
                "header": "#/components/schemas/HeaderValueAuthentication",
                "query": "#/components/schemas/QueryParamAuthentication",
                "clientCredentials": "#/components/schemas/ClientCredentialsAuthentication"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/BasicAuthentication"
              },
              {
                "$ref": "#/components/schemas/HeaderValueAuthentication"
              },
              {
                "$ref": "#/components/schemas/QueryParamAuthentication"
              },
              {
                "$ref": "#/components/schemas/ClientCredentialsAuthentication"
              }
            ],
            "title": "Authentication",
            "description": "Authentication details for source"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "type",
          "externalId",
          "host",
          "createdTime",
          "lastUpdatedTime",
          "scheme"
        ],
        "title": "RestSource",
        "type": "object"
      },
      "CreateBasicAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "basic"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "username": {
            "title": "User name",
            "description": "User name to use for basic authentication",
            "type": "string"
          },
          "password": {
            "title": "Password",
            "description": "Password to use for basic authentication",
            "type": "string"
          }
        },
        "required": [
          "username",
          "password",
          "type"
        ],
        "title": "CreateBasicAuthentication",
        "type": "object"
      },
      "CreateHeaderValueAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "header"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "key": {
            "title": "Header key",
            "description": "Key for the header to place the authentication token in",
            "type": "string"
          },
          "value": {
            "title": "Value",
            "description": "Value of the authentication token",
            "type": "string"
          }
        },
        "required": [
          "key",
          "value",
          "type"
        ],
        "title": "CreateHeaderValueAuthentication",
        "type": "object"
      },
      "CreateQueryParamAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "query"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "key": {
            "title": "Query parameter key",
            "description": "Key for the query parameter to place the authentication token in",
            "type": "string"
          },
          "value": {
            "title": "Value",
            "description": "Value of the authentication token",
            "type": "string"
          }
        },
        "required": [
          "key",
          "value",
          "type"
        ],
        "title": "CreateQueryParamAuthentication",
        "type": "object"
      },
      "CreateClientCredentialsAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "clientCredentials"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "clientId": {
            "title": "Client ID",
            "description": "Client ID for for the service principal used by the extractor",
            "type": "string"
          },
          "clientSecret": {
            "title": "Client secret",
            "description": "Client secret for for the service principal used by the extractor",
            "type": "string"
          },
          "tokenUrl": {
            "title": "Token URL",
            "description": "URL to fetch authentication tokens from",
            "type": "string"
          },
          "scopes": {
            "title": "Scopes",
            "description": "A space separated list of scopes",
            "type": "string"
          },
          "defaultExpiresIn": {
            "title": "Default expires in",
            "description": "Default value for the expires_in OAuth 2.0 parameter. If the identity provider does not return expires_in in token requests, this parameter must be set or the request will fail.",
            "type": "string"
          }
        },
        "required": [
          "clientId",
          "clientSecret",
          "tokenUrl",
          "scopes",
          "type"
        ],
        "title": "CreateClientCredentialsAuthentication",
        "type": "object"
      },
      "CreateScramSha256": {
        "additionalProperties": false,
        "type": "object",
        "title": "CreateScramSha256",
        "properties": {
          "type": {
            "enum": [
              "scramSha256"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type"
          },
          "username": {
            "type": "string",
            "description": "Username for authentication",
            "title": "Username",
            "maxLength": 200
          },
          "password": {
            "type": "string",
            "title": "Password",
            "description": "Password for authentication",
            "maxLength": 200
          }
        },
        "required": [
          "type",
          "username",
          "password"
        ]
      },
      "ScramSha256": {
        "additionalProperties": false,
        "type": "object",
        "title": "ScramSha256",
        "properties": {
          "type": {
            "enum": [
              "scramSha256"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type",
            "maxLength": 200
          },
          "username": {
            "type": "string",
            "description": "Username for authentication",
            "title": "Username",
            "maxLength": 200
          }
        },
        "required": [
          "type",
          "username"
        ]
      },
      "CreateScramSha512": {
        "additionalProperties": false,
        "type": "object",
        "title": "CreateScramSha512",
        "properties": {
          "type": {
            "enum": [
              "scramSha512"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type"
          },
          "username": {
            "type": "string",
            "description": "Username for authentication",
            "title": "Username",
            "maxLength": 200
          },
          "password": {
            "type": "string",
            "title": "Password",
            "description": "Password for authentication",
            "maxLength": 200
          }
        },
        "required": [
          "type",
          "username",
          "password"
        ]
      },
      "ScramSha512": {
        "additionalProperties": false,
        "type": "object",
        "title": "ScramSha512",
        "properties": {
          "type": {
            "enum": [
              "scramSha512"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type",
            "maxLength": 200
          },
          "username": {
            "type": "string",
            "description": "Username for authentication",
            "title": "Username",
            "maxLength": 200
          }
        },
        "required": [
          "type",
          "username"
        ]
      },
      "BasicAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "basic"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "username": {
            "title": "User name",
            "description": "User name to use for basic authentication",
            "type": "string"
          }
        },
        "required": [
          "type",
          "username"
        ],
        "title": "BasicAuthentication",
        "type": "object"
      },
      "HeaderValueAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "header"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "key": {
            "title": "Header key",
            "description": "Key for the header to place the authentication token in",
            "type": "string"
          }
        },
        "required": [
          "type",
          "key"
        ],
        "title": "HeaderValueAuthentication",
        "type": "object"
      },
      "QueryParamAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "query"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "key": {
            "title": "Query parameter key",
            "description": "Key for the query parameter to place the authentication token in",
            "type": "string"
          }
        },
        "required": [
          "type",
          "key"
        ],
        "title": "QueryParamAuthentication",
        "type": "object"
      },
      "ClientCredentialsAuthentication": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "clientCredentials"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type."
          },
          "clientId": {
            "title": "Client ID",
            "description": "Client ID for for the service principal used by the extractor",
            "type": "string"
          },
          "tokenUrl": {
            "title": "Token URL",
            "description": "URL to fetch authentication tokens from",
            "type": "string"
          },
          "scopes": {
            "title": "Scopes",
            "description": "A space separated list of scopes",
            "type": "string"
          },
          "defaultExpiresIn": {
            "title": "Default expires in",
            "description": "Default value for the expires_in OAuth 2.0 parameter. If the identity provider does not return expires_in in token requests, this parameter must be set or the request will fail.",
            "type": "string"
          }
        },
        "required": [
          "type",
          "clientId",
          "tokenUrl",
          "scopes"
        ],
        "title": "ClientCredentialsAuthentication",
        "type": "object"
      },
      "RockwellFormat": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "rockwell"
            ],
            "title": "Type",
            "type": "string",
            "description": "Format type."
          },
          "encoding": {
            "$ref": "#/components/schemas/EncodingType"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType"
          },
          "prefix": {
            "$ref": "#/components/schemas/PrefixConfig"
          },
          "dataModels": {
            "$ref": "#/components/schemas/DataModels"
          }
        },
        "required": [
          "type"
        ],
        "title": "RockwellFormat",
        "description": "Transform data on the Rockwell FactoryTalk format into CDF timeseries",
        "type": "object"
      },
      "Mapping": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "mapping": {
            "$ref": "#/components/schemas/CustomMapping"
          },
          "input": {
            "$ref": "#/components/schemas/InputConfig"
          },
          "published": {
            "title": "Published",
            "type": "boolean",
            "description": "Whether this mapping is published and should be available to be used in jobs."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "externalId",
          "mapping",
          "published",
          "lastUpdatedTime",
          "createdTime",
          "input"
        ],
        "title": "Mapping",
        "type": "object"
      },
      "MappingUpdateItem": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateMapping"
          }
        },
        "required": [
          "externalId",
          "update"
        ],
        "title": "MappingUpdateItem",
        "type": "object"
      },
      "UpdateDestination": {
        "additionalProperties": false,
        "properties": {
          "credentials": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              },
              {
                "$ref": "#/components/schemas/UpdateItem_SessionCredentials_"
              }
            ],
            "title": "Credentials",
            "description": "Set a new session, or remove the value."
          },
          "targetDataSetId": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              },
              {
                "$ref": "#/components/schemas/UpdateItem_DataSetId_"
              }
            ],
            "title": "Dataset Id",
            "description": "Set a new value for the dataset ID, or remove the value."
          }
        },
        "title": "UpdateDestination",
        "type": "object"
      },
      "UpdateEventHubSource": {
        "additionalProperties": false,
        "properties": {
          "host": {
            "$ref": "#/components/schemas/UpdateItem_Host_"
          },
          "eventHubName": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "string",
                "maxLength": 200
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Set a new value for the event hub name."
          },
          "keyName": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "string",
                "maxLength": 200
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Set a new value for the key name."
          },
          "keyValue": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "string",
                "maxLength": 200
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Set a new value for the key value."
          },
          "consumerGroup": {
            "anyOf": [
              {
                "type": "object",
                "required": [
                  "set"
                ],
                "properties": {
                  "set": {
                    "title": "Set",
                    "type": "string",
                    "maxLength": 200
                  }
                }
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "title": "ConsumerGroup",
            "description": "Set a new value for the consumer group, or remove the value."
          }
        },
        "title": "UpdateEventHubSource",
        "type": "object"
      },
      "UpdateEventHubSourceItem": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "eventhub"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateEventHubSource"
          }
        },
        "required": [
          "type",
          "externalId",
          "update"
        ],
        "title": "UpdateEventHubSourceItem",
        "type": "object"
      },
      "UpdateFormat": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "discriminator": {
              "mapping": {
                "cognite": "#/components/schemas/CogniteFormat",
                "custom": "#/components/schemas/WriteCustomFormat",
                "rockwell": "#/components/schemas/RockwellFormat",
                "value": "#/components/schemas/ValueFormat"
              },
              "propertyName": "type"
            },
            "oneOf": [
              {
                "$ref": "#/components/schemas/RockwellFormat"
              },
              {
                "$ref": "#/components/schemas/CogniteFormat"
              },
              {
                "$ref": "#/components/schemas/WriteCustomFormat"
              },
              {
                "$ref": "#/components/schemas/ValueFormat"
              }
            ],
            "title": "Set",
            "description": "The format of the messages from the source. This is used to convert messages coming from the source system to a format that can be inserted into CDF.",
            "type": "object"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateFormat",
        "type": "object",
        "description": "Set a new format."
      },
      "UpdateItem_AuthCertificate_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/AuthCertificate"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_AuthCertificate",
        "type": "object",
        "description": "Set a new authentication certificate."
      },
      "UpdateItem_CACertificate_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CACertificate"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_CACertificate",
        "type": "object",
        "description": "Set a new certificate authority."
      },
      "UpdateItem_JobTargetStatus_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/JobTargetStatus"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_JobTargetStatus",
        "type": "object",
        "description": "Set a new job target status."
      },
      "UpdateItem_CustomMapping_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/CustomMapping"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_CustomMapping",
        "type": "object",
        "description": "Set a new mapping value."
      },
      "UpdateItem_SessionCredentials_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/SessionCredentials"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_SessionCredentials",
        "type": "object",
        "description": "Set a new set of session credentials for writing to CDF."
      },
      "UpdateItem_Host_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "title": "Set",
            "type": "string",
            "maxLength": 200
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_Host",
        "type": "object",
        "description": "Set a new host or IP address."
      },
      "UpdateItem_DestinationId_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "title": "Set",
            "type": "string",
            "maxLength": 255
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_DestinationId",
        "type": "object",
        "description": "Set a new destination this job should write to."
      },
      "UpdateItem_Port_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "title": "Set",
            "type": "integer",
            "minimum": 1,
            "maximum": 65535
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_Port",
        "type": "object",
        "description": "Set a new port this source should connect to."
      },
      "UpdateItem_RestScheme_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "title": "Set",
            "type": "string",
            "enum": [
              "http",
              "https"
            ]
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_RestScheme",
        "type": "object",
        "description": "Set a new scheme for this source to use"
      },
      "UpdateItem_DataSetId_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "title": "Set",
            "type": "integer",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_Port",
        "type": "object",
        "description": "Set a new dataset ID."
      },
      "UpdateItem_SourceId_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "title": "Set",
            "type": "string",
            "maxLength": 255
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_SourceId",
        "type": "object",
        "description": "Set a new source this job should write to."
      },
      "UpdateItem_MqttAuthentication_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/MqttAuthenticationWrite"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_MqttAuthentication",
        "type": "object",
        "description": "Set new credentials for authenticating with the broker."
      },
      "UpdateItem_KafkaAuthentication_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/KafkaAuthenticationWrite"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_KafkaAuthentication",
        "type": "object",
        "description": "Set new credentials for authenticating with the broker."
      },
      "JobUpdateItem": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "title": "External ID",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/JobUpdate"
          }
        },
        "required": [
          "externalId",
          "update"
        ],
        "title": "UpdateJob",
        "type": "object"
      },
      "UpdateMqttV3Source": {
        "additionalProperties": false,
        "properties": {
          "host": {
            "$ref": "#/components/schemas/UpdateItem_Host_"
          },
          "port": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_Port_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "title": "Port",
            "description": "Set or remove the port on the MQTT broker."
          },
          "authentication": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_MqttAuthentication_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "title": "Authentication",
            "description": "Set or remove the credentials used for authentication."
          },
          "useTls": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "boolean"
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Enable or disable TLS to the MQTT broker."
          },
          "caCertificate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_CACertificate_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ]
          },
          "authCertificate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_AuthCertificate_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ]
          }
        },
        "title": "UpdateMqttV3Source",
        "type": "object"
      },
      "UpdateMqttV3SourceItem": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "mqtt3"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateMqttV3Source"
          }
        },
        "required": [
          "type",
          "externalId",
          "update"
        ],
        "title": "UpdateMqttV3SourceItem",
        "type": "object"
      },
      "UpdateMqttV5Source": {
        "additionalProperties": false,
        "properties": {
          "host": {
            "$ref": "#/components/schemas/UpdateItem_Host_"
          },
          "port": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_Port_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "title": "Port",
            "description": "Set or remove the port on the MQTT broker."
          },
          "authentication": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_MqttAuthentication_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "title": "Authentication",
            "description": "Set or remove the credentials used for authentication."
          },
          "useTls": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "boolean"
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Enable or disable TLS to the MQTT broker."
          },
          "caCertificate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_CACertificate_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ]
          },
          "authCertificate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_AuthCertificate_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ]
          }
        },
        "title": "UpdateMqttV5Source",
        "type": "object"
      },
      "UpdateMqttV5SourceItem": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "mqtt5"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateMqttV5Source"
          }
        },
        "required": [
          "type",
          "externalId",
          "update"
        ],
        "title": "UpdateMqttV5SourceItem",
        "type": "object"
      },
      "UpdateRestSource": {
        "additionalProperties": false,
        "properties": {
          "host": {
            "$ref": "#/components/schemas/UpdateItem_Host_"
          },
          "scheme": {
            "$ref": "#/components/schemas/UpdateItem_RestScheme_"
          },
          "port": {
            "$ref": "#/components/schemas/UpdateItem_Port_"
          }
        },
        "title": "UpdateRestSource",
        "type": "object"
      },
      "UpdateRestSourceItem": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "rest"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateRestSource"
          }
        },
        "required": [
          "type",
          "externalId",
          "update"
        ],
        "title": "UpdateRestSourceItem",
        "type": "object"
      },
      "UpdateSetNull": {
        "additionalProperties": false,
        "properties": {
          "setNull": {
            "title": "SetNull",
            "type": "boolean",
            "description": "Clear this value"
          }
        },
        "required": [
          "setNull"
        ],
        "title": "UpdateSetNull",
        "type": "object"
      },
      "UpdateMapping": {
        "additionalProperties": false,
        "properties": {
          "mapping": {
            "$ref": "#/components/schemas/UpdateItem_CustomMapping_"
          },
          "input": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_InputConfig_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "description": "Set or remove mapping input. When removed this defaults to json."
          },
          "published": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "boolean"
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Publish or unpublish the mapping."
          }
        },
        "title": "UpdateMapping",
        "type": "object"
      },
      "ValueFormat": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "value"
            ],
            "title": "Type",
            "type": "string",
            "description": "Format type."
          },
          "encoding": {
            "$ref": "#/components/schemas/EncodingType"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType"
          },
          "prefix": {
            "$ref": "#/components/schemas/PrefixConfig"
          },
          "dataModels": {
            "$ref": "#/components/schemas/DataModels"
          }
        },
        "required": [
          "type"
        ],
        "title": "ValueFormat",
        "type": "object",
        "description": "Assume the source data is on the form `some string` or `123.456`, and convert these into CDF datapoints, using prefix config to determine the timeseries external ID, and current time as timestamp.\nIf no prefix config is set, use the topic name as timeseries ID."
      },
      "WriteCustomFormat": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "custom"
            ],
            "title": "Type",
            "type": "string",
            "description": "Format type."
          },
          "encoding": {
            "$ref": "#/components/schemas/EncodingType"
          },
          "compression": {
            "$ref": "#/components/schemas/CompressionType"
          },
          "mappingId": {
            "title": "Mapping ID",
            "type": "string",
            "description": "ID of the mapping this format should be tied to.",
            "maxLength": 255
          }
        },
        "required": [
          "type",
          "mappingId"
        ],
        "title": "WriteCustomFormat",
        "type": "object",
        "description": "Format the source data using a custom mapping."
      },
      "ValidationErrorContent": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 422
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Extra inputs are not permitted: type"
          }
        }
      },
      "CustomMapping": {
        "type": "object",
        "properties": {
          "expression": {
            "type": "string",
            "description": "Custom transform expression written in the Cognite transformation language.",
            "maxLength": 2000
          }
        },
        "required": [
          "expression"
        ]
      },
      "KafkaBroker": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "host": {
            "title": "Host",
            "type": "string",
            "description": "Host name or IP address of the bootstrap broker."
          },
          "port": {
            "title": "Port",
            "type": "integer",
            "description": "Port on the bootstrap broker to connect to.",
            "minimum": 1,
            "maximum": 65535
          }
        },
        "required": [
          "host",
          "port"
        ]
      },
      "KafkaBrokerList": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/KafkaBroker"
        },
        "description": "List of redundant kafka brokers to connect to.",
        "minItems": 1,
        "maxItems": 8
      },
      "KafkaSource": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "kafka"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "bootstrapBrokers": {
            "$ref": "#/components/schemas/KafkaBrokerList"
          },
          "authentication": {
            "$ref": "#/components/schemas/KafkaAuthentication"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          },
          "authCertificate": {
            "$ref": "#/components/schemas/CertificateDetails"
          },
          "useTls": {
            "type": "boolean",
            "title": "UseTLS",
            "description": "Indicates whether TLS will be used for connection to broker."
          }
        },
        "required": [
          "bootstrapBrokers",
          "externalId",
          "type",
          "createdTime",
          "lastUpdatedTime"
        ]
      },
      "CreateKafkaSource": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "kafka"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "bootstrapBrokers": {
            "$ref": "#/components/schemas/KafkaBrokerList"
          },
          "authentication": {
            "$ref": "#/components/schemas/KafkaAuthenticationWrite"
          },
          "useTls": {
            "type": "boolean",
            "title": "UseTLS",
            "description": "If true, use TLS when connecting to the broker"
          },
          "caCertificate": {
            "$ref": "#/components/schemas/CACertificate"
          },
          "authCertificate": {
            "$ref": "#/components/schemas/AuthCertificate"
          }
        },
        "required": [
          "bootstrapBrokers",
          "externalId",
          "type"
        ]
      },
      "UpdateItem_KafkaBrokers_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/KafkaBrokerList"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_KafkaBrokers",
        "type": "object",
        "description": "Set a new list of redundant kafka brokers."
      },
      "UpdateItem_Partitions_": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "type": "integer",
            "title": "Partitions",
            "description": "The number of partitions in the broker.",
            "minimum": 1,
            "maximum": 10,
            "default": 1
          }
        },
        "description": "Set a new number of kafka partitions.",
        "type": "object",
        "title": "UpdateItem_Partitions",
        "required": [
          "set"
        ]
      },
      "UpdateKafkaSource": {
        "additionalProperties": false,
        "properties": {
          "bootstrapBrokers": {
            "$ref": "#/components/schemas/UpdateItem_KafkaBrokers_"
          },
          "authentication": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_KafkaAuthentication_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ],
            "title": "Authentication",
            "description": "Set or remove the credentials used for authentication."
          },
          "useTls": {
            "additionalProperties": false,
            "properties": {
              "set": {
                "title": "Set",
                "type": "boolean"
              }
            },
            "required": [
              "set"
            ],
            "type": "object",
            "description": "Enable or disable TLS to the Kafka broker."
          },
          "caCertificate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_CACertificate_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ]
          },
          "authCertificate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateItem_AuthCertificate_"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              }
            ]
          }
        }
      },
      "UpdateKafkaSourceItem": {
        "additionalProperties": false,
        "properties": {
          "type": {
            "enum": [
              "kafka"
            ],
            "title": "Type",
            "type": "string",
            "description": "Source type."
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateKafkaSource"
          }
        },
        "required": [
          "type",
          "externalId",
          "update"
        ],
        "title": "UpdateKafkaSourceItem",
        "type": "object"
      },
      "SimpleBasicAuthentication": {
        "additionalProperties": false,
        "type": "object",
        "title": "BasicAuthentication",
        "description": "Username and password authentication.",
        "properties": {
          "type": {
            "enum": [
              "basic"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type"
          },
          "username": {
            "type": "string",
            "title": "Username",
            "description": "Username used for authenticating with the broker.",
            "maxLength": 200
          }
        },
        "required": [
          "username",
          "type"
        ]
      },
      "SimpleBasicAuthenticationWrite": {
        "additionalProperties": false,
        "type": "object",
        "title": "BasicAuthenticationWrite",
        "description": "Username and password authentication.",
        "properties": {
          "type": {
            "enum": [
              "basic"
            ],
            "title": "Type",
            "type": "string",
            "description": "Authentication type"
          },
          "username": {
            "type": "string",
            "title": "Username",
            "description": "Username used for basic authentication.",
            "maxLength": 200
          },
          "password": {
            "type": "string",
            "title": "Password",
            "description": "Password used for basic authentication.",
            "maxLength": 200
          }
        },
        "required": [
          "username",
          "type"
        ]
      },
      "KafkaAuthentication": {
        "type": "object",
        "discriminator": {
          "mapping": {
            "basic": "#/components/schemas/SimpleBasicAuthentication",
            "clientCredentials": "#/components/schemas/ClientCredentialsAuthentication",
            "scramSha256": "#/components/schemas/ScramSha256",
            "scramSha512": "#/components/schemas/ScramSha512"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/SimpleBasicAuthentication"
          },
          {
            "$ref": "#/components/schemas/ClientCredentialsAuthentication"
          },
          {
            "$ref": "#/components/schemas/ScramSha256"
          },
          {
            "$ref": "#/components/schemas/ScramSha512"
          }
        ],
        "description": "Method used for authenticating with the kafka brokers.\nThis may be used together with auth certificate."
      },
      "KafkaAuthenticationWrite": {
        "type": "object",
        "discriminator": {
          "mapping": {
            "basic": "#/components/schemas/SimpleBasicAuthenticationWrite",
            "clientCredentials": "#/components/schemas/CreateClientCredentialsAuthentication",
            "scramSha256": "#/components/schemas/CreateScramSha256",
            "scramSha512": "#/components/schemas/CreateScramSha512"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/SimpleBasicAuthenticationWrite"
          },
          {
            "$ref": "#/components/schemas/CreateClientCredentialsAuthentication"
          },
          {
            "$ref": "#/components/schemas/CreateScramSha256"
          },
          {
            "$ref": "#/components/schemas/CreateScramSha512"
          }
        ],
        "description": "Method used for authenticating with the kafka brokers.\nThis may be used together with auth certificate."
      },
      "MqttAuthentication": {
        "type": "object",
        "discriminator": {
          "mapping": {
            "basic": "#/components/schemas/SimpleBasicAuthentication"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/SimpleBasicAuthentication"
          }
        ],
        "description": "Method used for authenticating with the mqtt broker.\nThis may be used together with auth certificate."
      },
      "MqttAuthenticationWrite": {
        "type": "object",
        "discriminator": {
          "mapping": {
            "basic": "#/components/schemas/SimpleBasicAuthenticationWrite"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/SimpleBasicAuthenticationWrite"
          }
        ],
        "description": "Method used for authenticating with the mqtt broker.\nThis may be used together with auth certificate."
      },
      "CreatePreview": {
        "type": "object",
        "title": "CreatePreview",
        "description": "Create object for a preview job.",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "sourceId": {
            "title": "Source ID",
            "description": "ID of the source this preview job should read from.",
            "type": "string",
            "maxLength": 255
          },
          "config": {
            "$ref": "#/components/schemas/JobConfig"
          },
          "format": {
            "type": "object",
            "title": "Format",
            "description": "Input format parameters.",
            "properties": {
              "encoding": {
                "$ref": "#/components/schemas/EncodingType"
              },
              "compression": {
                "$ref": "#/components/schemas/CompressionType"
              }
            }
          },
          "input": {
            "$ref": "#/components/schemas/CreateInputConfig"
          }
        },
        "required": [
          "externalId",
          "sourceId",
          "config"
        ]
      },
      "MinimalPreview": {
        "type": "object",
        "title": "MinimalPreview",
        "description": "Preview create response",
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "sourceId": {
            "title": "Source ID",
            "description": "ID of the source this preview job should read from.",
            "type": "string",
            "maxLength": 255
          },
          "config": {
            "$ref": "#/components/schemas/JobConfig"
          },
          "format": {
            "type": "object",
            "title": "Format",
            "description": "Input format parameters.",
            "properties": {
              "encoding": {
                "$ref": "#/components/schemas/EncodingType"
              },
              "compression": {
                "$ref": "#/components/schemas/CompressionType"
              }
            }
          },
          "input": {
            "$ref": "#/components/schemas/InputConfig"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "externalId",
          "sourceId",
          "config",
          "createdTime",
          "input"
        ]
      },
      "PreviewResultError": {
        "type": "object",
        "title": "PreviewResultError",
        "description": "Result of a failed preview.",
        "properties": {
          "type": {
            "enum": [
              "error"
            ],
            "title": "Type",
            "type": "string",
            "description": "Result type"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "kind": {
            "enum": [
              "startup_error",
              "connection_error",
              "transform_error"
            ],
            "type": "string",
            "title": "Kind",
            "description": "The type of error that occured. If the type is transform_error, raw data is usually available in the /download endpoint."
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Error message."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "type",
          "externalId",
          "createdTime",
          "kind"
        ]
      },
      "PreviewResultPayload": {
        "type": "object",
        "title": "PreviewResultPayload",
        "description": "Result of a successful preview.",
        "properties": {
          "type": {
            "enum": [
              "preview"
            ],
            "title": "Type",
            "type": "string",
            "description": "Result type"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "json": {
            "title": "Json",
            "description": "Arbitrary json that is the data that would be passed to the mapping. Note that if you have specified a custom `input` type, or custom `format` parameters, this is the data _after_ it has passed through those."
          },
          "context": {
            "title": "Context",
            "description": "Message context that would be passed to the mapping.",
            "type": "object"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "type",
          "externalId",
          "createdTime"
        ]
      },
      "PreviewResultPending": {
        "type": "object",
        "title": "PreviewResultPayload",
        "description": "A result indicating the preview is still running.",
        "properties": {
          "type": {
            "enum": [
              "pending"
            ],
            "title": "Type",
            "type": "string",
            "description": "Result type"
          },
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "required": [
          "type",
          "externalId"
        ]
      },
      "PreviewResult": {
        "type": "object",
        "title": "PreviewResult",
        "description": "Result of a preview job.",
        "discriminator": {
          "mapping": {
            "error": "#/components/schemas/PreviewResultError",
            "preview": "#/components/schemas/PreviewResultPayload",
            "pending": "#/components/schemas/PreviewResultPending"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/PreviewResultError"
          },
          {
            "$ref": "#/components/schemas/PreviewResultPayload"
          },
          {
            "$ref": "#/components/schemas/PreviewResultPending"
          }
        ]
      },
      "FilterUsers": {
        "type": "object",
        "additionalProperties": false,
        "title": "Filter Users",
        "properties": {
          "limit": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10,
            "format": "int32"
          },
          "cursor": {
            "type": "string",
            "title": "Cursor",
            "description": "Cursor for pagination"
          }
        }
      },
      "Username": {
        "type": "string",
        "title": "Username",
        "description": "Username to authenticate the user on the DB."
      },
      "Tablename": {
        "type": "string",
        "title": "Tablename",
        "maxLength": 60,
        "minLength": 1
      },
      "UsernameWrapper": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "username"
        ],
        "properties": {
          "username": {
            "$ref": "#/components/schemas/Username"
          }
        }
      },
      "TablenameWrapper": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "tablename"
        ],
        "properties": {
          "tablename": {
            "$ref": "#/components/schemas/Tablename"
          }
        }
      },
      "FdwUser": {
        "type": "object",
        "required": [
          "username",
          "createdTime"
        ],
        "description": "A user",
        "properties": {
          "username": {
            "$ref": "#/components/schemas/Username"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "sessionId": {
            "type": "integer",
            "title": "Session ID",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "ID of the session tied to this user."
          }
        }
      },
      "TableType": {
        "enum": [
          "raw_rows",
          "built_in",
          "nodes",
          "edges"
        ],
        "type": "string",
        "title": "TableType",
        "description": "The type of table (usually built_in) but could be any of raw_rows, nodes or edges when custom."
      },
      "RawTableOptions": {
        "type": "object",
        "additionalProperties": false,
        "description": "Raw rows options",
        "required": [
          "database",
          "table"
        ],
        "properties": {
          "database": {
            "type": "string"
          },
          "table": {
            "type": "string"
          },
          "primaryKey": {
            "type": "string"
          }
        }
      },
      "FdmTableOptions": {
        "type": "object",
        "additionalProperties": false,
        "description": "Fdm table options",
        "required": [
          "space",
          "externalId"
        ],
        "properties": {
          "space": {
            "type": "string"
          },
          "externalId": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        }
      },
      "Column_": {
        "type": "object",
        "description": "Foreign table columns.",
        "additionalProperties": {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "TEXT",
                "VARCHAR",
                "BOOL",
                "BIGINT",
                "DOUBLE PRECISION",
                "REAL",
                "TIMESTAMPTZ",
                "JSON",
                "TEXT[]",
                "VARCHAR[]",
                "BOOL[]",
                "BIGINT[]",
                "DOUBLE PRECISION[]",
                "REAL[]",
                "JSON[]",
                "BYTEA"
              ]
            }
          }
        }
      },
      "TableOptions": {
        "description": "Table options",
        "title": "Table Options",
        "oneOf": [
          {
            "$ref": "#/components/schemas/FdmTableOptions"
          },
          {
            "$ref": "#/components/schemas/RawTableOptions"
          }
        ]
      },
      "Table": {
        "type": "object",
        "additionalProperties": false,
        "title": "(Custom) Table",
        "description": "Foreign tables",
        "required": [
          "type",
          "columns",
          "tablename"
        ],
        "properties": {
          "columns": {
            "$ref": "#/components/schemas/Column_"
          },
          "options": {
            "$ref": "#/components/schemas/TableOptions"
          },
          "type": {
            "$ref": "#/components/schemas/TableType"
          },
          "tablename": {
            "$ref": "#/components/schemas/Tablename"
          }
        }
      },
      "TableCreated": {
        "type": "object",
        "additionalProperties": false,
        "title": "Table Created Response",
        "description": "Foreign tables",
        "required": [
          "type",
          "columns",
          "tablename",
          "createdTime"
        ],
        "properties": {
          "columns": {
            "$ref": "#/components/schemas/Column_"
          },
          "options": {
            "$ref": "#/components/schemas/TableOptions"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "type": {
            "type": "string",
            "title": "Table Type",
            "enum": [
              "raw_rows",
              "view"
            ]
          },
          "tablename": {
            "$ref": "#/components/schemas/Tablename"
          }
        }
      },
      "UserCreated": {
        "type": "object",
        "required": [
          "username",
          "password",
          "createdTime",
          "host"
        ],
        "description": "A user",
        "properties": {
          "host": {
            "type": "string",
            "title": "Host",
            "description": "The connection host for the postgres instance.",
            "example": "fdw.<CLUSTER>.cogniteapp.com"
          },
          "username": {
            "$ref": "#/components/schemas/Username"
          },
          "password": {
            "type": "string",
            "title": "Password",
            "description": "Password to authenticate the user on the DB."
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "sessionId": {
            "type": "integer",
            "title": "Session ID",
            "minimum": 1,
            "maximum": 9007199254740991,
            "format": "int64",
            "description": "ID of the session tied to this user."
          }
        }
      },
      "UpdateItem_SessionCredentials": {
        "additionalProperties": false,
        "properties": {
          "set": {
            "$ref": "#/components/schemas/SessionCredentials"
          }
        },
        "required": [
          "set"
        ],
        "title": "UpdateItem_SessionCredentials",
        "type": "object",
        "description": "Set a new set of session credentials for writing to CDF."
      },
      "CreateUser": {
        "type": "object",
        "title": "Create User",
        "additionalProperties": false,
        "required": [
          "credentials"
        ],
        "properties": {
          "credentials": {
            "$ref": "#/components/schemas/SessionCredentials"
          }
        }
      },
      "UpdateUser": {
        "additionalProperties": false,
        "type": "object",
        "properties": {
          "credentials": {
            "$ref": "#/components/schemas/UpdateItem_SessionCredentials"
          }
        }
      },
      "UserUpdateItem": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "username",
          "update"
        ],
        "properties": {
          "username": {
            "$ref": "#/components/schemas/Username"
          },
          "update": {
            "$ref": "#/components/schemas/UpdateUser"
          }
        }
      },
      "CreateTable_": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "type",
          "tablename"
        ],
        "properties": {
          "type": {
            "enum": [
              "raw_rows",
              "view"
            ],
            "title": "Type",
            "type": "string"
          },
          "tablename": {
            "type": "string",
            "title": "Tablename",
            "maxLength": 60,
            "minLength": 1,
            "description": "Name of the foreign table.\\\n__CANNOT__ be any of the the built-in table names found [here](https://docs.cognite.com/cdf/integration/guides/interfaces/ingest_into_raw#create-a-table)\n"
          }
        }
      },
      "CreateRawTable": {
        "type": "object",
        "title": "Create Raw Table",
        "additionalProperties": false,
        "required": [
          "type",
          "options",
          "columns"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateTable_"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "enum": [
                  "raw_rows"
                ],
                "title": "Type",
                "type": "string"
              },
              "options": {
                "$ref": "#/components/schemas/RawTableOptions"
              },
              "columns": {
                "$ref": "#/components/schemas/Column_"
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "CreateFdmTable": {
        "type": "object",
        "title": "Create Fdm table",
        "additionalProperties": false,
        "required": [
          "type",
          "tablename",
          "options"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateTable_"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "enum": [
                  "view"
                ],
                "title": "Type",
                "type": "string"
              },
              "options": {
                "$ref": "#/components/schemas/FdmTableOptions"
              }
            }
          }
        ],
        "discriminator": {
          "propertyName": "type"
        }
      },
      "CreateTable": {
        "type": "object",
        "title": "Create Table",
        "additionalProperties": false,
        "discriminator": {
          "mapping": {
            "raw_rows": "#/components/schemas/CreateRawTable",
            "view": "#/components/schemas/CreateFdmTable"
          },
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/CreateRawTable"
          },
          {
            "$ref": "#/components/schemas/CreateFdmTable"
          }
        ]
      },
      "Items_CreateTable_": {
        "additionalProperties": false,
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateTable"
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 10
          }
        }
      },
      "ItemsWithoutCursor_TableCreated_": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/TableCreated"
            },
            "title": "Items",
            "type": "array"
          }
        },
        "required": [
          "items"
        ]
      },
      "ItemsWithoutCursor_Table_": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Table"
            },
            "title": "Items",
            "type": "array"
          }
        },
        "required": [
          "items"
        ]
      },
      "ItemsWithCursor_Table_": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Table"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ]
      },
      "ItemsWithIgnoreUnknown_Tablename_": {
        "type": "object",
        "additionalProperties": false,
        "title": "List of postgres table names",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/TablenameWrapper"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 10,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "title": "IgnoreUnknown",
            "description": "Ignore table names not found"
          }
        }
      },
      "ItemsWithCursor_User_": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/FdwUser"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ]
      },
      "ItemsWithoutCursor_User_": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/FdwUser"
            },
            "title": "Items",
            "type": "array",
            "minItems": 0
          }
        },
        "required": [
          "items"
        ]
      },
      "ItemsWithCursor_UserCreated_": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/UserCreated"
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 1
          }
        },
        "required": [
          "items"
        ]
      },
      "Items_CreateUser_": {
        "type": "object",
        "additionalProperties": false,
        "title": "CreateUser list",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateUser"
            },
            "title": "Items",
            "type": "array",
            "minItems": 1,
            "maxItems": 1
          }
        }
      },
      "ItemsWithIgnoreUnknown_Username_": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/UsernameWrapper"
            },
            "type": "array",
            "maxItems": 10,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore usernames that are not found"
          }
        }
      },
      "ItemsWithIgnoreUnknown_Username_1_": {
        "type": "object",
        "additionalProperties": false,
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/UsernameWrapper"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "description": "Ignore usernames that are not found"
          }
        }
      },
      "Items_UserUpdate_": {
        "additionalProperties": false,
        "title": "Items[UserUpdate]",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/UserUpdateItem"
            },
            "title": "Items",
            "maxItems": 1,
            "minItems": 1
          }
        }
      },
      "ValidationErrorContent_": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 422
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Extra inputs are not permitted: type"
          }
        }
      },
      "Instance": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "gatewayUrl": {
            "title": "gatewayUrl",
            "type": "string",
            "description": "SAP NetWeaver Gateway URL"
          },
          "client": {
            "title": "client",
            "type": "integer",
            "description": "SAP client number"
          },
          "username": {
            "title": "username",
            "type": "string",
            "description": "SAP username to use when connecting to the SAP NetWeaver Gateway URL"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "externalId",
          "gatewayUrl",
          "client",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Instance",
        "type": "object"
      },
      "Endpoint": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "endpointType": {
            "title": "endpointType",
            "type": "string",
            "description": "SAP OData endpoint type",
            "enum": [
              "notification",
              "attachment"
            ]
          },
          "instanceId": {
            "title": "Instance ID",
            "description": "ID of the SAP instance the endpoint should connect to.",
            "type": "string",
            "maxLength": 255
          },
          "mappingId": {
            "title": "SchemaMapping ID",
            "description": "ID of the schema mapping used by this endpoint to transform the writeback request.",
            "type": "string",
            "maxLength": 255
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "externalId",
          "endpointType",
          "instanceId",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Endpoint",
        "type": "object"
      },
      "SchemaMapping": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "expression": {
            "type": "string",
            "description": "Custom transform expression written in the Cognite mapping language.",
            "maxLength": 2000,
            "example": "\n{\n \"SAPFieldA\": substring(input.CDFFieldA,0,40), \n \"SAPFieldB\": input.CDFFieldB, \n}\n"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "externalId",
          "expression",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "SchemaMapping",
        "type": "object"
      },
      "Request": {
        "additionalProperties": false,
        "properties": {
          "endpointId": {
            "title": "Endpoint ID",
            "description": "ID of the SAP endpoint the writeback request should be sent to.",
            "type": "string",
            "maxLength": 255
          },
          "requestId": {
            "title": "Request ID",
            "description": "Unique request ID generated by the CDF writeback API.",
            "type": "string",
            "maxLength": 255
          },
          "request": {
            "$ref": "#/components/schemas/List_RequestItem_"
          },
          "status": {
            "title": "status",
            "type": "string",
            "description": "Status of a writeback request",
            "enum": [
              "pending",
              "in_progress",
              "done",
              "failed"
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "endpointId",
          "requestId",
          "request",
          "status",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Request",
        "type": "object"
      },
      "RequestMinimal": {
        "additionalProperties": false,
        "properties": {
          "requestId": {
            "title": "Request ID",
            "description": "Unique request ID generated by the CDF writeback API.",
            "type": "string",
            "maxLength": 255
          },
          "request": {
            "$ref": "#/components/schemas/List_RequestItemMinimal_"
          },
          "status": {
            "title": "status",
            "type": "string",
            "description": "Status of the writeback request",
            "enum": [
              "pending",
              "in_progress",
              "done",
              "failed"
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "errorMessage": {
            "type": "string",
            "description": "Writeback request error message. This field only contains data when the writeback request status is set to `failed`"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "requestId",
          "request",
          "status",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Request",
        "type": "object"
      },
      "RequestFull": {
        "additionalProperties": false,
        "type": "object",
        "properties": {
          "requestId": {
            "title": "Request ID",
            "description": "Unique request ID generated by the CDF writeback API.",
            "type": "string",
            "maxLength": 255
          },
          "request": {
            "$ref": "#/components/schemas/List_RequestItemFull_"
          },
          "status": {
            "title": "status",
            "type": "string",
            "description": "Writeback request status",
            "enum": [
              "pending",
              "in_progress",
              "done",
              "failed"
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "errorMessage": {
            "title": "errorMessage",
            "type": "string",
            "description": "Writeback request error message. This field only contains data when the request status is set to `failed`"
          }
        },
        "required": [
          "endpointId",
          "requestId",
          "request",
          "status",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Request Full"
      },
      "CreateRequestResponse": {
        "additionalProperties": false,
        "type": "object",
        "properties": {
          "requestId": {
            "title": "Request ID",
            "description": "Unique request ID generated by the CDF writeback API.",
            "type": "string",
            "maxLength": 255
          },
          "request": {
            "$ref": "#/components/schemas/List_CreateRequestItemResponse_"
          },
          "status": {
            "title": "status",
            "type": "string",
            "description": "Writeback request status",
            "enum": [
              "pending",
              "in_progress",
              "done",
              "failed"
            ]
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        },
        "required": [
          "endpointId",
          "requestId",
          "request",
          "status",
          "lastUpdatedTime",
          "createdTime"
        ],
        "title": "Request Full"
      },
      "RequestItem": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "title": "key",
            "description": "External object key related to this request",
            "type": "string",
            "maxLength": 255
          },
          "payload": {
            "title": "payload",
            "description": "Payload to send to the SAP endpoint",
            "type": "object"
          }
        },
        "required": [
          "payload"
        ],
        "title": "RequestItem"
      },
      "CreateRequestItemResponse": {
        "additionalProperties": false,
        "properties": {
          "payload": {
            "title": "payload",
            "description": "Payload to send to the SAP endpoint",
            "type": "object"
          }
        },
        "required": [
          "payload"
        ],
        "title": "Create RequestItem Response"
      },
      "RequestItemFull": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "title": "key",
            "description": "External object key related to this request",
            "type": "string",
            "maxLength": 255
          },
          "payload": {
            "title": "payload",
            "description": "Payload to send to the SAP endpoint",
            "type": "object"
          },
          "sapObjectId": {
            "title": "sapObjectId",
            "description": "Object key of the created records in the SAP destination.",
            "type": "string",
            "maxLength": 255
          }
        },
        "required": [
          "payload"
        ],
        "title": "Instance",
        "type": "object"
      },
      "RequestItemMinimal": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "title": "key",
            "description": "External object key related to this request",
            "type": "string",
            "maxLength": 255
          },
          "sapObjectId": {
            "title": "sapObjectId",
            "description": "Object key of the created records in the SAP destination.",
            "type": "string",
            "maxLength": 255
          }
        },
        "title": "Request Item Minimal",
        "type": "object"
      },
      "List_RequestItem_": {
        "items": {
          "$ref": "#/components/schemas/RequestItem"
        },
        "title": "List RequestItem",
        "type": "array",
        "maxItems": 100,
        "minItems": 0
      },
      "List_CreateRequestItemResponse_": {
        "items": {
          "$ref": "#/components/schemas/CreateRequestItemResponse"
        },
        "title": "List RequestItem",
        "type": "array",
        "maxItems": 100,
        "minItems": 0
      },
      "List_RequestItemMinimal_": {
        "items": {
          "$ref": "#/components/schemas/RequestItemMinimal"
        },
        "title": "List RequestItem Minimal",
        "type": "array",
        "maxItems": 100,
        "minItems": 0
      },
      "List_RequestItemFull_": {
        "additionalProperties": false,
        "items": {
          "$ref": "#/components/schemas/RequestItemFull"
        },
        "title": "List RequestItem Full",
        "type": "array",
        "maxItems": 100,
        "minItems": 0
      },
      "List_CreateRequestItem_": {
        "additionalProperties": false,
        "items": {
          "$ref": "#/components/schemas/CreateRequestItem"
        },
        "title": "List CreateRequestItem",
        "type": "array",
        "maxItems": 100,
        "minItems": 0
      },
      "CreateInstance": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "title": "External ID",
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "gatewayUrl": {
            "title": "gatewayUrl",
            "type": "string",
            "description": "SAP NetWeaver Gateway URL"
          },
          "client": {
            "title": "client",
            "type": "integer",
            "description": "SAP client number"
          },
          "username": {
            "title": "username",
            "type": "string",
            "description": "SAP username to use when connecting to the SAP NetWeaver Gateway URL"
          },
          "password": {
            "title": "password",
            "type": "string",
            "description": "SAP password to use when connecting to the SAP NetWeaver Gateway URL"
          }
        },
        "required": [
          "externalId",
          "gatewayUrl",
          "client",
          "username",
          "password"
        ],
        "title": "CreateInstance",
        "type": "object"
      },
      "CreateEndpoint": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "endpointType": {
            "title": "endpointType",
            "type": "string",
            "description": "SAP OData endpoint",
            "enum": [
              "notification",
              "attachment"
            ]
          },
          "instanceId": {
            "title": "Instance ID",
            "description": "External ID of the SAP instance the endpoint should connect to.",
            "type": "string",
            "maxLength": 255
          },
          "mappingId": {
            "title": "SchemaMapping ID",
            "description": "External ID of the schema mapping this endpoint should use to transform the writeback request.",
            "type": "string",
            "maxLength": 255
          }
        },
        "required": [
          "externalId",
          "endpointType",
          "instanceId"
        ],
        "title": "Instance",
        "type": "object"
      },
      "CreateSchemaMapping": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "expression": {
            "type": "string",
            "description": "Custom transform expression written in the Cognite mapping language.",
            "maxLength": 2000,
            "example": "\n{\n \"SAPFieldA\": substring(input.CDFFieldA,0,40), \n \"SAPFieldB\": input.CDFFieldB, \n}\n"
          }
        },
        "required": [
          "externalId",
          "expression"
        ],
        "title": "Create SchemaMapping",
        "type": "object"
      },
      "CreateRequest": {
        "additionalProperties": false,
        "properties": {
          "endpointId": {
            "title": "Endpoint ID",
            "description": "External ID of the SAP endpoint the writeback request should be sent to.",
            "type": "string",
            "maxLength": 255
          },
          "request": {
            "$ref": "#/components/schemas/List_CreateRequestItem_"
          }
        },
        "required": [
          "endpointId",
          "request"
        ],
        "title": "CreateRequest",
        "type": "object"
      },
      "CreateRequestItem": {
        "additionalProperties": false,
        "properties": {
          "key": {
            "title": "key",
            "description": "External object key related to this request.",
            "type": "string",
            "maxLength": 255
          },
          "fileId": {
            "title": "fileId",
            "description": "CDF File external Id. Only use when the SAP endpoint type is 'attachment'",
            "type": "string",
            "maxLength": 255
          },
          "payload": {
            "title": "payload",
            "description": "Payload to send to the SAP endpoint",
            "type": "object"
          }
        },
        "required": [
          "payload"
        ],
        "title": "Instance",
        "type": "object"
      },
      "Items_Instance_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Instance"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_Endpoint_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Endpoint"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_SchemaMapping_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SchemaMapping"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_Request_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Request"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_RequestMinimal_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/RequestMinimal"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_RequestFull_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/RequestFull"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_CreateRequest_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateRequest"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 1,
            "minItems": 1
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_CreateRequestResponse_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateRequestResponse"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 1,
            "minItems": 1
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceList",
        "type": "object"
      },
      "Items_CreateInstance_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateInstance"
            },
            "title": "Items",
            "type": "array",
            "minLength": 1,
            "maxLength": 100
          }
        },
        "required": [
          "items"
        ],
        "title": "CreateInstancelist",
        "type": "object"
      },
      "Items_CreateEndpoint_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateEndpoint"
            },
            "title": "Items",
            "type": "array",
            "minLength": 1,
            "maxLength": 100
          }
        },
        "required": [
          "items"
        ],
        "title": "CreateEndpoint list",
        "type": "object"
      },
      "Items_CreateSchemaMapping_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/CreateSchemaMapping"
            },
            "title": "Items",
            "type": "array",
            "minLength": 1,
            "maxLength": 100
          }
        },
        "required": [
          "items"
        ],
        "title": "CreateSchemaMapping list",
        "type": "object"
      },
      "ItemsWithCursor_Instance_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Instance"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "InstanceListWithCursor",
        "type": "object"
      },
      "ItemsWithCursor_Endpoint_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Endpoint"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "EndpointListWithCursor",
        "type": "object"
      },
      "ItemsWithCursor_SchemaMapping_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SchemaMapping"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "MappingList",
        "type": "object"
      },
      "ItemsWithCursor_ListRequestMinimal_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/RequestMinimal"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 0
          },
          "nextCursor": {
            "type": "string",
            "title": "Next cursor",
            "description": "Cursor for pagination"
          }
        },
        "required": [
          "items"
        ],
        "title": "MappingList",
        "type": "object"
      },
      "WritebackRequestId": {
        "description": "Unique request ID generated by the CDF writeback API.",
        "type": "string",
        "maxLength": 255
      },
      "RequestIdWrapper": {
        "additionalProperties": false,
        "properties": {
          "requestId": {
            "$ref": "#/components/schemas/WritebackRequestId"
          }
        },
        "required": [
          "externalId"
        ],
        "title": "WritebackExternalIdWrapper",
        "type": "object"
      },
      "ItemsWithIgnoreUnknownIds_RequestId_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/RequestIdWrapper"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "title": "IgnoreUnknownIds",
            "description": "Ignore IDs and external IDs that are not found"
          }
        },
        "required": [
          "items"
        ],
        "title": "ItemsWithIgnoreUnknownIds_RequestId",
        "type": "object"
      },
      "ConnectionCheckContent": {
        "type": "object",
        "required": [
          "status",
          "error_message"
        ],
        "description": "Cognite API error.",
        "properties": {
          "status": {
            "type": "string",
            "title": "status",
            "description": "Connectivity status between the writeback API and the SAP destination endpoint. `success` means that the CDF writeback API has successfully connected to the SAP endpoint destination.",
            "default": "success"
          },
          "detail": {
            "type": "string",
            "description": "Description of the connection check"
          }
        }
      },
      "WritebackExternalIdWrapper": {
        "additionalProperties": false,
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        },
        "required": [
          "externalId"
        ],
        "title": "WritebackExternalIdWrapper",
        "type": "object"
      },
      "WritebackItemsWithIgnoreUnknownIds_ExternalId_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/WritebackExternalIdWrapper"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "title": "IgnoreUnknownIds",
            "description": "Ignore IDs and external IDs that are not found"
          }
        },
        "required": [
          "items"
        ],
        "title": "ItemsWithIgnoreUnknownIds_ExternalId",
        "type": "object"
      },
      "WritebackItemsWithIgnoreUnknownIdsAndForce_ExternalId_": {
        "additionalProperties": false,
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/WritebackExternalIdWrapper"
            },
            "title": "Items",
            "type": "array",
            "maxItems": 100,
            "minItems": 1
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "title": "IgnoreUnknownIds",
            "description": "Ignore IDs and external IDs that are not found."
          },
          "force": {
            "type": "boolean",
            "title": "Force",
            "description": "Delete any jobs associated with each item."
          }
        },
        "required": [
          "items"
        ],
        "title": "ItemsWithIgnoreUnknownIdsAndForce_ExternalId",
        "type": "object"
      },
      "WritebackValidationErrorContent": {
        "type": "object",
        "required": [
          "code",
          "message"
        ],
        "description": "Cognite API error.",
        "properties": {
          "code": {
            "type": "integer",
            "description": "HTTP status code.",
            "format": "int32",
            "example": 422
          },
          "message": {
            "type": "string",
            "description": "Error message.",
            "example": "Extra inputs are not permitted: type"
          }
        }
      },
      "AggregateCount": {
        "properties": {
          "count": {
            "type": "integer",
            "title": "Count",
            "description": "Number of items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "count"
        ],
        "title": "AggregateCount"
      },
      "AggregateSimulatorModelsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorModelsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "aggregate": {
            "type": "string",
            "const": "count",
            "title": "Aggregate",
            "description": "Aggregate type",
            "enum": [
              "count"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "aggregate"
        ],
        "title": "AggregateSimulatorModelsQuery"
      },
      "DataPointsAggregate": {
        "type": "string",
        "enum": [
          "average",
          "interpolation",
          "stepInterpolation"
        ],
        "title": "DataPointsAggregate"
      },
      "EmptyResponse": {
        "properties": {},
        "type": "object",
        "title": "EmptyResponse"
      },
      "ErrorBase": {
        "properties": {
          "error": {
            "$ref": "#/components/schemas/APIError"
          }
        },
        "type": "object",
        "required": [
          "error"
        ],
        "title": "ErrorBase"
      },
      "IdRef": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "ID",
            "examples": [
              5559452808603919
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id"
        ],
        "title": "IdRef"
      },
      "InputItemsList20_Union_IdRef__ExternalIdRef__": {
        "properties": {
          "items": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IdRef"
                },
                {
                  "$ref": "#/components/schemas/ExternalIdRef"
                }
              ]
            },
            "type": "array",
            "maxItems": 20,
            "minItems": 1,
            "title": "Items",
            "description": "A list of items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "InputItemsList20[Union[IdRef, ExternalIdRef]]"
      },
      "InputItemsList_IdRef_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/IdRef"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Items",
            "description": "A list of items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "InputItemsList[IdRef]"
      },
      "InputItemsList_Union_IdRef__ExternalIdRef__": {
        "properties": {
          "items": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IdRef"
                },
                {
                  "$ref": "#/components/schemas/ExternalIdRef"
                }
              ]
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Items",
            "description": "A list of items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "InputItemsList[Union[IdRef, ExternalIdRef]]"
      },
      "ListSimulationRunsFilters": {
        "properties": {
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationRunStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by simulation run status"
          },
          "runType": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationRunType"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by simulation run type"
          },
          "simulatorIntegrationExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorIntegrationExternalIds",
            "description": "Filter by simulator integration external ids",
            "examples": [
              [
                "PROSPER_connector",
                "DWSIM_connector"
              ]
            ]
          },
          "simulatorExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorExternalIds",
            "description": "Filter by simulator external ids",
            "examples": [
              [
                "PROSPER",
                "PetroSIM"
              ]
            ]
          },
          "modelExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ModelExternalIds",
            "description": "Filter by simulator model external ids",
            "examples": [
              [
                "PROSPER_model",
                "PetroSIM_model"
              ]
            ]
          },
          "routineExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "RoutineExternalIds",
            "description": "Filter by simulator routine external ids",
            "examples": [
              [
                "PROSPER_routine",
                "PetroSIM_routine"
              ]
            ]
          },
          "routineRevisionExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "RoutineRevisionExternalIds",
            "description": "Filter by routine revision external ids",
            "examples": [
              [
                "routineRevisionForModel"
              ]
            ]
          },
          "modelRevisionExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ModelRevisionExternalIds",
            "description": "Filter by model revision external ids",
            "examples": [
              [
                "wellModel"
              ]
            ]
          },
          "createdTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by created time range"
          },
          "simulationTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by simulation time range"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulationRunsFilters"
      },
      "ListSimulationRunsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulationRunsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Limit",
            "default": 1000
          },
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cursor",
            "description": "Cursor for pagination"
          },
          "sort": {
            "anyOf": [
              {
                "items": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/SortByCreatedTime"
                    },
                    {
                      "$ref": "#/components/schemas/SortBySimulationTime"
                    }
                  ]
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Only supports sorting by one property at a time"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulationRunsQuery"
      },
      "ListSimulatorIntegrationsFilters": {
        "properties": {
          "simulatorExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorExternalIds",
            "description": "Filter by simulator external ids",
            "examples": [
              [
                "PROSPER"
              ]
            ]
          },
          "active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Active",
            "description": "Filter by whether the simulator integration is active or not. Connector is considered active if the heartbeat was reported within the last minute"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorIntegrationsFilters"
      },
      "ListSimulatorIntegrationsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorIntegrationsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Limit",
            "default": 1000
          }
        },
        "type": "object",
        "title": "ListSimulatorIntegrationsQuery"
      },
      "ListSimulatorModelRevisionsFilters": {
        "properties": {
          "modelExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ModelExternalIds",
            "description": "Filter by model external ids",
            "examples": [
              [
                "model_1",
                "model_2"
              ]
            ]
          },
          "allVersions": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "AllVersions",
            "description": "If all versions of the entity should be returned. Defaults to false which returns only the latest revision for each model.",
            "default": false
          },
          "createdTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by created time range"
          },
          "lastUpdatedTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by last updated time range"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorModelRevisionsFilters"
      },
      "ListSimulatorModelRevisionsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorModelRevisionsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Limit",
            "default": 1000
          },
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cursor",
            "description": "Cursor for pagination"
          },
          "sort": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SortByCreatedTime"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Only supports sorting by one property at a time"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorModelRevisionsQuery"
      },
      "ListSimulatorModelsFilters": {
        "properties": {
          "simulatorExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorExternalIds",
            "description": "Filter by simulator external ids",
            "examples": [
              [
                "PROSPER"
              ]
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorModelsFilters"
      },
      "ListSimulatorModelsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorModelsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Limit",
            "default": 1000
          },
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cursor",
            "description": "Cursor for pagination"
          },
          "sort": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SortByCreatedTime"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Only supports sorting by one property at a time"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorModelsQuery"
      },
      "ListSimulatorRoutineRevisionsFilters": {
        "properties": {
          "routineExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "RoutineExternalIds",
            "description": "Filter by simulator routine external ids",
            "examples": [
              [
                "routine_1",
                "routine_2"
              ]
            ]
          },
          "allVersions": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "AllVersions",
            "description": "If all versions of the entity should be returned. Defaults to false which returns only the latest revision for each routine.",
            "default": false
          },
          "modelExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ModelExternalIds",
            "description": "Filter by simulator model external ids",
            "examples": [
              [
                "model_1",
                "model_2"
              ]
            ]
          },
          "simulatorIntegrationExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorIntegrationExternalIds",
            "description": "Filter by simulator integration external ids",
            "examples": [
              [
                "simulator_integration_1",
                "simulator_integration_2"
              ]
            ]
          },
          "simulatorExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorExternalIds",
            "description": "Filter by simulator external ids",
            "examples": [
              [
                "PROSPER",
                "PetroSIM"
              ]
            ]
          },
          "createdTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EpochTimestampRange"
              },
              {
                "type": "null"
              }
            ],
            "description": "Filter by created time range"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorRoutineRevisionsFilters"
      },
      "ListSimulatorRoutineRevisionsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorRoutineRevisionsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 20,
            "minimum": 1,
            "title": "Limit",
            "default": 10
          },
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cursor",
            "description": "Cursor for pagination"
          },
          "sort": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SortByCreatedTime"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Only supports sorting by one property at a time"
          },
          "includeAllFields": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "IncludeAllFields",
            "description": "If all fields should be included in the response. Defaults to false which does not include script, configuration.inputs and configuration.outputs in the response. If true - all fields are included.",
            "default": false
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorRoutineRevisionsQuery"
      },
      "ListSimulatorRoutinesFilters": {
        "properties": {
          "modelExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ModelExternalIds",
            "description": "Filter by simulator model external ids",
            "examples": [
              [
                "model_1",
                "model_2"
              ]
            ]
          },
          "simulatorIntegrationExternalIds": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorIntegrationExternalIds",
            "description": "Filter by simulator integration external ids",
            "examples": [
              [
                "simulator_integration_1",
                "simulator_integration_2"
              ]
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorRoutinesFilters"
      },
      "ListSimulatorRoutinesQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorRoutinesFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Limit",
            "default": 1000
          },
          "cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cursor",
            "description": "Cursor for pagination"
          },
          "sort": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SortByCreatedTime"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Sort",
            "description": "Only supports sorting by one property at a time"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorRoutinesQuery"
      },
      "ListSimulatorsFilters": {
        "properties": {},
        "additionalProperties": false,
        "type": "object",
        "title": "ListSimulatorsFilters"
      },
      "ListSimulatorsQuery": {
        "properties": {
          "filter": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ListSimulatorsFilters"
              },
              {
                "type": "null"
              }
            ]
          },
          "limit": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Limit",
            "default": 1000
          }
        },
        "type": "object",
        "title": "ListSimulatorsQuery"
      },
      "RunIdRef": {
        "properties": {
          "runId": {
            "type": "integer",
            "title": "RunId",
            "description": "Simulation run id",
            "examples": [
              5559452808603919
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "runId"
        ],
        "title": "RunIdRef"
      },
      "SimulationInputOverride": {
        "properties": {
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "Reference id of the value to override"
          },
          "value": {
            "anyOf": [
              {
                "type": "string",
                "description": "String value. Minimum length is 1 and maximum length is 1024"
              },
              {
                "type": "number",
                "description": "Double precision value"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "description": "Array of strings. Minimum length is 1 and maximum length is 200"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array",
                "description": "Array of double precision values. Minimum length is 1 and maximum length is 200"
              }
            ],
            "title": "Value",
            "description": "Override the value used for simulation run"
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnitName"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override the unit of the value"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "referenceId",
          "value"
        ],
        "title": "SimulationInputOverride"
      },
      "SimulationRunCallbackCommand": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Simulation run id"
          },
          "status": {
            "$ref": "#/components/schemas/SimulationRunStatus",
            "description": "Status value to set for the given simulation run"
          },
          "statusMessage": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "StatusMessage",
            "description": "Status message, useful especially when status is 'failure'"
          },
          "simulationTime": {
            "anyOf": [
              {
                "type": "integer",
                "minimum": 0
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulationTime",
            "description": "Simulation time in milliseconds. Timestamp when the input data was sampled. Used for indexing input and output time series."
          },
          "inputs": {
            "items": {
              "$ref": "#/components/schemas/SimulationValue"
            },
            "type": "array",
            "maxItems": 200,
            "title": "Inputs",
            "description": "List of input values used for the simulation run",
            "default": []
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/SimulationValueBase"
            },
            "type": "array",
            "maxItems": 200,
            "minItems": 1,
            "title": "Outputs",
            "description": "List of output values generated by the simulation run",
            "default": []
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "status"
        ],
        "title": "SimulationRunCallbackCommand"
      },
      "SimulationRunCommandByRoutine": {
        "properties": {
          "runTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "RunTime",
            "description": "Run time in milliseconds. Reference timestamp used for data pre-processing and data sampling."
          },
          "queue": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Queue",
            "description": "Queue the simulation run when connector is down.",
            "default": false
          },
          "logSeverity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorLogSeverityLevel"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override the minimum severity level for the simulation run logs. If not provided, the minimum severity is read from the connector logger configuration."
          },
          "inputs": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulationInputOverride"
                },
                "type": "array",
                "maxItems": 200,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Inputs",
            "description": "List of input overrides"
          },
          "routineExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "RoutineExternalId",
            "description": "Routine external id",
            "examples": [
              "calculation_1"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "routineExternalId"
        ],
        "title": "SimulationRunCommandByRoutine"
      },
      "SimulationRunCommandByRoutineRevision": {
        "properties": {
          "runTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "RunTime",
            "description": "Run time in milliseconds. Reference timestamp used for data pre-processing and data sampling."
          },
          "queue": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Queue",
            "description": "Queue the simulation run when connector is down.",
            "default": false
          },
          "logSeverity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorLogSeverityLevel"
              },
              {
                "type": "null"
              }
            ],
            "description": "Override the minimum severity level for the simulation run logs. If not provided, the minimum severity is read from the connector logger configuration."
          },
          "inputs": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulationInputOverride"
                },
                "type": "array",
                "maxItems": 200,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Inputs",
            "description": "List of input overrides"
          },
          "routineRevisionExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "RoutineRevisionExternalId",
            "description": "Routine revision external id",
            "examples": [
              "dwsim_shower_mixer_model_v1"
            ]
          },
          "modelRevisionExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ModelRevisionExternalId",
            "description": "Model revision external id",
            "examples": [
              "dwsim_shower_mixer_routine_v1"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "routineRevisionExternalId",
          "modelRevisionExternalId"
        ],
        "title": "SimulationRunCommandByRoutineRevision"
      },
      "SimulationRunDataItem": {
        "properties": {
          "runId": {
            "type": "integer",
            "title": "RunId"
          },
          "inputs": {
            "items": {
              "$ref": "#/components/schemas/SimulationValue"
            },
            "type": "array",
            "title": "Inputs"
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/SimulationValueBase"
            },
            "type": "array",
            "title": "Outputs"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "runId",
          "inputs",
          "outputs"
        ],
        "title": "SimulationRunDataItem"
      },
      "SimulationRunStatus": {
        "type": "string",
        "enum": [
          "ready",
          "running",
          "success",
          "failure"
        ],
        "title": "SimulationRunStatus"
      },
      "SimulationRunType": {
        "type": "string",
        "enum": [
          "external",
          "manual",
          "scheduled"
        ],
        "title": "SimulationRunType"
      },
      "SimulationRunView": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulation run"
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator. Null for the legacy runs"
          },
          "simulatorIntegrationExternalId": {
            "type": "string",
            "title": "SimulatorIntegrationExternalId",
            "description": "External id of the simulator integration. Null for the legacy runs"
          },
          "modelExternalId": {
            "type": "string",
            "title": "ModelExternalId",
            "description": "External id of the simulation model. Null for the legacy runs"
          },
          "modelRevisionExternalId": {
            "type": "string",
            "title": "ModelRevisionExternalId",
            "description": "External id of the simulator model revision. Null for the legacy runs"
          },
          "routineExternalId": {
            "type": "string",
            "title": "RoutineExternalId",
            "description": "External id of the simulation routine. Null for the legacy runs"
          },
          "routineRevisionExternalId": {
            "type": "string",
            "title": "RoutineRevisionExternalId",
            "description": "External id of the simulation routine revision. Null for the legacy runs"
          },
          "runTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "RunTime",
            "description": "Run time in milliseconds. Reference timestamp used for data pre-processing and data sampling."
          },
          "simulationTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulationTime",
            "description": "Simulation time in milliseconds. Timestamp when the input data was sampled. Used for indexing input and output time series."
          },
          "status": {
            "$ref": "#/components/schemas/SimulationRunStatus",
            "description": "Status of the simulation run"
          },
          "statusMessage": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "StatusMessage",
            "description": "Message status of the simulation run"
          },
          "runType": {
            "$ref": "#/components/schemas/SimulationRunType",
            "description": "Type of the simulation run"
          },
          "userId": {
            "type": "string",
            "title": "UserId",
            "description": "User id of the simulation run"
          },
          "logId": {
            "type": "integer",
            "title": "LogId",
            "description": "Log ID"
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime",
            "description": "The number of milliseconds since epoch"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime",
            "description": "The number of milliseconds since epoch"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "simulatorExternalId",
          "simulatorIntegrationExternalId",
          "modelExternalId",
          "modelRevisionExternalId",
          "routineExternalId",
          "routineRevisionExternalId",
          "status",
          "runType",
          "userId",
          "logId",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulationRunView"
      },
      "SimulationValue": {
        "properties": {
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "Reference id of the value"
          },
          "value": {
            "anyOf": [
              {
                "type": "string",
                "description": "String value. Minimum length is 1 and maximum length is 1024"
              },
              {
                "type": "number",
                "description": "Double precision value"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "description": "Array of strings. Minimum length is 1 and maximum length is 200"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array",
                "description": "Array of double precision values. Minimum length is 1 and maximum length is 200"
              }
            ],
            "title": "Value",
            "description": "Value used for simulation. Can be string, double, array of strings or array of doubles. Maximum length is 1024 for strings and 200 for arrays"
          },
          "valueType": {
            "$ref": "#/components/schemas/SimulationValueType",
            "description": "Type of the value"
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnit"
              },
              {
                "type": "null"
              }
            ],
            "description": "Unit of the value"
          },
          "simulatorObjectReference": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorObjectRef"
              },
              {
                "type": "null"
              }
            ],
            "description": "Where the value was written to, and for the outputs it is where the value was read from"
          },
          "timeseriesExternalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "TimeseriesExternalId",
            "description": "External id of the time series where the value was written to"
          },
          "overridden": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Overridden",
            "description": "Whether the value was overridden by for this simulation run or used directly from the routine configuration"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "referenceId",
          "value",
          "valueType"
        ],
        "title": "SimulationValue"
      },
      "SimulationValueBase": {
        "properties": {
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "Reference id of the value"
          },
          "value": {
            "anyOf": [
              {
                "type": "string",
                "description": "String value. Minimum length is 1 and maximum length is 1024"
              },
              {
                "type": "number",
                "description": "Double precision value"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "description": "Array of strings. Minimum length is 1 and maximum length is 200"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array",
                "description": "Array of double precision values. Minimum length is 1 and maximum length is 200"
              }
            ],
            "title": "Value",
            "description": "Value used for simulation. Can be string, double, array of strings or array of doubles. Maximum length is 1024 for strings and 200 for arrays"
          },
          "valueType": {
            "$ref": "#/components/schemas/SimulationValueType",
            "description": "Type of the value"
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnit"
              },
              {
                "type": "null"
              }
            ],
            "description": "Unit of the value"
          },
          "simulatorObjectReference": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorObjectRef"
              },
              {
                "type": "null"
              }
            ],
            "description": "Where the value was written to, and for the outputs it is where the value was read from"
          },
          "timeseriesExternalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "TimeseriesExternalId",
            "description": "External id of the time series where the value was written to"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "referenceId",
          "value",
          "valueType"
        ],
        "title": "SimulationValueBase"
      },
      "SimulationValueType": {
        "type": "string",
        "enum": [
          "STRING",
          "DOUBLE",
          "STRING_ARRAY",
          "DOUBLE_ARRAY"
        ],
        "title": "SimulationValueType"
      },
      "SimulationValueUnit": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the unit",
            "examples": [
              "kg",
              "m",
              "Pa"
            ]
          },
          "externalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ExternalId",
            "description": "External id of the unit",
            "examples": [
              "mass:kilogm",
              "length:m",
              "pressure:pa"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name"
        ],
        "title": "SimulationValueUnit"
      },
      "SimulationValueUnitInput": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the unit",
            "examples": [
              "kg",
              "m",
              "Pa"
            ]
          },
          "quantity": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Quantity",
            "description": "Quantity of measure for the unit",
            "examples": [
              "Mass",
              "Length",
              "Pressure"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name"
        ],
        "title": "SimulationValueUnitInput"
      },
      "SimulationValueUnitName": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the unit",
            "examples": [
              "kg",
              "m",
              "Pa"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name"
        ],
        "title": "SimulationValueUnitName"
      },
      "SimulationValueUnitQuantity": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the unit",
            "examples": [
              "kg",
              "m",
              "Pa"
            ]
          },
          "externalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "ExternalId",
            "description": "External id of the unit",
            "examples": [
              "mass:kilogm",
              "length:m",
              "pressure:pa"
            ]
          },
          "quantity": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 50,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Quantity",
            "description": "Quantity of measure for the unit",
            "examples": [
              "Mass",
              "Length",
              "Pressure"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name"
        ],
        "title": "SimulationValueUnitQuantity"
      },
      "Simulator": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulator"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulator"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the simulator"
          },
          "fileExtensionTypes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "FileExtensionTypes",
            "description": "File extension types supported by the simulator"
          },
          "modelTypes": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulatorModelType"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "ModelTypes",
            "description": "Model types supported by the simulator"
          },
          "stepFields": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulatorStep"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "StepFields",
            "description": "Step types supported by the simulator when creating routines"
          },
          "unitQuantities": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulatorQuantity"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "UnitQuantities",
            "description": "Quantities and their units supported by the simulator"
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "externalId",
          "name",
          "fileExtensionTypes",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "Simulator"
      },
      "SimulatorCreateCommand": {
        "properties": {
          "externalId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ExternalId",
            "description": "External id of the simulator"
          },
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the simulator",
            "examples": [
              "PROSPER"
            ]
          },
          "fileExtensionTypes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "FileExtensionTypes",
            "description": "File extension types supported by the simulator"
          },
          "modelTypes": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelType"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "ModelTypes",
            "description": "Model types supported by the simulator"
          },
          "stepFields": {
            "items": {
              "$ref": "#/components/schemas/SimulatorStep"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "StepFields",
            "description": "Step types supported by the simulator when creating routines"
          },
          "unitQuantities": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulatorQuantity"
                },
                "type": "array",
                "maxItems": 1000,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "UnitQuantities",
            "description": "Quantities and their units supported by the simulator"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "name",
          "fileExtensionTypes",
          "modelTypes",
          "stepFields"
        ],
        "title": "SimulatorCreateCommand"
      },
      "SimulatorIntegration": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulator integration"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulator integration"
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "heartbeat": {
            "type": "integer",
            "title": "Heartbeat",
            "description": "When was the last time the simulator integration was active"
          },
          "connectorVersion": {
            "type": "string",
            "title": "ConnectorVersion",
            "description": "Connector version of the simulator integration"
          },
          "licenseStatus": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorIntegrationLicenseStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether the license is valid or not"
          },
          "simulatorVersion": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "SimulatorVersion",
            "description": "Simulator version of the simulator integration"
          },
          "licenseLastCheckedTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "LicenseLastCheckedTime",
            "description": "Timestamp when license was last checked"
          },
          "connectorStatus": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorIntegrationConnectorStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the connector (indicates whether a calculation is running or not)"
          },
          "connectorStatusUpdatedTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "ConnectorStatusUpdatedTime",
            "description": "Timestamp when status of the connector was last updated"
          },
          "active": {
            "type": "boolean",
            "title": "Active",
            "description": "Connector is considered active if the heartbeat was reported within the last minute"
          },
          "logId": {
            "type": "integer",
            "title": "LogId",
            "description": "Log ID"
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "externalId",
          "simulatorExternalId",
          "heartbeat",
          "connectorVersion",
          "active",
          "logId",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulatorIntegration"
      },
      "SimulatorIntegrationConnectorStatus": {
        "type": "string",
        "enum": [
          "IDLE",
          "RUNNING_SIMULATION"
        ],
        "title": "SimulatorIntegrationConnectorStatus"
      },
      "SimulatorIntegrationCreateCommand": {
        "properties": {
          "externalId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ExternalId",
            "description": "External id of the simulator integration"
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "heartbeat": {
            "type": "integer",
            "title": "Heartbeat",
            "description": "When was the last time the simulator integration was active"
          },
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Data set id of the simulator integration"
          },
          "connectorVersion": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ConnectorVersion",
            "description": "Connector version of the simulator integration"
          },
          "simulatorVersion": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "SimulatorVersion",
            "description": "Simulator version of the simulator integration"
          },
          "licenseStatus": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorIntegrationLicenseStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Whether licese is valid or not"
          },
          "licenseLastCheckedTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "LicenseLastCheckedTime",
            "description": "Timestamp when license was last checked"
          },
          "connectorStatus": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorIntegrationConnectorStatus"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the connector (indicates whether a calculation is running or not)"
          },
          "connectorStatusUpdatedTime": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "ConnectorStatusUpdatedTime",
            "description": "Timestamp when status of the connector was last updated"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "simulatorExternalId",
          "heartbeat",
          "dataSetId",
          "connectorVersion",
          "simulatorVersion"
        ],
        "title": "SimulatorIntegrationCreateCommand"
      },
      "SimulatorIntegrationLicenseStatus": {
        "type": "string",
        "enum": [
          "AVAILABLE",
          "NOT_AVAILABLE",
          "DISABLED",
          "UNKNOWN"
        ],
        "title": "SimulatorIntegrationLicenseStatus"
      },
      "SimulatorIntegrationUpdate": {
        "properties": {
          "heartbeat": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_int_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update when was the last time the simulator integration was active"
          },
          "dataSetId": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_int_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update data set id of the simulator integration"
          },
          "connectorVersion": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____1"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update connector version of the simulator integration"
          },
          "simulatorVersion": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____1"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update simulator version of the simulator integration"
          },
          "licenseStatus": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_SimulatorIntegrationLicenseStatus_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update whether the license is valid or not"
          },
          "licenseLastCheckedTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_int_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update timestamp when license was last checked"
          },
          "connectorStatus": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_SimulatorIntegrationConnectorStatus_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update status of the connector"
          },
          "connectorStatusUpdatedTime": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_int_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Update timestamp when status of the connector was last updated"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "SimulatorIntegrationUpdate"
      },
      "SimulatorIntegrationUpdateById": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Id of the simulator integration"
          },
          "update": {
            "$ref": "#/components/schemas/SimulatorIntegrationUpdate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "update"
        ],
        "title": "SimulatorIntegrationUpdateById"
      },
      "SimulatorLog": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulator resource log"
          },
          "data": {
            "items": {
              "$ref": "#/components/schemas/SimulatorLogData"
            },
            "type": "array",
            "title": "Data",
            "description": "Log data of the simulator resource"
          },
          "severity": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorLogSeverityLevel"
              },
              {
                "type": "null"
              }
            ],
            "description": "Minimum severity level of the log data. This overrides connector configuration minimum severity level and can be used for more granular control, e.g. to debug a specific simulation run."
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime",
            "description": "The number of milliseconds since epoch"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime",
            "description": "The number of milliseconds since epoch"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "data",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulatorLog"
      },
      "SimulatorLogData": {
        "properties": {
          "timestamp": {
            "type": "integer",
            "title": "Timestamp",
            "description": "Timestamp of the log message"
          },
          "message": {
            "type": "string",
            "maxLength": 4096,
            "minLength": 1,
            "title": "Message",
            "description": "Log message"
          },
          "severity": {
            "$ref": "#/components/schemas/SimulatorLogSeverityLevel",
            "description": "Log severity level"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "timestamp",
          "message",
          "severity"
        ],
        "title": "SimulatorLogData"
      },
      "SimulatorLogSeverityLevel": {
        "type": "string",
        "enum": [
          "Debug",
          "Information",
          "Warning",
          "Error"
        ],
        "title": "SimulatorLogSeverityLevel"
      },
      "SimulatorLogUpdate": {
        "properties": {
          "data": {
            "$ref": "#/components/schemas/UpdateAdd_Annotated_list_SimulatorLogData___FieldInfo_annotation_NoneType__required_True__metadata__MinLen_min_length_1___MaxLen_max_length_1000_____",
            "description": "Log data of the simulator resource"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "data"
        ],
        "title": "SimulatorLogUpdate"
      },
      "SimulatorLogUpdateCommand": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Id of the simulator resource log"
          },
          "update": {
            "$ref": "#/components/schemas/SimulatorLogUpdate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "update"
        ],
        "title": "SimulatorLogUpdateCommand"
      },
      "SimulatorModel": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulation model"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulation model"
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the simulation model"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the simulation model"
          },
          "type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Type",
            "description": "Model type of the simulation model. List of available types is available in the simulator resource."
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "externalId",
          "simulatorExternalId",
          "name",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulatorModel"
      },
      "SimulatorModelCreateCommand": {
        "properties": {
          "externalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ExternalId",
            "description": "External id of the simulation model"
          },
          "simulatorExternalId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the simulation model"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the simulation model"
          },
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Data set id of the simulation model"
          },
          "type": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Type",
            "description": "Model type of the simulation model. List of available types is available in the simulator resource."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "simulatorExternalId",
          "name",
          "dataSetId",
          "type"
        ],
        "title": "SimulatorModelCreateCommand"
      },
      "SimulatorModelRevision": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulation model revision"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulation model revision"
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "modelExternalId": {
            "type": "string",
            "title": "ModelExternalId",
            "description": "External id of the simulation model"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the simulation model revision"
          },
          "fileId": {
            "type": "integer",
            "title": "FileId",
            "description": "Source file id of the simulation model revision"
          },
          "createdByUserId": {
            "type": "string",
            "title": "CreatedByUserId",
            "description": "Author of the simulation model revision"
          },
          "status": {
            "$ref": "#/components/schemas/SimulatorModelRevisionStatus",
            "description": "Status of the simulation model revision",
            "default": "unknown"
          },
          "statusMessage": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "StatusMessage",
            "description": "Status message of the simulation model revision"
          },
          "versionNumber": {
            "type": "integer",
            "title": "VersionNumber",
            "description": "Version number of the simulation model revision. Unique per simulation model."
          },
          "logId": {
            "type": "integer",
            "title": "LogId",
            "description": "Log ID"
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "externalId",
          "simulatorExternalId",
          "modelExternalId",
          "fileId",
          "createdByUserId",
          "versionNumber",
          "logId",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulatorModelRevision"
      },
      "SimulatorModelRevisionCreateCommand": {
        "properties": {
          "externalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ExternalId",
            "description": "External id of the simulation model revision"
          },
          "modelExternalId": {
            "type": "string",
            "title": "ModelExternalId",
            "description": "External id of the simulation model"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the simulation model revision"
          },
          "fileId": {
            "type": "integer",
            "title": "FileId",
            "description": "Source file id of the simulation model revision"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "modelExternalId",
          "fileId"
        ],
        "title": "SimulatorModelRevisionCreateCommand"
      },
      "SimulatorModelRevisionDataConnectionType": {
        "type": "string",
        "enum": [
          "Material",
          "Energy",
          "Information"
        ],
        "title": "SimulatorModelRevisionDataConnectionType"
      },
      "SimulatorModelRevisionDataFlowsheet": {
        "properties": {
          "simulatorObjectNodes": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionDataObjectNode"
            },
            "type": "array",
            "title": "SimulatorObjectNodes",
            "description": "List of flowsheet nodes"
          },
          "simulatorObjectEdges": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionDataObjectEdge"
            },
            "type": "array",
            "title": "SimulatorObjectEdges",
            "description": "List of flowsheet edges"
          },
          "thermodynamics": {
            "$ref": "#/components/schemas/SimulatorModelRevisionDataThermodynamic",
            "description": "Thermodynamic data"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "simulatorObjectNodes",
          "simulatorObjectEdges",
          "thermodynamics"
        ],
        "title": "SimulatorModelRevisionDataFlowsheet"
      },
      "SimulatorModelRevisionDataGraphicalObject": {
        "properties": {
          "position": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorModelRevisionDataPosition"
              },
              {
                "type": "null"
              }
            ],
            "description": "Position of the graphical object"
          },
          "height": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Height",
            "description": "Height of the graphical object"
          },
          "width": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Width",
            "description": "Width of the graphical object"
          },
          "scaleX": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "ScaleX",
            "description": "Horizontal scale factor"
          },
          "scaleY": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "ScaleY",
            "description": "Vertical scale factor"
          },
          "angle": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Angle",
            "description": "Rotation angle"
          },
          "active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Active",
            "description": "Whether the object is active"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "SimulatorModelRevisionDataGraphicalObject"
      },
      "SimulatorModelRevisionDataModelExternalId": {
        "properties": {
          "modelRevisionExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ModelRevisionExternalId",
            "description": "External id of the model revision"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "modelRevisionExternalId"
        ],
        "title": "SimulatorModelRevisionDataModelExternalId"
      },
      "SimulatorModelRevisionDataObjectEdge": {
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Id",
            "description": "Edge identifier"
          },
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 50,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Edge name"
          },
          "sourceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "SourceId",
            "description": "Source node identifier"
          },
          "targetId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "TargetId",
            "description": "Target node identifier"
          },
          "connectionType": {
            "$ref": "#/components/schemas/SimulatorModelRevisionDataConnectionType",
            "description": "Type of connection"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "sourceId",
          "targetId",
          "connectionType"
        ],
        "title": "SimulatorModelRevisionDataObjectEdge"
      },
      "SimulatorModelRevisionDataObjectNode": {
        "properties": {
          "id": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Id",
            "description": "Node identifier"
          },
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 50,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Node name"
          },
          "type": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Type",
            "description": "Node type"
          },
          "graphicalObject": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorModelRevisionDataGraphicalObject"
              },
              {
                "type": "null"
              }
            ],
            "description": "Graphical representation"
          },
          "properties": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionDataProperty"
            },
            "type": "array",
            "title": "Properties",
            "description": "List of node properties"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "type",
          "properties"
        ],
        "title": "SimulatorModelRevisionDataObjectNode"
      },
      "SimulatorModelRevisionDataPosition": {
        "properties": {
          "x": {
            "type": "number",
            "title": "X",
            "description": "X coordinate"
          },
          "y": {
            "type": "number",
            "title": "Y",
            "description": "Y coordinate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "x",
          "y"
        ],
        "title": "SimulatorModelRevisionDataPosition"
      },
      "SimulatorModelRevisionDataProperty": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Property name"
          },
          "referenceObject": {
            "additionalProperties": {
              "type": "string",
              "maxLength": 50,
              "minLength": 1
            },
            "propertyNames": {
              "maxLength": 50,
              "minLength": 1
            },
            "type": "object",
            "title": "ReferenceObject",
            "description": "Reference object mapping"
          },
          "valueType": {
            "$ref": "#/components/schemas/SimulationValueType",
            "description": "Type of the value"
          },
          "value": {
            "anyOf": [
              {
                "type": "string",
                "description": "String value. Minimum length is 1 and maximum length is 1024"
              },
              {
                "type": "number",
                "description": "Double precision value"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "description": "Array of strings. Minimum length is 1 and maximum length is 200"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array",
                "description": "Array of double precision values. Minimum length is 1 and maximum length is 200"
              }
            ],
            "title": "Value",
            "description": "Property value"
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnitQuantity"
              },
              {
                "type": "null"
              }
            ],
            "description": "Unit of the property"
          },
          "readOnly": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "ReadOnly",
            "description": "Whether the property is read-only"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "referenceObject",
          "valueType",
          "value"
        ],
        "title": "SimulatorModelRevisionDataProperty"
      },
      "SimulatorModelRevisionDataThermodynamic": {
        "properties": {
          "propertyPackages": {
            "items": {
              "type": "string",
              "maxLength": 50,
              "minLength": 1
            },
            "type": "array",
            "title": "PropertyPackages",
            "description": "List of property packages"
          },
          "components": {
            "items": {
              "type": "string",
              "maxLength": 50,
              "minLength": 1
            },
            "type": "array",
            "title": "Components",
            "description": "List of components"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "propertyPackages",
          "components"
        ],
        "title": "SimulatorModelRevisionDataThermodynamic"
      },
      "SimulatorModelRevisionDataUpdate": {
        "properties": {
          "flowsheet": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_SimulatorModelRevisionDataFlowsheet_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Flowsheet of the model revision"
          },
          "info": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_Dict_Annotated_str__StringConstraints___Annotated_str__StringConstraints___"
              },
              {
                "type": "null"
              }
            ],
            "description": "Additional simulator-specific information"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "SimulatorModelRevisionDataUpdate"
      },
      "SimulatorModelRevisionDataUpdateCommand": {
        "properties": {
          "modelRevisionExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ModelRevisionExternalId",
            "description": "External id of the model revision"
          },
          "update": {
            "$ref": "#/components/schemas/SimulatorModelRevisionDataUpdate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "modelRevisionExternalId",
          "update"
        ],
        "title": "SimulatorModelRevisionDataUpdateCommand"
      },
      "SimulatorModelRevisionDataView": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "modelRevisionExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ModelRevisionExternalId",
            "description": "External id of the model revision"
          },
          "flowsheet": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorModelRevisionDataFlowsheet"
              },
              {
                "type": "null"
              }
            ],
            "description": "Flowsheet of the model revision"
          },
          "info": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string",
                  "maxLength": 50,
                  "minLength": 1
                },
                "propertyNames": {
                  "maxLength": 50,
                  "minLength": 1
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Info",
            "description": "Additional simulator-specific information"
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "modelRevisionExternalId",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulatorModelRevisionDataView"
      },
      "SimulatorModelRevisionStatus": {
        "type": "string",
        "enum": [
          "unknown",
          "success",
          "failure"
        ],
        "title": "SimulatorModelRevisionStatus"
      },
      "SimulatorModelRevisionUpdate": {
        "properties": {
          "status": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSet_SimulatorModelRevisionStatus_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Status of the simulation model revision"
          },
          "statusMessage": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____2"
              },
              {
                "$ref": "#/components/schemas/UpdateSetNull"
              },
              {
                "type": "null"
              }
            ],
            "title": "StatusMessage",
            "description": "Status message of the simulation model revision"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "SimulatorModelRevisionUpdate"
      },
      "SimulatorModelRevisionUpdateCommand": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Id of the simulator model revision"
          },
          "update": {
            "$ref": "#/components/schemas/SimulatorModelRevisionUpdate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "update"
        ],
        "title": "SimulatorModelRevisionUpdateCommand"
      },
      "SimulatorModelType": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the model type"
          },
          "key": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Key",
            "description": "Key of the model type"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "key"
        ],
        "title": "SimulatorModelType"
      },
      "SimulatorModelUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____1"
              },
              {
                "type": "null"
              }
            ],
            "description": "Name of the model",
            "examples": [
              {
                "set": "Model for PROSPER"
              }
            ]
          },
          "description": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____2"
              },
              {
                "type": "null"
              }
            ],
            "description": "Description of the simulation model"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "SimulatorModelUpdate"
      },
      "SimulatorModelUpdateCommand": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Id of the simulator model"
          },
          "update": {
            "$ref": "#/components/schemas/SimulatorModelUpdate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "update"
        ],
        "title": "SimulatorModelUpdateCommand"
      },
      "SimulatorObjectRef": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "SimulatorObjectRef"
      },
      "SimulatorQuantity": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the quantity",
            "examples": [
              "Mass",
              "Length",
              "Pressure"
            ]
          },
          "label": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Label",
            "description": "Label of the quantity. For display purposes",
            "examples": [
              "Mass",
              "Length",
              "Pressure"
            ]
          },
          "units": {
            "items": {
              "$ref": "#/components/schemas/SimulatorUnitEntry"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Units",
            "description": "Units of measure supported by the simulator for the given quantity"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "label",
          "units"
        ],
        "title": "SimulatorQuantity"
      },
      "SimulatorRoutineBase": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulation routine"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulation routine"
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "modelExternalId": {
            "type": "string",
            "title": "ModelExternalId",
            "description": "External id of the simulation model"
          },
          "simulatorIntegrationExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "SimulatorIntegrationExternalId",
            "description": "External id of the simulator integration this routine belongs to"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the simulation routine"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the simulation routine"
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime",
            "description": "The number of milliseconds since epoch"
          },
          "lastUpdatedTime": {
            "type": "integer",
            "title": "LastUpdatedTime",
            "description": "The number of milliseconds since epoch"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "externalId",
          "simulatorExternalId",
          "modelExternalId",
          "simulatorIntegrationExternalId",
          "name",
          "createdTime",
          "lastUpdatedTime"
        ],
        "title": "SimulatorRoutineBase"
      },
      "SimulatorRoutineConfigDisabled": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "const": false,
            "title": "Enabled",
            "description": "When disabled other fields are not allowed",
            "enum": [
              false
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "enabled"
        ],
        "title": "SimulatorRoutineConfigDisabled"
      },
      "SimulatorRoutineConfiguration": {
        "properties": {
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorRoutineConfigDisabled"
              },
              {
                "$ref": "#/components/schemas/SimulatorRoutineScheduleEnabled"
              }
            ],
            "title": "Schedule"
          },
          "dataSampling": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorRoutineConfigDisabled"
              },
              {
                "$ref": "#/components/schemas/SimulatorRoutineDataSamplingEnabled"
              }
            ],
            "title": "DataSampling"
          },
          "logicalCheck": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineLogicalCheckEnabled"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 0,
            "title": "LogicalCheck",
            "description": "List of logical check rules. Used to find out data points which satisfy the logical check."
          },
          "steadyStateDetection": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineSteadyStateDetectionEnabled"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 0,
            "title": "SteadyStateDetection",
            "description": "List of steady state detection rules. Used to find out data points which are in steady state."
          },
          "inputs": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SimulatorRoutineInputConstant"
                },
                {
                  "$ref": "#/components/schemas/SimulatorRoutineInputTimeseries"
                }
              ],
              "description": "Input item for the simulation routine"
            },
            "type": "array",
            "maxItems": 200,
            "title": "Inputs",
            "description": "List of input constants and input time series. Used to define the inputs of the simulation routine.",
            "default": []
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineOutput"
            },
            "type": "array",
            "maxItems": 200,
            "title": "Outputs",
            "description": "List of outputs for the simulation routine.",
            "default": []
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "schedule",
          "dataSampling",
          "logicalCheck",
          "steadyStateDetection"
        ],
        "title": "SimulatorRoutineConfiguration"
      },
      "SimulatorRoutineConfigurationBase": {
        "properties": {
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorRoutineConfigDisabled"
              },
              {
                "$ref": "#/components/schemas/SimulatorRoutineScheduleEnabled"
              }
            ],
            "title": "Schedule"
          },
          "dataSampling": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorRoutineConfigDisabled"
              },
              {
                "$ref": "#/components/schemas/SimulatorRoutineDataSamplingEnabled"
              }
            ],
            "title": "DataSampling"
          },
          "logicalCheck": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineLogicalCheckEnabled"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 0,
            "title": "LogicalCheck",
            "description": "List of logical check rules. Used to find out data points which satisfy the logical check."
          },
          "steadyStateDetection": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineSteadyStateDetectionEnabled"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 0,
            "title": "SteadyStateDetection",
            "description": "List of steady state detection rules. Used to find out data points which are in steady state."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "schedule",
          "dataSampling",
          "logicalCheck",
          "steadyStateDetection"
        ],
        "title": "SimulatorRoutineConfigurationBase"
      },
      "SimulatorRoutineConfigurationCreate": {
        "properties": {
          "schedule": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorRoutineConfigDisabled"
              },
              {
                "$ref": "#/components/schemas/SimulatorRoutineScheduleEnabled"
              }
            ],
            "title": "Schedule"
          },
          "dataSampling": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulatorRoutineConfigDisabled"
              },
              {
                "$ref": "#/components/schemas/SimulatorRoutineDataSamplingEnabled"
              }
            ],
            "title": "DataSampling"
          },
          "logicalCheck": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineLogicalCheckEnabled"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 0,
            "title": "LogicalCheck",
            "description": "List of logical check rules. Used to find out data points which satisfy the logical check."
          },
          "steadyStateDetection": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineSteadyStateDetectionEnabled"
            },
            "type": "array",
            "maxItems": 1,
            "minItems": 0,
            "title": "SteadyStateDetection",
            "description": "List of steady state detection rules. Used to find out data points which are in steady state."
          },
          "inputs": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SimulatorRoutineInputConstant"
                },
                {
                  "$ref": "#/components/schemas/SimulatorRoutineInputTimeseries"
                }
              ],
              "description": "Input item for the simulation routine"
            },
            "type": "array",
            "maxItems": 200,
            "title": "Inputs",
            "description": "List of input constants and input time series. Used to define the inputs of the simulation routine.",
            "default": []
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineOutput"
            },
            "type": "array",
            "maxItems": 200,
            "title": "Outputs",
            "description": "List of outputs for the simulation routine.",
            "default": []
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "schedule",
          "dataSampling",
          "logicalCheck",
          "steadyStateDetection"
        ],
        "title": "SimulatorRoutineConfigurationCreate"
      },
      "SimulatorRoutineCreateCommand": {
        "properties": {
          "externalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ExternalId",
            "description": "External id of the simulator routine"
          },
          "modelExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ModelExternalId",
            "description": "External id of the simulation model"
          },
          "simulatorIntegrationExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "SimulatorIntegrationExternalId",
            "description": "External id of the simulator integration this routine belongs to"
          },
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the routine",
            "examples": [
              "Fluid Sloshing in Tank",
              "Thermal-Structural Analysis"
            ]
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the simulation routine"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "modelExternalId",
          "simulatorIntegrationExternalId",
          "name"
        ],
        "title": "SimulatorRoutineCreateCommand"
      },
      "SimulatorRoutineDataSamplingEnabled": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "const": true,
            "title": "Enabled",
            "description": "Whether the data sampling is enabled or not",
            "enum": [
              true
            ]
          },
          "validationWindow": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "ValidationWindow",
            "description": "Validation window of the data sampling. Represented in minutes. Used when either logical check or steady state detection is enabled."
          },
          "samplingWindow": {
            "type": "integer",
            "title": "SamplingWindow",
            "description": "Sampling window of the data sampling. Represented in minutes"
          },
          "granularity": {
            "type": "integer",
            "title": "Granularity",
            "description": "Granularity of the data sampling in minutes"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "enabled",
          "samplingWindow",
          "granularity"
        ],
        "title": "SimulatorRoutineDataSamplingEnabled"
      },
      "SimulatorRoutineInputConstant": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Constant name."
          },
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "A unique id of the input to be used in the routine."
          },
          "value": {
            "anyOf": [
              {
                "type": "string",
                "description": "String value. Minimum length is 1 and maximum length is 1024"
              },
              {
                "type": "number",
                "description": "Double precision value"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array",
                "description": "Array of strings. Minimum length is 1 and maximum length is 200"
              },
              {
                "items": {
                  "type": "number"
                },
                "type": "array",
                "description": "Array of double precision values. Minimum length is 1 and maximum length is 200"
              }
            ],
            "title": "Value",
            "description": "Constant value. For the list, the maximum length is 200, and the minimum length is 1."
          },
          "valueType": {
            "$ref": "#/components/schemas/SimulationValueType",
            "description": "Constant value type.",
            "default": "STRING"
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnitInput"
              },
              {
                "type": "null"
              }
            ],
            "description": "Constant unit."
          },
          "saveTimeseriesExternalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SaveTimeseriesExternalId",
            "description": "Time series external ID to use when saving the input sample in CDF."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "referenceId",
          "value"
        ],
        "title": "SimulatorRoutineInputConstant"
      },
      "SimulatorRoutineInputTimeseries": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Input/output name."
          },
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "A unique id of the input to be used in the routine."
          },
          "sourceExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "SourceExternalId",
            "description": "External id of the source time series to read from."
          },
          "aggregate": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DataPointsAggregate"
              },
              {
                "type": "null"
              }
            ],
            "description": "Aggregate type of the sensor data. Only used if data sampling is enabled. Otherwise, the latest data point value is used."
          },
          "saveTimeseriesExternalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SaveTimeseriesExternalId",
            "description": "Time series external ID to use when saving the input sample in CDF.",
            "examples": [
              "PROSPER-INPUT-ChokeDp-THP-Well_A2"
            ]
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnitInput"
              },
              {
                "type": "null"
              }
            ],
            "description": "Time series unit."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "referenceId",
          "sourceExternalId"
        ],
        "title": "SimulatorRoutineInputTimeseries"
      },
      "SimulatorRoutineLogicalCheckEnabled": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "const": true,
            "title": "Enabled",
            "description": "Whether the logical check is enabled or not",
            "enum": [
              true
            ]
          },
          "timeseriesExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "TimeseriesExternalId",
            "description": "External ID of the time series to run the logical check against"
          },
          "aggregate": {
            "$ref": "#/components/schemas/DataPointsAggregate",
            "description": "Data points aggregate to be used for the time series"
          },
          "operator": {
            "$ref": "#/components/schemas/SimulatorRoutineOperator",
            "description": "Operator of the logical check"
          },
          "value": {
            "type": "number",
            "title": "Value",
            "description": "Value to compare with"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "enabled",
          "aggregate",
          "operator",
          "value"
        ],
        "title": "SimulatorRoutineLogicalCheckEnabled"
      },
      "SimulatorRoutineOperator": {
        "type": "string",
        "enum": [
          "eq",
          "ne",
          "gt",
          "ge",
          "lt",
          "le"
        ],
        "title": "SimulatorRoutineOperator"
      },
      "SimulatorRoutineOutput": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Output name."
          },
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "A unique identifier of the output in a given routine."
          },
          "unit": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/SimulationValueUnitInput"
              },
              {
                "type": "null"
              }
            ],
            "description": "Output unit."
          },
          "valueType": {
            "$ref": "#/components/schemas/SimulationValueType",
            "description": "Output value type.",
            "default": "STRING"
          },
          "saveTimeseriesExternalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "SaveTimeseriesExternalId",
            "description": "External id of the output time series."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "referenceId"
        ],
        "title": "SimulatorRoutineOutput"
      },
      "SimulatorRoutineRevision": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulation routine revision"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulation routine revision",
            "examples": [
              "fluid_sloshing",
              "thermal_analysis"
            ]
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "routineExternalId": {
            "type": "string",
            "title": "RoutineExternalId",
            "description": "External id of the simulation routine"
          },
          "simulatorIntegrationExternalId": {
            "type": "string",
            "title": "SimulatorIntegrationExternalId",
            "description": "External id of the simulator integration this routine belongs to"
          },
          "modelExternalId": {
            "type": "string",
            "title": "ModelExternalId",
            "description": "External id of the simulation model"
          },
          "createdByUserId": {
            "type": "string",
            "title": "CreatedByUserId",
            "description": "Author of the simulation routine revision"
          },
          "versionNumber": {
            "type": "integer",
            "title": "VersionNumber",
            "description": "Version number of the simulation routine revision. Unique per simulation routine."
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime",
            "description": "The number of milliseconds since epoch"
          },
          "configuration": {
            "$ref": "#/components/schemas/SimulatorRoutineConfiguration"
          },
          "script": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineStage"
            },
            "type": "array",
            "maxItems": 10,
            "title": "Script",
            "description": "Script of the simulation routine revision"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "externalId",
          "simulatorExternalId",
          "routineExternalId",
          "simulatorIntegrationExternalId",
          "modelExternalId",
          "createdByUserId",
          "versionNumber",
          "createdTime",
          "configuration",
          "script"
        ],
        "title": "SimulatorRoutineRevision"
      },
      "SimulatorRoutineRevisionCreateCommand": {
        "properties": {
          "externalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "ExternalId",
            "description": "External id of the simulator routine revision"
          },
          "routineExternalId": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "RoutineExternalId",
            "description": "External id of the simulation routine",
            "examples": [
              "fluid_sloshing",
              "thermal_analysis"
            ]
          },
          "configuration": {
            "$ref": "#/components/schemas/SimulatorRoutineConfigurationCreate"
          },
          "script": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineStage"
            },
            "type": "array",
            "maxItems": 10,
            "title": "Script",
            "description": "Script of the simulation routine revision"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "routineExternalId",
          "configuration",
          "script"
        ],
        "title": "SimulatorRoutineRevisionCreateCommand"
      },
      "SimulatorRoutineRevisionView": {
        "properties": {
          "dataSetId": {
            "type": "integer",
            "title": "DataSetId",
            "description": "Dataset id of the resource",
            "examples": [
              5559452808603919
            ]
          },
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "A unique id of a simulation routine revision"
          },
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "External id of the simulation routine revision",
            "examples": [
              "fluid_sloshing",
              "thermal_analysis"
            ]
          },
          "simulatorExternalId": {
            "type": "string",
            "title": "SimulatorExternalId",
            "description": "External id of the simulator"
          },
          "routineExternalId": {
            "type": "string",
            "title": "RoutineExternalId",
            "description": "External id of the simulation routine"
          },
          "simulatorIntegrationExternalId": {
            "type": "string",
            "title": "SimulatorIntegrationExternalId",
            "description": "External id of the simulator integration this routine belongs to"
          },
          "modelExternalId": {
            "type": "string",
            "title": "ModelExternalId",
            "description": "External id of the simulation model"
          },
          "createdByUserId": {
            "type": "string",
            "title": "CreatedByUserId",
            "description": "Author of the simulation routine revision"
          },
          "versionNumber": {
            "type": "integer",
            "title": "VersionNumber",
            "description": "Version number of the simulation routine revision. Unique per simulation routine."
          },
          "createdTime": {
            "type": "integer",
            "title": "CreatedTime",
            "description": "The number of milliseconds since epoch"
          },
          "configuration": {
            "$ref": "#/components/schemas/SimulatorRoutineConfigurationBase"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "dataSetId",
          "id",
          "externalId",
          "simulatorExternalId",
          "routineExternalId",
          "simulatorIntegrationExternalId",
          "modelExternalId",
          "createdByUserId",
          "versionNumber",
          "createdTime",
          "configuration"
        ],
        "title": "SimulatorRoutineRevisionView"
      },
      "SimulatorRoutineScheduleEnabled": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the schedule is enabled or not"
          },
          "cronExpression": {
            "type": "string",
            "pattern": "(@((annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|s|ms|s|m|h))+)|((((\\d+,)+\\d+|(\\d+(\\/|-)\\d+)|\\d+|\\*) ?){5,7}))",
            "title": "CronExpression",
            "description": "Cron expression representing the schedule.\nExamples:\n- @annually: Run once a year at midnight of January 1st.\n- @daily: Run once a day at midnight.\n- */5 * * * *: Run every 5 minutes.\n- 0 0 * * *: Run once a day at midnight.\n- 0 0 * * MON-FRI: Run once a day at midnight, Monday through Friday."
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "enabled",
          "cronExpression"
        ],
        "title": "SimulatorRoutineScheduleEnabled"
      },
      "SimulatorRoutineStage": {
        "properties": {
          "order": {
            "type": "integer",
            "maximum": 10,
            "minimum": 1,
            "title": "Order",
            "description": "Stage number"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Stage description"
          },
          "steps": {
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/SimulatorRoutineStepGet"
                },
                {
                  "$ref": "#/components/schemas/SimulatorRoutineStepSet"
                },
                {
                  "$ref": "#/components/schemas/SimulatorRoutineStepCommand"
                }
              ],
              "discriminator": {
                "propertyName": "stepType",
                "mapping": {
                  "Command": "#/components/schemas/SimulatorRoutineStepCommand",
                  "Get": "#/components/schemas/SimulatorRoutineStepGet",
                  "Set": "#/components/schemas/SimulatorRoutineStepSet"
                }
              }
            },
            "type": "array",
            "maxItems": 1000,
            "title": "Steps",
            "description": "Stage steps"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "order",
          "steps"
        ],
        "title": "SimulatorRoutineStage"
      },
      "SimulatorRoutineSteadyStateDetectionEnabled": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "const": true,
            "title": "Enabled",
            "description": "Whether the steady state detection is enabled or not",
            "enum": [
              true
            ]
          },
          "timeseriesExternalId": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "TimeseriesExternalId",
            "description": "External ID of the time series to be evaluated"
          },
          "aggregate": {
            "$ref": "#/components/schemas/DataPointsAggregate",
            "description": "Aggregate type of the steady state detection"
          },
          "minSectionSize": {
            "type": "integer",
            "title": "MinSectionSize",
            "description": "Min section size of the steady state detection"
          },
          "varThreshold": {
            "type": "number",
            "title": "VarThreshold",
            "description": "Var threshold of the steady state detection"
          },
          "slopeThreshold": {
            "type": "number",
            "title": "SlopeThreshold",
            "description": "Slope threshold of the steady state detection"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "enabled",
          "aggregate",
          "minSectionSize",
          "varThreshold",
          "slopeThreshold"
        ],
        "title": "SimulatorRoutineSteadyStateDetectionEnabled"
      },
      "SimulatorRoutineStepArgumentsCommand": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "SimulatorRoutineStepArgumentsCommand"
      },
      "SimulatorRoutineStepArgumentsGet": {
        "properties": {
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "A unique id of the output defined in the routine configuration."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "referenceId"
        ],
        "title": "SimulatorRoutineStepArgumentsGet"
      },
      "SimulatorRoutineStepArgumentsSet": {
        "properties": {
          "referenceId": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "ReferenceId",
            "description": "A unique id to the input time series (or a constant) defined in the routine configuration."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "referenceId"
        ],
        "title": "SimulatorRoutineStepArgumentsSet"
      },
      "SimulatorRoutineStepCommand": {
        "properties": {
          "order": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Order",
            "description": "Step number"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Step description"
          },
          "stepType": {
            "type": "string",
            "const": "Command",
            "title": "StepType",
            "description": "Step type",
            "enum": [
              "Command"
            ]
          },
          "arguments": {
            "$ref": "#/components/schemas/SimulatorRoutineStepArgumentsCommand"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "order",
          "stepType",
          "arguments"
        ],
        "title": "SimulatorRoutineStepCommand",
        "description": "Used to run a command in a simulation routine. For example, to run a solver."
      },
      "SimulatorRoutineStepGet": {
        "properties": {
          "order": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Order",
            "description": "Step number"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Step description"
          },
          "stepType": {
            "type": "string",
            "const": "Get",
            "title": "StepType",
            "description": "Step type",
            "enum": [
              "Get"
            ]
          },
          "arguments": {
            "$ref": "#/components/schemas/SimulatorRoutineStepArgumentsGet",
            "description": "Step arguments",
            "examples": [
              {
                "objectName": "WELL.A2",
                "objectProperty": "Tempretature",
                "referenceId": "CWTC"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "order",
          "stepType",
          "arguments"
        ],
        "title": "SimulatorRoutineStepGet",
        "description": "Used to extract the output of a simulation routine and write it back into the Cognite Data Fusion."
      },
      "SimulatorRoutineStepSet": {
        "properties": {
          "order": {
            "type": "integer",
            "maximum": 1000,
            "minimum": 1,
            "title": "Order",
            "description": "Step number"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Step description"
          },
          "stepType": {
            "type": "string",
            "const": "Set",
            "title": "StepType",
            "description": "Step type",
            "enum": [
              "Set"
            ]
          },
          "arguments": {
            "$ref": "#/components/schemas/SimulatorRoutineStepArgumentsSet",
            "description": "Step arguments",
            "examples": [
              {
                "objectName": "WELL.A2",
                "objectProperty": "Tempretature",
                "referenceId": "CWTC"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "order",
          "stepType",
          "arguments"
        ],
        "title": "SimulatorRoutineStepSet",
        "description": "Used to set the input of a simulation routine from timeseries or constant fields."
      },
      "SimulatorStep": {
        "properties": {
          "stepType": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "StepType",
            "description": "Step type"
          },
          "fields": {
            "items": {
              "$ref": "#/components/schemas/SimulatorStepField"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Fields",
            "description": "Fields of the step"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "stepType",
          "fields"
        ],
        "title": "SimulatorStep"
      },
      "SimulatorStepField": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Name",
            "description": "Name of the step field"
          },
          "label": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Label",
            "description": "Label of the step field. Used to render the field label in the GUI of the routine builder"
          },
          "info": {
            "type": "string",
            "maxLength": 200,
            "title": "Info",
            "description": "Info of the step field. Used to render a tooltip for the field in the GUI of the routine builder"
          },
          "options": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/SimulatorStepOption"
                },
                "type": "array",
                "maxItems": 100,
                "minItems": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Options",
            "description": "Options to show in the GUI dropdown of the routine builder"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "label",
          "info"
        ],
        "title": "SimulatorStepField"
      },
      "SimulatorStepOption": {
        "properties": {
          "label": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Label",
            "description": "Label that will be shown in the dropdown in the GUI of the routine builder",
            "examples": [
              "Solve Flowsheet",
              "Pause Solver"
            ]
          },
          "value": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Value",
            "description": "Name of the dropdown item",
            "examples": [
              "Solve",
              "Pause"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "label",
          "value"
        ],
        "title": "SimulatorStepOption"
      },
      "SimulatorUnitEntry": {
        "properties": {
          "label": {
            "type": "string",
            "maxLength": 50,
            "minLength": 0,
            "title": "Label",
            "description": "Label of the unit. For display purposes",
            "examples": [
              "kg",
              "m",
              "Pa"
            ]
          },
          "name": {
            "type": "string",
            "maxLength": 50,
            "minLength": 0,
            "title": "Name",
            "description": "Name of the unit",
            "examples": [
              "kg",
              "m",
              "Pa"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "label",
          "name"
        ],
        "title": "SimulatorUnitEntry"
      },
      "SimulatorUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____1"
              },
              {
                "type": "null"
              }
            ],
            "description": "Name of the simulator",
            "examples": [
              {
                "set": "PROSPER"
              }
            ]
          },
          "fileExtensionTypes": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSetList_str_"
              },
              {
                "type": "null"
              }
            ],
            "description": "File extension types supported by the simulator"
          },
          "modelTypes": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSetList_SimulatorModelType_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Model types supported by the simulator"
          },
          "stepFields": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSetList_SimulatorStep_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Step types supported by the simulator when creating routines"
          },
          "unitQuantities": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/UpdateSetList1k_SimulatorQuantity_"
              },
              {
                "type": "null"
              }
            ],
            "description": "Quantities and their units supported by the simulator"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "SimulatorUpdate"
      },
      "SimulatorUpdateCommand": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Id of the simulator resource"
          },
          "update": {
            "$ref": "#/components/schemas/SimulatorUpdate"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "id",
          "update"
        ],
        "title": "SimulatorUpdateCommand"
      },
      "SingleItemList_IdRef_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/IdRef"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[IdRef]"
      },
      "SingleItemList_RunIdRef_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/RunIdRef"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[RunIdRef]"
      },
      "SingleItemList_SimulationRunCallbackCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulationRunCallbackCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulationRunCallbackCommand]"
      },
      "SingleItemList_SimulatorCreateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorCreateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorCreateCommand]"
      },
      "SingleItemList_SimulatorIntegrationCreateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorIntegrationCreateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorIntegrationCreateCommand]"
      },
      "SingleItemList_SimulatorIntegrationUpdateById_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorIntegrationUpdateById"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorIntegrationUpdateById]"
      },
      "SingleItemList_SimulatorLogUpdateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorLogUpdateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorLogUpdateCommand]"
      },
      "SingleItemList_SimulatorModelCreateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelCreateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorModelCreateCommand]"
      },
      "SingleItemList_SimulatorModelRevisionCreateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionCreateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorModelRevisionCreateCommand]"
      },
      "SingleItemList_SimulatorModelRevisionDataModelExternalId_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionDataModelExternalId"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorModelRevisionDataModelExternalId]"
      },
      "SingleItemList_SimulatorModelRevisionDataUpdateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionDataUpdateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorModelRevisionDataUpdateCommand]"
      },
      "SingleItemList_SimulatorModelRevisionUpdateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionUpdateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorModelRevisionUpdateCommand]"
      },
      "SingleItemList_SimulatorModelUpdateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelUpdateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorModelUpdateCommand]"
      },
      "SingleItemList_SimulatorRoutineCreateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineCreateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorRoutineCreateCommand]"
      },
      "SingleItemList_SimulatorRoutineRevisionCreateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineRevisionCreateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorRoutineRevisionCreateCommand]"
      },
      "SingleItemList_SimulatorUpdateCommand_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorUpdateCommand"
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[SimulatorUpdateCommand]"
      },
      "SingleItemList_Union_IdRef__ExternalIdRef__": {
        "properties": {
          "items": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/IdRef"
                },
                {
                  "$ref": "#/components/schemas/ExternalIdRef"
                }
              ]
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[Union[IdRef, ExternalIdRef]]"
      },
      "SingleItemList_Union_SimulationRunCommandByRoutine__SimulationRunCommandByRoutineRevision__": {
        "properties": {
          "items": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/SimulationRunCommandByRoutine"
                },
                {
                  "$ref": "#/components/schemas/SimulationRunCommandByRoutineRevision"
                }
              ]
            },
            "type": "array",
            "title": "Items",
            "description": "A list with a single item"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "SingleItemList[Union[SimulationRunCommandByRoutine, SimulationRunCommandByRoutineRevision]]"
      },
      "SortByCreatedTime": {
        "properties": {
          "order": {
            "anyOf": [
              {
                "type": "string",
                "const": "asc",
                "enum": [
                  "asc"
                ]
              },
              {
                "type": "string",
                "const": "desc",
                "enum": [
                  "desc"
                ]
              }
            ],
            "title": "Order",
            "description": "Sort order"
          },
          "property": {
            "type": "string",
            "const": "createdTime",
            "title": "Property",
            "description": "Name of the property to sort by",
            "enum": [
              "createdTime"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "order",
          "property"
        ],
        "title": "SortByCreatedTime"
      },
      "SortBySimulationTime": {
        "properties": {
          "order": {
            "anyOf": [
              {
                "type": "string",
                "const": "asc",
                "enum": [
                  "asc"
                ]
              },
              {
                "type": "string",
                "const": "desc",
                "enum": [
                  "desc"
                ]
              }
            ],
            "title": "Order",
            "description": "Sort order"
          },
          "property": {
            "type": "string",
            "const": "simulationTime",
            "title": "Property",
            "description": "Name of the property to sort by",
            "enum": [
              "simulationTime"
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "order",
          "property"
        ],
        "title": "SortBySimulationTime"
      },
      "UpdateAdd_Annotated_list_SimulatorLogData___FieldInfo_annotation_NoneType__required_True__metadata__MinLen_min_length_1___MaxLen_max_length_1000_____": {
        "properties": {
          "add": {
            "items": {
              "$ref": "#/components/schemas/SimulatorLogData"
            },
            "type": "array",
            "maxItems": 1000,
            "minItems": 1,
            "title": "Add",
            "description": "Value to add"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "add"
        ],
        "title": "UpdateAdd[Annotated[list[SimulatorLogData], FieldInfo(annotation=NoneType, required=True, metadata=[MinLen(min_length=1), MaxLen(max_length=1000)])]]"
      },
      "UpdateSetList1k_SimulatorQuantity_": {
        "properties": {
          "set": {
            "items": {
              "$ref": "#/components/schemas/SimulatorQuantity"
            },
            "type": "array",
            "maxItems": 1000,
            "minItems": 1,
            "title": "Set",
            "description": "List value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSetList1k[SimulatorQuantity]"
      },
      "UpdateSetList_SimulatorModelType_": {
        "properties": {
          "set": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelType"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Set",
            "description": "List value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSetList[SimulatorModelType]"
      },
      "UpdateSetList_SimulatorStep_": {
        "properties": {
          "set": {
            "items": {
              "$ref": "#/components/schemas/SimulatorStep"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Set",
            "description": "List value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSetList[SimulatorStep]"
      },
      "UpdateSetList_str_": {
        "properties": {
          "set": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "maxItems": 100,
            "minItems": 1,
            "title": "Set",
            "description": "List value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSetList[str]"
      },
      "UpdateSet_Dict_Annotated_str__StringConstraints___Annotated_str__StringConstraints___": {
        "properties": {
          "set": {
            "additionalProperties": {
              "type": "string",
              "maxLength": 50,
              "minLength": 1
            },
            "propertyNames": {
              "maxLength": 50,
              "minLength": 1
            },
            "type": "object",
            "title": "Set",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[Dict[Annotated[str, StringConstraints], Annotated[str, StringConstraints]]]"
      },
      "UpdateSet_SimulatorIntegrationConnectorStatus_": {
        "properties": {
          "set": {
            "$ref": "#/components/schemas/SimulatorIntegrationConnectorStatus",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[SimulatorIntegrationConnectorStatus]"
      },
      "UpdateSet_SimulatorIntegrationLicenseStatus_": {
        "properties": {
          "set": {
            "$ref": "#/components/schemas/SimulatorIntegrationLicenseStatus",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[SimulatorIntegrationLicenseStatus]"
      },
      "UpdateSet_SimulatorModelRevisionDataFlowsheet_": {
        "properties": {
          "set": {
            "$ref": "#/components/schemas/SimulatorModelRevisionDataFlowsheet",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[SimulatorModelRevisionDataFlowsheet]"
      },
      "UpdateSet_SimulatorModelRevisionStatus_": {
        "properties": {
          "set": {
            "$ref": "#/components/schemas/SimulatorModelRevisionStatus",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[SimulatorModelRevisionStatus]"
      },
      "UpdateSet_int_": {
        "properties": {
          "set": {
            "type": "integer",
            "title": "Set",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[int]"
      },
      "ViewListWithCursor_SimulationRunView_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulationRunView"
            },
            "type": "array",
            "title": "Items"
          },
          "nextCursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "NextCursor"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewListWithCursor[SimulationRunView]"
      },
      "ViewListWithCursor_SimulatorModelRevision_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevision"
            },
            "type": "array",
            "title": "Items"
          },
          "nextCursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "NextCursor"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewListWithCursor[SimulatorModelRevision]"
      },
      "ViewListWithCursor_SimulatorModel_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModel"
            },
            "type": "array",
            "title": "Items"
          },
          "nextCursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "NextCursor"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewListWithCursor[SimulatorModel]"
      },
      "ViewListWithCursor_SimulatorRoutineBase_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineBase"
            },
            "type": "array",
            "title": "Items"
          },
          "nextCursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "NextCursor"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewListWithCursor[SimulatorRoutineBase]"
      },
      "ViewListWithCursor_SimulatorRoutineRevisionView_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineRevisionView"
            },
            "type": "array",
            "title": "Items"
          },
          "nextCursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "NextCursor"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewListWithCursor[SimulatorRoutineRevisionView]"
      },
      "ViewListWithCursor_SimulatorRoutineRevision_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineRevision"
            },
            "type": "array",
            "title": "Items"
          },
          "nextCursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "NextCursor"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewListWithCursor[SimulatorRoutineRevision]"
      },
      "ViewList_AggregateCount_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/AggregateCount"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[AggregateCount]"
      },
      "ViewList_SimulationRunDataItem_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulationRunDataItem"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulationRunDataItem]"
      },
      "ViewList_SimulationRunView_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulationRunView"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulationRunView]"
      },
      "ViewList_SimulatorIntegration_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorIntegration"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorIntegration]"
      },
      "ViewList_SimulatorLog_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorLog"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorLog]"
      },
      "ViewList_SimulatorModelRevisionDataView_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevisionDataView"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorModelRevisionDataView]"
      },
      "ViewList_SimulatorModelRevision_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModelRevision"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorModelRevision]"
      },
      "ViewList_SimulatorModel_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorModel"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorModel]"
      },
      "ViewList_SimulatorRoutineBase_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineBase"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorRoutineBase]"
      },
      "ViewList_SimulatorRoutineRevision_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/SimulatorRoutineRevision"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[SimulatorRoutineRevision]"
      },
      "ViewList_Simulator_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Simulator"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[Simulator]"
      },
      "services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____1": {
        "properties": {
          "set": {
            "type": "string",
            "maxLength": 50,
            "minLength": 1,
            "title": "Set",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[Annotated[str, StringConstraints]]"
      },
      "services__simint_api__src__common__models__UpdateSet_Annotated_str__StringConstraints____2": {
        "properties": {
          "set": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Set",
            "description": "Value to set"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "set"
        ],
        "title": "UpdateSet[Annotated[str, StringConstraints]]"
      },
      "APIError": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message"
          },
          "code": {
            "type": "integer",
            "title": "Code"
          }
        },
        "type": "object",
        "required": [
          "message",
          "code"
        ],
        "title": "APIError"
      },
      "ExternalIdRef": {
        "properties": {
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "String-based ID"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId"
        ],
        "title": "ExternalIdRef"
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "RestrictedItemList_ExternalIdRef_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/ExternalIdRef"
            },
            "type": "array",
            "title": "Items"
          },
          "ignoreUnknownIds": {
            "title": "IgnoreUnknownIds",
            "description": "Ignore external IDs that are not found. If set to true, no error will be thrown if an external ID is not found.",
            "default": false,
            "nullable": true,
            "type": "boolean",
            "example": false
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "RestrictedItemList[ExternalIdRef]"
      },
      "Unit": {
        "properties": {
          "externalId": {
            "type": "string",
            "title": "ExternalId",
            "description": "Unique identifier of the unit. Usually in a form of unit_quantity_name:unit_name",
            "example": "temperature:deg_c"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "A compact name of the unit.",
            "example": "DEG_C"
          },
          "longName": {
            "type": "string",
            "title": "LongName",
            "description": "A more verbose name of the unit.",
            "example": "degree Celsius"
          },
          "symbol": {
            "type": "string",
            "title": "Symbol",
            "description": "The symbol for the unit.",
            "example": "C"
          },
          "aliasNames": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "AliasNames",
            "description": "A list of alternative aliases (names) for the unit.",
            "example": [
              "C",
              "C",
              "deg C",
              "degC",
              "DegC"
            ]
          },
          "quantity": {
            "type": "string",
            "title": "Quantity",
            "description": "Specifies the physical quantity the unit measures.",
            "example": "Temperature"
          },
          "conversion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UnitConversion"
              }
            ],
            "description": "An object containing multiplier and offset values for converting between units",
            "example": {
              "multiplier": 1,
              "offset": 273.15
            }
          },
          "source": {
            "title": "Source",
            "description": "Source of the unit specification",
            "nullable": true,
            "type": "string",
            "example": "qudt.org"
          },
          "sourceReference": {
            "title": "SourceReference",
            "description": "Reference to the source of the unit specification",
            "nullable": true,
            "type": "string",
            "example": "http://qudt.org/vocab/unit/DEG_C"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "externalId",
          "name",
          "longName",
          "symbol",
          "aliasNames",
          "quantity",
          "conversion"
        ],
        "title": "Unit",
        "description": "Unit: This represents a standard measure of a given quantity.\n\nExamples:\n\n- Temperature: Degrees Celsius, Degrees Fahrenheit\n\n- Pressure: Bar, Psi"
      },
      "UnitConversion": {
        "properties": {
          "multiplier": {
            "type": "number",
            "title": "Multiplier",
            "example": 1
          },
          "offset": {
            "type": "number",
            "title": "Offset",
            "example": -273.15
          }
        },
        "type": "object",
        "required": [
          "multiplier",
          "offset"
        ],
        "title": "UnitConversion"
      },
      "UnitSystem": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the unit system",
            "example": "SI"
          },
          "quantities": {
            "items": {
              "$ref": "#/components/schemas/UnitSystemQuantity"
            },
            "type": "array",
            "title": "Quantities",
            "description": "List of quantities and their default units",
            "example": [
              {
                "name": "Temperature",
                "unitExternalId": "temperature:deg_c"
              }
            ]
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "quantities"
        ],
        "title": "UnitSystem",
        "description": "Unit System: A set of default units designated per quantity.\n\nAn example being:\n\n- SI: Temperature in Kelvin, Pressure in Pa\n\n- SI (Engineering): Temperature in degrees Celsius, Pressure in bar\n\n- Imperial: Temperature in degrees Fahrenheit, Pressure in psi"
      },
      "UnitSystemQuantity": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Name of the quantity",
            "example": "Temperature"
          },
          "unitExternalId": {
            "type": "string",
            "title": "UnitExternalId",
            "description": "Default unit for the quantity",
            "example": "temperature:deg_c"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "name",
          "unitExternalId"
        ],
        "title": "UnitSystemQuantity"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "ViewList_UnitSystem_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/UnitSystem"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[UnitSystem]"
      },
      "ViewList_Unit_": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/Unit"
            },
            "type": "array",
            "title": "Items"
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "items"
        ],
        "title": "ViewList[Unit]"
      },
      "CreateEntityRequest": {
        "description": "",
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "visibility": {
            "$ref": "#/components/schemas/Visibility"
          },
          "data": {
            "type": "object"
          }
        }
      },
      "CreateEntityRequestList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/Entity"
            }
          }
        }
      },
      "CreateEntityResponseList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/EntityResponse"
            }
          }
        }
      },
      "EntitiesLookupById": {
        "description": "Schema for fetching the list of entities byIds using externalIds",
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 1000,
            "items": {
              "type": "object",
              "required": [
                "externalId"
              ],
              "properties": {
                "externalId": {
                  "$ref": "#/components/schemas/CogniteExternalId"
                }
              }
            }
          }
        }
      },
      "EntityResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/CreateEntityRequest"
          },
          {
            "type": "object",
            "properties": {
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          }
        ]
      },
      "EntityListFilter": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "visibility": {
                "$ref": "#/components/schemas/Visibility"
              },
              "isOwned": {
                "type": "boolean",
                "description": "only match entities the client owns"
              }
            }
          }
        ]
      },
      "EntityListRequest": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/EntityListFilter"
          },
          "limit": {
            "description": "Maximum number of items that the client want to get back.",
            "type": "integer",
            "format": "int32",
            "minimum": 1,
            "maximum": 1000,
            "default": 100
          }
        }
      },
      "EntityResponseList": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 10000,
            "items": {
              "$ref": "#/components/schemas/EntityResponse"
            }
          }
        }
      },
      "EntityResponseByIds": {
        "description": "",
        "type": "object",
        "properties": {
          "items": {
            "type": "array",
            "minItems": 0,
            "maxItems": 1000,
            "items": {
              "$ref": "#/components/schemas/EntityResponse"
            }
          }
        }
      },
      "Entity": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "visibility": {
            "$ref": "#/components/schemas/Visibility"
          },
          "data": {
            "type": "object"
          }
        }
      },
      "Visibility": {
        "type": "string",
        "enum": [
          "PUBLIC",
          "PRIVATE"
        ]
      },
      "UserPreferencesLanguageField": {
        "type": "string",
        "enum": [
          "de",
          "en",
          "es",
          "fr",
          "it",
          "ja",
          "ko",
          "lv",
          "nl",
          "pt",
          "sv",
          "zh"
        ]
      },
      "UserPreferencesTimezoneField": {
        "type": "string",
        "pattern": "(GMT|UTC)(+|-)hh:mm",
        "example": "GMT+02:00"
      },
      "UserPreferencesDateFormatField": {
        "type": "string",
        "enum": [
          "YYYY/MM/DD",
          "MM/DD/YYYY",
          "DD/MM/YYYY"
        ]
      },
      "UserPreferencesTimeFormatField": {
        "type": "string",
        "enum": [
          "H:mm",
          "h:mm A"
        ]
      },
      "UserPreferencesRead": {
        "type": "object",
        "properties": {
          "general": {
            "type": "object",
            "properties": {
              "language": {
                "$ref": "#/components/schemas/UserPreferencesLanguageField"
              },
              "timezone": {
                "$ref": "#/components/schemas/UserPreferencesTimezoneField"
              },
              "dateFormat": {
                "$ref": "#/components/schemas/UserPreferencesDateFormatField"
              },
              "timeFormat": {
                "$ref": "#/components/schemas/UserPreferencesTimeFormatField"
              }
            }
          }
        }
      },
      "UserPreferencesUpdate": {
        "type": "object",
        "properties": {
          "general": {
            "type": "object",
            "properties": {
              "update": {
                "type": "object",
                "description": "Fields omitted from `update` object will retain their previous values.",
                "properties": {
                  "language": {
                    "type": "object",
                    "properties": {
                      "set": {
                        "$ref": "#/components/schemas/UserPreferencesLanguageField"
                      }
                    }
                  },
                  "timezone": {
                    "type": "object",
                    "properties": {
                      "set": {
                        "$ref": "#/components/schemas/UserPreferencesTimezoneField"
                      }
                    }
                  },
                  "dateFormat": {
                    "type": "object",
                    "properties": {
                      "set": {
                        "$ref": "#/components/schemas/UserPreferencesDateFormatField"
                      }
                    }
                  },
                  "timeFormat": {
                    "type": "object",
                    "properties": {
                      "set": {
                        "$ref": "#/components/schemas/UserPreferencesTimeFormatField"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "LocationFilterRead": {
        "type": "object",
        "required": [
          "id",
          "createdTime",
          "lastUpdatedTime"
        ],
        "allOf": [
          {
            "$ref": "#/components/schemas/LocationFilterWrite"
          }
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/CogniteInternalId"
          },
          "createdTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          },
          "lastUpdatedTime": {
            "$ref": "#/components/schemas/EpochTimestamp"
          }
        }
      },
      "LocationFilterWrite": {
        "type": "object",
        "required": [
          "externalId",
          "name"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          },
          "name": {
            "type": "string",
            "description": "The name of the location filter",
            "maxLength": 255
          },
          "parentId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CogniteInternalId"
              }
            ],
            "description": "The ID of the parent location filter"
          },
          "description": {
            "type": "string",
            "description": "The description of the location filter",
            "maxLength": 255
          },
          "dataModels": {
            "type": "array",
            "description": "The data models in the location filter",
            "items": {
              "$ref": "#/components/schemas/LocationFilterDataModel"
            }
          },
          "instanceSpaces": {
            "type": "array",
            "description": "The list of spaces that instances are in",
            "items": {
              "type": "string"
            }
          },
          "scene": {
            "$ref": "#/components/schemas/LocationFilterScene"
          },
          "assetCentric": {
            "$ref": "#/components/schemas/LocationFilterAssetCentric"
          },
          "views": {
            "type": "array",
            "description": "The list of view mappings",
            "items": {
              "$ref": "#/components/schemas/LocationFilterView"
            }
          }
        }
      },
      "LocationFilterView": {
        "type": "object",
        "description": "The view mappings for the location filter",
        "required": [
          "externalId",
          "space",
          "version",
          "representsEntity"
        ],
        "properties": {
          "externalId": {
            "type": "string",
            "description": "The external ID of the view"
          },
          "space": {
            "type": "string",
            "description": "The space that the view belongs to"
          },
          "version": {
            "type": "string",
            "description": "The version of the view"
          },
          "representsEntity": {
            "type": "string",
            "enum": [
              "MAINTENANCE_ORDER",
              "OPERATION",
              "NOTIFICATION",
              "ASSET"
            ]
          }
        }
      },
      "LocationFilterAssetCentric": {
        "type": "object",
        "description": "The filter definition for asset centric resource types",
        "allOf": [
          {
            "$ref": "#/components/schemas/LocationFilterAssetCentricBaseFilter"
          }
        ],
        "properties": {
          "assets": {
            "$ref": "#/components/schemas/LocationFilterAssetCentricBaseFilter"
          },
          "events": {
            "$ref": "#/components/schemas/LocationFilterAssetCentricBaseFilter"
          },
          "files": {
            "$ref": "#/components/schemas/LocationFilterAssetCentricBaseFilter"
          },
          "timeseries": {
            "$ref": "#/components/schemas/LocationFilterAssetCentricBaseFilter"
          },
          "sequences": {
            "$ref": "#/components/schemas/LocationFilterAssetCentricBaseFilter"
          }
        }
      },
      "LocationFilterAssetCentricBaseFilter": {
        "type": "object",
        "properties": {
          "dataSetIds": {
            "type": "array",
            "description": "The list of data set IDs",
            "items": {
              "type": "number"
            }
          },
          "assetSubtreeIds": {
            "type": "array",
            "description": "The list of asset subtree IDs",
            "items": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/IdEither"
                }
              ]
            }
          },
          "externalIdPrefix": {
            "type": "string",
            "description": "The external ID prefix"
          }
        }
      },
      "LocationFilterDataModel": {
        "type": "object",
        "required": [
          "externalId",
          "space",
          "version"
        ],
        "properties": {
          "externalId": {
            "type": "string",
            "description": "The external ID of the data model"
          },
          "space": {
            "type": "string",
            "description": "The space of the data model"
          },
          "version": {
            "type": "string",
            "description": "The version of the data model"
          }
        }
      },
      "LocationFilterScene": {
        "type": "object",
        "description": "The scene config for the location filter",
        "required": [
          "externalId",
          "space",
          "version"
        ],
        "properties": {
          "externalId": {
            "type": "string",
            "description": "The external ID of the scene"
          },
          "space": {
            "type": "string",
            "description": "The space that the scene is in"
          }
        }
      },
      "OrgId": {
        "type": "string",
        "description": "The ID of an organization",
        "minLength": 3,
        "maxLength": 64,
        "example": "my-org",
        "pattern": "^([a-z][a-z0-9-]{1,62}[a-z0-9])$"
      },
      "ClusterName": {
        "type": "string",
        "description": "A CDF cluster name",
        "minLength": 1,
        "maxLength": 32,
        "pattern": "^[a-z0-9-]{1,32}$",
        "example": "westeurope-1"
      },
      "MigrationStatus": {
        "type": "string",
        "description": "This attribute will be removed in a future version, and it is recommended to not send it in requests and to ignore it in responses.\nIf it is present, the single valid value is equivalent to the attribute being null or absent.",
        "enum": [
          "EXCLUSIVE_LOGIN"
        ]
      },
      "ExternalGroupId": {
        "type": "string",
        "description": "The ID of a group managed by the external identity provider",
        "minLength": 3,
        "maxLength": 64,
        "example": "my-external-group"
      },
      "NullableExternalGroupId": {
        "type": "string",
        "description": "The ID of a group managed by the external identity provider.",
        "minLength": 3,
        "maxLength": 64,
        "example": "my-external-group"
      },
      "IdentityProvider": {
        "description": "Configuration for an external OIDC-compliant IdP.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/AzureAdIdp"
          },
          {
            "$ref": "#/components/schemas/Auth0Idp"
          },
          {
            "$ref": "#/components/schemas/KeycloakIdp"
          },
          {
            "$ref": "#/components/schemas/SAuthIdp"
          },
          {
            "$ref": "#/components/schemas/AWSCognitoIdP"
          }
        ]
      },
      "IdpBase": {
        "type": "object",
        "required": [
          "issuer"
        ],
        "properties": {
          "issuer": {
            "type": "string",
            "format": "url",
            "example": "https://login.microsoftonline.com/some-tenant-id/v2.0",
            "description": "The issuer for the external IdP."
          }
        }
      },
      "AzureAdIdp": {
        "allOf": [
          {
            "type": "object",
            "description": "Azure AD IdP configuration",
            "required": [
              "idpVendor"
            ],
            "properties": {
              "idpVendor": {
                "type": "string",
                "enum": [
                  "AZURE_AD"
                ]
              },
              "issuer": {
                "example": "https://login.microsoftonline.com/some-tenant-id/v2.0",
                "description": "The issuer for the external IdP. For Azure AD, it conforms to the example URL and contains the tenant ID."
              }
            }
          },
          {
            "$ref": "#/components/schemas/IdpBase"
          }
        ]
      },
      "Auth0Idp": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdpBase"
          },
          {
            "type": "object",
            "description": "Auth0 IdP configuration",
            "required": [
              "idpVendor",
              "clientId",
              "clientSecret",
              "groupsClaimName"
            ],
            "properties": {
              "idpVendor": {
                "type": "string",
                "enum": [
                  "AUTH0"
                ]
              },
              "clientId": {
                "type": "string",
                "description": "The client ID of the Auth0 application"
              },
              "clientSecret": {
                "type": "string",
                "format": "password",
                "description": "The client secret of the Auth0 application. It is write-only and cannot be read."
              },
              "groupsClaimName": {
                "description": "The name of the claim that contains the groups in the token",
                "type": "string",
                "pattern": "^[a-z0-9][a-z0-9_\\-./:]{0,31}(?<![^a-z0-9])$",
                "minLength": 1,
                "maxLength": 32,
                "example": "my-groups-claim"
              },
              "extraAuthParameters": {
                "type": "array",
                "description": "Extra parameters to be sent to the Auth0 token endpoint",
                "items": {
                  "$ref": "#/components/schemas/ExtraAuthParameter"
                }
              }
            }
          }
        ]
      },
      "KeycloakIdp": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdpBase"
          },
          {
            "type": "object",
            "description": "Keycloak IdP configuration",
            "required": [
              "idpVendor",
              "clientId"
            ],
            "properties": {
              "idpVendor": {
                "type": "string",
                "enum": [
                  "KEYCLOAK"
                ]
              },
              "clientId": {
                "type": "string",
                "description": "The client ID of the Keycloak application"
              }
            }
          }
        ]
      },
      "SAuthIdp": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdpBase"
          },
          {
            "type": "object",
            "description": "SAuth IdP configuration",
            "required": [
              "idpVendor",
              "clientId",
              "clientSecret",
              "appKey",
              "groupsUrl",
              "idTokenAudience",
              "extraScope"
            ],
            "properties": {
              "idpVendor": {
                "type": "string",
                "enum": [
                  "SAUTH"
                ]
              },
              "clientId": {
                "type": "string",
                "description": "The client ID of the SAuth application"
              },
              "clientSecret": {
                "type": "string",
                "format": "password",
                "description": "The client secret of the SAuth application. It is write-only and cannot be read."
              },
              "appKey": {
                "type": "string",
                "format": "password",
                "description": "The app key of the SAuth application. It is write-only and cannot be read."
              },
              "groupsUrl": {
                "type": "string",
                "description": "The URL for the group membership callback endpoint of the SAuth server."
              },
              "idTokenAudience": {
                "type": "string",
                "description": "The expected value of the `aud` claim in the SAuth identity tokens."
              },
              "extraScope": {
                "type": "string",
                "description": "The extra scope to request from SAuth, in addition to the standard scopes `openid offline_access profile email`."
              }
            }
          }
        ]
      },
      "AWSCognitoIdP": {
        "allOf": [
          {
            "$ref": "#/components/schemas/IdpBase"
          },
          {
            "type": "object",
            "description": "AWS Cognito IdP configuration",
            "required": [
              "idpVendor",
              "clientId",
              "clientSecret"
            ],
            "properties": {
              "idpVendor": {
                "type": "string",
                "enum": [
                  "AWS_COGNITO"
                ]
              },
              "clientId": {
                "type": "string",
                "description": "The client ID of the AWS Cognito application"
              },
              "clientSecret": {
                "type": "string",
                "format": "password",
                "description": "The client secret of the AWS Cognito application"
              }
            }
          }
        ]
      },
      "ExtraAuthParameter": {
        "type": "object",
        "description": "Extra parameters to send to the external IdP",
        "required": [
          "name",
          "value"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the parameter"
          },
          "value": {
            "type": "string",
            "description": "The value of the parameter"
          }
        }
      },
      "ContactPerson": {
        "type": "object",
        "description": "A contact person for an organization",
        "required": [
          "id",
          "email"
        ],
        "properties": {
          "id": {
            "type": "integer"
          },
          "email": {
            "type": "string",
            "format": "email"
          },
          "name": {
            "type": "string"
          },
          "phone": {
            "type": "string"
          },
          "note": {
            "type": "string"
          }
        }
      },
      "Organization": {
        "description": "An organization",
        "type": "object",
        "required": [
          "id",
          "parentId",
          "idp",
          "adminsCanCreateOrgsInSubtree",
          "adminsCanCreateProjectsInSubtree",
          "allowedClusters"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/OrgId"
          },
          "parentId": {
            "allOf": [
              {
                "description": "The ID of the parent organization"
              },
              {
                "$ref": "#/components/schemas/OrgId"
              }
            ]
          },
          "idp": {
            "$ref": "#/components/schemas/IdentityProvider"
          },
          "adminGroupId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExternalGroupId"
              },
              {
                "description": "The ID of the externally managed group that contains the organization's admins.",
                "default": null
              }
            ]
          },
          "adminsCanCreateOrgsInSubtree": {
            "type": "boolean",
            "description": "Whether admins of the new organization are allowed to create organizations in the subtree of the\norganization.",
            "default": false
          },
          "adminsCanCreateProjectsInSubtree": {
            "type": "boolean",
            "description": "Whether admins of the new organization are allowed to create CDF projects in the subtree of the\norganization.",
            "default": false
          },
          "allowedClusters": {
            "type": "array",
            "description": "The clusters on which the admins of the organization will be able to create projects.\nThis must be a (non-strict) subset of the `allowedClusters` set of the parent organization.",
            "default": [],
            "example": [
              "westeurope-1",
              "asia-northeast1-1"
            ],
            "items": {
              "$ref": "#/components/schemas/ClusterName"
            }
          }
        }
      },
      "OrganizationWithContactPersons": {
        "allOf": [
          {
            "$ref": "#/components/schemas/Organization"
          },
          {
            "description": "An organization"
          }
        ]
      },
      "ClustersListRequestResponse": {
        "type": "object",
        "required": [
          "clusters"
        ],
        "properties": {
          "clusters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClusterName"
            }
          }
        }
      },
      "ProjectCreateRequest": {
        "type": "object",
        "required": [
          "name",
          "clusterName"
        ],
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ProjectUrlName"
          },
          "clusterName": {
            "$ref": "#/components/schemas/ClusterName"
          },
          "projectAdminGroupId": {
            "allOf": [
              {
                "description": "The ID of the externally-managed group that contains the project's admins.\n\n- If omitted, the project will inherit the admin group ID of the organization under which it is created.\n  That value might be `null`.\n- If set to a (non-null) string, the project will have that group as its admin group, overriding\n  the organization's admin group ID.\n- If explicitly set to `null`, the project will not have an admin group ID. Note that this will make the\n  project inaccessible, and only a Cognite admin can make it accessible."
              },
              {
                "$ref": "#/components/schemas/NullableExternalGroupId"
              }
            ]
          }
        }
      },
      "ProjectResponse": {
        "type": "object",
        "required": [
          "name",
          "apiUrl"
        ],
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ProjectUrlName"
          },
          "apiUrl": {
            "$ref": "#/components/schemas/ProjectApiUrl"
          }
        }
      },
      "ProjectWithAdminPropertiesResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ProjectResponse"
          },
          {
            "type": "object",
            "required": [
              "clusterName",
              "state"
            ],
            "properties": {
              "clusterName": {
                "$ref": "#/components/schemas/ClusterName"
              },
              "state": {
                "$ref": "#/components/schemas/ProjectState"
              },
              "deletionTime": {
                "type": "integer",
                "description": "milliseconds since epoch",
                "format": "int64",
                "example": 1697194426715
              }
            }
          }
        ]
      },
      "ProjectInternalV0Response": {
        "type": "object",
        "required": [
          "name",
          "apiUrl"
        ],
        "properties": {
          "name": {
            "$ref": "#/components/schemas/ProjectUrlName"
          },
          "apiUrl": {
            "$ref": "#/components/schemas/ProjectApiUrl"
          },
          "dataModelingStatus": {
            "$ref": "#/components/schemas/DataModelingStatus"
          }
        }
      },
      "ProjectApiUrl": {
        "type": "string",
        "format": "url",
        "description": "The base API URL for the project",
        "example": "https://api.cognitedata.com"
      },
      "OrganizationRequestItem": {
        "type": "object",
        "required": [
          "id",
          "idp"
        ],
        "properties": {
          "id": {
            "allOf": [
              {
                "description": "The ID of the new organization",
                "example": "new-org"
              },
              {
                "$ref": "#/components/schemas/OrgId"
              }
            ]
          },
          "idp": {
            "$ref": "#/components/schemas/IdentityProvider"
          },
          "adminGroupId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExternalGroupId"
              },
              {
                "description": "The ID of the externally managed group that contains the organization's admins.",
                "default": null
              }
            ]
          },
          "adminsCanCreateOrgsInSubtree": {
            "type": "boolean",
            "description": "Whether admins of the new organization are allowed to create organizations in the subtree of the\norganization.",
            "default": false
          },
          "adminsCanCreateProjectsInSubtree": {
            "type": "boolean",
            "description": "Whether admins of the new organization are allowed to create CDF projects in the subtree of the\norganization.",
            "default": false
          },
          "allowedClusters": {
            "type": "array",
            "description": "The clusters on which the admins of the organization will be able to create projects.\nThis must be a (non-strict) subset of the `allowedClusters` set of the parent organization.",
            "default": [],
            "example": [
              "westeurope-1",
              "asia-northeast1-1"
            ],
            "items": {
              "$ref": "#/components/schemas/ClusterName"
            }
          }
        }
      },
      "OrganizationResponseItem": {
        "type": "object",
        "required": [
          "id",
          "idp"
        ],
        "properties": {
          "id": {
            "allOf": [
              {
                "description": "The ID of the new organization",
                "example": "new-org"
              },
              {
                "$ref": "#/components/schemas/OrgId"
              }
            ]
          },
          "idp": {
            "$ref": "#/components/schemas/IdentityProvider"
          },
          "adminGroupId": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ExternalGroupId"
              },
              {
                "description": "The ID of the externally managed group that contains the organization's admins.",
                "default": null
              }
            ]
          },
          "adminsCanCreateOrgsInSubtree": {
            "type": "boolean",
            "description": "Whether admins of the new organization are allowed to create organizations in the subtree of the\norganization.",
            "default": false
          },
          "adminsCanCreateProjectsInSubtree": {
            "type": "boolean",
            "description": "Whether admins of the new organization are allowed to create CDF projects in the subtree of the\norganization.",
            "default": false
          },
          "allowedClusters": {
            "type": "array",
            "description": "The clusters on which the admins of the organization will be able to create projects.\nThis must be a (non-strict) subset of the `allowedClusters` set of the parent organization.",
            "default": [],
            "example": [
              "westeurope-1",
              "asia-northeast1-1"
            ],
            "items": {
              "$ref": "#/components/schemas/ClusterName"
            }
          }
        }
      },
      "ProjectState": {
        "type": "string",
        "description": "The state field indicates the state of a project.\n\n- `ACTIVE`: The project is active.\n- `LOCKED`: The project is deleted but still within its grace period.\n- `DELETED`: The project and its resources are permanently deleted.\n",
        "enum": [
          "ACTIVE",
          "LOCKED",
          "DELETED"
        ],
        "default": "ACTIVE"
      },
      "PrincipalDto": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/ServiceAccountDto"
          },
          {
            "$ref": "#/components/schemas/UserDto"
          }
        ]
      },
      "BasePrincipalDto": {
        "type": "object",
        "description": "A principal",
        "required": [
          "id",
          "name",
          "pictureUrl"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/PrincipalId"
          },
          "name": {
            "$ref": "#/components/schemas/PrincipalName"
          },
          "pictureUrl": {
            "$ref": "#/components/schemas/PrincipalPictureUrl"
          }
        }
      },
      "PrincipalListByIdsRequestDto": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "minItems": 1,
            "maxItems": 100,
            "items": {
              "$ref": "#/components/schemas/ReferenceByIdOrExternalId"
            }
          },
          "ignoreUnknownIds": {
            "type": "boolean",
            "default": false,
            "description": "If `true`, IDs that do not match existing principals will be ignored.\n\nIf `false`, the request will fail if any of the IDs do not match existing principals.\nThis is the default behavior."
          }
        }
      },
      "ReferenceByIdOrExternalId": {
        "type": "object",
        "description": "Either a principal ID, or a principal external ID",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ReferenceById"
          },
          {
            "$ref": "#/components/schemas/ReferenceByExternalId"
          }
        ]
      },
      "ReferenceById": {
        "type": "object",
        "required": [
          "id"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/PrincipalId"
          }
        }
      },
      "ReferenceByExternalId": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "$ref": "#/components/schemas/CogniteExternalId"
          }
        }
      },
      "PrincipalsListResponseDto": {
        "type": "object",
        "required": [
          "items"
        ],
        "properties": {
          "items": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PrincipalDto"
            }
          }
        }
      },
      "PrincipalsListPaginatedDto": {
        "type": "object",
        "required": [
          "items",
          "nextCursor"
        ],
        "properties": {
          "items": {
            "type": "array",
            "maxLength": 100,
            "items": {
              "$ref": "#/components/schemas/PrincipalDto"
            }
          },
          "nextCursor": {
            "$ref": "#/components/schemas/Cursor/properties/cursor"
          }
        }
      },
      "ServiceAccountDto": {
        "allOf": [
          {
            "type": "object",
            "description": "A service account",
            "required": [
              "id",
              "type",
              "name",
              "createdBy",
              "createdTime",
              "lastUpdatedTime"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/ServiceAccountId"
              },
              "type": {
                "type": "string",
                "description": "Principal type",
                "enum": [
                  "SERVICE_ACCOUNT"
                ],
                "example": "SERVICE_ACCOUNT"
              },
              "externalId": {
                "$ref": "#/components/schemas/CogniteExternalId"
              },
              "name": {
                "$ref": "#/components/schemas/ServiceAccountName"
              },
              "description": {
                "$ref": "#/components/schemas/ServiceAccountDescription"
              },
              "createdBy": {
                "$ref": "#/components/schemas/ServiceAccountCreator"
              },
              "createdTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              },
              "lastUpdatedTime": {
                "$ref": "#/components/schemas/EpochTimestamp"
              }
            }
          },
          {
            "$ref": "#/components/schemas/BasePrincipalDto"
          }
        ]
      },
      "UserDto": {
        "allOf": [
          {
            "type": "object",
            "description": "A user",
            "required": [
              "id",
              "type",
              "name"
            ],
            "properties": {
              "id": {
                "$ref": "#/components/schemas/UserId"
              },
              "type": {
                "type": "string",
                "description": "Principal type",
                "enum": [
                  "USER"
                ],
                "example": "USER"
              },
              "name": {
                "type": "string",
                "example": "John N. Doe"
              },
              "email": {
                "type": "string",
                "format": "email",
                "description": "Do not use this to uniquely identify a user, as it can be changed and is not guaranteed to be unique.\nUse the `id` field instead."
              },
              "givenName": {
                "type": "string",
                "example": "John"
              },
              "middleName": {
                "type": "string",
                "example": "N."
              },
              "familyName": {
                "type": "string",
                "example": "Doe"
              }
            }
          },
          {
            "$ref": "#/components/schemas/BasePrincipalDto"
          }
        ]
      },
      "PrincipalType": {
        "type": "string",
        "enum": [
          "SERVICE_ACCOUNT",
          "USER"
        ],
        "description": "The type of a principal"
      },
      "PrincipalId": {
        "type": "string",
        "description": "Unique identifier of a principal",
        "example": "5yAFQRAATb7vtWGp4gvbJD3wE7VS81CGuQ7EZT"
      },
      "PrincipalPictureUrl": {
        "type": "string",
        "description": "URL to a picture of the principal",
        "format": "url"
      },
      "PrincipalName": {
        "type": "string",
        "description": "Human-readable name of the principal"
      },
      "ServiceAccountName": {
        "type": "string",
        "description": "Human-readable name of a service account",
        "minLength": 1,
        "maxLength": 50,
        "example": "My service account"
      },
      "ServiceAccountDescription": {
        "type": "string",
        "description": "Longer description of a service account",
        "maxLength": 500,
        "example": "This is a service account used by data pipeline A-xxx"
      },
      "ServiceAccountCreator": {
        "description": "The principal that created the entity.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/ServiceAccountCreatorUser"
          }
        ]
      },
      "ServiceAccountCreatorUser": {
        "type": "object",
        "description": "The user that created the entity.",
        "required": [
          "orgId",
          "userId"
        ],
        "properties": {
          "orgId": {
            "$ref": "#/components/schemas/OrgId"
          },
          "userId": {
            "$ref": "#/components/schemas/UserId"
          }
        }
      },
      "ServiceAccountId": {
        "type": "string",
        "description": "Unique identifier of a service account",
        "example": "5yAFQRAATb7vtWGp4gvbJD3wE7VS81CGuQ7EZT"
      }
    },
    "parameters": {
      "cdfversionheader": {
        "in": "header",
        "name": "cdf-version",
        "description": "cdf version header. Use this to specify the requested CDF release.",
        "schema": {
          "type": "string",
          "example": "alpha"
        }
      },
      "projectName": {
        "in": "path",
        "name": "projectName",
        "required": true,
        "description": "The CDF project name, equal to the project variable in the server URL.",
        "schema": {
          "type": "string",
          "example": "publicdata"
        }
      },
      "project": {
        "in": "path",
        "name": "project",
        "required": true,
        "description": "The CDF project name, equal to the project variable in the server URL.",
        "schema": {
          "type": "string",
          "example": "publicdata"
        }
      },
      "partition": {
        "in": "query",
        "name": "partition",
        "required": false,
        "description": "Splits the data set into `N` partitions.\nThe attribute is specified as a \"M/N\" string, where `M` is a natural number in the interval of `[1, N]`.\nYou need to follow the cursors within each partition in order to receive all the data.\n\nTo prevent unexpected problems and maximize read throughput, you should at most use 10 (N <= 10) partitions.\n\nWhen using more than 10 partitions, CDF may reduce the number of partitions silently.\nFor example, CDF may reduce the number of partitions to `K = 10` so if you specify an `X/N` `partition` value where `X = 8` and `N = 20` - i.e. `\"partition\": \"8/20\"`- then\nCDF will change `N` to `N = K = 10` and process the request.\nBut if you  specify the `X/N` `partition` value where `X = 11` (`X > K`) and `N = 20` - i.e. `\"partition\": \"11/20\"`- then\nCDF will reply with an empty result list and no cursor in the response.\n\nIn future releases of the resource APIs, Cognite may reject requests if you specify more than 10 partitions.\nWhen Cognite enforces this behavior, the requests will result in a 400 Bad Request status.\n",
        "schema": {
          "type": "string",
          "example": "1/10"
        }
      },
      "partitionLimited10": {
        "in": "query",
        "name": "partition",
        "required": false,
        "description": "Splits the data set into `N` partitions.\nThe attribute is specified as a \"M/N\" string, where `M` is a natural number in the interval of `[1, N]`.\nYou need to follow the cursors within each partition in order to receive all the data.\n\nThe maximum number of allowed partitions (`N`) is 10.\n\nCognite rejects requests if you specify more than 10 partitions.\nWhen Cognite enforces this behavior, the requests result in a 400 Bad Request status.\n",
        "schema": {
          "type": "string",
          "example": "1/3"
        }
      },
      "CogniteInternalId": {
        "in": "path",
        "name": "id",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "Offset": {
        "name": "offset",
        "description": "Offset from the first result. Sum of limit and offset must not exceed 1000.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 0,
          "minimum": 0,
          "maximum": 1000
        }
      },
      "Limit": {
        "name": "limit",
        "description": "Limits the number of results to be returned. The maximum results returned by the server is 1000 even if you specify a higher limit.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 1000
        }
      },
      "Cursor": {
        "name": "cursor",
        "description": "Cursor for paging through results.",
        "in": "query",
        "schema": {
          "type": "string",
          "example": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo"
        }
      },
      "IncludeMetadata": {
        "name": "includeMetadata",
        "in": "query",
        "description": "Whether the metadata field should be returned or not.",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "IncludeInheritedProperties": {
        "name": "includeInheritedProperties",
        "description": "Include properties inherited from views this view implements.",
        "in": "query",
        "schema": {
          "type": "boolean",
          "default": true
        }
      },
      "ReducedLimit": {
        "name": "limit",
        "description": "Limit the number of results returned. The largest result-set returned by the server will be 1000 items, even if you specify a higher limit.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 10,
          "minimum": 1,
          "maximum": 1000
        }
      },
      "Space": {
        "in": "query",
        "name": "space",
        "description": "The space to query.",
        "schema": {
          "type": "string",
          "pattern": "(?!^(space|cdf|dms|pg3|shared|system|node|edge)$)(^[a-zA-Z][a-zA-Z0-9_-]{0,41}[a-zA-Z0-9]?$)",
          "minLength": 1,
          "maxLength": 43,
          "example": "timeseries"
        }
      },
      "AllVersions": {
        "name": "allVersions",
        "in": "query",
        "description": "If all versions of the entity should be returned. Defaults to false which returns the latest version, attributed to the newest 'createdTime' field",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "InlineViews": {
        "name": "inlineViews",
        "in": "query",
        "description": "Should we expand the referenced views inline in the returned result.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "IncludeGlobal": {
        "name": "includeGlobal",
        "in": "query",
        "description": "If the global items of the entity should be returned. Defaults to false which excludes global items.",
        "schema": {
          "type": "boolean",
          "default": false
        }
      },
      "StreamId": {
        "name": "streamId",
        "in": "path",
        "description": "An identifier of the stream where the records are stored.\n",
        "required": true,
        "schema": {
          "type": "string",
          "pattern": "^[a-z]([a-z0-9_-]{0,98}[a-z0-9])?$",
          "minLength": 1,
          "maxLength": 100,
          "example": "test1"
        }
      },
      "Name": {
        "name": "name",
        "in": "query",
        "schema": {
          "$ref": "#/components/schemas/FileName"
        }
      },
      "callId": {
        "schema": {
          "type": "integer"
        },
        "name": "callId",
        "in": "path",
        "required": true,
        "description": "The function call id."
      },
      "functionId": {
        "schema": {
          "type": "integer"
        },
        "name": "functionId",
        "in": "path",
        "required": true,
        "description": "The function id."
      },
      "scheduleId": {
        "schema": {
          "type": "integer"
        },
        "name": "scheduleId",
        "in": "path",
        "required": true,
        "description": "The function schedule id."
      },
      "LimitQuery": {
        "name": "limit",
        "description": "Limits the number of results to be returned.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1
        }
      },
      "ModelId": {
        "name": "modelId",
        "in": "path",
        "description": "Model ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "RevisionId": {
        "name": "revisionId",
        "in": "path",
        "description": "Revision ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "AssetId": {
        "name": "assetId",
        "in": "path",
        "description": "Asset ID.",
        "required": true,
        "schema": {
          "type": "integer",
          "format": "int64"
        }
      },
      "modelId": {
        "in": "path",
        "name": "modelId",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/ModelId"
        }
      },
      "jobId": {
        "in": "path",
        "name": "jobId",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/JobId"
        }
      },
      "Limit100": {
        "name": "limit",
        "in": "query",
        "description": "Limits the number of results to be returned. The maximum results\nreturned by the server is 100, even if you specify a higher limit.",
        "schema": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100,
          "default": 100
        }
      },
      "PipelineId": {
        "name": "pipelineId",
        "in": "path",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "diagramId": {
        "name": "diagramId",
        "description": "Retrieve items related to the diagram",
        "in": "query",
        "schema": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "diagramIdPath": {
        "name": "diagramId",
        "description": "External ID of a diagram",
        "required": true,
        "in": "path",
        "schema": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "fileExternalId": {
        "name": "fileExternalId",
        "description": "Retrieve data related to a file",
        "required": true,
        "in": "path",
        "schema": {
          "type": "string"
        }
      },
      "fileId": {
        "name": "fileId",
        "description": "Internal ID of a file",
        "required": true,
        "in": "path",
        "schema": {
          "$ref": "#/components/schemas/CogniteInternalId"
        }
      },
      "fileSpace": {
        "name": "fileSpace",
        "description": "A DMS space where the files reside",
        "required": true,
        "in": "path",
        "schema": {
          "type": "string"
        }
      },
      "libraryIdPath": {
        "name": "libraryId",
        "description": "External ID of a library",
        "required": true,
        "in": "path",
        "schema": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "libraryIdQuery": {
        "name": "libraryId",
        "description": "Retrieve items related to this library",
        "in": "query",
        "schema": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "limit": {
        "name": "limit",
        "description": "Limits the number of results to be returned. The maximum number of results the server returns is 1000, even if you specify a higher limit.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 1000
        }
      },
      "pageNumber": {
        "name": "pageNumber",
        "description": "The file's page number",
        "required": true,
        "in": "path",
        "schema": {
          "type": "integer"
        }
      },
      "symbolId": {
        "name": "symbolId",
        "description": "Retrieve items related to the symbol",
        "in": "query",
        "schema": {
          "$ref": "#/components/schemas/CogniteExternalId"
        }
      },
      "geospatialFilterOnlyCustom": {
        "in": "query",
        "name": "filterOnlyCustom",
        "schema": {
          "type": "boolean",
          "example": true
        },
        "description": "Optional parameter to only list custom Coordinate Reference Systems. Defaults to false."
      },
      "geospatialRasterSrid": {
        "in": "query",
        "name": "srid",
        "required": true,
        "schema": {
          "type": "integer",
          "minimum": 1,
          "maximum": 999999,
          "example": 3857
        },
        "description": "mandatory parameter that specifies the SRID of the coordinate reference system of a raster."
      },
      "geospatialRasterInputFormat": {
        "in": "query",
        "name": "format",
        "required": true,
        "schema": {
          "type": "string",
          "enum": [
            "XYZ"
          ],
          "example": "XYZ"
        },
        "description": "mandatory parameter that specifies the format of the input raster."
      },
      "geospatialRasterPixelScaleX": {
        "in": "query",
        "name": "scaleX",
        "required": false,
        "schema": {
          "type": "number",
          "format": "double",
          "example": 2
        },
        "description": "optional parameter that specifies the pixel scale x in storage. If not specified, the pixel scale remains the same as the input raster."
      },
      "geospatialRasterPixelScaleY": {
        "in": "query",
        "name": "scaleY",
        "required": false,
        "schema": {
          "type": "number",
          "format": "double",
          "example": 2
        },
        "description": "optional parameter that specifies the pixel scale y in storage. If not specified, the pixel scale remains the same as the input raster."
      },
      "geospatialFeatureTypeExternalId": {
        "in": "path",
        "name": "featureTypeExternalId",
        "required": true,
        "schema": {
          "type": "string",
          "maxLength": 32,
          "pattern": "^[A-Za-z][A-Za-z0-9_]{0,31}$",
          "example": "ocean_measures"
        },
        "description": "External Id of the feature type provided by client. Must be unique among all feature type external ids within a CDF project."
      },
      "geospatialFeatureExternalId": {
        "in": "path",
        "name": "featureExternalId",
        "required": true,
        "schema": {
          "type": "string",
          "maxLength": 256,
          "pattern": "^[A-Za-z][A-Za-z0-9_]{0,255}$",
          "example": "ocean_measure_W87H62"
        },
        "description": "External Id of the type provided by client. Must be unique among all feature external ids within a CDF project and feature type."
      },
      "geospatialRasterPropertyName": {
        "in": "path",
        "name": "rasterPropertyName",
        "required": true,
        "schema": {
          "type": "string",
          "maxLength": 32,
          "pattern": "^[A-Za-z][A-Za-z0-9_]{0,31}$",
          "example": "bathymetry"
        },
        "description": "Raster Id of the raster property provided by client. Must be unique among all feature property names within a feature type."
      },
      "geospatialRasterAllowCrsTransformation": {
        "in": "query",
        "name": "allowCrsTransformation",
        "required": false,
        "schema": {
          "type": "boolean",
          "example": true
        },
        "description": "Optional parameter indicating if the input raster coordinates should be transformed into the Coordinate Reference Systems defined for the raster property in the feature type specification. The transformation will typically impact the pixel values. When the parameter is false, requests with rasters in Coordinate Reference System different from the ones defined in the feature type will result in bad request response code."
      },
      "AnnotationId": {
        "name": "annotationId",
        "in": "path",
        "required": true,
        "description": "The internal ID of the annotation",
        "schema": {
          "$ref": "#/components/schemas/AnnotationId"
        }
      },
      "seismicId": {
        "in": "path",
        "name": "seismicId",
        "required": true,
        "description": "The identifier of a seismic object",
        "schema": {
          "type": "integer"
        }
      },
      "100Limit": {
        "name": "limit",
        "description": "Limits the number of results to be returned. The maximum results returned by the server is 100 even if you specify a higher limit.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 100
        }
      },
      "100Limit_": {
        "name": "limit",
        "description": "Limits the number of results to be returned. The maximum results returned by the server is 100 even if you specify a higher limit.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 100
        }
      },
      "Username": {
        "name": "username",
        "description": "The name of the username (a.k.a. database) to be managed from the API",
        "in": "path",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/Username"
        }
      },
      "Writeback100Limit": {
        "name": "limit",
        "description": "Limits the number of results to be returned. The maximum results returned by the server is 100 even if you specify a higher limit.",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 100,
          "minimum": 1,
          "maximum": 100
        }
      },
      "OrgId": {
        "name": "org",
        "in": "path",
        "description": "ID of an organization",
        "required": true,
        "schema": {
          "$ref": "#/components/schemas/OrgId"
        }
      },
      "ListLimit": {
        "in": "query",
        "required": false,
        "name": "limit",
        "schema": {
          "type": "integer",
          "minimum": 1,
          "maximum": 100
        }
      },
      "PrincipalTypes": {
        "in": "query",
        "required": false,
        "name": "types",
        "description": "Filter by principal types.\nIf not specified, all principal types will be included.\nYou can filter by multiple types by providing a comma-separated list, or by repeating the parameter.",
        "schema": {
          "$ref": "#/components/schemas/PrincipalType"
        },
        "example": "USER,SERVICE_ACCOUNT"
      }
    },
    "responses": {
      "MissingField": {
        "description": "Missing required fields.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "description": "Some required fields are missing.",
              "required": [
                "code",
                "message",
                "missingFields"
              ],
              "properties": {
                "code": {
                  "type": "integer",
                  "description": "HTTP status code.",
                  "format": "int32",
                  "example": 400
                },
                "message": {
                  "type": "string",
                  "description": "Error message."
                },
                "missingFields": {
                  "uniqueItems": true,
                  "type": "array",
                  "description": "Fields that are missing.",
                  "items": {
                    "type": "object",
                    "description": "Fields that are missing."
                  }
                }
              }
            }
          }
        }
      },
      "EmptyResponse": {
        "description": "Empty response.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "ErrorResponse": {
        "description": "The response for a failed request.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            }
          }
        }
      },
      "400ErrorResponse": {
        "description": "The response for a bad request.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/Error"
                }
              }
            },
            "example": {
              "error": {
                "code": 400,
                "message": "`null` values aren't allowed."
              }
            }
          }
        }
      },
      "429ErrorResponse": {
        "description": "The response for too many requests (concurrency or rate throttling).",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/429Error"
                }
              }
            },
            "example": {
              "error": {
                "code": 429,
                "message": "Project exceeded maximum number='50' of concurrent requests. Please try again later."
              }
            }
          }
        }
      },
      "AggregateResponse": {
        "description": "Response with a list of aggregation results.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AggregateResult"
            }
          }
        }
      },
      "AssetDataWithCursorResponse": {
        "description": "Paged response with list of assets.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataWithCursorAsset"
            }
          }
        }
      },
      "AssetDataResponse": {
        "description": "Response with list of assets.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataAsset"
            }
          }
        }
      },
      "AssetResponse": {
        "description": "Response with a single asset.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Asset"
            }
          }
        }
      },
      "SearchResponse": {
        "description": "Search query results",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of nodes and edges",
                  "items": {
                    "$ref": "#/components/schemas/NodeOrEdge"
                  }
                },
                "typing": {
                  "$ref": "#/components/schemas/TypeInformationOuter"
                }
              }
            }
          }
        }
      },
      "AggregationResponse": {
        "description": "Aggregated query results",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/AggregatedResultItemCollection"
                },
                {
                  "type": "object",
                  "properties": {
                    "typing": {
                      "$ref": "#/components/schemas/TypeInformationOuter"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "AggregationResponseV2": {
        "description": "Aggregated query results",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "aggregates"
              ],
              "properties": {
                "typing": {
                  "$ref": "#/components/schemas/TypeInformationOuter"
                },
                "aggregates": {
                  "$ref": "#/components/schemas/AggregatesResultDefinition"
                }
              }
            }
          }
        }
      },
      "ByIdsResponse": {
        "description": "List of matching nodes and edges",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of nodes and edges",
                  "items": {
                    "$ref": "#/components/schemas/NodeOrEdge"
                  }
                },
                "typing": {
                  "$ref": "#/components/schemas/TypeInformationOuter"
                }
              }
            }
          }
        }
      },
      "QueryResponse": {
        "description": "Matching nodes and edges",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items",
                "nextCursor"
              ],
              "properties": {
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "x-additionalPropertiesName": "result-expression",
                    "allOf": [
                      {
                        "type": "array",
                        "description": "List of nodes or edges",
                        "items": {
                          "$ref": "#/components/schemas/NodeOrEdge"
                        }
                      }
                    ]
                  }
                },
                "typing": {
                  "type": "object",
                  "description": "Property type information for selected result expressions.",
                  "additionalProperties": {
                    "x-additionalPropertiesName": "result-expression",
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/TypeInformationOuter"
                      }
                    ]
                  }
                },
                "nextCursor": {
                  "type": "object",
                  "additionalProperties": {
                    "x-additionalPropertiesName": "cursor-name",
                    "allOf": [
                      {
                        "type": "string",
                        "description": "The value to use for the cursor"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "InstanceInspectResponse": {
        "description": "Instances along with which containers/views they are associated with",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of instance inspection results",
                  "items": {
                    "$ref": "#/components/schemas/InstanceInspectResultItem"
                  }
                }
              }
            }
          }
        }
      },
      "SlimNodeAndEdgeCollectionResponse": {
        "description": "Created or updated nodes and edges",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of nodes and edges that were created or updated",
                  "items": {
                    "$ref": "#/components/schemas/SlimNodeOrEdge"
                  }
                }
              }
            }
          }
        }
      },
      "NodeAndEdgeCollectionResponseWithCursorV3": {
        "description": "List of matching nodes and edges",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of nodes and edges",
                  "items": {
                    "$ref": "#/components/schemas/NodeOrEdge"
                  }
                },
                "typing": {
                  "$ref": "#/components/schemas/TypeInformationOuter"
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "DataModelCollectionResponse": {
        "description": "List of data models",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of data models",
                  "items": {
                    "$ref": "#/components/schemas/DataModel"
                  }
                }
              }
            }
          }
        }
      },
      "DataModelCollectionResponseWithCursor": {
        "description": "List of data models",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of data models",
                  "items": {
                    "$ref": "#/components/schemas/DataModel"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "ViewCollectionResponse": {
        "description": "List of views",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of views",
                  "items": {
                    "$ref": "#/components/schemas/ViewDefinition"
                  }
                }
              }
            }
          }
        }
      },
      "ViewCollectionResponseWithCursor": {
        "description": "List of views",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of views",
                  "items": {
                    "$ref": "#/components/schemas/ViewDefinition"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "ContainerCollectionResponse": {
        "description": "List of containers",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of containers",
                  "items": {
                    "$ref": "#/components/schemas/ContainerDefinition"
                  }
                }
              }
            }
          }
        }
      },
      "ContainerCollectionResponseWithCursor": {
        "description": "List of containers",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of containers",
                  "items": {
                    "$ref": "#/components/schemas/ContainerDefinition"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "ContainerInspectResponse": {
        "description": "Containers along with the results of the inspection operations",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of container inspection results",
                  "items": {
                    "$ref": "#/components/schemas/ContainerInspectResultItem"
                  }
                }
              }
            }
          }
        }
      },
      "SpaceCollectionResponseV3": {
        "description": "List of spaces",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of spaces",
                  "items": {
                    "$ref": "#/components/schemas/SpaceDefinition"
                  }
                }
              }
            }
          }
        }
      },
      "SpaceCollectionResponseWithCursor": {
        "description": "List of spaces",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "List of spaces",
                  "items": {
                    "$ref": "#/components/schemas/SpaceDefinition"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "NodeOrEdgeDeleteResponse": {
        "description": "Nodes or edges that were deleted",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1000,
                  "items": {
                    "type": "object",
                    "required": [
                      "instanceType",
                      "space",
                      "externalId"
                    ],
                    "properties": {
                      "instanceType": {
                        "description": "Is the deleted item a node or an edge",
                        "type": "string",
                        "enum": [
                          "node",
                          "edge"
                        ]
                      },
                      "externalId": {
                        "description": "External id for the requested item",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/NodeOrEdgeExternalId"
                          }
                        ]
                      },
                      "space": {
                        "description": "The space that the node or edge belongs to",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/SpaceSpecification"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "VersionReferencesCollectionResponse": {
        "description": "Items affected by the request",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "type": "object",
                    "required": [
                      "space",
                      "externalId",
                      "version"
                    ],
                    "properties": {
                      "externalId": {
                        "description": "External id for the requested item",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/DMSExternalId"
                          }
                        ]
                      },
                      "space": {
                        "description": "Space the requested item belongs to",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/SpaceSpecification"
                          }
                        ]
                      },
                      "version": {
                        "description": "Version of the requested item",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/DMSVersion"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "ListOfSpaceIdsResponse": {
        "description": "List of space id(s) affected by the request",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "type": "object",
                    "required": [
                      "space"
                    ],
                    "properties": {
                      "space": {
                        "description": "List of space ids for the requested item(s)",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/SpaceSpecification"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "ListOfSpaceExternalIdsResponse": {
        "description": "List of External id(s) for the affected items",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "type": "object",
                    "required": [
                      "space",
                      "externalId"
                    ],
                    "properties": {
                      "externalId": {
                        "description": "List of external id(s) for the requested items",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/DMSExternalId"
                          }
                        ]
                      },
                      "space": {
                        "$ref": "#/components/schemas/SpaceSpecification"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "ListOfContainerSubObjectIdentifierResponse": {
        "description": "List of External id(s) for the affected items",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "space",
                      "containerExternalId",
                      "identifier"
                    ],
                    "properties": {
                      "space": {
                        "$ref": "#/components/schemas/SpaceSpecification"
                      },
                      "containerExternalId": {
                        "description": "External id of the container",
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/DMSExternalId"
                          }
                        ]
                      },
                      "identifier": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "RecordsIngestResponse": {
        "description": "Empty response in the case of a successful accepting all records form the ingestion request.\n",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "title": "emptyResponse",
              "description": "Empty JSON object indicates all records are successfully accepted.\n"
            }
          }
        }
      },
      "RecordsIngestPartialSuccessResponse": {
        "description": "List of statuses for records ingestion request in the case of a partial success records ingestion.\n",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "title": "emptyResponse",
              "description": "Currently, empty result in the case of a success records ingestion.\n",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "title": "statusItems",
                  "description": "List of record ingestion statuses.\n",
                  "items": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/RecordStatus"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "RecordsFilterResponse": {
        "description": "List of matching records.\n",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "title": "recordItems",
                  "description": "List of records.\n",
                  "items": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Record"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "RecordsAggregationResponse": {
        "description": "Aggregated query results.\n",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "aggregates"
              ],
              "properties": {
                "aggregates": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/AggregatesResultDefinitionIla"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "RecordsSyncResponse": {
        "description": "The next chunk of matching the filter records starting from the cursor in the request.\n",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items",
                "hasNext"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "title": "recordItems",
                  "description": "List of records.\n",
                  "items": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/Record"
                      }
                    ]
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "title": "nextCursor",
                  "description": "A cursor to use in the next request as a starting point to get the next chunk of records.\n",
                  "example": "c29tZSBjdXJzb3I="
                },
                "hasNext": {
                  "type": "boolean",
                  "title": "hasNext",
                  "description": "The attribute indicates if there are more records to read in the storage or the cursor points to the last item.\n",
                  "example": true
                }
              }
            }
          }
        }
      },
      "EventDataResponse": {
        "description": "Paged response with list of events",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EventResponse"
            }
          }
        }
      },
      "EventAggregateResponse": {
        "description": "Response with list of event aggregations",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataEventAggregate"
            }
          }
        }
      },
      "EventResponse": {
        "description": "response with list of events",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Event"
            }
          }
        }
      },
      "EventDataWithCursorResponse": {
        "description": "Paged response with list of events",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/EventWithCursorResponse"
            }
          }
        }
      },
      "FileMetadataResponse": {
        "description": "The response for a successful GET files/id operation",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FilesMetadata"
            }
          }
        }
      },
      "UploadFileMetadataResponse": {
        "description": "The response for a successful files operation",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataFileUploadFileMetadata"
            }
          }
        }
      },
      "MultiPartUploadFileMetadataResponse": {
        "description": "The response for a successful request to initiate upload of multiple parts for a file.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataMultiPartUploadFileMetadata"
            }
          }
        }
      },
      "FileMetadataWithCursorResponse": {
        "description": "The response for a successful files/list operation",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataWithCursor"
            }
          }
        }
      },
      "FileResponse": {
        "description": "The response for a successful files/byids, files/search or files/update operation",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataFileMetadata"
            }
          }
        }
      },
      "DataWithLinks": {
        "description": "The response for a successful files/downloadlink operation.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/FileLink"
                      },
                      {
                        "$ref": "#/components/schemas/FileIdEither"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "FilesAggregateResponse": {
        "description": "Response with files aggregates.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataFilesAggregate"
            }
          }
        }
      },
      "FunctionScheduleDataResponse": {
        "description": "Input data to the associated function.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                },
                "data": {
                  "$ref": "#/components/schemas/data"
                }
              }
            }
          }
        }
      },
      "FunctionCallResponse": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "functionId",
                "callId"
              ],
              "description": "The function response.",
              "properties": {
                "response": {
                  "type": "object"
                },
                "functionId": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                },
                "callId": {
                  "$ref": "#/components/schemas/CogniteInternalId"
                }
              }
            },
            "examples": {
              "Function response example": {
                "value": {
                  "response": {
                    "numAssets": 1234,
                    "someCalculation": 3.14
                  }
                }
              }
            }
          }
        }
      },
      "FunctionScheduleCreated": {
        "description": "Created",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionSchedule"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionScheduleList": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionSchedule"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionCalled": {
        "description": "Created",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCall"
            }
          }
        }
      },
      "FunctionCallLog": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FunctionCallLogEntry"
                  }
                }
              }
            },
            "examples": {
              "Example response": {
                "value": {
                  "items": [
                    {
                      "timestamp": 1585350274000,
                      "message": "Did do fancy thing"
                    },
                    {
                      "timestamp": 1585350276000,
                      "message": "Did do another fancy thing"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "FunctionCallList": {
        "description": "List of function calls.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCalls"
            }
          }
        }
      },
      "FunctionCallListWithCursor": {
        "description": "Paged response with list of function calls.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/FunctionCallsWithCursor"
            }
          }
        }
      },
      "FunctionList": {
        "description": "List of functions.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Function"
                  }
                }
              }
            }
          }
        }
      },
      "FunctionsLimits": {
        "description": "Limits",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "timeoutMinutes",
                "cpuCores",
                "memoryGb",
                "runtimes",
                "responseSizeMb"
              ],
              "properties": {
                "timeoutMinutes": {
                  "type": "integer",
                  "description": "Timeout of each function call.",
                  "example": 9
                },
                "cpuCores": {
                  "$ref": "#/components/schemas/CPURange"
                },
                "memoryGb": {
                  "$ref": "#/components/schemas/MemoryRange"
                },
                "runtimes": {
                  "type": "array",
                  "description": "Available runtimes. For example, runtime \"py38\" translates to the latest version of the Python 3.8 series.",
                  "items": {
                    "type": "string"
                  },
                  "example": [
                    "py38",
                    "py39",
                    "py310",
                    "py311"
                  ]
                },
                "responseSizeMb": {
                  "type": "integer",
                  "description": "Maximum response size of function calls.",
                  "example": 1
                }
              }
            }
          }
        }
      },
      "FunctionsActivation": {
        "description": "Functions activation status",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "status"
              ],
              "properties": {
                "status": {
                  "type": "string",
                  "description": "Signifies whether Cognite Functions have been requested or activated for the project. Set to inactive by default.",
                  "enum": [
                    "inactive",
                    "requested",
                    "activated"
                  ]
                }
              }
            }
          }
        }
      },
      "ProjectCreationResponse": {
        "description": "Information on the projects created",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "name",
                "urlName"
              ],
              "properties": {
                "name": {
                  "$ref": "#/components/schemas/ProjectName"
                },
                "urlName": {
                  "$ref": "#/components/schemas/ProjectUrlName"
                },
                "oidcConfiguration": {
                  "$ref": "#/components/schemas/OidcConfigurationDTO"
                },
                "userProfilesConfiguration": {
                  "$ref": "#/components/schemas/UserProfilesConfigurationDTO"
                }
              }
            }
          }
        }
      },
      "ProjectResponse": {
        "description": "Information about the project.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "name",
                "urlName",
                "userProfilesConfiguration"
              ],
              "properties": {
                "name": {
                  "$ref": "#/components/schemas/ProjectName"
                },
                "urlName": {
                  "$ref": "#/components/schemas/ProjectUrlName"
                },
                "oidcConfiguration": {
                  "$ref": "#/components/schemas/OidcConfigurationDTO"
                },
                "userProfilesConfiguration": {
                  "$ref": "#/components/schemas/UserProfilesConfigurationDTO"
                }
              }
            }
          }
        }
      },
      "ProjectListResponse": {
        "description": "List of projects",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "description": "Information about a project.",
                    "type": "object",
                    "required": [
                      "urlName"
                    ],
                    "properties": {
                      "urlName": {
                        "$ref": "#/components/schemas/ProjectUrlName"
                      },
                      "dataModelingStatus": {
                        "allOf": [
                          {
                            "$ref": "#/components/schemas/DataModelingStatus"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "DataSetListResponse": {
        "description": "A list of data sets.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataSetList"
            }
          }
        }
      },
      "DataSetFilterResponse": {
        "description": "A list of data sets.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataSetListWithCursor"
            }
          }
        }
      },
      "DataSetAggregateResponse": {
        "description": "Response with list of data set aggregations",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/DataDataSetAggregate"
            }
          }
        }
      },
      "LabelDefinitionCreateResponse": {
        "description": "A list of label definitions.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/LabelDefinitionCreateList"
            }
          }
        }
      },
      "LabelDefinitionListResponse": {
        "description": "A list of label definitions.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/LabelDefinitionList"
            }
          }
        }
      },
      "generalError": {
        "description": "General error object.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/generalErrorWrapper"
            }
          }
        }
      },
      "400GeneralError": {
        "description": "Bad request error. Typically issued if relationships in a create request have illegal/unsupported values.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/generalErrorWrapper"
            }
          }
        }
      },
      "409GeneralError": {
        "description": "Conflict error. Typically issued if external IDs on any relationship already exists, or if there are duplicate external IDs in the request itself.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/generalErrorWrapper"
            }
          }
        }
      },
      "persistedRelationships": {
        "description": "Relationships stored by CDF.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/relationshipResponseWrapper"
            }
          }
        }
      },
      "enrichedPersistedRelationships": {
        "description": "Relationships stored by CDF.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/enrichedRelationshipResponseWrapper"
            }
          }
        }
      },
      "pagedPersistedRelationships": {
        "description": "One page of relationships stored by CDF.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/pagedRelationshipResponseWrapper"
            }
          }
        }
      },
      "pagedEnrichedPersistedRelationships": {
        "description": "One page of relationships stored by CDF.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/pagedEnrichedRelationshipResponseWrapper"
            }
          }
        }
      },
      "emptyDeleteResponse": {
        "description": "Empty response for deleting relationships.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "filteredRelationships": {
        "description": "One page of relationships stored by CDF that match the provided filter.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/pagedEnrichedRelationshipResponseWrapper"
            }
          }
        }
      },
      "PipelineCreatedResponse": {
        "description": "Created pipelines",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PipelineCreatedItem"
                  }
                }
              }
            }
          }
        }
      },
      "PipelineListResponse": {
        "description": "List of pipelines",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PipelineResponseItem"
                  }
                }
              }
            }
          }
        }
      },
      "PipelineUpdatedResponse": {
        "description": "Updated pipelines",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PipelineCreatedItem"
                  }
                }
              }
            }
          }
        }
      },
      "PipelineCursoredListResponse": {
        "description": "List of pipelines",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PipelineResponseItem"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextPageCursor"
                }
              }
            }
          }
        }
      },
      "PipelineResponse": {
        "description": "Single pipeline",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PipelineResponseItem"
            }
          }
        }
      },
      "PipelineRunResponse": {
        "description": "Run job for a pipeline",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PipelineRunItem"
            }
          }
        }
      },
      "PipelineRunCursoredListResponse": {
        "description": "List of pipeline runs",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PipelineRunItem"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextPageCursor"
                }
              }
            }
          }
        }
      },
      "PipelineRunWithResultsResponse": {
        "description": "Results of a pipeline run",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/PipelineRunItemWithResults"
                },
                {
                  "type": "object",
                  "properties": {
                    "status": {
                      "example": "Completed"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "ConnectionsListResponse": {
        "description": "List of connections",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConnectionDto"
                  }
                }
              }
            }
          }
        }
      },
      "ConnectionsListWithCursorResponse": {
        "description": "List of connections with next cursor",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConnectionDto"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "InstantParsingResponse": {
        "description": "Temporary diagram entity detections in a given file based on the provided library.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/InstantParseResult"
            }
          }
        }
      },
      "DiagramsListResponse": {
        "description": "List of diagrams",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DiagramDto"
                  }
                }
              }
            }
          }
        }
      },
      "DiagramsListWithCursorResponse": {
        "description": "List of diagrams with next cursor",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DiagramDto"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "ExtendedDiagramResponse": {
        "description": "A single diagram with its entities and connections",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ExtendedDiagramDto"
            }
          }
        }
      },
      "ExtendedDiagramWithPathsResponse": {
        "description": "Diagram with its entities, connections, and SVG paths data",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ExtendedDiagramWithPathsDto"
            }
          }
        }
      },
      "GeometriesListResponse": {
        "description": "List of geometries",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GeometryDto"
                  }
                }
              }
            }
          }
        }
      },
      "GeometriesListWithCursorResponse": {
        "description": "List of geometries with next cursor",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GeometryDto"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "CopyLibraryResponse": {
        "description": "The copied library with its symbols and geometries",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ExtendedLibraryDto"
            }
          }
        }
      },
      "ExtendedLibraryResponse": {
        "description": "A single library with its symbols and geometries",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ExtendedLibraryDto"
            }
          }
        }
      },
      "LibrariesListResponse": {
        "description": "List of libraries",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LibraryDto"
                  }
                }
              }
            }
          }
        }
      },
      "LibrariesListWithCursorResponse": {
        "description": "List of libraries with next cursor",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/LibraryDto"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "EntitiesListResponse": {
        "description": "List of diagram entities",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/EntityDto"
                  }
                }
              }
            }
          }
        }
      },
      "EntitiesListWithCursorResponse": {
        "description": "List of diagram entities with next cursor",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/EntityDto"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "SymbolsListResponse": {
        "description": "List of symbols",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SymbolDto"
                  }
                }
              }
            }
          }
        }
      },
      "SymbolsListWithCursorResponse": {
        "description": "List of symbols with next cursor",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/SymbolDto"
                  }
                },
                "nextCursor": {
                  "$ref": "#/components/schemas/NextCursorV3"
                }
              }
            }
          }
        }
      },
      "GetSVGDataResponse": {
        "description": "The SVG data for a file",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/SvgData"
            }
          }
        }
      },
      "ExternalIdsResponse": {
        "description": "List of external IDs returned in a response",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "$ref": "#/components/schemas/CogniteExternalId"
                  }
                }
              }
            }
          }
        }
      },
      "VisionExtractPostResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "features"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "description": "List of files to be analyzed by the feature extractors.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/VisionAllOfFileId"
                      }
                    },
                    "features": {
                      "type": "array",
                      "description": "The type of detections to perform. New feature extractors may appear.",
                      "uniqueItems": true,
                      "minimum": 1,
                      "maximum": 3,
                      "items": {
                        "$ref": "#/components/schemas/VisionExtractFeature"
                      },
                      "example": [
                        "TextDetection",
                        "AssetTagDetection",
                        "PeopleDetection"
                      ]
                    },
                    "parameters": {
                      "$ref": "#/components/schemas/FeatureParameters"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "VisionExtractGetResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of file IDs and their corresponding predictions.",
                      "items": {
                        "$ref": "#/components/schemas/VisionExtractItem"
                      }
                    },
                    "failedItems": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/FailedBatch"
                      }
                    },
                    "parameters": {
                      "$ref": "#/components/schemas/FeatureParameters"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "VisionSegmentPostResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "anyOf": [
                    {
                      "required": [
                        "points"
                      ]
                    },
                    {
                      "required": [
                        "boundingBox"
                      ]
                    }
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "description": "List of files to be analyzed by the feature extractors.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/VisionAllOfFileId"
                      }
                    },
                    "points": {
                      "type": "array",
                      "description": "Prompt points.",
                      "uniqueItems": true,
                      "items": {
                        "$ref": "#/components/schemas/SegmentPoint"
                      }
                    },
                    "boundingBox": {
                      "$ref": "#/components/schemas/SegmentBoundingBox"
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "VisionSegmentGetResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "prompt"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of file IDs and their corresponding predictions.",
                      "items": {
                        "$ref": "#/components/schemas/VisionSegmentItem"
                      }
                    },
                    "prompt": {
                      "type": "object",
                      "description": "Input prompt used to segment the image.",
                      "anyOf": [
                        {
                          "required": [
                            "points"
                          ]
                        },
                        {
                          "required": [
                            "boundingBox"
                          ]
                        }
                      ],
                      "properties": {
                        "points": {
                          "type": "array",
                          "description": "Prompt points.",
                          "uniqueItems": true,
                          "items": {
                            "$ref": "#/components/schemas/SegmentPoint"
                          }
                        },
                        "boundingBox": {
                          "$ref": "#/components/schemas/SegmentBoundingBox"
                        }
                      }
                    },
                    "failedItems": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/FailedBatch"
                      }
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "VisionSegmentEmbeddingPostResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items",
                    "points"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "description": "List of files to be analyzed by the feature extractors.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/VisionAllOfFileId"
                      }
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "VisionSegmentEmbeddingGetResponse": {
        "description": "Success",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "allOf": [
                {
                  "$ref": "#/components/schemas/StatusSchema"
                },
                {
                  "type": "object",
                  "required": [
                    "jobId",
                    "items"
                  ],
                  "properties": {
                    "jobId": {
                      "$ref": "#/components/schemas/JobId"
                    },
                    "items": {
                      "type": "array",
                      "description": "List of file IDs and their corresponding predictions.",
                      "items": {
                        "$ref": "#/components/schemas/VisionSegmentEmbeddingItem"
                      }
                    }
                  }
                }
              ]
            }
          }
        }
      },
      "DocumentSearchResponse": {
        "description": "The results of a search.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentSearchItem"
                  }
                },
                "aggregates": {
                  "deprecated": true,
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentSearchAggregate"
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available). The search endpoint only gives a limited number of results. A missing nextCursor does not imply there are no more results for the provided search."
                }
              }
            }
          }
        }
      },
      "DocumentSemanticSearchResponse": {
        "description": "List of most relevant document passages for a given query. The results are sorted by relevance, and contains metadata such as page numbers.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentSemanticSearchItem"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentPassagesSearchResponse": {
        "description": "List of most relevant document passages for a given query. The results are sorted by relevance, and contains metadata such as page numbers.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentPassagesSearchItem"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentStatusResponse": {
        "description": "List of documents and their status to signify if they are ready for search.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentStatusItem"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentStatusDeprecatedResponse": {
        "description": "List of documents and their status to signify if they are ready for search.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/DocumentStatusItemOld"
                  }
                }
              }
            }
          }
        }
      },
      "DocumentsAggregateResponse": {
        "description": "The results of an aggregation request. The object returned depends on the aggregate specified.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "oneOf": [
                {
                  "$ref": "#/components/schemas/DocumentsAggregateCountResponse"
                },
                {
                  "$ref": "#/components/schemas/DocumentsAggregateCardinalityValuesResponse"
                },
                {
                  "$ref": "#/components/schemas/DocumentsAggregateCardinalityPropertiesResponse"
                },
                {
                  "$ref": "#/components/schemas/DocumentsAggregateUniqueValuesResponse"
                },
                {
                  "$ref": "#/components/schemas/DocumentsAggregateUniquePropertiesResponse"
                },
                {
                  "$ref": "#/components/schemas/DocumentsAggregateAllUniquePropertiesResponse"
                },
                {
                  "$ref": "#/components/schemas/DocumentsAggregateAllUniqueValuesResponse"
                }
              ]
            }
          }
        }
      },
      "DocumentListResponse": {
        "description": "One page of document list results.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Document"
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available)."
                }
              }
            }
          }
        }
      },
      "DocumentsPreviewTemporaryLinkResponse": {
        "description": "OK",
        "content": {
          "application/json": {
            "schema": {
              "description": "A temporary link to download a preview of the document. The link is reachable without additional authentication details for a limited time.\n",
              "type": "object",
              "required": [
                "temporaryLink",
                "expirationTime"
              ],
              "properties": {
                "temporaryLink": {
                  "type": "string"
                },
                "expirationTime": {
                  "example": 1519862400000,
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/EpochTimestamp"
                    }
                  ]
                }
              }
            }
          }
        }
      },
      "DocumentElementsResponse": {
        "description": "Parsed textual content for the document",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "elements"
              ],
              "properties": {
                "elements": {
                  "$ref": "#/components/schemas/DocumentElements"
                }
              }
            }
          }
        }
      },
      "GeospatialErrorResponse": {
        "description": "Failed request reponse.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/GeospatialError"
                }
              }
            }
          }
        }
      },
      "GeospatialFeatureTypesResponse": {
        "description": "Feature type list response.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialFeatureTypes"
            },
            "examples": {
              "FeatureTypesExample": {
                "$ref": "#/components/examples/GeospatialFeatureTypesResponseExample"
              }
            }
          }
        }
      },
      "GeospatialFeaturesResponse": {
        "description": "Feature list response.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialFeatures"
            },
            "examples": {
              "GeospatialFeaturesResponseExample": {
                "$ref": "#/components/examples/GeospatialFeaturesResponseExample"
              }
            }
          }
        }
      },
      "GeospatialFeaturesWithCursorResponse": {
        "description": "Feature list response.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialFeaturesWithCursor"
            },
            "examples": {
              "GeospatialFeaturesResponseExample": {
                "$ref": "#/components/examples/GeospatialFeaturesWithCursorResponseExample"
              }
            }
          }
        }
      },
      "GeospatialCoordinateReferenceSystemResponse": {
        "description": "Coordinate reference system list response.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialCoordinateReferenceSystemList"
            },
            "examples": {
              "GeospatialCoordinateReferenceSystemResponseExample": {
                "$ref": "#/components/examples/GeospatialCoordinateReferenceSystemResponseExample"
              }
            }
          }
        }
      },
      "GeospatialCustomCoordinateReferenceSystemResponse": {
        "description": "Custom coordinate reference system list response.",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GeospatialCustomCoordinateReferenceSystem"
                  }
                }
              }
            }
          }
        }
      },
      "GeospatialFeatureSearchResponse": {
        "description": "The feature search response.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialFeatureSearchResult"
            },
            "examples": {
              "GeospatialFeaturesResponseExample": {
                "$ref": "#/components/examples/GeospatialFeaturesResponseExample"
              }
            }
          }
        }
      },
      "GeospatialFeatureSearchStreamingResponse": {
        "description": "The feature search streaming response - it can be length prefixed, new line delimited, record separator delimited or concatenated depending on requested output.\n",
        "content": {
          "application/json-seq": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialFeature"
            }
          }
        }
      },
      "GeospatialFeatureAggregateResponse": {
        "description": "The aggregate feature response. The present fields in the response body correspond to requested aggregations.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialFeatureAggregates"
            },
            "examples": {
              "GeospatialFeatureAggregateResponseExample": {
                "$ref": "#/components/examples/GeospatialFeatureAggregateResponseExample"
              }
            }
          }
        }
      },
      "GeospatialComputeResponse": {
        "description": "Compute response.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialComputedItems"
            },
            "examples": {
              "GeospatialComputeResponseExample": {
                "$ref": "#/components/examples/GeospatialComputeResponseExample"
              }
            }
          }
        }
      },
      "GeospatialRasterMetadataResponse": {
        "description": "The raster metadata.\n",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/GeospatialRasterMetadata"
            },
            "examples": {
              "GeospatialFeatureTasterMetadataResponseExample": {
                "$ref": "#/components/examples/GeospatialRasterMetadataResponseExample"
              }
            }
          }
        }
      },
      "AnnotationsV2CreateResponseSchema": {
        "description": "Successful creation",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ListResponseSchema": {
        "description": "Successful retrieval",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ResponseSchema": {
        "description": "Successful retrieval",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2CursoredListResponseSchema": {
        "description": "Successful retrieval",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2CursoredListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2UpdateResponseSchema": {
        "description": "Successful update",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ListResponseSchema"
            }
          }
        }
      },
      "AnnotationsV2ReverseLookupSchema": {
        "description": "Successful reverse lookup of annotated resource ids",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/AnnotationsV2ReverseLookupResponseSchema"
            }
          }
        }
      },
      "DownloadSeismicResponse": {
        "description": "The generated SEG-Y file",
        "content": {
          "application/octet-stream": {
            "schema": {
              "type": "string",
              "format": "binary/segy"
            }
          }
        }
      },
      "UserListResponseDto": {
        "description": "A list of organization users",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/UserListResponse"
            }
          }
        }
      },
      "PrincipalProfileDto": {
        "description": "Principal's profile data",
        "content": {
          "application/json": {
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/UserPrincipal"
                },
                {
                  "$ref": "#/components/schemas/ServicePrincipal"
                }
              ]
            }
          }
        }
      },
      "ValidationError": {
        "description": "Validation Error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/ValidationErrorContent"
                }
              }
            }
          }
        }
      },
      "ValidationError_": {
        "description": "Validation Error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/ValidationErrorContent_"
                }
              }
            }
          }
        }
      },
      "WritebackValidationError": {
        "description": "Validation Error",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/WritebackValidationErrorContent"
                }
              }
            }
          }
        }
      },
      "ConnectionCheck": {
        "description": "Connection Check Result",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/ConnectionCheckContent"
                }
              }
            }
          }
        }
      },
      "UserPreferencesResponse": {
        "description": "Response with user preferences.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/UserPreferencesRead"
            }
          }
        }
      },
      "LocationFilterResponse": {
        "description": "Response with a single location filter.",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/LocationFilterRead"
            }
          }
        }
      },
      "LocationFilterListResponse": {
        "description": "Response with an array of location filters",
        "content": {
          "application/json": {
            "schema": {
              "properties": {
                "items": {
                  "type": "array",
                  "description": "The array of location filters",
                  "items": {
                    "$ref": "#/components/schemas/LocationFilterRead"
                  }
                }
              }
            }
          }
        }
      },
      "OrganizationResponseDtoBeta": {
        "description": "A successfully created organization",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Organization"
            }
          }
        }
      },
      "OrganizationResponseDto": {
        "description": "A successfully created organization",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "items": {
                    "$ref": "#/components/schemas/Organization"
                  }
                }
              }
            }
          }
        }
      },
      "OrganizationListResponseBeta": {
        "description": "A list of organizations",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Organization"
              }
            }
          }
        }
      },
      "OrganizationListResponse": {
        "description": "A list of organizations",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Organization"
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available). Note that the server\nmay choose to paginate the results even though no limit can be specified by the user."
                }
              }
            }
          }
        }
      },
      "OrganizationWithContactPersonsResponseDto": {
        "description": "An organization",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/OrganizationWithContactPersons"
            }
          }
        }
      },
      "ClustersListResponseDto": {
        "description": "A successfully changed list of allowed clusters",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ClustersListRequestResponse"
            }
          }
        }
      },
      "NewProjectResponseDto": {
        "description": "A successfully created project",
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "required": [
                    "projectAdminGroupId"
                  ],
                  "properties": {
                    "projectAdminGroupId": {
                      "description": "The ID of the externally-managed group that was assigned as the admin group for the new project.\nThis may be different from what was specified in the request - see the description of the request\nfield `projectAdminGroupId`."
                    }
                  }
                },
                {
                  "$ref": "#/components/schemas/ProjectCreateRequest"
                }
              ]
            }
          }
        }
      },
      "NewProjectListResponseDto": {
        "description": "A successfully created project",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "items": {
                    "allOf": [
                      {
                        "required": [
                          "projectAdminGroupId"
                        ],
                        "properties": {
                          "projectAdminGroupId": {
                            "description": "The ID of the externally-managed group that was assigned as the admin group for the new project.\nThis may be different from what was specified in the request - see the description of the request\nfield `projectAdminGroupId`."
                          }
                        }
                      },
                      {
                        "$ref": "#/components/schemas/ProjectCreateRequest"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      },
      "ProjectResponseDto": {
        "description": "A list of projects",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/ProjectResponse"
                      },
                      {
                        "$ref": "#/components/schemas/ProjectWithAdminPropertiesResponse"
                      }
                    ]
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available). Note that the server\nmay choose to paginate the results even though no limit can be specified by the user."
                }
              }
            }
          }
        }
      },
      "ProjectIntervalV0ResponseDto": {
        "description": "A list of projects",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ProjectInternalV0Response"
                  }
                },
                "nextCursor": {
                  "type": "string",
                  "description": "The cursor to get the next page of results (if available). Note that the server\nmay choose to paginate the results even though no limit can be specified by the user."
                }
              }
            }
          }
        }
      },
      "PrincipalsListResponse": {
        "description": "A list of principals",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PrincipalsListResponseDto"
            }
          }
        }
      },
      "PrincipalsPaginatedListResponse": {
        "description": "A list of principals, with a cursor pointing to the next results page",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PrincipalsListPaginatedDto"
            }
          }
        }
      },
      "MeResponse": {
        "description": "The principal that issued the request",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PrincipalDto"
            }
          }
        }
      }
    },
    "requestBodies": {
      "newRelationship": {
        "description": "Data required to create relationships. You can request a maximum of 1000 relationships per request.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/relationshipRequestWrapper"
            }
          }
        }
      },
      "listOfExternalIds": {
        "description": "Data required to list relationships.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/byIdsRequest"
            }
          }
        }
      },
      "delete": {
        "description": "Data required to delete relationships. You can delete a maximum of 1000 relationships per request.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/deleteRequest"
            }
          }
        }
      },
      "advancedList": {
        "description": "Data required to filter relationships. Combined filters are interpreted as an AND operation (not OR). Only relationships that match ALL the provided filters are returned.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/relationshipsAdvancedListRequest"
            }
          }
        }
      },
      "updateObject": {
        "description": "Data required to update relationships.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/updateRelationshipWrapper"
            }
          }
        }
      },
      "PipelineCreateRequest": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "Pipelines to create",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "$ref": "#/components/schemas/PipelineCreateItem"
                  }
                }
              }
            }
          }
        }
      },
      "PipelinesByIdsRequest": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "Pipeline identifiers",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "$ref": "#/components/schemas/IdEither"
                  }
                }
              }
            }
          }
        }
      },
      "PipelinesUpdateRequest": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "Update patches to apply",
                  "minItems": 1,
                  "maxItems": 100,
                  "items": {
                    "$ref": "#/components/schemas/PipelineUpdateItem"
                  }
                }
              }
            }
          }
        }
      },
      "VisionExtractPostRequestSchema": {
        "description": "A request for running an extract job.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items",
                "features"
              ],
              "properties": {
                "items": {
                  "description": "List of image files to be analyzed by the feature extractors.",
                  "type": "array",
                  "minimum": 1,
                  "maximum": 100,
                  "items": {
                    "$ref": "#/components/schemas/FileReference"
                  }
                },
                "features": {
                  "type": "array",
                  "description": "The type of detections to perform. New feature extractors may appear. You can use up to three feature extractors per request.",
                  "uniqueItems": true,
                  "minimum": 1,
                  "maximum": 3,
                  "items": {
                    "$ref": "#/components/schemas/VisionExtractFeature"
                  },
                  "example": [
                    "TextDetection",
                    "AssetTagDetection",
                    "PeopleDetection"
                  ]
                },
                "parameters": {
                  "$ref": "#/components/schemas/FeatureParameters"
                }
              }
            }
          }
        }
      },
      "VisionSegmentPostRequestSchema": {
        "description": "A request for running an segment job.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "anyOf": [
                {
                  "required": [
                    "points"
                  ]
                },
                {
                  "required": [
                    "boundingBox"
                  ]
                }
              ],
              "properties": {
                "items": {
                  "description": "List of image files to be segmented. Currently supporting only one image.",
                  "type": "array",
                  "minimum": 1,
                  "maximum": 1,
                  "items": {
                    "$ref": "#/components/schemas/FileReference"
                  }
                },
                "points": {
                  "type": "array",
                  "description": "Prompt points.",
                  "uniqueItems": true,
                  "items": {
                    "$ref": "#/components/schemas/SegmentPoint"
                  }
                },
                "boundingBox": {
                  "$ref": "#/components/schemas/SegmentBoundingBox"
                }
              }
            }
          }
        }
      },
      "VisionSegmentEmbeddingPostRequestSchema": {
        "description": "A request for running a calculate embedding job.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items",
                "points"
              ],
              "properties": {
                "items": {
                  "description": "List of image files to be segmented. Currently supporting only one image.",
                  "type": "array",
                  "minimum": 1,
                  "maximum": 1,
                  "items": {
                    "$ref": "#/components/schemas/FileReference"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2SuggestRequestSchema": {
        "description": "A request for suggesting annotations, i.e., creating them with the \"suggested\" `status`",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "A list of annotations to suggest",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2SuggestSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2CreateRequestSchema": {
        "description": "A request for creating annotations",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "A list of annotations to create",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2CreateSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2ByIdsRequestSchema": {
        "description": "A request referencing existing annotations",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "description": "A list of existing annotation references",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2ReferenceSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2ListRequestSchema": {
        "description": "A request specifying the annotation listing behavior",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "filter"
              ],
              "properties": {
                "cursor": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StrCursor"
                    }
                  ],
                  "nullable": true,
                  "type": "string"
                },
                "limit": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 25,
                  "maximum": 1000
                },
                "filter": {
                  "$ref": "#/components/schemas/AnnotationsV2FilterSchema"
                }
              }
            }
          }
        }
      },
      "AnnotationsV2UpdateRequestSchema": {
        "description": "A request for updating existing annotations",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minimum": 1,
                  "maximum": 1000,
                  "items": {
                    "$ref": "#/components/schemas/AnnotationsV2UpdateItemSchema"
                  }
                }
              }
            }
          }
        }
      },
      "AnnotationsV2ReverseLookupRequestSchema": {
        "description": "A request to look up annotated resource ids based on having annotations matching a filter.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "filter"
              ],
              "properties": {
                "filter": {
                  "$ref": "#/components/schemas/AnnotationsV2ReverseLookupFilterSchema"
                },
                "limit": {
                  "type": "integer",
                  "minimum": 1,
                  "default": 100,
                  "maximum": 1000
                },
                "cursor": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/StrCursor"
                    }
                  ],
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "UpdateUserPreferencesRequest": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/UserPreferencesUpdate"
            }
          }
        }
      },
      "CreateLocationFilterRequest": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/LocationFilterWrite"
            }
          }
        }
      },
      "ListLocationFiltersRequest": {
        "content": {
          "application/json": {
            "schema": {
              "properties": {
                "flat": {
                  "type": "boolean",
                  "description": "Determines whether to return location filters in a flat list or in a hierarchical format",
                  "default": false
                }
              }
            }
          }
        }
      },
      "ByIdsLocationFiltersRequest": {
        "content": {
          "application/json": {
            "schema": {
              "required": [
                "ids"
              ],
              "properties": {
                "ids": {
                  "type": "array",
                  "description": "The array of location filter ids to retrieve",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        }
      },
      "OrganizationRequestDtoBeta": {
        "description": "A request to create an organization.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/OrganizationRequestItem"
            }
          }
        }
      },
      "OrganizationRequestDto": {
        "description": "A request to create an organization.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "items": {
                    "$ref": "#/components/schemas/OrganizationRequestItem"
                  }
                }
              }
            }
          }
        }
      },
      "ClustersListRequestDto": {
        "description": "A request to change the allowed clusters for an organization",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ClustersListRequestResponse"
            }
          }
        }
      },
      "NewProjectRequestDto": {
        "description": "A request to create a new project",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/ProjectCreateRequest"
            }
          }
        }
      },
      "NewProjectListRequestDto": {
        "description": "A request to create a new project",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "required": [
                "items"
              ],
              "properties": {
                "items": {
                  "type": "array",
                  "minItems": 1,
                  "maxItems": 1,
                  "items": {
                    "$ref": "#/components/schemas/ProjectCreateRequest"
                  }
                }
              }
            }
          }
        }
      },
      "UpdateIdpRequestDto": {
        "required": true,
        "description": "A request to update the IdP configuration of an organization",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/IdentityProvider"
            }
          }
        }
      },
      "PrincipalsListByIdsRequest": {
        "description": "A request to retrieve principals by reference.\n\nFor now, only service accounts can have an external ID.",
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/PrincipalListByIdsRequestDto"
            }
          }
        }
      }
    },
    "examples": {
      "GeospatialFeatureTypesRequestExample": {
        "value": {
          "items": [
            {
              "externalId": "ocean_temperature",
              "properties": {
                "temperature": {
                  "type": "DOUBLE"
                },
                "location": {
                  "type": "POINT",
                  "srid": 4326
                }
              },
              "searchSpec": {
                "location_idx": {
                  "properties": [
                    "location"
                  ]
                }
              }
            }
          ]
        }
      },
      "GeospatialFeatureTypesUpdateRequestExample": {
        "value": {
          "items": [
            {
              "externalId": "ocean_temperature",
              "update": {
                "properties": {
                  "add": {
                    "depth": {
                      "type": "DOUBLE"
                    }
                  }
                },
                "searchSpec": {
                  "add": {
                    "depth_idx": {
                      "properties": [
                        "depth"
                      ]
                    }
                  }
                }
              }
            }
          ]
        }
      },
      "GeospatialFeatureTypesResponseExample": {
        "value": {
          "items": [
            {
              "externalId": "ocean_temperature",
              "dataSetId": 1278028,
              "createdTime": 1629784673505,
              "lastUpdatedTime": 1629784673505,
              "properties": {
                "temperature": {
                  "type": "DOUBLE"
                },
                "location": {
                  "type": "POINT",
                  "srid": 4326
                },
                "createdTime": {
                  "type": "LONG"
                },
                "lastUpdatedTime": {
                  "type": "LONG"
                },
                "externalId": {
                  "type": "STRING",
                  "size": 32
                }
              },
              "searchSpec": {
                "location_idx": {
                  "properties": [
                    "location"
                  ]
                },
                "createdTimeIdx": {
                  "properties": [
                    "createdTime"
                  ]
                },
                "lastUpdatedTimeIdx": {
                  "properties": [
                    "lastUpdatedTime"
                  ]
                },
                "externalIdIdx": {
                  "properties": [
                    "externalId"
                  ]
                }
              }
            }
          ]
        }
      },
      "GeospatialFeatureTypeExternalIdsExample": {
        "value": {
          "items": [
            {
              "externalId": "ocean_temperature"
            }
          ]
        }
      },
      "GeospatialFeaturesRequestExample": {
        "value": {
          "items": [
            {
              "externalId": "measurement_point_765",
              "temperature": 5.65,
              "location": {
                "wkt": "POINT(60.547602 -5.423433)"
              }
            },
            {
              "externalId": "measurement_point_863",
              "temperature": 5.03,
              "location": {
                "wkt": "POINT(60.585858 -6.474416)"
              }
            }
          ]
        }
      },
      "GeospatialFeaturesResponseExample": {
        "value": {
          "items": [
            {
              "externalId": "measurement_point_765",
              "temperature": 5.65,
              "location": {
                "wkt": "POINT(60.547602 -5.423433)"
              },
              "createdTime": 1629784673505,
              "lastUpdatedTime": 1629784673505
            },
            {
              "externalId": "measurement_point_863",
              "temperature": 5.03,
              "location": {
                "wkt": "POINT(60.585858 -6.474416)"
              },
              "createdTime": 1629784673505,
              "lastUpdatedTime": 1629784673505
            }
          ]
        }
      },
      "GeospatialFeaturesWithCursorResponseExample": {
        "value": {
          "items": [
            {
              "externalId": "measurement_point_765",
              "temperature": 5.65,
              "location": {
                "wkt": "POINT(60.547602 -5.423433)"
              },
              "createdTime": 1629784673505,
              "lastUpdatedTime": 1629784673505
            },
            {
              "externalId": "measurement_point_863",
              "temperature": 5.03,
              "location": {
                "wkt": "POINT(60.585858 -6.474416)"
              },
              "createdTime": 1629784673505,
              "lastUpdatedTime": 1629784673505
            }
          ],
          "nextCursor": "pwGTFXeL-JiWO8CZpgP23g"
        }
      },
      "GeospatialFeatureAggregateResponseExample": {
        "value": {
          "items": [
            {
              "category": "first category",
              "max": 12.3,
              "min": 0.5,
              "average": 5.32
            },
            {
              "category": "second category",
              "max": 14.3,
              "min": 0.7,
              "average": 8.32
            }
          ]
        }
      },
      "GeospatialFeatureExternalIdsExample": {
        "value": {
          "items": [
            {
              "externalId": "measurement_point_765"
            },
            {
              "externalId": "measurement_point_863"
            }
          ]
        }
      },
      "GeospatialListExample": {
        "value": {
          "filter": {
            "and": [
              {
                "range": {
                  "property": "temperature",
                  "gt": 4.54
                }
              },
              {
                "stWithin": {
                  "property": "location",
                  "value": {
                    "wkt": "POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))"
                  }
                }
              }
            ]
          },
          "limit": 100,
          "cursor": "4zj0Vy2fo0NtNMb229mI9r1V3YG5NBL752kQz1cKtwo"
        }
      },
      "GeospatialSearchExample": {
        "value": {
          "filter": {
            "and": [
              {
                "range": {
                  "property": "temperature",
                  "gt": 4.54
                }
              },
              {
                "stWithin": {
                  "property": "location",
                  "value": {
                    "wkt": "POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))"
                  }
                }
              }
            ]
          },
          "limit": 100,
          "sort": [
            "temperature:ASC",
            "location"
          ]
        }
      },
      "GeospatialSearchStreamingExample": {
        "value": {
          "filter": {
            "and": [
              {
                "range": {
                  "property": "temperature",
                  "gt": 4.54
                }
              },
              {
                "stWithin": {
                  "property": "location",
                  "value": {
                    "wkt": "POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))"
                  }
                }
              }
            ]
          },
          "limit": 100,
          "output": {
            "jsonStreamFormat": "NEW_LINE_DELIMITED"
          }
        }
      },
      "GeospatialFeatureAggregateExample": {
        "value": {
          "filter": {
            "and": [
              {
                "range": {
                  "property": "temperature",
                  "gt": 4.54
                }
              },
              {
                "stWithin": {
                  "property": "location",
                  "value": {
                    "wkt": "POLYGON((60.547602 -5.423433, 60.547602 -6.474416, 60.585858 -6.474416, 60.585858 -5.423433, 60.547602 -5.423433))"
                  }
                }
              }
            ]
          },
          "groupBy": [
            "category"
          ],
          "sort": [
            "average:ASC",
            "category:DESC"
          ],
          "output": {
            "min_temperature": {
              "min": {
                "property": "temperature"
              }
            },
            "max_speed": {
              "max": {
                "property": "speed"
              }
            }
          }
        }
      },
      "GeospatialCreateCoordinateReferenceSystemsExample": {
        "value": {
          "items": [
            {
              "srid": 456789,
              "wkt": "GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]]",
              "projString": "+proj=longlat +datum=WGS84 +no_defs \"\""
            }
          ]
        }
      },
      "GeospatialCoordinateReferenceSystemRequestExample": {
        "value": {
          "items": [
            {
              "srid": 4326
            }
          ]
        }
      },
      "GeospatialCoordinateReferenceSystemResponseExample": {
        "value": {
          "items": [
            {
              "srid": 4326,
              "wkt": "GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]]",
              "projString": "+proj=longlat +datum=WGS84 +no_defs \"\"",
              "createdTime": 1633596134000,
              "lastUpdatedTime": 1633596134000
            }
          ]
        }
      },
      "GeospatialRasterMetadataResponseExample": {
        "value": {
          "srid": 3857,
          "width": 4,
          "height": 5,
          "numBands": 1,
          "scaleX": 1,
          "scaleY": 1,
          "skewX": 0,
          "skewY": 0,
          "upperLeftX": -0.5,
          "upperLeftY": -0.5
        }
      },
      "GeospatialComputeRequestExample": {
        "value": {
          "output": {
            "value": {
              "stTransform": {
                "geometry": {
                  "ewkt": "SRID=4326;POLYGON((0 0,10 0,10 10,0 10,0 0))"
                },
                "srid": 23031
              }
            }
          }
        }
      },
      "GeospatialComputeResponseExample": {
        "value": {
          "items": [
            {
              "value": {
                "wkt": "POLYGON((0 0,10.5 0,10.5 10.5,0 10.5,0 0))",
                "srid": 23031
              }
            }
          ]
        }
      }
    }
  },
  "security": [
    {
      "oidc-token": [
        "https://{cluster}.cognitedata.com/.default"
      ]
    },
    {
      "oauth2-client-credentials": [
        "https://{cluster}.cognitedata.com/.default"
      ]
    },
    {
      "oauth2-open-industrial-data": [
        "https://api.cognitedata.com/.default"
      ]
    },
    {
      "oauth2-auth-code": [
        "https://{cluster}.cognitedata.com/.default"
      ]
    }
  ],
  "x-tagGroups": [
    {
      "name": "Changelog",
      "tags": [
        "Changelog"
      ]
    },
    {
      "name": "Organizations and projects",
      "tags": [
        "Organizations",
        "Projects"
      ]
    },
    {
      "name": "Identity and access management",
      "tags": [
        "Principals",
        "Groups",
        "Security categories",
        "Sessions",
        "Token",
        "User profiles",
        "Project Deletion Reporting"
      ]
    },
    {
      "name": "Data modeling",
      "tags": [
        "Data Modeling",
        "Data models",
        "Spaces",
        "Views",
        "Containers",
        "Nodes",
        "Instances"
      ]
    },
    {
      "name": "Asset-centric data model",
      "tags": [
        "Assets",
        "Time series",
        "Synthetic Time Series",
        "Data point subscriptions",
        "Events",
        "Files",
        "Sequences",
        "Geospatial",
        "Seismic"
      ]
    },
    {
      "name": "3D",
      "tags": [
        "3D Models",
        "3D Model Revisions",
        "3D Files",
        "3D Asset Mapping"
      ]
    },
    {
      "name": "Contextualization",
      "tags": [
        "Entity matching",
        "Entity matching pipelines",
        "Engineering diagrams",
        "Vision",
        "Advanced joins"
      ]
    },
    {
      "name": "Cognite AI",
      "tags": [
        "Document AI"
      ]
    },
    {
      "name": "Documents",
      "tags": [
        "Documents",
        "Document preview"
      ]
    },
    {
      "name": "Data ingestion",
      "tags": [
        "Raw",
        "Extraction Pipelines",
        "Extraction Pipelines Runs",
        "Extraction Pipelines Config"
      ]
    },
    {
      "name": "Data organization",
      "tags": [
        "Data sets",
        "Labels",
        "Relationships",
        "Annotations"
      ]
    },
    {
      "name": "Transformations",
      "tags": [
        "Transformations",
        "Transformation Jobs",
        "Transformation Schedules",
        "Transformation Notifications",
        "Query",
        "Schema"
      ]
    },
    {
      "name": "Functions",
      "tags": [
        "Functions",
        "Function calls",
        "Function schedules"
      ]
    },
    {
      "name": "Hosted Extractors",
      "tags": [
        "Sources",
        "Jobs",
        "Destinations",
        "Mappings"
      ]
    },
    {
      "name": "PostgreSQL Gateway",
      "tags": [
        "Postgres Gateway Users",
        "Postgres Gateway Tables"
      ]
    },
    {
      "name": "SAP Writeback",
      "tags": [
        "SAP Instances",
        "SAP Endpoints",
        "Schema Mappings",
        "Writeback Requests"
      ]
    },
    {
      "name": "Data workflows",
      "tags": [
        "Workflows",
        "Workflow versions",
        "Workflow executions",
        "Workflow triggers",
        "Tasks"
      ]
    },
    {
      "name": "Simulators",
      "tags": [
        "Simulators",
        "Simulator Integrations",
        "Simulator Models",
        "Simulator Routines",
        "Simulation Runs",
        "Simulator Logs"
      ]
    },
    {
      "name": "Units",
      "tags": [
        "Units",
        "Unit Systems"
      ]
    },
    {
      "name": "",
      "tags": [
        ""
      ]
    }
  ],
  "tags": [
    {
      "name": "Changelog",
      "description": "This article documents all notable changes to the Cognite Data Fusion (CDF) API v1.\n\n<!--\nGroup changes by release (and date), API area, and these types of changes:\n\n - **Added** for new features.\n - **Changed** for changes in existing functionality.\n - **Deprecated** for soon-to-be removed features.\n - **Removed** for now removed features.\n - **Fixed** for any bug fixes.\n - **Security** in case of vulnerabilities.-\n\nUse[ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) for dates: 2019-06-20\n\nAdd entries for new features on top of this page. Newest release goes on top.\nChanges only for API v1 series\n\nTemplate:\n\n## <YYYY-MM-DD>\n\n### <Core resource name>\n\n#### <Group name -- see top of the page>\n\n    - <my change>\n    - <my change>\n\n#### <Group name -- see top of the page>\n\n    - <my change>\n    - <my change>\n-->\n\n## 2025-02-17\n### PostgreSQL Gateway API\n#### Added\n- The PostgreSQL Gateway API is now in General Availability (GA).\n  - The following endpoints are now available:\n    - `POST /postgresgateway` to create postgres users.\n    - `POST /postgresgateway/delete` to delete postgres users.\n    - `POST /postgresgateway/list` to filter postgres users.\n    - `GET /postgresgateway` to list postgres users.\n    - `POST /postgresgateway/byids` to retrieve postgres users by their username.\n    - `POST /postgresgateway/update` to update postgres users.\n    - `POST /postgresgateway/tables/{username}` to create postgres foreign tables.\n    - `POST /postgresgateway/tables/{username}/delete` to delete postgres foreign tables.\n    - `GET /postgresgateway/tables/{username}` to list postgres foreign tables.\n    - `POST /postgresgateway/tables/{username}/byids` to retrieve postgres foreign tables by name.\n\n## 2025-02-15\n### Principals API\n#### Added\n- The Principals API is now generally available.\n\n#### Deprecated\n- The User profiles API is deprecated in favor of the Principals API, which offers a superset of the functionality.\nThe User profiles API will be removed in a future release.\n\n## 2025-01-20\n### Hosted Extractors API\n#### Added\n- Added support for `clientCredentials` auth to kafka sources.\n\n## 2024-12-03\n### SAP Writeback API\n#### Added\n- SAP writeback API reaches General Availability (GA).\n  - The following endpoints are now available:\n    - `GET /writeback/sap/instances` to list SAP instance destinations\n    - `POST /writeback/sap/instances` to create SAP instance destinations\n    - `POST /writeback/sap/instances/delete` to delete SAP instance destinations\n    - `POST /writeback/sap/instances/byids` to retrieve SAP instance destinations by externalId\n    - `GET /writeback/sap/endpoints` to list SAP endpoint destinations\n    - `POST /writeback/sap/endpoints` to create SAP endpoint destinations\n    - `POST /writeback/sap/endpoints/delete` to delete SAP endpoint destinations\n    - `POST /writeback/sap/endpoints/byids` to retrieve SAP instance destinations by externalId\n    - `POST /writeback/sap/endpoints/verify` to verify connectivity between CDF and the SAP endpoint destination\n    - `GET /writeback/sap/mappings` to list schema mappings\n    - `POST /writeback/sap/mappings` to create schema mappings\n    - `POST /writeback/sap/mappings/delete` to delete schema mappings\n    - `POST /writeback/sap/mappings/byids` to retrieve schema mappings destinations by externalId\n    - `GET /writeback/sap/requests` to list writeback requests\n    - `POST /writeback/sap/requests` to create writeback requests. Maximum concurrent limit of 50 requests per CDF project.\n    - `POST /writeback/sap/requests/byids` to retrieve writeback requests by externalId\n\n### Hosted Extractors API\n#### Added\n- `REST` and `EventHub` sources and jobs are now in GA.\n\n## 2024-11-19\n### Simulator integration API\n#### Added\n- Simulator integration API reaches General Availability (GA).\n  - The following endpoints are now available:\n    - `POST /simulators/*` to access the simulators API and list simulators enabled for the project\n    - `POST /simulators/integrations/*` to list simulator connectors and their state\n    - `POST /simulators/models/*` to create/list/remove simulator models and their revisions\n    - `POST /simulators/routines/*` to create/list/remove simulator routines and their revisions\n    - `POST /simulators/runs/*` to create/schedule simulation runs\n    - `POST /simulators/logs/*` to access simulator logs\n\n## 2024-11-14\n### User profiles\n#### Added\n- Organization principals: get calling principal's profile\n\n#### Deprecated\n- `GET /api/v1/{projectName}/profiles/me` is deprecated in favor of the new endpoint.\n\n## 2024-11-12\n### Organizations and Projects\n#### Updated\n- `GET /api/v1/orgs/{org}/projects?includeAdminProperties=true` now includes `state` and `deletionTime`\n\n## 2024-10-22\n### Hosted Extractors API\n#### Added\n- Stabilized the API for `Sources`, `Mappings`, `Destinations` and `Jobs`, for MQTT and Kafka extractors.\n- Promote Rest and EventHub extractors to public beta.\n- Support data models in hosted extractors.\n\n## 2024-10-14\n### AWS Cognito support\n#### Added\n- Support creating organization with AWS Cognito as IdP.\n  - `POST /api/v1/orgs/{orgId}/orgs` can be called to create organization with AWS Cognito as IdP.\n\n## 2024-10-11\n### Organizations and Projects\n#### Added\n- Allow non-admin users to list all projects in an organization.\n  - `GET /api/v1/orgs/{orgId}/projects` can be called by all users of an organization.\n- Include `apiUrl` when listing projects in an organization.\n  - `GET /api/v1/orgs/{orgId}/projects` will include `apiUrl` for each project.\n\n## 2024-09-31\n### Time Series API\n#### Added\n- Introduced support for time series managed by Data modeling in data point subscriptions.\n  - `GET subscriptions/members` can contain members with `instanceId`.\n  - `POST subscriptions` can be used to create subscriptions with an defined set of instance ids.\n  - `POST subscriptions/update` can be used to add/remove/set the instance id time series members.\n\n## 2024-09-19\n### Contextualization / Vision\n#### Added\n- Support for Vision endpoints referencing files by data modeling instance IDs, as an alternative to ID and external ID.\n\n## 2024-09-14\n### Simulator integration API\n#### Added\n- The simulator integration API endpoints have now been promoted to public beta. The following is just a brief list of endpoints. Go to the Cognite API [reference documentation (beta)](https://api-docs.cognite.com/20230101-beta/tag/Simulators/) to view all endpoints and their functionalities.\n  - `POST /simulators/*` to access the simulators API and list simulators enabled for the project\n  - `POST /simulators/integrations/*` to list simulator connectors and their state\n  - `POST /simulators/models/*` to create/list/remove simulator models and their revisions\n  - `POST /simulators/routines/*` to create/list/remove simulator routines and their revisions\n  - `POST /simulators/runs/*` to create/schedule simulation runs\n  - `POST /simulators/logs/*` to access simulator logs\n\n## 2024-09-13\n### Contextualization / Engineering diagrams\n#### Added\n- Support for detecting tags in diagrams referencing files by data modelling instance ids as an alternative to id and externalId.\n\n## 2024-09-12\n### Files API\n#### Added\n- Add support for `ignoreUnknownIds` to the `files/delete` endpoint.\n\n### SAP Writeback\n#### Added\n- SAP Writeback API (Beta)\n\n## 2024-09-10\n### Time Series API\n#### Added\n- Introduces support for Time Series managed by Data modeling.\n  - `/timeseries/*` endpoints will return data modeling instance Id in time series objects where applicable.\n  - `POST /timeseries/update` can be used to update properties of data modeling time series, but only fields that are not managed by data modeling.\n  - `POST /timeseries/byids` can be used to retrieve time series by instance Id.\n  - `POST /timeseries/list` and `POST /timeseries/aggregate` support advanced filters with `instanceId.space` and `instanceId.externalId` fields. (No changes to regular filters)\n  - `POST /timeseries/data/*` can be used with instance Id to ingest/delete/query data points.\n  - `POST /timeseries/synthetic/query` can lookup by instance Id.\n\n### Subscriptions API\n#### Added\n- Subscription filters support advanced filters with `instanceId.space` and `instanceId.externalId` fields.\n- List subscription members will show time series instance Ids, if available.\n\n## 2024-09-02\n### Files API\n#### Added\n- Introduces support for Files managed by Data modeling, which means following endpoints will allow specifying instance Id\n  - `POST /files/uploadlink` to get upload links for files\n  - `POST /files/multiuploadlink` to get multipart upload link for files\n  - `POST /files/completemultipartupload` to complete a multipart file upload\n  - `POST /files/downloadlink` to get download links for files\n  - `GET /files/icon` to get an image representation of a file\n  - `POST /files/byids` to retrieve metadata information about multiple specific files\n  - `POST /files/update` to updates the information for the files\n\n## 2024-08-23\n### Data Workflows\n#### Added\n- subworkflow task: add support for referencing other workflow versions to run as part of a workflow\n\n## 2024-08-20\n### Data Workflows\n#### Added\n- Introduces the trigger resource for Data Workflows, which adds support for scheduling the execution of workflows and the management thereof.\n  - `POST /workflows/triggers` to create a UNIX cron trigger for a workflow\n  - `GET /workflows/triggers` to list all triggers\n  - `POST /workflows/triggers/delete` to delete a trigger\n  - `GET /workflows/triggers/{triggerExternalId}/history` which keeps a ledger of when the trigger fired and if it successfully started a workflow or not.\n\n## 2024-07-18\n### Organizations and Projects\n#### Added\n- Selected endpoints are promoted from beta to v1 (all under https://auth.cognite.com; note that the routes are\n  different from the beta routes, and that some request and response signatures have changed):\n  - `GET /api/v1/orgs/{orgId}` to get organization info\n  - `POST /api/v1/orgs/{orgId}/orgs` to create an organization\n  - `POST /api/v1/orgs/{orgId}/delete` to delete an organization\n  - `GET /api/v1/orgs/{orgId}/orgs` to list the child organizations of an organization\n  - `POST /api/v1/orgs/{orgId}/projects` to create a project in an organization\n  - `GET /api/v1/orgs/{orgId}/projects` to list the projects in an organization\n\n#### Deprecated\n- The six beta endpoints that have been published as new V1 endpoints (just above) are deprecated and will be removed in\n  a future release.\n\n## 2024-06-24\n### Data Modeling\n\n#### Added\n- Support marking properties as immutable\n\n## 2024-06-17\n### Data Modeling\n\n#### Added\n- Support for creating properties of type `direct_relation[]`, allowing direct relations to point to multiple nodes.\n- /containers/inspect endpoint to retrieve information about which views map a container.\n- /instances/inspect endpoint to retrieve information about which containers an instance has data in.\n\n## 2024-06-13\n### Organizations and Projects\n#### Added\n- Projects API (Beta): Allow for parametrization of the initial admin group when creating a project.\n\n### Time Series\n#### Added\n- Time zone aware aggregate queries. Align aggregates with a given time zone. Also works with half-hour offsets like Asia/Kolkata (UTC+5:30). Takes DST transitions into account.\n- New `month` (mo) granularity.\n- Also applies to synthetic time series.\n\n## 2024-05-24\n### Organizations and Projects\n#### Added\n- Organizations API (Beta): create, list, and delete CDF organizations\n- Organizations API (Alpha): update CDF organizations\n- Projects API (Beta): create and list projects in CDF organizations\n\n### User profiles\n#### Added\n- Organization user profiles (Beta): list users in CDF organizations\n\n### Projects\n#### Removed\n- Removed the previous Projects API from public documentation, as those endpoints are available to Cognite and resellers\n  only.\n\n## 2024-05-23\n\n### Time series\n\n#### Added\n- Beta support for time zone aware aggregate queries. Align aggregates with a given time zone. Also works with half-hour offsets like Asia/Kolkata (UTC+5:30). Takes DST transitions into account.\n- Beta support for new `month` (mo) granularity.\n- Also applies to synthetic time series.\n\n## 2024-05-02\n\n### Postgres gateway\n\n#### Added\n- Endpoints for managing PostgreSQL gateway\n\n## 2024-05-01\n\n### Time series\n\n#### Added\n\n- Added support for [status codes](https://developer.cognite.com/dev/concepts/resource_types/timeseries#data-point-quality-status-codes) for data points.\n\n## 2024-04-02\n\n### Groups\n\n#### Added\n\n- Introduce the option to manage members of a group through CDF instead of through external groups in the identity provider. This is done through the new `members` field on the group object. Members can either be explicitly enumerated or one declare a group to include all users accounts. The latter is useful if one wants all existing users and new users who joins a project to automatically receive certain capabilities.\n\n## 2024-03-19\n\n### Engineering diagrams (beta)\n\n#### Added\n- Beta endpoint for retrieving ocr data for a file per page.\n  Currently, only files that have been run through diagram/detect will give any results.\n  This may be up for change in the future.\n  The endpoint replaces a previous playground endpoint which is no longer documented.\n\n## 2024-03-11\n\n### Default runtime in Cognite functions\n\n#### Changed\n- Default Python runtime in Cognite functions has been updated from Python 3.8 (py38) to Python 3.11 (py311) in response to the upcoming end of community support for Python 3.8 in October 14, 2024.\n\n## 2024-03-06\n\n### Files\n\n#### Updated\n- Files API rate and concurrency limits have been documented.\n  -- Service layer request rate and concurrency limits added\n  -- CRUD endpoints request rate, concurrency and items rate limits added\n  -- Analytic endpoints request rate, concurrency rate limits added\n\n## 2024-02-29\n\n### Assets\n\n#### Updated\n- Assets API rate and concurrency limits have been documented.\n  -- Service layer request rate and concurrency limits added\n  -- CRUD endpoints request rate, concurrency and items rate limits added\n  -- Analytic endpoints request rate, concurrency and items rate limits added\n\n## 2024-02-20\n\n### Data Modeling\n\n#### Added\n**Conversion between unit types for returned values during filter and query operations.**\n- Trigger conversion by setting the `targetUnit` by `externalId` or `unitSystemName` parameters for the data source in a query.\n- When using filters with unit conversion, the unit for filter value is determined by the corresponding property in the `source` object. When querying data in centimeters by setting `targetUnit` on a property in the `source`, the filter value for that property will also be considered to be in centimeters.\n- `typing` - `type.unit` on a property in a `typing` object is now always the same as the unit for the returned data.\n- Added `typing` to following endpoints:\n    - query\n    - sync\n    - aggregate\n    - search\n\n## 2024-02-19\n\n### Time series\n\n#### Added\n\n- Data point subscriptions reaches General Availability (GA).\n  - Use the new [Data point subscriptions](https://developer.cognite.com/dev/concepts/data_point_subscriptions/)\n    feature to configure a subscription to listen to changes in one or more\n    time series (in ingestion order).\n    The feature is intended to be used where data points consumers need to keep up to date with\n    changes to one or more time series without the need to read the entire time series again.\n\n## 2024-02-08\n\n### Hosted Extractors\n\n#### Changed\n\n- `host` in kafka sources has been replaced with `bootstrapBrokers`, which is an array of objects with `host` and `port`.\n\n\n## 2024-02-01\n\n### Synthetic time series\n\n#### Added\n- Support for unit conversion by setting `targetUnit` or `targetUnitSystem` on time series or aggregates with a compatible `unitExternalId` field.\n\n\n## 2024-01-16\n\n### Sessions\n\n#### Added\n- Support for creating one-shot sessions by setting the `oneshotTokenExchange` flag. One-shot sessions are short-lived sessions that are not refreshed and do not require support for token exchange from the identity provider.\n\n## 2024-01-02\n\n### Data Modeling\n\n#### Added\n- Support for a `bySpace` flag on btree indexes and uniqueness constraints.\n\n\n## 2023-12-12\n\n### Data Modeling\n\n#### Added\n- **Units catalog support for container properties**: You can now specify a unit from [CDF units catalog](https://developer.cognite.com/dev/concepts/resource_types/units) on `float32` and `float64` properties in containers.\n\n\n## 2023-12-11\n\n### Time series\n\n#### Changed\n\n- Data point subscriptions [list data (beta)](https://api-docs.cognite.com/20230101-beta/tag/Data-point-subscriptions/operation/listSubscriptionData/) now supports _long polling_ through the `pollTimeoutSeconds` parameter. The request will be kept active for the specified number of seconds, or until new data is available, whichever comes first.\n\n## 2023-12-06\n\n### Time series\n\n#### Added\n- [Units catalog](https://developer.cognite.com/dev/concepts/resource_types/units) support to time series. This comes in addition to the existing free-text unit field.\n  - [Create timeseries](https://docs.cognite.com/api#tag/Time-series/operation/postTimeSeries) with a unitExternalId.\n  - [Update timeseries](https://docs.cognite.com/api#tag/Time-series/operation/alterTimeSeries) to add/remove unitExternalId.\n- Filter and aggregate time series by unitExternalId or unitQuantity (eg. \"volume\" or \"temperature\"). Both using regular filters and advanced filters.\n  - [Filter time series](https://docs.cognite.com/api#tag/Time-series/operation/listTimeSeries).\n  - [Aggregate time series](https://docs.cognite.com/api#tag/Time-series/operation/aggregateTimeSeries).\n  - [Search time series](https://docs.cognite.com/api#tag/Time-series/operation/searchTimeSeries).\n- Added unit conversion support to [retrieve data points/aggregates](https://docs.cognite.com/api#tag/Time-series/operation/getMultiTimeSeriesDatapoints) and [retrieve latest](https://docs.cognite.com/api#tag/Time-series/operation/getLatest). Specify a _targetUnit_ or _targetUnitSystem_ to convert the data points or aggregates to a different unit, or to the default unit of a given unit system.\n\n## 2023-11-30\n\n### Hosted extractors\n\n#### Changed\n\n- Hosted extractors API (Beta)\n  - Updates hosted extractor schema with tls certificate details hence users can now provide CA and authentication certificates for connection to MQTT brokers.\n  - Now includes schema requirements for connection to Kafka brokers i.e. connection to and extraction from Kafka brokers to Cognie Data fusion is not possible.\n\n## 2023-11-21\n\n### Units Catalog\n\n#### Added\n\n- Added the [Units Catalog](https://docs.cognite.com/api#tag/Units) API. The Units Catalog is a collection of units of measurement and their conversion factors. The Units Catalog is used within Cognite Data Fusion to easily convert between different units and unit systems when retrieving Time Series and Data Models.\n\n## 2023-11-17\n\n### Documents\n\n#### Added\n\n- Added support for sorting in the `/documents/list` endpoint. It works exactly the same as the sorting\n  in `/documents/search` except that you can not sort on search relevance.\n\n## 2023-11-08\n\n### Engineering diagrams\n\n#### Changed\n\n- Optional token mechanism for accessing detected results of engineering diagrams without read all access to assets.\n  See [diagram/detect](https://api-docs.cognite.com/20230101/tag/Engineering-diagrams/operation/diagramDetect) for details.\n\n## 2023-10-23\n\n### Files\n\n#### Added\n\n- Added multipart upload endpoints for the files API. This enables upload of files larger than 5 GiB, in a uniform way for all CDF cloud environments.\n  Optionally use parallel part upload, for greater upload speed.\n  See the documentation for the new endpoints at:\n  - [Upload multipart file](https://docs.cognite.com/api/20230101/#tag/Files/operation/initMultiPartUpload) and\n  - [Complete multipart upload](https://docs.cognite.com/api/20230101/#tag/Files/operation/completeMultiPartUpload) endpoints.\n\n## 2023-10-17\n### Events\n#### Added\n- New and old but previously undocumented API rate and concurrency limits have been documented.\nOverrides have been specified for existing customers, so that the new limits would not affect them.\n  - Service layer request rate and concurrency limits added.\n  - CRUD endpoints request rate and concurrency and items rate limits added\n\n## 2023-10-10\n\n### Entity matching\n\n#### Added\n\n- Entity matching pipelines are now in v1. We resuscitated the old playground API and made some changes.\n  We will keep the new v1 API in beta for the foreseeable future.\n\n### Vision (Contextualization)\n\n#### Added\n\n- New computer vision models (beta) are available in Vision extract service, including digital, dial and level gauge readers, valve state detection (open/closed) and model to segment objects in images.\n\n## 2023-10-05\n\n### Hosted extractors\n\n#### Added\n\n- Hosted extractors API (Beta)\n  - Use the new [Hosted extractors](https://docs.cognite.com/cdf/integration/guides/extraction/hosted_extractors)\n    feature to create simple streaming extractors running inside CDF, streaming data from sources available on the internet\n    directly into CDF.\n    Currently supports Azure Event Hub and MQTT. Support is planned for Kafka and REST APIs.\n\n## 2023-09-27\n\n### 3D\n\n#### Changed\n\n- If the 3d model processing is ongoing or has failed, the 3d api nodes endpoints will now return error code 400 with the response body \"Revision processing is not yet complete\" or \"Revision processing failed\" respectively.\n  The previous behavior was to return an empty or partial items list in these cases.\n  Before calling any 3d api nodes endpoints, clients should check that the model revision has \"status\":\"Done\".\n\n## 2023-08-25\n\n### Transformations\n\n#### Changed\n\n- Fixed wrong description for fields in \"transformations/update\" and \"/transformations/schedules/update\"\n\n## 2023-08-22\n\n### Functions\n\n#### Changed\n\n- Remove Functions runtime \"py37\".\n\n## 2023-08-22\n\n### Time series\n\n#### Added\n\n- Data point subscriptions (Beta)\n  - Use the new [Data point subscriptions](https://developer.cognite.com/dev/concepts/data_point_subscriptions/)\n    feature to configure a subscription to listen to changes in one or more\n    time series (in ingestion order).\n    The feature is intended to be used where data points consumers need to keep up to date with\n    changes to one or more time series without the need to read the entire time series again. (Beta)\n\n## 2023-08-10\n\n### Time series\n\n#### Added\n\n- Advanced query language support reaches General Availability (GA).\n  - Advanced search, filtering, and sorting capabilities in the [Filter time series](https://docs.cognite.com/api/20230101/#tag/Time-series/operation/listTimeSeries) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate time series](https://docs.cognite.com/api/20230101/#tag/Time-series/operation/aggregateTimeSeries) endpoint.\n\n### Sequences\n\n#### Added\n\n- Advanced query language support reaches General Availability (GA).\n  - Advanced search, filtering, and sorting capabilities in the [Filter sequences](https://docs.cognite.com/api/20230101/#tag/Sequences/operation/advancedListSequences) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate sequences](https://docs.cognite.com/api/20230101/#tag/Sequences/operation/aggregateSequences) endpoint.\n\n## 2023-08-08\n\n### Assets\n\n#### Added\n\n- Advanced query language support reaches General Availability (GA).\n  - Advanced search, filtering, and sorting capabilities in the [Filter assets](https://docs.cognite.com/api/20230101/#tag/Assets/operation/listAssets) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate assets](https://docs.cognite.com/api/20230101/#tag/Assets/operation/aggregateAssets) endpoint.\n\n### Events\n\n#### Added\n\n- Advanced query language support reaches General Availability (GA).\n  - Advanced search, filtering, and sorting capabilities in the [Filter events](https://docs.cognite.com/api/20230101/#tag/Events/operation/advancedListEvents) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate events](https://docs.cognite.com/api/20230101/#tag/Events/operation/aggregateEvents) endpoint.\n\n### Documents\n\n#### Added\n\n- Advanced query language support reaches General Availability (GA).\n  - Advanced aggregation capabilities in the [Aggregate documents](https://docs.cognite.com/api/20230101/#tag/Documents/operation/documentsAggregate) endpoint.\n\n## 2023-06-27\n\n### IAM (Identity and access management)\n\n#### Changed\n\n- Identity providers (IdP) are required to be compatible with the [OpenID Connect Discovery 1.0](https://openid.net/specs/openid-connect-discovery-1_0.html) standard, and compliance will now be enforced by the [Projects](tag/Projects) API.\n  - The `oidcConfiguration.jwksUrl` and `oidcConfiguration.tokenUrl` can be entirely omitted when updating the OIDC configuration for a project.\n  - The `oidcConfiguration.jwksUrl` and `oidcConfiguration.tokenUrl` are preserved for backwards compatibility of the API. However, if these are specified as part of the request body, the value must match excatly the values that are specified in the OpenID provider configuration document for the configured issuer (can be found at `https://{issuer-url}/.well-known/openid-configuration`). If the values does not match, the API will return an error message.\n\n- The `oidcConfiguration.skewMs` has been deprecated but remains part of the API for backwards compatibility. It can be omitted from the request. If included, it must always be set to `0`.\n\n- The `oidcConfiguration.isGroupCallbackEnabled` has been deprecated but remains part of the API for backwards compatibility. It can be omitted from the request.\n  - For projects configured to use Azure Active Directory as the identity provider, if this value is specified in the request, it must always be set to `true`.\n\n## 2023-06-05\n\n### Data Modeling\n\n#### Added\n\n- Added support for an `autoCreateDirectRelations` option on the endpoint for ingesting instances.\nThis option lets the user specify whether to create missing target nodes of direct relations.\n\n#### Removed\n\n- Removed support for the deprecated per-item `sources` field on the `/instances/byids` endpoint.\n\n### Time series\n\n#### Added\n\n- Added advanced query language support (Beta).\n  - Advanced search, filtering, and sorting capabilities in the [Filter time series](tag/Time-series/operation/listTimeSeries) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate time series](tag/Time-series/operation/aggregateTimeSeries) endpoint.\n\n### Sequences\n\n#### Added\n\n- Added advanced query language support (Beta).\n  - Advanced search, filtering, and sorting capabilities in the [Filter sequences](tag/Sequences/operation/advancedListSequences) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate sequences](tag/Sequences/operation/aggregateSequences) endpoint.\n\n## 2023-05-19\n\n### Transformations\n\n#### Added\n\n- Adding support for data model centric and view centric schema.\n\n## 2023-04-24\n\n### Transformations\n\n#### Removed\n\n- Removing support for authentication via API keys when creating or updating transformations.\n\n## 2023-05-04\n\n### Annotations\n\n#### Added\n\n- Added `image.InstanceLink` and `diagrams.InstanceLink` annotation types to allow you to link from objects discovered in images and engineering diagrams to data model instances.\n\n## 2023-04-18\n\n### All resources\n\n#### Added\n\n- Added information about [Requests throttling](section/Requests-throttling).\n\n#### Changed\n\n- Updated the [Parallel retrieval](section/Parallel-retrieval) documentation.\n- Aligned endpoint naming within Assets, Data sets, Events, and Files.\n\n### Assets\n\n#### Added\n\n- Added advanced query language support (Beta).\n  - Advanced search, filtering, and sorting capabilities in the [Filter assets](https://docs.cognite.com/api/20230101-beta/#tag/Assets/operation/listAssets) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate assets](https://docs.cognite.com/api/20230101-beta/#tag/Assets/operation/aggregateAssets) endpoint.\n\n### Events\n\n#### Added\n\n- Added advanced query language support (Beta).\n  - Advanced search, filtering, and sorting capabilities in the [Filter events](https://docs.cognite.com/api/20230101-beta/#tag/Events/operation/advancedListEvents) endpoint.\n  - Advanced aggregation capabilities in the [Aggregate events](https://docs.cognite.com/api/20230101-beta/#tag/Events/operation/aggregateEvents) endpoint.\n\n### Documents\n\n#### Added\n\n- Added advanced query language support (Beta).\n  - Advanced aggregation capabilities in the [Aggregate documents](https://docs.cognite.com/api/20230101-beta/#tag/Documents/operation/documentsAggregate) endpoint.\n\n## 2023-04-12\n\n### Sessions\n\n#### Fixed\n\n- Fixed the API documentation for the request body of the [POST /projects/{project}/sessions/byids](tag/Sessions/operation/getSessionsByIds) endpoint.\nThe documentation incorrectly stated the request body schema as specifying the list of session IDs to retrieve, in the form `{\"items\": [42]}` - it should in fact be `{\"items\": [{\"id\": 42}]}`. The documentation has been updated to reflect this.\n\n- Fixed the API documentation for the response body of the [POST /projects/{project}/sessions/byids](tag/Sessions/operation/getSessionsByIds) endpoint.\nThe documentation incorrectly stated `nextCursor` and `previousCursor` fields as being returned from the response, which was not the case, and these fields have now been removed from the API documentation.\n\n## 2023-04-04\n\n### Transformations\n\n#### Change\n\n- Transformations support new target types for view-centric data model instances.\n\n#### Added\n\n- Added target types `nodes` and `edges`.\n\n## 2023-03-06\n\n### Documents\n\n#### Change\n\n- Renamed \"approximateCardinality\" aggregate to \"cardinalityValues\" to unify the search spec in Cognite.\n- \"uniqueProperties\" aggregate no longer supports pagination. It returns unique properties (up to 10000) in the specified path. The results are sorted by frequency.\n\n#### Added\n\n- Added \"allUniqueProperties\" aggregate that returns all unique properties. The response contains a cursor that can be used to fetch all pages of data.\n\n## 2023-02-03\n\n### Seismic\n\n#### Added\n\n- Batch downloading of seismics as a ZIP archive is now an experimental v1 endpoint. A user requires the experimental ACL to use this endpoint, and any other ACLs and scopes to read the downloadable seismics.\n\n#### Fixed\n\n- The documentation for downloading seismics as SEG-Y files is part of v1. The API documentation didn't reflect that the endpoint had been promoted to version 1.\n\n## 2023-02-07\n\n### Documents\n\n#### Added\n\n- Added `highlight` field in the `search` endpoint to indicate whether matches in search results should be highlighted.\n\n## 2023-01-18\n\n### 3D\n\n#### Added\n\n- Added support for using names filter in list nodes endpoint.\n\n## 2023-01-17\n\n### Authentication\n\n#### Removed\n\nWe've removed authentication via CDF service accounts and API keys, and user sign-in via `/login`.\n\n### 3D\n\n#### Added\n\n- Added support for storing translation and scale for model revision.\n\n## 2023-01-12\n\n### Documents\n\n#### Added\n\n- Added support for approximateCardinality aggregate.\n\n## 2023-01-10\n\n### Documents\n\n#### Added\n\n- Added the search leaf filter, to allow filtering by searching through specified properties.\n\n## 2023-01-09\n\n### Documents\n\n#### Added\n\n- Added the uniqueProperties aggregation, which can be used to find all the metadata keys in use.\n\n## 2023-01-06\n\n### Documents\n\n#### Added\n\n- Added inAssetSubtree filter to filter documents that have a related asset in a subtree rooted at any of the specified IDs.\n\n## 2023-01-02\n\n### Documents\n\n#### Added\n\n- Added advanced filters for metadata (prefix, in, equals)\n\n## 2022-12-06\n\n### 3D\n\n#### Added\n\n- Added get3DNodesById endpoint to be able to fetch 3D nodes mapped to an asset.\n\n## 2022-12-16\n\n### Time series\n\n#### Changed\n\n- Timestamps of data points may now be as large as 4102444799999 (23:59:59.999, December 31, 2099). The previous limit was the year 2050.\n\n## 2022-11-29\n\n### Events\n\n#### Added\n\n- Added `nulls` field to the sort property specification\n\n## 2022-11-17\n\n### Time series\n\n#### Added\n\n- Added `nextCursor` field to [Retrieve data points](tag/Time-series/operation/getMultiTimeSeriesDatapoints), to support cursor pagination\n\n## 2022-10-14\n\n### Geospatial\n\n#### Added\n\n- Added the [POST /projects/{project}/geospatial/compute](tag/Geospatial/operation/compute) endpoint.\n\n## 2022-10-11\n\n### Transformations\n\n#### Added\n\n- Added capability to run a transformation with Nonce credentials provided through the Run endpoint.\n\n## 2022-10-06\n\n### IAM (Identity and access management)\n\n#### Added\n\n- Added the [POST /projects/{project}/sessions/byids](tag/Sessions/operation/getSessionsByIds) endpoint.\n\n## 2022-09-09\n\n### Vision (Contextualization)\n\n#### Added\n\n- Move Vision extract service from playground to V1.\n\n## 2022-08-12\n\n### Time series\n\n#### Changed\n\n- Updated datapoints timestamp range from 1971 - 2050 to 1900 - 2050.\n  Affected endpoints:\n  - [Insert data points](tag//Time-series/operation/postMultiTimeSeriesDatapoints)\n  - [Retrieve data points](tag//Time-series/operation/getMultiTimeSeriesDatapoints)\n  - [Delete data points](tag//Time-series/operation/deleteDatapoints)\n  - [Retrieve latest data point](tag//Time-series/operation/getLatest)\n  - [Synthetic query](tag//Synthetic-Time-Series/operation/querySyntheticTimeseries)\n\n## 2022-07-21\n\n### Transformations\n\n#### Added\n\n- Added authentication using nonce for transformation's exisiting endpoints.\n\n## 2022-06-21\n\n### Annotations (Data organization)\n\n#### Added\n\n- Moved the annotation service from playground to v1.\n\n## 2022-07-07\n\n### Events\n\n#### Removed\n\n- End-of-life for [filter.rootAssetIds](tag/Events/operation/advancedListEvents) filtering attribute.\n\n## 2022-06-13\n\n### IAM (Identity and access management)\n\n#### Added\n\n- Added the [POST /projects/{project}/sessions/revoke](tag/Sessions/operation/revokeSessions) endpoint.\n\n## 2022-05-20\n\n### Documents\n\n#### Added\n\n- Added the `POST /documents/aggregate` endpoint. The endpoint allows you to count documents optionally grouped by a property and also to retrieve all unique values of a property.\n\n## 2022-05-12\n\n### Documents\n\n#### Added\n\n- Added the `POST /documents/list` endpoint. The endpoint allows you to iterate through all the documents in a project.\n- Added the `POST /documents/{documentId}/content` endpoint. The endpoint lets you download the entire extracted plain text of a document.\n\n## 2022-04-11\n\n### Documents\n\n#### Added\n\n- Added the [GET /documents/{documentId}/preview/image/pages/{pageNumber}](tag/Document-preview/operation/documentsPreviewImagePage) endpoint.\n- Added the [GET /documents/{documentId}/preview/pdf](tag/Document-preview/operation/documentsPreviewPdf) endpoint.\n- Added the [GET /documents/{documentId}/preview/pdf/temporarylink](tag/Document-preview/operation/documentsPreviewPdfTemporaryLink) endpoint.\n\n## 2022-03-15\n\n### Sequences\n\n#### Changed\n\n- Changed sequences column limits. Old limit of maximum total 200 columns limits is updated to maximum 400 total columns, maximum 400 numeric columns and maximum 200 string columns.\n\n## 2022-03-02\n\n### Sequences\n\n#### Added\n\n- Added the [POST /sequences/data/latest](tag/Sequences/operation/getLatestSequenceRow) endpoint.\n\n## 2022-02-08\n\n### Time series\n\n#### Changed\n\n- Marked `isStep` parameter to be editable (i.e. removed description stating it is not updatable) in [POST /timeseries/create](tag/Time-series/operation/postTimeSeries).\n\n#### Added\n\n- Added `isStep` parameter to the `TimeSeriesPatch` object used in [POST /timeseries/update](tag/Time-series/operation/alterTimeSeries)\n\n## 2022-02-07\n\n### Documents\n\n#### Added\n\n- The [POST /documents/search](tag/Documents/operation/documentsSearch) endpoint now supports pagination.\n\n## 2022-01-25\n\n### Documents\n\n#### Added\n\n- Added the [POST /documents/search](tag/Documents/operation/documentsSearch) endpoint.\n\n## 2022-01-24\n\n### Time series\n\n#### Added\n\n- Added optional `ignoreUnknownIds` parameter to [POST /sequences/delete](tag/Sequences/operation/deleteSequences). Setting this to true will prevent the operation from failing if one or more of the given sequences do not exist; instead, those given sequences that do exist will be deleted.\n\n## 2021-12-07\n\n### Transformations\n\n#### Added\n\n- New [Transformations](tag//Transformations) APIs to v1 to create,retrieve,list and delete transformations\n- New [Transformation Jobs](tag//Transformation-Jobs) APIs to v1 to retrieve and list transformation jobs or job metrics\n- New [Transformation Schedule](tag//Transformation-Schedules) APIs to v1 to manage schedules of transformations\n- New [Transformation Notifications](tag//Transformation-Notifications) APIs to v1 to manage notifications from transformation job\n\n## 2021-11-22\n\n### Contextualization\n\n#### Added\n\n- Added [diagram detect](tag/Engineering-diagrams/operation/diagramDetect) endpoint to v1 to detect annotations in engineering diagrams\n- Added [diagram detect results](tag/Engineering-diagrams/operation/diagramDetectResults) endpoint to v1 to get the results from an engineering diagram detect job\n- Added [diagram convert](tag/Engineering-diagrams/operation/diagramConvert) endpoint to v1 to create interactive engineering diagrams in SVG format with highlighted annotations\n- Added [diagram convert results](tag/Engineering-diagrams/operation/diagramConvertResults) endpoint to v1 to get the results for a job converting engineering diagrams to SVGs\n\n## 2021-11-17\n\n### 3D\n\n#### Added\n\n- Added `dataSetId` support to 3D models enabling data access scoping of 3D data\n\n## 2021-10-13\n\n### Raw\n\n#### Changed\n\n- To align with Microsoft Azure clusters, table and database names are now sensitive to trailing spaces also in Google Cloud Platform clusters.\n\n## 2021-10-05\n\n### Extraction Pipelines\n\n#### Added\n\n- New [Extraction Pipelines](tag//Extraction-Pipelines) resource to document extractors and monitor the status of data ingestion to make sure reliable and trustworthy data are flowing into the CDF data sets.\n- API endpoints for creating, managing, and deleting extraction pipelines. Capture common attributes around extractors such as owners, contacts, schedule, destination RAW databases, and data set. Document structured metadata in the form of key-value attributes as well unstructured `documentation` attribute that supports Markdown (rendered as Markdown in Fusion).\n- Extraction Pipelines Runs are CDF objects to store statuses related to an extraction pipeline. The supported statuses are: `success`, `failure` and `seen`. They enable extractor developers to report status and error message after ingesting data. As well enables for reporting heartbeat through `seen` status by the extractor to easily identify issues related to crushed applications and scheduling issues.\n\n## 2021-09-28\n\n### Sequences\n\n#### Added\n\n- Added `partition` parameter to the [GET /sequences](tag/Sequences/operation/listSequences) endpoint to support [parallel retrieval](section/Parallel-retrieval).\n- [POST /sequences/list](tag/Sequences/operation/advancedListSequences) now supports [parallel retrieval](section/Parallel-retrieval).\n\n### Time series\n\n#### Added\n\n- Added `partition` parameter to the [GET /timeseries](tag/Time-series/operation/getTimeSeries) endpoint to support [parallel retrieval](section/Parallel-retrieval).\n\n## 2021-08-18\n\n### IAM (Identity and access management)\n\n#### Added\n\nAdded sessions to [v1](tag//Sessions). Sessions let you securely delegate access to CDF resources for CDF services (such as Functions) by an external principal and for an extended time.\n\n## 2021-08-12\n\n### Relationships\n\n#### Added\n\n- Relationships now support [Parallel Retrieval](section/Parallel-retrieval)\n\n## 2021-07-01\n\n### 3D\n\n#### Added\n\n- Added filter3dNodes endpoint to allow for more advanced filtering on node metadata\n\n## 2021-06-29\n\n### Labels\n\n#### Added\n\n- [Dataset scoping](tag/Labels/operation/listLabels) based on `dataSetIds`.\n\n## 2021-06-08\n\n### Sequences\n\n#### Added\n\n- Added [syntax for updating columns](tag/Sequences/operation/updateSequences) of existing sequences. Can `remove` columns, `modify` existing columns, and `add` new columns as well.\n\n## 2021-06-01\n\n### Assets\n\n#### Added\n\n- Added labels replace (set) method for [assets update](tag/Assets/operation/updateAssets).\n\n## 2021-04-28\n\n### Time series\n\n#### Changed granularity limits on hour aggreagates\n\nYou can now ask for a [granularity](https://docs.cognite.com/dev/concepts/aggregation/#granularity)\nof up to 100000 hours (previously 48 hours), both in normal aggregates and in synthetic time series.\n\n## 2021-04-12\n\n### IAM (Identity and access management)\n\n#### Added\n\n- Added a [projects list](tag/Projects/operation/listProjects) endpoint to v1\n- Added a [token inspection](tag/Token/operation/inspectToken) endpoint to v1\n\n## 2021-04-06\n\n### Authentication\n\n#### Deprecated\n\nWe are deprecating authentication via CDF service accounts and API keys, and user sign-in via `/login`, in favor of registering applications and services with your IdP (identity provider) and [using OpenID Connect](https://docs.cognite.com/cdf/access/) and the IdP framework to manage CDF access securely.\n\nThe legacy authentication flow is available for customers using Cognite Data Fusion (CDF) on GCP until further notice. We strongly encourage customers to adopt [the new authentication flows](https://docs.cognite.com/cdf/access/) as soon as possible.\n\nThe following API endpoints are deprecated:\n\n- `/api/v1/projects/*/apikeys`\n- `/api/v1/projects/*/serviceaccounts`\n- `/login`\n- `/logout`\n- `/api/v1/projects/*/groups/serviceaccounts` <sup>\\*</sup>\n\n<sup>\\*</sup>only the sub-resources for listing, adding, and removing members of groups.\n\n## 2021-03-22\n\nCDF API 0.5, 0.6 reached their end-of-life after its initial deprecation announcement in Summer 2019.\n\n## 2021-03-10\n\n### 3D\n\n#### Added\n\n- Added `partition` parameter to the List 3D Nodes endpoint for supporting parallel requests.\n- Added `sortByNodeId` parameter to the List 3D Nodes endpoint, improving request latency in most cases if set to `true`.\n\n## 2021-02-26\n\n### Entity matching\n\n#### Fixed\n\n- Fixed a bug in the documentation for Entity matching. The (job) `status` shall be capitalized string.\n\n## 2020-12-22\n\n### Files\n\n#### Added\n\n- New field `fileType` inside `derivedFields` to refer to a pre-defined subset of MIME types.\n- New filter `fileType` inside `derivedFields` to find files with a pre-defined subset of MIME types.\n\n## 2020-10-20\n\n### Files\n\n#### Added\n\n- New field `geoLocation` to refer to the geographic location of the file.\n- New filter `geoLocation` to find files matching a certain geographic location.\n\nTo learn how to leverage new geoLocation features, [follow our guide](https://developer.cognite.com/dev/concepts/resource_types/files.html).\n\n## 2020-08-29\n\n### Files\n\n#### Added\n\n- New field `directory` referring to the directory in the source containing the file.\n- New filter `directoryPrefix` allows you to find Files matching a certain directory prefix.\n\n## 2020-08-05\n\n### Files\n\n#### Added\n\n- New field `labels` allows you to attach labels to Files upon creation or updating.\n- New filter `labels` allows you to find Files that have been annotated with specific labels.\n\n## 2020-07-08\n\n### IAM (Identity and access management)\n\n#### Added\n\n- New project field `applicationDomains`. If this field is set, users only sign in to the project through applications hosted on\n  a whitelisted domain. [Read more](https://developer.cognite.com/dev/guides/iam/#application-domains).\n\n## 2020-07-01\n\n### Events\n\n#### Added\n\n- New aggregation [`uniqueValues`](tag/Events/operation/aggregateEvents) allows you to find different types, subtypes of events in your project.\n\n## 2020-06-29\n\n### Labels\n\n#### Added\n\n- New data organization resource: [labels](tag//Labels). Manage terms that you can use to annotate and group assets.\n\n### Assets\n\n#### Added\n\n- New filter `labels` allows you to find resources that have been annotated with specific labels.\n\n### Time series\n\n#### Added\n\n- Combine various input time series, constants and operators with on-the-fly [synthetic time series](https://developer.cognite.com/dev/concepts/resource_types/synthetic_timeseries.html).\n\n## 2020-04-28\n\n### Events\n\n#### Added\n\n- New filtering capabilities to find open events [`endTime=null`](tag/Events/operation/advancedListEvents).\n- New filtering capabilities to find all events intersecting a timespan using [activeAtTime](tag/Events/operation/advancedListEvents).\n\n## 2020-03-12\n\n### General\n\n#### Added\n\n- New data organization resource: [data sets](tag//Data-sets). Document and track data lineage, ensure data integrity, and allow 3rd parties to write their insights securely back to your Cognite Data Fusion (CDF) project.\n- New attribute `datasetId` introduced in assets, files, events, time series and sequences.\n- New filter `dataSetIds` allows you to narrow down results to resources containing `datasetId` by a list of ids or externalIds of a data set. Supported by assets, files, events, time series and sequences.\n- We have added a new aggregation endpoint for [time series](tag/Files/operation/aggregateFiles). With this endpoint, you can find out how many results in a tenant meet the criteria of a filter. We will expand this feature to add more aggregates than `count`.\n\n### Groups\n\n#### Added\n\n- Introduced a new capability: `datasetsAcl` for managing access to data set resources.\n- New scope `datasetScope` for assets, files, events, time series and sequences ACLs. Allows you to scope down access to resources contained within a specified set of data sets.\n\n## 2020-03-10\n\n### 3D\n\n#### Fixed\n\n- We fixed a bug in the documentation of [3D model revisions](tag/3D-Model-Revisions/operation/get3DNodesById). Applications should anticipate that 3D nodes may not have a bounding box.\n\n## 2020-02-25\n\n### Assets\n\n#### Added\n\n- We have added a new [aggregation endpoint](tag/Assets/operation/aggregateAssets) for assets. With this endpoint, you can find out how many assets in a tenant meet the criteria of a filter. We will expand this feature to add more aggregates than `count`.\n\n### Events\n\n#### Added\n\n- We have added a new [aggregation endpoint](tag/Events/operation/aggregateEvents) for events. With this endpoint, you can find out how many events in a tenant meet the criteria of a filter. We will expand this feature to add more aggregates than `count`.\n\n## 2020-02-12\n\n### Assets\n\n#### Added\n\n- We have added new aggregation properties: `depth` and `path`. You can use the properties in the filter and retrieve endpoints.\n\n## 2020-02-10\n\n### Assets\n\n#### Added\n\n- Added the property `parentExternalId` which is returned for all assets which have a parent with a defined `externalId`.\n\n## 2019-12-09\n\n### General\n\n#### Added\n\n- Added `assetSubtreeIds` as a parameter to filter, search, and list endpoints for all core resources. `assetSubtreeIds` allows you to specify assets that are subtree roots, and then only retrieve resources that are related to assets within those subtrees.\n\n## 2019-12-04\n\n### Assets\n\n#### Added\n\n- Added the ability to [filter](tag/Assets/operation/searchAssets) assets by parent external IDs.\n\n## 2019-11-18\n\n### Events\n\n#### Added\n\n- [Added the ability to filter events by the external ID of linked assets](tag/Events/operation/advancedListEvents)\n\n## 2019-11-12\n\n### Access control\n\n#### Removed\n\n- Groups can no longer be created with a permissions field in v0.5.\n\n## 2019-10-31\n\n### Assets\n\n#### Added\n\n- [Asset search](/api/v1/#operation/searchAssets) now has a `search.query` parameter. This uses an improved search algorithm that tries a wider range of variations of the input terms and gives much better relevancy ranking than the existing `search.name` and `search.description` fields.\n\n### Time Series\n\n#### Changed\n\n- The `search.query` parameter for [time series search](/api/v1/#operation/searchTimeSeries) now uses an improved search algorithm that tries a wider range of variations of the input terms, and gives much better relevancy ranking.\n\n## 2019-10-23\n\n### Files\n\n#### Added\n\n- Added support for updating the `mimeType` for existing files in files/update requests.\n\n## 2019-10-18\n\n### Time Series\n\n#### Added\n\n- Time series expanded their filtering capabilities with new `Filter time series` endpoint, allowing for additional filtering by:\n\n  - Name\n  - Unit\n  - Type of time series: string or step series\n  - Metadata objects\n  - ExternalId prefix filtering\n  - Create and last updated time ranges\n\n  Endpoint in addition support pagination and partitioning. Check out detailed API documentation [here](/api/v1/#operation/listTimeSeries).\n\n## 2019-10-16\n\n### Events\n\n#### Added\n\n- [Added the ability to sort events on startTime, endTime, createdTime, and lastUpdatedTime](tag/Events/operation/advancedListEvents)\n\n## 2019-10-02\n\n### Sequences\n\n#### Added\n\n- Introducing the new **sequences** core resource type that lets you store numerically indexed multi-column rows of data. Connect your sequences to physical assets and to their source systems through `externalId` and metadata support. Read more [here](https://developer.cognite.com/dev/concepts/resource_types/sequences.html).\n\n## 2019-09-30\n\n### 3D\n\n#### Added\n\n- Added endpoint to get multiple nodes for a 3D model by their IDs.\n- Added endpoint to get asset mappings for multiple node IDs or asset IDs.\n\n## 2019-09-23\n\n### Files\n\n#### Added\n\n- Added support for filter on `rootAssetIds` in files GET /files (using query parameter) and POST /files/list (in request body).\n\n## 2019-09-16\n\n### Assets and Events\n\n#### Added\n\n- Added support for `partition` in `/assets` and `/events` to support parallel retrieval. See guide for usage [here](./concepts/pagination)\n\n## 2019-08-22\n\n### 3D\n\n#### Added\n\n- Added the query parameter `intersectsBoundingBox` to the list asset mappings endpoint. The parameter filters asset mappings to the assets where the bounding box intersects (or is contained within) the specified bounding box.\n\n## 2019-08-21\n\n### Files\n\n#### Added\n\n- Added support for sourceCreatedTime and sourceModifiedTime fields in files v1 endpoints.\n\n### Assets\n\n#### Added\n\n- Allow the parent asset ID to be updated. The root asset ID must be preserved, and you can not convert a non-root asset to a root asset or vice versa.\n- Support for ignoreUnknownIds when deleting assets.\n\n## 2019-08-15\n\n### 3D\n\n#### Added\n\n- Properties field for 3D nodes, extracted from uploaded 3D files.\n- Ability to filter nodes with a specific set of properties.\n\n## 2019-07-24\n\n### Files\n\n#### Changed\n\n- Allow lookup of names with length up to 256 characters (was 50) for GET /files and POST /files/search operations.\n- Allow creating and retrieving files with mimeType length up to 256 characters (was 64).\n\n## 2019-07-15\n\n### Time series\n\n#### Added\n\n- Added query parameter `rootAssetIds` to list time series endpoint. Returns time series that are linked to an asset that has one of the root assets as an ancestor.\n\n## 2019-07-11\n\nList of changes for initial API v1 release in comparison to previous version - API 0.5\n\n### General\n\n#### Added\n\n- Support for `externalId` added across resource types. `externalId` lets you define a unique ID for a data object. Learn more: [External IDs](https://developer.cognite.com/dev/concepts/external_id.html)\n- `externalIdPrefix` added as a parameter to the list events, assets and files operations.\n- Richer filtering on the list assets, files and events operations.\n- Search, list and filter operations for assets, events and files now support filtering on source and metadata field values.\n\n#### Changed\n\n- Core resources standardize on HTTP methods and URI naming for common operations such as search, partial updates, delete, list and filter\n- API responses are no longer wrapped in a top level `data` object.\n- Standardized pagination across resources through `limit`, `cursor` and `nextCursor` parameters.\n- The `limit` parameter no longer implicitly rounds down requested page size to maximum page size.\n- Standardized error responses and codes across all resources. Errors across CDF can be parsed into a single model.\n- Overall improvements to reference documentation. Including documented input constraints, required fields, individual attribute descriptions.\n\n#### Removed\n\n- The `sourceId` field has been removed from resources. Use `externalId` instead of `sourceId`+`source` to define unique IDs for data objects.\n- Sorting is removed from the search operations for files, assets, events and time series. Results are sorted by relevance.\n- `offset` and `previousCursor` parameters are no longer supported for pagination across resources.\n- Fetching an asset subtree is no longer supported by files, assets, events and time series.\n\n### Assets\n\n#### Added\n\n- Ability to select only root assets though new `root` filter.\n- Added the `rootId` field to specify the top element in an asset hierarchy.\n- Added the ability to filter by the root asset ID. This allows you to scope queries for one or many asset hierarchies.\n- List Assets allows for filtering assets belonging to set of root assets, specified by list of asset internal ids. New query parameter: `rootIds`.\n- Filter and Search Assets allows or filtering assets belonging to a set of root assets, specified by combination of internal and external asset identifiers. New body attribute: `rootIds`.\n\n#### Changed\n\n- Updating a single asset is no longer supported through a separate endpoint. Use the update multiple endpoint instead.\n- Delete assets by default removes only leaf assets (assets without children). New parameter 'recursive' allows for enabling recursive removal of the entire subtree of the asset pointed by ID (API 0.5 behaviour).\n\n#### Removed\n\n- Overwriting assets is no longer supported.\n- Filtering assets by their complete description is no longer supported.\n- Locating assets fuzzily by name has been removed. Instead, search for assets on the `name` property.\n- When searching assets, querying over both name and description in the same query is no longer supported.\n- The experimental query parameter `boostName` has been removed from the search for assets operation.\n- Removed the `path` and `depth` fields.\n\n### Events\n\n#### Added\n\n- Events can now be filtered on asset ID in combination with other filters.\n- New filter `rootAssetIds` allows for narrowing down events belonging only to list or specified root assets. Supported by Filter and Search API\n\n#### Removed\n\n- Events can no longer be filtered by empty description.\n- The 'dir' parameter has been removed from the search events operation.\n\n### Files\n\n#### Added\n\n- Filtering files by `assetIds` in list files operations now support multiple assets in the same request.\n\n#### Changed\n\n- Download file content has changed from HTTP GET to HTTP POST method.\n- We have renamed the `fileType` field to `mimeType`. The field now requires a MIME formatted string (e.g. `text/plain`).\n- We have renamed the `uploadedAt` field to `uploadedTime`.\n- Resumable is now the default behavior for file uploads.\n- Update metadata for single files is no longer supported by a separate operation. Instead, use the update multiple operation.\n\n#### Removed\n\n- Replace files metadata endpoint has been removed.\n- Directory has been removed as a property of files.\n- Updating the `name` or `mimeType` of a file through the update multiple files operation is no longer supported.\n- Query parameter for specifying the sort direction has been removed from list all files operations.\n\n### Raw\n\n#### Changed\n\n- Raw has changed structure to become resource-oriented. The URL structure has changed.\n- Recursively delete of tables and rows when deleting a database is now the default behavior without a control parameter.\n\n### Time series\n\n#### Added\n\n- Support for adding datapoints by `id` and `externalId` of time series. Adding datapoints to time series by `name` has been removed.\n- Add ability to update the new `externalId` attribute for time series.\n- Allow to set `externalId` during creation of time series. `ExternalId` requires uniqueness across time series.\n- Consolidate multiple APIs to allow adding datapoints into a single endpoint. Allows datapoints to be added to multiple time series at the same time.\n- Retrieve data points by using `id` and `externalId` of the time series.\n- Time series created through API v1 are not discoverable by API 0.3, 0.4, 0.5 and 0.6 by default. Introduce the option to enable this compatibility by setting new attribute - `legacyName` on time series creation. Value is required to be unique.\n\n#### Changed\n\n- Get latest datapoints has been reworked. Introduces support for `id` and `externalId` lookup as well retrieval for multiple time series within the same request.\n- Time series name is no longer limited by uniqueness. Note that time series (meta objects) created by API v1 will not be discoverable by older API versions.\n- Delete time series endpoint has been redesigned to allow deletion of multiple time series by `id` and `externalId`.\n- Delete single and multiple datapoints endpoint has been redesigned and consolidated into a single endpoint. New delete allows selection of multiple time series and time ranges by `id` and `externalId`. Selecting by `name` is no longer available.\n- Update multiple time series restructured to support lookup by `externalId`.\n- Retrieve time series by ID endpoint restructured adding the ability to get time series by `externalId`.\n- Set limit for data point value to min -1E100, max 1E100.\n\n#### Removed\n\n- Experimental feature for performing calculations across multiple time series (synthetic time series), function and alias attributes are no longer available.\n- The experimental query parameter `boostName` has been removed from search operation.\n- Short names for aggregate functions are no longer supported.\n- Ability to remove time series by `name` have been removed as names are no longer unique identifiers.\n- Select multiple time series and time ranges by `name` is no longer available.\n- The ability to update `isString` and `isStep` attributes is removed. The attributes are not intended to be modified after creation of time series.\n- The endpoint for updating single time series is removed. Use the update multiple time series endpoint instead.\n- Remove ability to overwrite time series object by `id`. Use the update multiple time series endpoint instead.\n- The ability to retrieve time series matching by `name` has been removed. Use `externalId` instead.\n- The ability to retrieve by `id` from a single time series has been removed. Use retrieve multiple datapoints for multiple time series instead.\n- The ability to retrieve time-aligned datapoints through \"dataframe\" API has been removed. Similar functionality is available through our supported SDKs.\n- The ability to add datapoints to time series by `name` has been removed.\n- The ability to look up by time series `name` has been removed.\n\n### IAM (Identity and access management)\n\n#### Added\n\n- The login status endpoint includes the ID of the API key making the request (new attribute: `apiKeyId`), if the request used an API key.\n\n#### Changed\n\n- The user resource type has been replaced with service accounts. Users from previous API versions are equivalent to service accounts.\n- Adding, listing and removing users from a group has been replaced by equivalent operations for service accounts.\n- Retrieve project returns a single object instead of a list.\n- API keys endpoints for list/create rename `userId` attribute to `serviceAccountId`.\n\n#### Removed\n\n- List and create groups no longer use the `permissions` and `source` attributes.\n\n### 3D\n\n#### Added\n\n- New 3D API lets you upload and process 3D models. Supported format: FBX.\n- Ability to create and maintain multiple revisions for the 3D models.\n- API for mapping relationships between 3D model nodes and asset hierarchy.\n"
    },
    {
      "name": "Token",
      "description": "Access tokens issued by an IdP (Azure AD, Google, etc.) are used to access CDF resources.\n"
    },
    {
      "name": "Assets",
      "description": "The assets resource type stores digital representations of objects or\ngroups of objects from the physical world. Assets are organized in hierarchies.\nFor example, a water pump asset can be a part of a subsystem asset on an\noil platform asset.\n\n## Rate and concurrency limits\n\nBoth the rate of requests (denoted as request per second, or **rps**) and the number of concurrent (parallel) requests are governed by limits,\nfor all CDF API endpoints.  If a request exceeds one of the limits,\nit will be throttled with a `429: Too Many Requests` response. More on limit types\nand how to avoid being throttled is described\n[here](https://developer.cognite.com/dev/concepts/request_throttling/).\n\nLimits are defined at both the overall API service level, and on the API endpoints belonging to the service.\\\nSome types of requests consume more resources (compute, storage IO) than others, and where a service handles\nmultiple concurrent requests with varying resource consumption.\nFor example, CRUD type requests (**C**reate, **R**etrieve, **R**equest ByIDs, **U**pdate and **D**elete) are far less resource\nintensive than Analytical type requests (List, Search and Filter) and in addition, the most resource\nintensive Analytical endpoint of all, Aggregates, receives its own request budget within the overall Analytical request budget.\\\nThe version 1.0 limits for the overall API service and its constituent endpoints are illustrated in the diagram below.\\\nThese limits are subject to change, pending review of changing consumption patterns and resource availability over time:\n\n<img src=\"https://apps-cdn.cogniteapp.com/@cognite/docs-portal-images/1.0.0/images/api-docs/AssetsLimitsFeb2023.png\" alt=\" \" width=\"80%\"/>\n\n### Translating RPS into data speed\nA single request may retrieve up to 1000 items.  In the context of Assets, 1 item = 1 asset record\\\nTherefore, the maximum theoretical data speed at the top API service level is 200,000 items per second for all consumers,\nand 150,000 for a single identity or client in a project.\n\n### Use of Partitions / Parallel Retrieval\nAs a general guidance, Parallel Retrieval is a technique that should be used where due to query complexity, retrieval of data in a\nsingle request session turns out to be slow.  By parallelizing such requests, data retrieval performance can be tuned to meet the\nclient application needs.  Parallel retrieval may also be used where retrieval of large sets of data is required, up to the\ncapacity limits defined for a given API service.  For example (using the Assets API request budget):\n\n* A single request may retrieve up to 1000 items\n* Up to 23 requests per second may be issued for an analytical query (per identity), such as when using /list or /filter API endpoints\n* This provides a theoretical maximum of 23,000 items read per second per identity\n* The query complexity may result in it taking longer than 1s to read or write 1000 items in a single request\n* Therefore, it is appropriate to specify the query to retrieve a lower number of items per request, and retrieve more items in parallel, up to the theoretical maximum performance of 23,000 items per second.\n\n**Important Note:**\nParallel retrieval should be only used in situations where, due to query complexity,\na single request flow provides data retrieval speeds that are significantly less than the theoretical maximum.\\\nParallel retrieval does not act as a speed multiplier on optimally running queries.  Regardless of the number\nof concurrent requests issued, the overall requests per second limit still applies.\\\nSo for example, a single request returning data at approximately 18,000 items per second will only\nbenefit from adding a second parallel request, the capacity of which goes somewhat wasted\nas only an additional 5,000 items per second will return before the request rate budget limit is reached."
    },
    {
      "name": "Data Modeling",
      "description": "Use the Data Modeling Service to build industrial knowledge graphs. For more information, see [Data modeling](https://docs.cognite.com/cdf/dm).\n\nThis page contains the specifications for the 5 core data modeling resources:\n  - Spaces\n  - Instances (Nodes & Edges)\n  - Containers\n  - Views\n  - Data Models\n"
    },
    {
      "name": "Events",
      "description": "Events objects store complex information about multiple assets over a time period.\nTypical types of events that would be stored in this service might include Alarms, Process Data, and Logs.\\\nFor the storage of low volume, manually generated, schedulable activities (such as maintenance schedules,\nwork orders or other appointment type activities, the Data Modelling service is now recommended.\n\n#### Important Note:\nEvents and Time Series are somewhat closely related in that both are high volume types of data,\ncapable of recording data in microsecond resolutions.  However, Events is not recommended as a Time Series store,\nsuch as where the data flow is from a single instance of sensors (i.e. temperature, pressure, voltage),\nsimulators or state machines (on, off, disconnected, etc).\\\nTime Series offers very low latency read and write performance, as well as specialised filters and aggregations that\nare tailored to the analysis of time series data.\n\nAn events time period is defined by a start time and end time, both millisecond timestamps since the UNIX epoch.\nThe timestamps can be in the future. In addition, events can have a text description as well as arbitrary metadata and properties.\\\nWhen storing event information in metadata, it should be considered that all data is stored as string format.\n\n#### Note:\nIn Events API, timestamps are treated as strings when added to\nmetadata fields and arent converted to the users local time zone.\n\n**Caveats:**\\\nDue to the eventually consistent nature of Asset IDs stored in Events,\nit should be noted that Asset ID references obtained from the Events API may\noccasionally be invalid (such as if an Asset ID is deleted,\nbut the reference to that ID remains in the Event record for a time).\n\nAsset references obtained from an event - through asset ids - may be\ninvalid, simply by the non-transactional nature of HTTP.\nThey are maintained in an eventual consistent manner.\n\n## Rate and concurrency limits\n\nBoth the rate of requests (denoted as request per second, or **rps**) and the number of concurrent (parallel) requests are governed by limits,\nfor all CDF API endpoints.  If a request exceeds one of the limits,\nit will be throttled with a `429: Too Many Requests` response. More on limit types\nand how to avoid being throttled is described\n[here](https://developer.cognite.com/dev/concepts/request_throttling/).\n\nLimits are defined at both the overall API service level, and on the API endpoints belonging to the service.\\\nSome types of requests consume more resources (compute, storage IO) than others, and where a service handles\nmultiple concurrent requests with varying resource consumption.\nFor example, CRUD type requests (**C**reate, **R**etrieve, **R**equest ByIDs, **U**pdate and **D**elete) are far less resource\nintensive than Analytical type requests (List, Search and Filter) and in addition, the most resource\nintensive Analytical endpoint of all, Aggregates, receives its own request budget within the overall Analytical request budget.\\\nThe version 1.0 limits for the overall API service and its constituent endpoints are illustrated in the diagram below.\\\nThese limits are subject to change, pending review of changing consumption patterns and resource availability over time:\n\n<img src=\"https://apps-cdn.cogniteapp.com/@cognite/docs-portal-images/1.0.0/images/api-docs/EventsLimitsNov23.png\" alt=\" \" width=\"80%\"/>\n\n### Translating RPS into data speed\nA single request may retrieve up to 1000 items.  In the context of Events, 1 item = 1 event record\\\nTherefore, the maximum theoretical data speed at the top API service level is 200,000 items per second for all consumers,\nand 150,000 for a single identity or client in a project.\n\n### Use of Partitions / Parallel Retrieval\nAs a general guidance, Parallel Retrieval is a technique that should be used where due to query complexity, retrieval of data in a\nsingle request session turns out to be slow.  By parallelizing such requests, data retrieval performance can be tuned to meet the\nclient application needs.  Parallel retrieval may also be used where retrieval of large sets of data is required, up to the\ncapacity limits defined for a given API service.  For example (using the Events API request budget):\n\n* A single request may retrieve up to 1000 items\n* Up to 23 requests per second may be issued for an analytical query (per identity), such as when using /list or /filter API endpoints\n* This provides a theoretical maximum of 23,000 items read per second per identity\n* The query complexity may result in it taking longer than 1s to read or write 1000 items in a single request\n* Therefore, it is appropriate to specify the query to retrieve a lower number of items per request, and retrieve more items in parallel, up to the theoretical maximum performance of 23,000 items per second.\n\n**Important Note:**\nParallel retrieval should be only used in situations where, due to query complexity,\na single request flow provides data retrieval speeds that are significantly less than the theoretical maximum.\\\nParallel retrieval does not act as a speed multiplier on optimally running queries.  Regardless of the number\nof concurrent requests issued, the overall requests per second limit still applies.\\\nSo for example, a single request returning data at approximately 18,000 items per second will only\nbenefit from adding a second parallel request, the capacity of which goes somewhat wasted\nas only an additional 5,000 items per second will return before the request rate budget limit is reached."
    },
    {
      "name": "Files",
      "description": "A file stores a sequence of bytes connected to one or more assets. For\nexample, a file can contain a piping and instrumentation diagram (P&IDs)\nshowing how multiple assets are connected.\n\nEach file is identified by the 'id' field, which is generated internally\nfor each new file. Each file's 'id' field is unique within a project.\n\nThe 'externalId' field is optional, but can also be used to identify a file.\nThe 'externalId' (if used) must be unique within a project.\n\nFiles are created in two steps; First the metadata is stored in a file\nobject, and then the file contents are uploaded. This means that files can\nexist in a non-uploaded state. The upload state is reflected in the 'uploaded'\nfield in responses.\n\nAsset references obtained from a file - through asset ids - may be\ninvalid, simply by the non-transactional nature of HTTP.\nThey are maintained in an eventual consistent manner.\n\n## Rate and concurrency limits\n\nBoth the rate of requests (denoted as request per second, or **rps**) and the number of concurrent (parallel) requests are governed by limits,\nfor all CDF API endpoints.  If a request exceeds one of the limits,\nit will be throttled with a `429: Too Many Requests` response. More on limit types\nand how to avoid being throttled is described\n[here](https://developer.cognite.com/dev/concepts/request_throttling/).\n\nLimits are defined at both the overall API service level, and on the API endpoints belonging to the service.\nSome types of requests consume more resources (compute, storage IO) than others, and where a service handles\nmultiple concurrent requests with varying resource consumption.\nFor example, CRUD type requests (**C**reate, **R**etrieve, **R**equest ByIDs, **U**pdate and **D**elete and similar) are far less resource\nintensive than Analytical type requests (List, Search and Filter) and in addition, the most resource\nintensive Analytical endpoint of all, Aggregates, receives its own request budget within the overall Analytical request budget.\nThe version 1.0 limits for the overall API service and its constituent endpoints are illustrated in the diagram below.\nThese limits are subject to change, pending review of changing consumption patterns and resource availability over time:\n\n<img src=\"https://apps-cdn.cogniteapp.com/@cognite/docs-portal-images/1.0.0/images/api-docs/FilesLimitsFeb2023.png\" alt=\" \" width=\"80%\"/>\n\n### Translating RPS into data speed\nA single request may retrieve up to 1000 items. In the context of Files, 1 item = 1 file record\nTherefore, the maximum theoretical data speed at the top API service level is 160,000 items per second for all consumers,\nand 120,000 for a single identity or client in a project.\n\n### Use of Partitions / Parallel Retrieval\nAs a general guidance, Parallel Retrieval is a technique that should be used where due to query complexity, retrieval of data in a\nsingle request session turns out to be slow.  By parallelizing such requests, data retrieval performance can be tuned to meet the\nclient application needs. Parallel retrieval may also be used where retrieval of large sets of data is required, up to the\ncapacity limits defined for a given API service.  For example (using the Files API request budget):\n\n* A single request may retrieve up to 1000 items\n* Up to 23 requests per second may be issued for an analytical query (per identity), such as when using /list or /filter API endpoints\n* This provides a theoretical maximum of 23,000 items read per second per identity\n* The query complexity may result in it taking longer than 1s to read or write 1000 items in a single request\n* Therefore, it is appropriate to specify the query to retrieve a lower number of items per request, and retrieve more items in parallel, up to the theoretical maximum performance of 23,000 items per second.\n\n**Important Note:**\nParallel retrieval should be only used in situations where, due to query complexity,\na single request flow provides data retrieval speeds that are significantly less than the theoretical maximum.\nParallel retrieval does not act as a speed multiplier on optimally running queries. Regardless of the number\nof concurrent requests issued, the overall requests per second limit still applies.\nSo for example, a single request returning data at approximately 18,000 items per second will only\nbenefit from adding a second parallel request, the capacity of which goes somewhat wasted\nas only an additional 5,000 items per second will return before the request rate budget limit is reached."
    },
    {
      "name": "Functions",
      "description": "Functions enables Python code to be hosted and executed in the cloud, on demand or by using a schedule. Execution, status and logs are available through the API. A function is uploaded to the Files API as a zip file with at least a Python file called `handler.py` (unless specified otherwise through the `functionPath`-argument) that must contain a function named `handle` with any of the following arguments: `data`, `client`, `secrets`, or 'function_call_info', which are passed into the function. \nThe latest version of Cognite SDK's are available, and additional python packages and version specifications can be defined in a `requirements.txt` in the root of the zip."
    },
    {
      "name": "Function calls",
      "description": "Function calls let you execute functions asynchronously with a timeout of 15 minutes."
    },
    {
      "name": "Function schedules",
      "description": "Function schedules allow you to run functions with a specific input at intervals defined by a cron expression. These function calls will be asynchronous and show up in the function call list. Visit http://www.cronmaker.com to generate a cron expression with a UI."
    },
    {
      "name": "3D",
      "description": "We organize 3D data into models and revisions. A model is just a placeholder for a set of revisions. Revisions contains the actual 3D data. For example you can have a model named Compressor and you can upload a revision under that model. When you create a revision you need to attach a 3D file. For every new version of the 3D model you upload a new revision under the placeholder model. You can then easily track the history of a model by browsing the different revisions.\n\nWhen you upload a new revision Cognite need to process the 3D data to optimize it for rendering. This can take some time and we therefore give you a status string back in the revision object. You can then follow the process while you wait.\n\nA 3D model is typically built up by a hierarchical structure. This looks very similar to how we organize our internal asset hierarchy. We support endpoints to extract the 3D node hierarchy and endpoints to make mappings from the 3D nodes to nodes in Cognite's asset hierarchy. We assign a random ID, nodeId, to each node in the 3D hierarchy. This is the ID representing the object in the viewer. When a user click on a object in the viewer it returns the ID for the object that was clicked. You can then use that ID to look up which node in the hierarchy the user clicked on.\n\nWe also deliver a [web based 3D viewer](https://www.npmjs.com/package/@cognite/3d-viewer) to embed the 3D model in your own web page."
    },
    {
      "name": "Time series",
      "description": "A time series consists of a sequence of data points connected to a\nsingle asset. For example, a water pump asset can have a temperature time\nseries that records a data point in units of C every second.\n\nA single asset can have several time series. The water pump could have additional time series\nmeasuring pressure within the pump, rpm, flow volume, power consumption, and more.Time\nseries store data points as either numbers or strings. This is controlled by the\nis_string flag on the time series object. Numerical data points can be aggregated\nbefore they are returned from a query (e.g., to find the average temperature for\na day). String data points, on the other hand, can't be aggregated by CDF but\ncan store arbitrary information like states (e.g., open/closed) or more complex\ninformation (JSON).\n\nCognite stores discrete data points, but the underlying\nprocess measured by the data points can vary continuously. When interpolating\nbetween data points, we can either assume that each value stays the same until\nthe next measurement or linearly changes between the two measurements.\nThe `isStep` flag controls this on the time series object. For example,\nif we estimate the average over a time containing two data points, the average\nwill either be close to the first (`isStep`) or close to the mean of the two (not\n`isStep`).\n\nA data point stores a single piece of information, a number or a\nstring, associated with a specific time. Data points are identified by their timestamps,\nmeasured in milliseconds since the unix epoch -- 00:00:00.000, January 1st, 1970.\nThe time series service accepts timestamps in the range from 00:00:00.000, January 1st, 1900\nthrough 23:59:59.999, December 31st, 2099 (in other words, every millisecond in the two\ncenturies from 1900 to but not including 2100). Negative timestamps are\nused to define dates before 1970. Milliseconds is the finest time resolution supported by CDF, i.e.,\nfractional milliseconds are not supported. Leap seconds are not counted.\n\nNumerical data points can be aggregated before they are retrieved from CDF. This allows for faster queries by reducing\nthe amount of data transferred. You can aggregate data points by specifying one\nor more aggregates (e.g., average, minimum, maximum) as well as the time granularity\nover which the aggregates should be applied (e.g., 1h for one hour).\n\nAggregates are aligned to the start time modulo the granularity unit. For example, if you\nask for daily average temperatures since Monday afternoon last week, the first\naggregated data point will contain averages for Monday, the second for Tuesday,\netc. Determining aggregate alignment without considering data point timestamps\nallows CDF to pre-calculate aggregates (e.g., to quickly return daily average temperatures\nfor a year). Consequently, aggregating over 60 minutes can return a different\nresult than aggregating over 1 hour because the two queries will be aligned differently.\nAsset references obtained from a time series - through its asset ID - may be invalid simply\nby the non-transactional nature of HTTP. They are maintained in an eventually consistent\nmanner."
    },
    {
      "name": "Data point subscriptions",
      "description": "A data point subscription is a way to listen to changes to time series data points, in ingestion order.\n\nA single subscription can listen to many time series, and a time series can be part of many subscriptions.\n\nYou listen to subscriptions by calling the list subscription data endpoint. It will return\na list of data point upserts and deleted ranges, together with a cursor to retrieve the next\nbatch of updates. Updates written since the creation of the subscription, up to 7 days ago, can be\nretrieved through the subscription.\n\nSubscriptions can be defined explicitly through a list of time series external ids and\ninstance ids, or implicitly through a filter. The filter is a subset of the advanced filter\nquery in the regular time series search endpoint.\n\nPartitions:\nSubscriptions can be further divided into a number of partitions, for the purpose of\nfetching subscription data in parallel. Each partition will return data in ingestion order,\nbut the order between partitions is not guaranteed.\n\nLimitations:\n- Each subscription can have at most 10000 time series.\n- A time series can be part of at most 10 subscriptions.\n- A project can have at most 1000 subscriptions, of which 100 are filter subscriptions.\n- Time series with security categories can not be shown in filter subscriptions.\n- Time series with neither external id nor instance id cannot be added to non-filter subscriptions.\n- The number of partitions cannot be changed after creation.\n\nAccess control:\nYou need READ access to subscriptions ACL to read/list\nsubscriptions or list data, and you need WRITE access to create/update/delete subscriptions.\nFurthermore, you need READ access to the time series you want to get updates from.\nFor filter subscriptions, you either need READ access to all time series, or the filter must\nbe restricted according to your access rights (e.g. by filtering on specific data set IDs).\n\nSubscriptions can have data sets that allow for more granular access\ncontrol. The data set on a subscription does not influence the data\nstream, but allows you to restrict who can read/update the subscription.\n\nExample capabilities:\n```\n[\n    {\"timeSeriesAcl\":{\"actions\":[\"READ\"], \"scope\":{\"all\":{}}}},\n    {\"timeSeriesSubscriptionsAcl\":{\"actions\":[\"WRITE\", \"READ\"], \"scope\":{\"all\":{}}}}\n]\n```"
    },
    {
      "name": "Synthetic Time Series",
      "description": "Synthetic Time Series (STS) is a way to combine various input time series, constants and operators, to create completely new time series.\n\nFor example can we use the expression `24 * TS{externalId='production/hour'}` to convert from hourly to daily production rates.\n\nBut STS is not limited to simple conversions.\n* We support combination of different time series `TS{id=123} + TS{externalId='hei'} / TS{space='data modeling space', externalId='dm id'}`.\n* Functions of time series `sin(pow(TS{id=123}, 2))`.\n* Aggregations of time series `TS{id=123, aggregate='average', granularity='1h'}+TS{id=456}`\n* Convert time series with `unitExternalId` to another unit `TS{externalId='temp_c', targetUnit='temperature:deg_f'}`.\n\nTo learn more about synthetic time series please follow [our guide](https://developer.cognite.com/dev/concepts/resource_types/synthetic_timeseries.html)."
    },
    {
      "name": "Raw",
      "description": "Manage data in the raw NoSQL database.\nEach project will have a variable number of raw databases, each of which will have a variable number of tables, each of which will have a variable number of key-value objects.\nOnly queries on key are supported through this API.\\\n\n### Request and concurrency limits\n\nBoth the rate of requests and the number of concurrent (parallel) requests are governed by limits,\nfor all CDF API endpoints.  If a request exceeds one of the limits,\nit will be throttled with a `429: Too Many Requests` response. More on limit types\nand how to avoid being throttled is described\n[here](https://developer.cognite.com/dev/concepts/request_throttling/).\n\nThe limits for the Raw service are described in the table below. Note that under high load,\nsome deviation from the limits might occur for short periods of time as the service is scaling up.\nThe `/rows` endpoints for inserting and retrieving data are governed by specific data rate limits.\n\n| Limit                 | Per project           | Per user (identity) |\n|-----------------------|-----------------------|---------------------|\n| Concurrency           | 64 parallel requests  | 48 parallel requests|\n| Data rate (retrieve)  | 8.3 GB / 10 minutes   | 6.6 GB / 10 minutes |\n| Data rate (insert)    | 1.6 GB / 10 minutes   | 1.3 GB / 10 minutes |"
    },
    {
      "name": "Groups",
      "description": "Groups are used to give principals the capabilities to access CDF resources.\nOne principal can be a member in multiple groups and one group can have multiple members. Note that having more than 20 groups per principal is not supported and may result in login issues.\n\nGroups can either be managed through the external identity provider for the project or managed by CDF.\n- **Group Membership Managed Externally**: Groups membership is managed by the external identity provider. It is not possible edit or see the members of these groups in CDF.\n- **Group Membership Managed within CDF**: Lets you see and edit group membership in CDF instead of relying on the external identity provider.\n"
    },
    {
      "name": "Projects",
      "description": "Projects are used to isolate data in CDF from each other. All objects in CDF belong to a single project, and objects in different projects are generally isolated from each other.\n"
    },
    {
      "name": "Security categories",
      "description": "Manage security categories for a specific project.\nSecurity categories can be used to restrict access to a resource.\nApplying a security category to a resource means that only principals (users or service accounts) that also have this security category can access the resource.\nTo learn more about security categories please read [this page](https://developer.cognite.com/dev/guides/iam/authorization.html#security-categories).\n"
    },
    {
      "name": "Data sets",
      "description": "Data sets let you document and track data lineage, ensure data integrity, and allow 3rd parties to write their insights securely back to a Cognite Data Fusion (CDF) project.\n\n\nData sets group and track data by its source. For example, a data set can contain all work orders originating from SAP. Typically, an organization will have one data set for each of its data ingestion pipelines in CDF.\n\n\nA data set consists of metadata about the data set, and the data objects that belong to the data set. Data objects, for example events, files, and time series, are added to a data set through the `dataSetId` field of the data object. Each data object can belong to only one data set.\n\n\nTo learn more about data sets, see [getting started guide](https://docs.cognite.com/cdf/data_governance/concepts/datasets/)"
    },
    {
      "name": "Sequences",
      "description": "A sequence stores a table with up to 400 columns indexed by row number. There can be at most 400 numeric columns and 200 string columns. Each of the columns has a pre-defined type: a string, integer, or floating point number.\n\nFor example, a sequence can represent a curve, either with the dependent variable x as the row number and a single value column y, or can simply store (x,y) pairs in the rows directly. Other potential applications include data logs in which the index isn't time-based.\nTo learn more about sequences, see the [concept guide](https://developer.cognite.com/dev/concepts/resource_types/sequences.html).\n"
    },
    {
      "name": "Labels"
    },
    {
      "name": "Relationships",
      "description": "The relationships resource type represents connections between resource objects in CDF. Relationships allow you to organize assets in other structures in addition to the standard hierarchical asset structure.\nEach relationship is between a source and a target object and is defined by a relationship type and the external IDs and resource types of the source and target objects. Optionally, a relationship can be time-constrained with a start and end time.\nTo define and manage the available relationship types, use the labels resource type.\nThe externalId field uniquely identifies each relationship."
    },
    {
      "name": "Entity matching",
      "description": "The entity matching contextualization endpoints lets you match CDF resources. For example, you can match time series to assets. The model uses similarity between string-fields from the source and the target to find potential matches, for instance the source name and the target name. The exact algorithm may change over time."
    },
    {
      "name": "Vision",
      "description": "The Vision contextualization endpoints enable extraction of information from imagery data based on their visual content. For example, you can detect external ID or name of assets, detect and read value of gauges or identify common industrial objects in images.\n\nThis service has support for batch processing which enables processing of multiple image files via an asynchronous prediction request. A new contextualization job is triggered by sending a POST request to the service. The response of the POST request contains a job ID, which can then be used to make subsequent calls to check the status and retrieve the results of the job once it is completed."
    },
    {
      "description": "A collection of AI API services in CDF.",
      "name": "Cognite AI"
    },
    {
      "name": "Documents",
      "description": "A document is a file that has been indexed by the document search engine.\nEvery time a file is uploaded, updated or deleted in the Files API, it will also\nbe scheduled for processing by the document search engine. After some processing,\nit will be possible to search for the file in the document search API.\n\nThe document search engine is able to extract content from a variety of document\ntypes, and perform classification, contextualization and other operations on the\nfile. This extracted and derived information is made available in the form of a\n`Document` object.\n\nThe document structure consists of a selection of derived fields, such as the\n`title`, `author` and `language` of the document, plus some of the original fields\nfrom the raw file. The fields from the raw file can be found in the\n`sourceFile` structure. The derived fields are described in more detail below.\n\n### Derived fields\n\n#### title\nSome document types (such as PDFs) contain additional metadata fields. If the\ndocument contains its title as part of this metadata, this field will be populated\nwith that title.\n\nNote that we do not currently extract the title from the document content itself.\nIf there is a need for this, we may consider adding such functionality in the future.\n\n#### author\nSimilar to the `title` field, the author field is another field that can often be\nextracted from the document's metadata.\n\n#### producer\nThe `producer` field also exists in the document metadata. It contains information\nabout the software or the system that was used to create the document.\n\n#### createdTime\nThe `createdTime` we assign to the document is not exactly the same as the one found\nin the Files API. We first try to extract the created time from the document metadata.\nIf the document does not contain such a timestamp, we fall back to the time set in\nthe Files API.\n\n#### mimeType\nIf there is a mime type set in on the file in the Files API, this field will be set\nto the same mime type. If there is no mime type set on the file, we will try to\nauto-detect it.\n\n#### extension\nThis field contains the extension of the file, derived from the file name. For\ninstance, if the file name is `My Document.docx`, the `extension` field will contain\n`docx`.\n\n#### pageCount\nContains the number of pages in the document, if possible to determine.\n\n#### type\nThe `type` field contains a high level file type, derived from the mime type. Mime\ntypes are not that pleasant to look at, and not always easy to understand. That is\nwhy we map the mime types into more user-friendly types. Below is the list of types\ncurrently returned, but be aware that this list may be extended in the future.\n\n- `Document`: Document files from Microsoft Word or similar word processing software.\n- `PDF`: PDF files.\n- `Spreadsheet`: Files from Microsoft Excel or similar spreadsheet software.\n- `Presentation`: Slides from Microsoft Powerpoint or similar.\n- `Image`: Any kind of image such as PNG or JPG files.\n- `Video`: Any kind of video such as MOV or MP4 files.\n- `Tabular data`: Csv, tsv and other kinds of tabular data files.\n- `Plain text`: Plain text files.\n- `Compressed`: ZIP files and other kinds of compressed archive files.\n- `Script`: Program code such as python or matlab.\n- `Other`: Anything that doesn't fit in any of the above types.\n\n#### geoLocation\nIf there is a geolocation set on the file in the Files API, then this field will contain\nthe same geolocation. If there is no explicitly assigned geolocation, the document\nprocessing system will try to detect a location using two different techniques;\n\n1. We will extract locations from files that contain embedded GPS locations. Photos and\n   videos often have this kind of metadata.\n2. We will look at related assets that have locations, and assign the same location(s) to\n   the document.\n\n### File type support\n\nWe create a document for each uploaded file, but only derive data from certain files.\n\nThe following file types are eligible for further data extraction & enrichment:\n- PDF files\n- Spreadsheets, documents, and presentations from the Microsoft, Libre Office and macOS office suites\n- Plain text files\n- Images"
    },
    {
      "name": "Document preview",
      "x-displayName": "Preview",
      "description": "The document preview service is a utility API that can render most document types as an image or PDF.\nThis can be very helpful if you want to display a preview of a file in a frontend, or for other\ntasks that require one of these formats.\n\nFor both rendered formats there is a concept of a page. The actual meaning of a page depends on\nthe source document. E.g. an image will always have exactly one page, while a spreadsheet\nwill typically have one page representing each individual sheet.\n\nThe document preview service can only generate preview for document sizes that do not\nexceed 150 MiB. Trying to preview a larger document will give an error.\n\n### File type support\nPreviews can be created for the following types of files:\n- PDF files\n- Spreadsheets, documents and presentations from the Microsoft and Libre Office office suites\n- Images"
    },
    {
      "name": "Geospatial",
      "description": "The Geospatial API allows to model a problem domain when data has a geometric or geographic nature.\nThe geospatial data is organized in feature types that are homogeneous collections of features (geospatial items), each having the same spatial representation, such as points, lines, or polygons, and a common set of typed properties. The Geospatial API is aware of Coordinate Reference Systems, and allows transformations.\nTo learn more about geospatial concepts, see the [concept guide](https://developer.cognite.com/dev/concepts/resource_types/geospatial.html)."
    },
    {
      "name": "SessionsInternal"
    },
    {
      "name": "Sessions",
      "description": "Sessions are used to maintain access to CDF resources for an extended period of time. The methods available to extend a sessions lifetime are client credentials and token exchange.\nSessions depend on the project OIDC configuration and may become invalid in the following cases\n- Project OIDC configuration has been updated through the [update project](#operation/updateProject)\n  endpoint. This action invalidates all of the project's sessions.\n\n- The session was invalidated through the identity provider.\n"
    },
    {
      "name": "Extraction Pipelines",
      "description": "Extraction Pipeline objects represent the applications and software that are deployed to ingest operational data into CDF.  An extraction pipeline can consist of a number of different software components between the source system and CDF. The extraction pipeline object represents the software component that actually sends the data to CDF. Two examples are Cognite extractors and third party ETL tools such as Microsoft Azure or Informatica PowerCenter"
    },
    {
      "name": "Extraction Pipelines Runs",
      "description": "Extraction Pipelines Runs are CDF objects to store statuses related to an extraction pipeline. The supported statuses are: success, failure and seen. The statuses are related to two different types of operation of the extraction pipeline. Success and failure indicate the status for a particular EP run where the EP attempts to send data to CDF. If the data is successfully posted to CDF the status of the run is success; if the run has been unsuccessful and the data is not posted to CDF, the status of the run is failure. Message can be stored to explain run status. Seen is a heartbeat status that indicates that the extraction pipeline is alive. This message is sent periodically on a schedule and indicates that the extraction pipeline is working even though data may not have been sent to CDF by the extraction pipeline."
    },
    {
      "name": "Extraction Pipelines Config",
      "description": "Extraction Pipelines Configs are configuration file revisions tied to an extraction pipeline. Users can create new configuration revisions, and extractors can fetch the latest, making it easy to deploy configuration files from source control, automated scripts, etc."
    },
    {
      "name": "Transformations",
      "description": "Transformations enable users to use Spark SQL queries to transform\ndata from the CDF staging area, RAW, into the CDF data model.\n\n### Concurrency limits\n\nThe number of concurrent (parallel) jobs are governed by limits. If a request exceeds one of the limits,\nthe job fails to run. This limitation also applies to scheduled transformations.\n\nThe limits for the transformation service are described in the table below. Note that under high load,\nsome deviation from the limits might occur for short periods as the service scales up.\n\n| Limit                 | Per project           |\n|-----------------------|-----------------------|\n| Concurrency           | 10 parallel jobs  |"
    },
    {
      "name": "Transformation Jobs",
      "description": "Transformation jobs let you execute transformations asynchronously."
    },
    {
      "name": "Transformation Schedules",
      "description": "Transformation schedules allow you to run transformations with a specific input at intervals defined by a cron expression. These transformation jobs will be asynchronous and show up in the transformation job list. Visit http://www.cronmaker.com to generate a cron expression with a UI."
    },
    {
      "name": "Transformation Notifications",
      "description": "Transformation notifications let users know when a job fails if subscribed."
    },
    {
      "name": "Query",
      "description": "Query lets the users preview the result of their queries."
    },
    {
      "name": "Schema",
      "description": "Schema provides the expected schema for CDF resources."
    },
    {
      "name": "Annotations",
      "description": "Annotations reflect contextual information in base CDF resource types, such as Files and Time series, that are not\npresent on the object itself. The benefits of the annotations concept are threefold:\n\n- The annotations concept is a good fit for enriching the base resources themselves, so that the overall data\n  quality is higher in a given project.\n- It is also a good fit for building reference datasets for data problems uniformly across customer projects.\n  Product teams can then use those reference datasets to train machine learning models or validate the\n  performance of their algorithms on actual customer data.\n- Given a uniform way of labelling similar concepts across projects, it becomes easy for apps to agree on a consistent\n  visual representation of those concepts."
    },
    {
      "name": "Seismic",
      "description": "A seismic object is a no-copy view into seismic stores. Once you have defined the object, either via a polygon to \"cut out\" from the origin seismic store or via an explicit trace-by-trace mapping, you cannot modify it. You can assign seismic objects to partitions and restrict user access to each partition. That way, seismic objects are the most granular unit of access control. Each seismic object has one corresponding partition. If a user is restricted to a specific partition, they will only be able to view the seismic objects that have been assigned to that partition."
    },
    {
      "name": "User profiles",
      "description": "User profiles is an authoritative source of core user profile information (email,\nname, job title, etc.) for principals based on data from the identity provider\nconfigured for the CDF project.\n\nUser profiles are first created (usually within a few seconds) when a principal issues\na request against a CDF API. We currently don't support automatic exchange of user identity\ninformation between the identity provider and CDF, but the profile data is updated regularly\nwith the latest data from the identity provider for the principals issuing requests against\na CDF API.\n\nNote:\n- Do not use other fields than `userIdentifier` (e.g. email) to uniquely identify a\nprincipal. User profile data is mutable and is not guaranteed to be stable or unique (except\n`userIdentifier`).\n- Do not use user profile data for authentication or authorization purposes. It is not\nguaranteed to be under the strict governance necessary for that. For example, one should not\nuse email address as proof of identity or job title to give access to resources.\n- We strongly recommend _against_ storing any user profile data. It is intended for display\npurposes only and may update at any time. Clients should fetch user profile data at demand,\nand optionally cache for performance reasons.\n"
    },
    {
      "name": "Workflows",
      "description": "Define and orchestrate data workflows consisting of CDF Transformations, Cognite Functions, and other processes. This service enables you to build data pipelines and business solutions leveraging the capabilities of CDF and external tools."
    },
    {
      "name": "Workflow versions"
    },
    {
      "name": "Workflow executions"
    },
    {
      "name": "Tasks"
    },
    {
      "name": "Workflow triggers",
      "description": "Triggers allow you to automate the execution of your data workflows based on specific conditions, such as scheduled times (defined by cron expressions)."
    },
    {
      "name": "Sources",
      "description": "A hosted extractor **source** represents an external source system on the internet. The **source** resource in CDF contains all the information the extractor needs to connect to the external source system.\nA source can have many jobs, each streaming different data from the source system."
    },
    {
      "name": "Jobs",
      "description": "A hosted extractor **job** represents the running extractor. Jobs produce logs and metrics that give the state of the job. For details on available states and metrics see documentation [here](https://docs.cognite.com/cdf/integration/guides/extraction/hosted_extractors)."
    },
    {
      "name": "Destinations",
      "description": "A hosted extractor writes to a **destination**. The destination contains credentials for CDF, and additional information about where the data should land, such as data set ID.\nMultiple jobs can share a single destination, in which case requests will be combined, reducing the number of requests made to CDF APIs. Metrics are still reported for each individual job."
    },
    {
      "name": "Mappings",
      "description": "A **mapping** is a custom transformation, translating the source format to a format that can be ingested into CDF. Mappings are written in the Cognite transformation language. For more details see documentation [here](https://docs.cognite.com/cdf/integration/guides/extraction/hosted_extractors/hosted_extractors_custom_mappings)."
    },
    {
      "name": "Previews",
      "description": "A **preview** is a temporary job that runs until it times out, fails, or receives a single message, then stores the result. This is useful for development, as it allows you to easily inspect the output of a source.\nPreviews require a source, but not a mapping or a destination.\nThis API is in alpha. The endpoints listed here are available only when the `cdf-version` header with the value `alpha` is provided."
    },
    {
      "name": "Postgres Gateway Users",
      "description": "A postgres gateway **user** (also a typical postgres user) owns the foreign tables (built in or custom).\n\nThe created postgres user only has access to use foreign tables and cannot directly create tables users. To create foreign tables use the Postgres Gateway Tables APIs\n"
    },
    {
      "name": "Postgres Gateway Tables",
      "description": "View and create foreign **tables** for a given **user**"
    },
    {
      "name": "SAP Instances",
      "description": "An SAP **instance** represents a configuration to an external SAP S/4HANA destination system. The **instance** resource\ncontains all the information this API service needs to connect to an SAP S/4HANA destination.\n\nSupported SAP S/4HANA versions:\n* SAP S/4HANA OnPremise 2021 FPS01, and later\n* SAP S/4HANA Cloud"
    },
    {
      "name": "SAP Endpoints",
      "description": "An SAP **endpoint** represents a configuration to an SAP S/4HANA OData endpoint (and its related OData entity) the API will send the writeback requests.\nIt defines which SAP Instance destination and which schema mapping should be used when processing a writeback request.\n\nSupported SAP entities:\n* [Maintenance Notifications](https://api.sap.com/api/OP_API_MAINTNOTIFICATION/overview)\n* [Attachments](https://api.sap.com/api/OP_API_CV_ATTACHMENT_SRV_0001/overview)"
    },
    {
      "name": "Schema Mappings",
      "description": "A **mapping** uses field and value mapping(s) to perform an in-flight transformation from source CDF entities to SAP S/4HANA entities. Mappings are written in the Cognite transformation language. For more details see the [documentation](https://docs.cognite.com/cdf/integration/guides/extraction/hosted_extractors/hosted_extractors_custom_mappings)."
    },
    {
      "name": "Writeback Requests",
      "description": "A writeback **request** to the SAP S/4HANA destination. The request body contains the target SAP endpoint destination, and the payload to send."
    },
    {
      "name": "Simulators",
      "description": "The simulator resource contains the definitions necessary for Cognite Data Fusion (CDF) to interact with a given simulator. It serves as a central contract that allows APIs, UIs, and integrations (connectors) to utilize the same definitions when dealing with a specific simulator.\n\nEach simulator is uniquely identified and can be associated with various file extension types, model types, step fields, and unit quantities. Simulators are essential for managing data flows between CDF and external simulation tools, ensuring consistency and reliability in data handling.\n\n#### Limitations:\n\n- A project can have a maximum of 100 simulators\n"
    },
    {
      "name": "Simulator Integrations",
      "description": "\n\nThe simulator integration resource represents a simulator connector in Cognite Data Fusion (CDF). It provides information about the configured connectors for a given simulator, including their status and additional details such as dataset, name, license status, connector version, simulator version, and more. This resource is essential for monitoring and managing the interactions between CDF and external simulators, ensuring proper data flow and integration.\n\n#### Limitations:\n\n- A project can have a maximum of 20 simulator integrations\n"
    },
    {
      "name": "Simulator Routines",
      "description": "\n\nThe simulator routine resource defines instructions on interacting with a simulator model. A simulator routine includes:\n- Inputs (values set into the simulator model)\n- Commands (actions to be performed by the simulator)\n- Outputs (values read from the simulator model)\n\nSimulator routines can have multiple revisions, enabling users to track changes and evolve the routine over time. Each model can have multiple routines, each performing different objectives such as calculating optimal operation setpoints, forecasting production, benchmarking asset performance, and more.\n\n#### Limitations:\n\n- Each simulator model can have a maximum of 10 simulator routines\n\n- Each simulator routine can have a maximum of 10 revisions\n"
    },
    {
      "name": "Simulator Models",
      "description": "\n\nThe simulator model resource represents an asset modeled in a simulator. This asset could range from a pump or well to a complete processing facility or refinery.\nThe simulator model is the root of its associated revisions, routines, runs, and results. The dataset assigned to a model is inherited by its children. Deleting a model also deletes all its children, thereby maintaining the integrity and hierarchy of the simulation data.\n\nSimulator model revisions track changes and updates to a simulator model over time. Each revision ensures that modifications to models are traceable and allows users to understand the evolution of a given model.\n\n#### Limitations:\n\n- A project can have a maximum of 1000 simulator models\n\n- Each simulator model can have a maximum of 200 revisions\n"
    },
    {
      "name": "Simulation Runs",
      "description": "\nEvery time a simulation routine executes, a simulation run object is created. This object ensures that each execution of a routine is documented and traceable. Each run has an associated simulation data resource, which stores the inputs and outputs of a simulation run, capturing the values set into and read from the simulator model to ensure the traceability and integrity of the simulation data.\n\nSimulation runs provide a historical record of the simulations performed, allowing users to analyze and compare different runs, track changes over time, and make informed decisions based on the simulation results.\n\n#### Limitations:\n\n- A retention policy is in place for simulation runs, allowing up to 100000 entries.\n- Once this limit is reached, the oldest runs will be deleted to accommodate new runs.\n"
    },
    {
      "name": "Simulator Logs",
      "description": "\nSimulator logs track what happens during simulation runs, model parsing, and generic connector logic. They provide valuable information for monitoring, debugging, and auditing.\n\nSimulator logs capture important events, messages, and exceptions that occur during the execution of simulations, model parsing, and connector operations. They help users identify issues, diagnose problems, and gain insights into the behavior of the simulator integrations.\n\n#### Limitations:\n- A retention policy is in place for simulator logs, allowing a maximum of 10000 entries per logId.\n- Once this limit is reached, the oldest logs will be deleted to accommodate new logs.\n"
    },
    {
      "name": "Units",
      "description": "Units Catalog API provides a standardized list of units that can be used in Cognite Data Fusion.\nThe content this API serves is based on the [CDF Units Catalog](https://github.com/cognitedata/units-catalog)"
    },
    {
      "name": "Unit Systems",
      "description": "Unit system is a collection of default units for different quantities.\nThis API provides a list of supported unit systems and their associated quantities and respective unit."
    },
    {
      "name": "Organizations",
      "description": "An **organization** is used to group CDF projects and facilitate their management.\n\nAn organization holds users, projects, and perhaps other organizations. The organization ID is what the users enter\nwhen logging into Cognite apps, such as Cognite Data Fusion. The organization has one IdP configuration, which is used\nfor both interactive login and service account authentication against all projects in the organization.\n\n### External identity providers (IdP)\nCDF supports interfacing with external IdPs to manage users and groups. The following vendors are supported:\n- Microsoft Entra ID (formerly known as Azure AD or Azure Active Directory)\n- Auth0\n- Keycloak\n\n### Users\nIf a user can log into the external IdP configured for the organization, then they have access to the CDF organization.\nWhich of the organization's projects they have access to, and what they may do inside those projects, is determined by\nthe access settings within each project.\n\nAfter a user has logged into the organization for the first time, they will be visible in the organization's user list.\nUsers can see each other, which enables them to collaborate on projects.\n\n### Organization hierarchy\nAn organization can have child organizations. The ownership relationship is materialized through the `parentId`\nfield of the organization resource.\n\n### Projects\nAn organization holds CDF projects. The users that are logged into the organization can see all the projects in the\norganization, but what they can actually do within each project is controlled by the project's access control lists\n(ACLs) and other access control settings.\n\n### Allowed clusters\nAn organization has a list of clusters on which it can hold projects. This is the `allowedClusters` field on the\nresource.\n\n### Organization admins\nAn organization can have admins, which are identified principals that can perform an extended set of modifications on\nthe organization, such as creating projects, changing who the admins are, and so on.\n\nAdmins are identified by the `adminGroupId` field on the organization resource, which is the ID of a group that is\nmanaged in the external IdP.\n\nThe different organization API endpoints have different access rules, which are documented under each endpoint.\nThe general rule is that admins of a given organization have control over most aspects of the organization itself\nand full control of any sub-organizations.\n\n### Authentication for this API\nOrganizations are global, which means that they are not tied to specific projects or clusters.\nAPI requests against organizations are directed to `auth.cognite.com`, instead of a specific cluster and projects\nas for other resources.\n\nOnly OAuth tokens issued by `https://auth.cognite.com` (such as the ones issued when logging into Fusion) are accepted\nby the organizations API.\n\nIt is also possible to obtain a token by initiating a login flow against the authorization server directly. See\nthe \"Authorizations\" sections for more information.\n"
    },
    {
      "name": "Principals",
      "description": "**Principal** is an umbrella term for **user accounts** and **service accounts**. Both entities can be uniquely identified, \nauthenticated, and authorized in CDF. Principals are unique within an organization, and therefore also within a project in the \norganization. Principals can access data and create and run processes (transformations, Functions) in a CDF project.\n\n* A **user account** is associated with a **person** who wants to interact with CDF. Each user account has a user \nprofile containing a unique user ID.\n* A **service account** is associated with an **application** or **process** that wants to interact with CDF, such as \nan extractor or Cognite Functions, rather than a person.\n\n## Authentication for this API\nRequests to the Principals API are directed to `auth.cognite.com`, like for organizations.\n\nOnly OAuth tokens issued by `https://auth.cognite.com` (such as the ones issued when logging into Fusion) are accepted\nby the Principals API.\n\nIt is also possible to obtain a token by initiating a login flow against the authorization server directly. See\nthe \"Authorizations\" sections for more information.\n\n## User Accounts\nThe Principals API lets you query user accounts in an organization, and retrieve profiles.\n"
    }
  ]
}
